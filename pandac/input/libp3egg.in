1713075180
3 3
8 libp3egg 4 hhEq 11 panda3d.egg 
992
1006 11 EggUserData 0 260 1998 24 EggUserData::EggUserData 0 2 1 2 22
/**
 *
 */

/**
 *
 */
96
inline EggUserData::EggUserData(void);
inline EggUserData::EggUserData(EggUserData const &copy);

1007 10 operator = 0 4 1998 23 EggUserData::operator = 0 1 3 10
/**
 *
 */
61
inline void EggUserData::operator =(EggUserData const &copy);

1008 14 get_class_type 0 4 1998 27 EggUserData::get_class_type 0 1 4 0
52
static TypeHandle EggUserData::get_class_type(void);

1009 9 EggObject 0 260 2000 20 EggObject::EggObject 0 2 5 6 22
/**
 *
 */

/**
 *
 */
72
EggObject::EggObject(void);
EggObject::EggObject(EggObject const &copy);

1010 10 operator = 0 4 2000 21 EggObject::operator = 0 1 7 10
/**
 *
 */
50
void EggObject::operator =(EggObject const &copy);

1011 13 set_user_data 0 4 2000 24 EggObject::set_user_data 0 1 8 766
/**
 * Sets the user data associated with this object.  This may be any
 * EggUserData-derived object.  The egg library will do nothing with this
 * pointer, except to hold its reference count and return the pointer on
 * request.
 *
 * The EggObject maintains multiple different EggUserData pointers, one for
 * each unique type (as reported by get_type()).  If you know that only one
 * type of EggUserData object will be added in your application, you may use
 * the query functions that accept no parameters, but it is recommended that
 * in general you pass in the type of your particular user data, to allow
 * multiple applications to coexist in the same egg data.
 *
 * This pointer is also copied by the copy assignment operator and copy
 * constructor.
 */
54
void EggObject::set_user_data(EggUserData *user_data);

1012 13 get_user_data 0 4 2000 24 EggObject::get_user_data 0 2 9 10 228
/**
 * Returns the user data pointer most recently stored on this object, or NULL
 * if nothing was previously stored.
 */

/**
 * Returns the user data pointer of the indicated type, if it exists, or NULL
 * if it does not.
 */
112
EggUserData *EggObject::get_user_data(void) const;
EggUserData *EggObject::get_user_data(TypeHandle type) const;

1013 13 has_user_data 0 4 2000 24 EggObject::has_user_data 0 2 11 12 223
/**
 * Returns true if a generic user data pointer has recently been set and not
 * yet cleared, false otherwise.
 */

/**
 * Returns true if the user data pointer of the indicated type has been set,
 * false otherwise.
 */
96
bool EggObject::has_user_data(void) const;
bool EggObject::has_user_data(TypeHandle type) const;

1014 15 clear_user_data 0 4 2000 26 EggObject::clear_user_data 0 2 13 14 123
/**
 * Removes *all* user data pointers from the node.
 */

/**
 * Removes the user data pointer of the indicated type.
 */
88
void EggObject::clear_user_data(void);
void EggObject::clear_user_data(TypeHandle type);

1015 14 get_class_type 0 4 2000 25 EggObject::get_class_type 0 1 15 0
50
static TypeHandle EggObject::get_class_type(void);

1016 19 upcast_to_EggObject 0 12 2001 35 EggNamedObject::upcast_to_EggObject 0 1 21 39
upcast from EggNamedObject to EggObject
53
EggObject *EggNamedObject::upcast_to_EggObject(void);

1017 26 downcast_to_EggNamedObject 0 12 2000 37 EggObject::downcast_to_EggNamedObject 0 0 41
downcast from EggObject to EggNamedObject
60
EggNamedObject *EggObject::downcast_to_EggNamedObject(void);

1018 17 upcast_to_Namable 0 12 2001 33 EggNamedObject::upcast_to_Namable 0 1 22 37
upcast from EggNamedObject to Namable
49
Namable *EggNamedObject::upcast_to_Namable(void);

1019 26 downcast_to_EggNamedObject 0 12 2002 35 Namable::downcast_to_EggNamedObject 0 0 39
downcast from Namable to EggNamedObject
58
EggNamedObject *Namable::downcast_to_EggNamedObject(void);

1020 14 EggNamedObject 0 260 2001 30 EggNamedObject::EggNamedObject 0 2 16 17 22
/**
 *
 */

/**
 *
 */
144
inline explicit EggNamedObject::EggNamedObject(std::string const &name = "");
inline EggNamedObject::EggNamedObject(EggNamedObject const &copy);

1021 10 operator = 0 4 2001 26 EggNamedObject::operator = 0 1 18 10
/**
 *
 */
67
inline void EggNamedObject::operator =(EggNamedObject const &copy);

1022 6 output 0 4 2001 22 EggNamedObject::output 0 1 19 10
/**
 *
 */
53
void EggNamedObject::output(std::ostream &out) const;

1023 14 get_class_type 0 4 2001 30 EggNamedObject::get_class_type 0 1 20 0
55
static TypeHandle EggNamedObject::get_class_type(void);

1024 15 ~EggNamedObject 0 516 2001 31 EggNamedObject::~EggNamedObject 0 0 0
38
EggNamedObject::~EggNamedObject(void);

1025 10 operator = 0 4 2003 19 EggNode::operator = 0 1 23 10
/**
 *
 */
53
inline void EggNode::operator =(EggNode const &copy);

1026 10 get_parent 0 4 2003 19 EggNode::get_parent 0 1 24 10
/**
 *
 */
53
inline EggGroupNode *EggNode::get_parent(void) const;

1027 9 get_depth 0 4 2003 18 EggNode::get_depth 0 1 25 76
/**
 * Returns the number of nodes above this node in the egg hierarchy.
 */
42
inline int EggNode::get_depth(void) const;

1028 17 is_under_instance 0 4 2003 26 EggNode::is_under_instance 0 1 26 123
/**
 * Returns true if there is an <Instance> node somewhere in the egg tree at or
 * above this node, false otherwise.
 */
51
inline bool EggNode::is_under_instance(void) const;

1029 18 is_under_transform 0 4 2003 27 EggNode::is_under_transform 0 1 27 124
/**
 * Returns true if there is a <Transform> entry somewhere in the egg tree at
 * or above this node, false otherwise.
 */
52
inline bool EggNode::is_under_transform(void) const;

1030 14 is_local_coord 0 4 2003 23 EggNode::is_local_coord 0 1 28 189
/**
 * Returns true if this node's vertices are not in the global coordinate
 * space.  This will be the case if there was an <Instance> node under a
 * transform at or above this node.
 */
48
inline bool EggNode::is_local_coord(void) const;

1031 12 EggGroupNode 0 260 2005 26 EggGroupNode::EggGroupNode 0 2 62 63 10
/**
 *
 */
120
explicit EggGroupNode::EggGroupNode(std::string const &name = "");
EggGroupNode::EggGroupNode(EggGroupNode const &copy);

1032 10 operator = 0 4 2005 24 EggGroupNode::operator = 0 1 64 10
/**
 *
 */
56
void EggGroupNode::operator =(EggGroupNode const &copy);

1033 5 empty 0 4 2005 19 EggGroupNode::empty 0 1 65 10
/**
 *
 */
37
bool EggGroupNode::empty(void) const;

1034 4 size 0 4 2005 18 EggGroupNode::size 0 1 66 10
/**
 *
 */
55
EggGroupNode::size_type EggGroupNode::size(void) const;

1035 5 clear 0 4 2005 19 EggGroupNode::clear 0 1 67 10
/**
 *
 */
31
void EggGroupNode::clear(void);

1036 15 get_first_child 0 4 2005 29 EggGroupNode::get_first_child 0 1 68 607
// This is an alternate way to traverse the list of children.  It is mainly
// provided for scripting code, which can't use the iterators defined above
// (they don't export through interrogate very well). These are, of course,
// non-thread-safe.

/**
 * Returns the first child in the group's list of children, or NULL if the
 * list of children is empty.  Can be used with get_next_child() to return the
 * complete list of children without using the iterator class; however, this
 * is non-thread-safe, and so is not recommended except for languages other
 * than C++ which cannot use the iterators.
 */
45
EggNode *EggGroupNode::get_first_child(void);

1037 14 get_next_child 0 4 2005 28 EggGroupNode::get_next_child 0 1 69 506
/**
 * Returns the next child in the group's list of children since the last call
 * to get_first_child() or get_next_child(), or NULL if the last child has
 * been returned.  Can be used with get_first_child() to return the complete
 * list of children without using the iterator class; however, this is non-
 * thread-safe, and so is not recommended except for languages other than C++
 * which cannot use the iterators.
 *
 * It is an error to call this without previously calling get_first_child().
 */
44
EggNode *EggGroupNode::get_next_child(void);

1038 12 get_children 0 4 2005 26 EggGroupNode::get_children 0 1 70 0
49
PyObject *EggGroupNode::get_children(void) const;

1039 9 add_child 0 4 2005 23 EggGroupNode::add_child 0 1 71 143
/**
 * Adds the indicated child to the group and returns it.  If the child node is
 * already a child of some other node, removes it first.
 */
48
EggNode *EggGroupNode::add_child(EggNode *node);

1040 12 remove_child 0 4 2005 26 EggGroupNode::remove_child 0 1 72 152
/**
 * Removes the indicated child node from the group and returns it.  If the
 * child was not already in the group, does nothing and returns NULL.
 */
63
PointerTo< EggNode > EggGroupNode::remove_child(EggNode *node);

1041 14 steal_children 0 4 2005 28 EggGroupNode::steal_children 0 1 73 171
/**
 * Moves all the children from the other node to this one.  This is especially
 * useful because the group node copy assignment operator does not copy
 * children.
 */
55
void EggGroupNode::steal_children(EggGroupNode &other);

1042 10 find_child 0 4 2005 24 EggGroupNode::find_child 0 1 74 169
/**
 * Returns the child of this node whose name is the indicated string, or NULL
 * if there is no child of this node by that name.  Does not search
 * recursively.
 */
65
EggNode *EggGroupNode::find_child(std::string const &name) const;

1043 22 has_absolute_pathnames 0 4 2005 36 EggGroupNode::has_absolute_pathnames 0 1 75 160
/**
 * Returns true if any nodes at this level and below include a reference to a
 * file via an absolute pathname, or false if all references are relative.
 */
54
bool EggGroupNode::has_absolute_pathnames(void) const;

1044 17 resolve_filenames 0 4 2005 31 EggGroupNode::resolve_filenames 0 1 76 207
/**
 * Walks the tree and attempts to resolve any filenames encountered.  This
 * looks up filenames along the specified search path; it does not
 * automatically search the model_path for missing files.
 */
68
void EggGroupNode::resolve_filenames(DSearchPath const &searchpath);

1045 15 force_filenames 0 4 2005 29 EggGroupNode::force_filenames 0 1 77 190
/**
 * Similar to resolve_filenames, but each non-absolute filename encountered is
 * arbitrarily taken to be in the indicated directory, whether or not the so-
 * named filename exists.
 */
62
void EggGroupNode::force_filenames(Filename const &directory);

1046 23 reverse_vertex_ordering 0 4 2005 37 EggGroupNode::reverse_vertex_ordering 0 1 78 136
/**
 * Reverses the vertex ordering of all polygons defined at this node and
 * below.  Does not change the surface normals, if any.
 */
49
void EggGroupNode::reverse_vertex_ordering(void);

1047 24 recompute_vertex_normals 0 4 2005 38 EggGroupNode::recompute_vertex_normals 0 1 79 711
/**
 * Recomputes all the vertex normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  A shared
 * edge between two polygons (even in different groups) is considered smooth
 * if the angle between the two edges is less than threshold degrees.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the correct normals.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */
98
void EggGroupNode::recompute_vertex_normals(double threshold, CoordinateSystem cs = ::CS_default);

1048 25 recompute_polygon_normals 0 4 2005 39 EggGroupNode::recompute_polygon_normals 0 1 80 672
/**
 * Recomputes all the polygon normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  Normals
 * are removed from the vertices and defined only on polygons, giving the
 * geometry a faceted appearance.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normals removed.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */
81
void EggGroupNode::recompute_polygon_normals(CoordinateSystem cs = ::CS_default);

1049 13 strip_normals 0 4 2005 27 EggGroupNode::strip_normals 0 1 81 317
/**
 * Removes all normals from primitives, and the vertices they reference, at
 * this node and below.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normal removed.  Thus, it is a good idea to
 * call remove_unused_vertices() after calling this.
 */
39
void EggGroupNode::strip_normals(void);

1050 26 recompute_tangent_binormal 0 4 2005 40 EggGroupNode::recompute_tangent_binormal 0 2 82 83 907
/**
 * This function recomputes the tangent and binormal for the named texture
 * coordinate set for all vertices at this level and below.  Use the empty
 * string for the default texture coordinate set.
 *
 * It is necessary for each vertex to already have a normal (or at least a
 * polygon normal), as well as a texture coordinate in the named texture
 * coordinate set, before calling this function.  You might precede this with
 * recompute_vertex_normals() to ensure that the normals exist.
 *
 * Like recompute_vertex_normals(), this function does not remove or adjust
 * vertices in the vertex pool; it only adds new vertices with the new
 * tangents and binormals computed.  Thus, it is a good idea to call
 * remove_unused_vertices() after calling this.
 */

/**
 * This function recomputes the tangent and binormal for the named texture
 * coordinate sets.  Returns true if anything was done.
 */
149
bool EggGroupNode::recompute_tangent_binormal(GlobPattern const &uv_name);
bool EggGroupNode::recompute_tangent_binormal(vector_string const &names);

1051 31 recompute_tangent_binormal_auto 0 4 2005 45 EggGroupNode::recompute_tangent_binormal_auto 0 1 84 160
/**
 * This function recomputes the tangent and binormal for any texture
 * coordinate set that affects a normal map.  Returns true if anything was
 * done.
 */
57
bool EggGroupNode::recompute_tangent_binormal_auto(void);

1052 20 triangulate_polygons 0 4 2005 34 EggGroupNode::triangulate_polygons 0 1 85 428
/**
 * Replace all higher-order polygons at this point in the scene graph and
 * below with triangles.  Returns the total number of new triangles produced,
 * less degenerate polygons removed.
 *
 * If flags contains T_polygon and T_convex, both concave and convex polygons
 * will be subdivided into triangles; with only T_polygon, only concave
 * polygons will be subdivided, and convex polygons will be largely unchanged.
 */
50
int EggGroupNode::triangulate_polygons(int flags);

1053 14 mesh_triangles 0 4 2005 28 EggGroupNode::mesh_triangles 0 1 86 84
/**
 * Combine triangles together into triangle strips, at this group and below.
 */
45
void EggGroupNode::mesh_triangles(int flags);

1054 21 make_point_primitives 0 4 2005 35 EggGroupNode::make_point_primitives 0 1 87 127
/**
 * Creates PointLight primitives to reference any otherwise unreferences
 * vertices discovered in this group or below.
 */
47
void EggGroupNode::make_point_primitives(void);

1055 12 rename_nodes 0 4 2005 26 EggGroupNode::rename_nodes 0 1 88 45
/**
 * Rename by stripping out the prefix
 */
73
int EggGroupNode::rename_nodes(vector_string strip_prefix, bool recurse);

1056 22 remove_unused_vertices 0 4 2005 36 EggGroupNode::remove_unused_vertices 0 1 89 692
/**
 * Removes all vertices from VertexPools within this group or below that are
 * not referenced by at least one primitive.  Also collapses together
 * equivalent vertices, and renumbers all vertices after the operation so
 * their indices are consecutive, beginning at zero.  Returns the total number
 * of vertices removed.
 *
 * Note that this operates on the VertexPools within this group level, without
 * respect to primitives that reference these vertices (unlike other functions
 * like strip_normals()).  It is therefore most useful to call this on the
 * EggData root, rather than on a subgroup within the hierarchy, since a
 * VertexPool may appear anywhere in the hierarchy.
 */
55
int EggGroupNode::remove_unused_vertices(bool recurse);

1057 25 remove_invalid_primitives 0 4 2005 39 EggGroupNode::remove_invalid_primitives 0 1 90 181
/**
 * Removes primitives at this level and below which appear to be degenerate;
 * e.g.  polygons with fewer than 3 vertices, etc.  Returns the number of
 * primitives removed.
 */
58
int EggGroupNode::remove_invalid_primitives(bool recurse);

1058 23 clear_connected_shading 0 4 2005 37 EggGroupNode::clear_connected_shading 0 1 91 319
/**
 * Resets the connected_shading information on all primitives at this node and
 * below, so that it may be accurately rederived by the next call to
 * get_connected_shading().
 *
 * It may be a good idea to call remove_unused_vertices() as well, to
 * establish the correct connectivity between common vertices.
 */
49
void EggGroupNode::clear_connected_shading(void);

1059 21 get_connected_shading 0 4 2005 35 EggGroupNode::get_connected_shading 0 1 92 194
/**
 * Queries the connected_shading information on all primitives at this node
 * and below, to ensure that it has been completely filled in before we start
 * mucking around with vertices.
 */
47
void EggGroupNode::get_connected_shading(void);

1060 16 unify_attributes 0 4 2005 30 EggGroupNode::unify_attributes 0 1 93 1065
/**
 * Applies per-vertex normal and color to all vertices, if they are in fact
 * per-vertex (and different for each vertex), or moves them to the primitive
 * if they are all the same.
 *
 * After this call, either the primitive will have normals or its vertices
 * will, but not both.  Ditto for colors.
 *
 * If use_connected_shading is true, each polygon is considered in conjunction
 * with all connected polygons; otherwise, each polygon is considered
 * individually.
 *
 * If allow_per_primitive is false, S_per_face or S_overall will treated like
 * S_per_vertex: normals and colors will always be assigned to the vertices.
 * In this case, there will never be per-primitive colors or normals after
 * this call returns.  On the other hand, if allow_per_primitive is true, then
 * S_per_face means that normals and colors should be assigned to the
 * primitives, and removed from the vertices, as described above.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */
104
void EggGroupNode::unify_attributes(bool use_connected_shading, bool allow_per_primitive, bool recurse);

1061 20 apply_last_attribute 0 4 2005 34 EggGroupNode::apply_last_attribute 0 1 94 424
/**
 * Sets the last vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * OpenGL convention of storing flat-shaded properties on the last vertex,
 * although it is not usually a convention in Egg.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */
54
void EggGroupNode::apply_last_attribute(bool recurse);

1062 21 apply_first_attribute 0 4 2005 35 EggGroupNode::apply_first_attribute 0 1 95 427
/**
 * Sets the first vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * DirectX convention of storing flat-shaded properties on the first vertex,
 * although it is not usually a convention in Egg.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */
55
void EggGroupNode::apply_first_attribute(bool recurse);

1063 25 post_apply_flat_attribute 0 4 2005 39 EggGroupNode::post_apply_flat_attribute 0 1 96 217
/**
 * Intended as a followup to apply_last_attribute(), this also sets an
 * attribute on the first vertices of the primitive, if they don't already
 * have an attribute set, just so they end up with *something*.
 */
59
void EggGroupNode::post_apply_flat_attribute(bool recurse);

1064 14 has_primitives 0 6 2005 28 EggGroupNode::has_primitives 0 1 97 124
/**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, false otherwise.
 */
54
virtual bool EggGroupNode::has_primitives(void) const;

1065 20 joint_has_primitives 0 6 2005 34 EggGroupNode::joint_has_primitives 0 1 98 154
/**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, but the search does not include nested joints.
 */
60
virtual bool EggGroupNode::joint_has_primitives(void) const;

1066 11 has_normals 0 6 2005 25 EggGroupNode::has_normals 0 1 99 164
/**
 * Returns true if any of the primitives (e.g.  polygons) defined within this
 * group or below have either face or vertex normals defined, false otherwise.
 */
51
virtual bool EggGroupNode::has_normals(void) const;

1067 8 is_right 0 4 2005 22 EggGroupNode::is_right 0 1 100 60
/**
 * Returns true if the 2-d v1 is to the right of v2.
 */
84
static inline bool EggGroupNode::is_right(LVector2d const &v1, LVector2d const &v2);

1068 14 get_class_type 0 4 2005 28 EggGroupNode::get_class_type 0 1 101 0
53
static TypeHandle EggGroupNode::get_class_type(void);

1069 16 get_vertex_frame 0 4 2003 25 EggNode::get_vertex_frame 0 1 29 711
/**
 * Returns the coordinate frame of the vertices referenced by primitives at or
 * under this node.  This is not the same as get_node_frame().
 *
 * Generally, vertices in an egg file are stored in the global coordinate
 * space, regardless of the transforms defined at each node.  Thus,
 * get_vertex_frame() will usually return the identity transform (global
 * coordinate space).  However, primitives under an <Instance> entry reference
 * their vertices in the coordinate system under effect at the time of the
 * <Instance>.  Thus, nodes under an <Instance> entry may return this non-
 * identity matrix.
 *
 * Specifically, this may return a non-identity matrix only if
 * is_local_coord() is true.
 */
62
inline LMatrix4d const &EggNode::get_vertex_frame(void) const;

1070 14 get_node_frame 0 4 2003 23 EggNode::get_node_frame 0 1 30 133
/**
 * Returns the coordinate frame of the node itself.  This is simply the net
 * product of all transformations up to the root.
 */
60
inline LMatrix4d const &EggNode::get_node_frame(void) const;

1071 20 get_vertex_frame_inv 0 4 2003 29 EggNode::get_vertex_frame_inv 0 1 31 104
/**
 * Returns the inverse of the matrix returned by get_vertex_frame().  See
 * get_vertex_frame().
 */
66
inline LMatrix4d const &EggNode::get_vertex_frame_inv(void) const;

1072 18 get_node_frame_inv 0 4 2003 27 EggNode::get_node_frame_inv 0 1 32 100
/**
 * Returns the inverse of the matrix returned by get_node_frame().  See
 * get_node_frame().
 */
64
inline LMatrix4d const &EggNode::get_node_frame_inv(void) const;

1073 18 get_vertex_to_node 0 4 2003 27 EggNode::get_vertex_to_node 0 1 33 231
/**
 * Returns the transformation matrix suitable for converting the vertices as
 * read from the egg file into the coordinate space of the node.  This is the
 * same thing as:
 *
 * get_vertex_frame() * get_node_frame_inv()
 *
 */
64
inline LMatrix4d const &EggNode::get_vertex_to_node(void) const;

1074 18 get_node_to_vertex 0 4 2003 27 EggNode::get_node_to_vertex 0 1 34 263
/**
 * Returns the transformation matrix suitable for converting vertices in the
 * coordinate space of the node to the appropriate coordinate space for
 * storing in the egg file.  This is the same thing as:
 *
 * get_node_frame() * get_vertex_frame_inv()
 *
 */
64
inline LMatrix4d const &EggNode::get_node_to_vertex(void) const;

1075 20 get_vertex_frame_ptr 0 4 2003 29 EggNode::get_vertex_frame_ptr 0 1 35 120
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_frame() matrix.
 */
66
inline LMatrix4d const *EggNode::get_vertex_frame_ptr(void) const;

1076 18 get_node_frame_ptr 0 4 2003 27 EggNode::get_node_frame_ptr 0 1 36 118
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_frame() matrix.
 */
64
inline LMatrix4d const *EggNode::get_node_frame_ptr(void) const;

1077 24 get_vertex_frame_inv_ptr 0 4 2003 33 EggNode::get_vertex_frame_inv_ptr 0 1 37 124
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_frame_inv() matrix.
 */
70
inline LMatrix4d const *EggNode::get_vertex_frame_inv_ptr(void) const;

1078 22 get_node_frame_inv_ptr 0 4 2003 31 EggNode::get_node_frame_inv_ptr 0 1 38 122
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_frame_inv() matrix.
 */
68
inline LMatrix4d const *EggNode::get_node_frame_inv_ptr(void) const;

1079 22 get_vertex_to_node_ptr 0 4 2003 31 EggNode::get_vertex_to_node_ptr 0 1 39 122
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_to_node() matrix.
 */
68
inline LMatrix4d const *EggNode::get_vertex_to_node_ptr(void) const;

1080 22 get_node_to_vertex_ptr 0 4 2003 31 EggNode::get_node_to_vertex_ptr 0 1 40 122
/**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_to_vertex() matrix.
 */
68
inline LMatrix4d const *EggNode::get_node_to_vertex_ptr(void) const;

1081 9 transform 0 4 2003 18 EggNode::transform 0 1 41 90
/**
 * Applies the indicated transformation to the node and all of its
 * descendants.
 */
53
inline void EggNode::transform(LMatrix4d const &mat);

1082 23 transform_vertices_only 0 4 2003 32 EggNode::transform_vertices_only 0 1 42 213
/**
 * Applies the indicated transformation only to vertices that appear in global
 * space within vertex pools at this node and below.  Joints and other
 * transforms are not affected, nor are local vertices.
 */
67
inline void EggNode::transform_vertices_only(LMatrix4d const &mat);

1083 18 flatten_transforms 0 4 2003 27 EggNode::flatten_transforms 0 1 43 382
/**
 * Removes any transform and instance records from this node in the scene
 * graph and below.  If an instance node is encountered, removes the instance
 * and applies the transform to its vertices, duplicating vertices if
 * necessary.
 *
 * Since this function may result in duplicated vertices, it may be a good
 * idea to call remove_unused_vertices() after calling this.
 */
46
inline void EggNode::flatten_transforms(void);

1084 13 apply_texmats 0 4 2003 22 EggNode::apply_texmats 0 1 44 159
/**
 * Applies the texture matrices to the UV's of the vertices that reference
 * them, and then removes the texture matrices from the textures themselves.
 */
34
void EggNode::apply_texmats(void);

1085 11 rename_node 0 4 2003 20 EggNode::rename_node 0 1 45 45
/**
 * Rename by stripping out the prefix
 */
53
int EggNode::rename_node(vector_string strip_prefix);

1086 8 is_joint 0 6 2003 17 EggNode::is_joint 0 1 46 229
/**
 * Returns true if this particular node represents a <Joint> entry or not.
 * This is a handy thing to know since Joints are sorted to the end of their
 * sibling list when writing an egg file.  See EggGroupNode::write().
 */
43
virtual bool EggNode::is_joint(void) const;

1087 14 is_anim_matrix 0 6 2003 23 EggNode::is_anim_matrix 0 1 47 109
/**
 * Returns true if this node represents a table of animation transformation
 * data, false otherwise.
 */
49
virtual bool EggNode::is_anim_matrix(void) const;

1088 20 determine_alpha_mode 0 6 2003 29 EggNode::determine_alpha_mode 0 1 48 266
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has an alpha_mode
 * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */
59
virtual EggRenderMode *EggNode::determine_alpha_mode(void);

1089 26 determine_depth_write_mode 0 6 2003 35 EggNode::determine_depth_write_mode 0 1 49 272
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
65
virtual EggRenderMode *EggNode::determine_depth_write_mode(void);

1090 25 determine_depth_test_mode 0 6 2003 34 EggNode::determine_depth_test_mode 0 1 50 271
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
64
virtual EggRenderMode *EggNode::determine_depth_test_mode(void);

1091 25 determine_visibility_mode 0 6 2003 34 EggNode::determine_visibility_mode 0 1 51 270
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
64
virtual EggRenderMode *EggNode::determine_visibility_mode(void);

1092 22 determine_depth_offset 0 6 2003 31 EggNode::determine_depth_offset 0 1 52 251
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a depth_offset
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
61
virtual EggRenderMode *EggNode::determine_depth_offset(void);

1093 20 determine_draw_order 0 6 2003 29 EggNode::determine_draw_order 0 1 53 249
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a draw_order
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
59
virtual EggRenderMode *EggNode::determine_draw_order(void);

1094 13 determine_bin 0 6 2003 22 EggNode::determine_bin 0 1 54 238
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a bin specified.
 * Returns a valid EggRenderMode pointer if one is found, or NULL otherwise.
 */
52
virtual EggRenderMode *EggNode::determine_bin(void);

1095 17 determine_indexed 0 6 2003 26 EggNode::determine_indexed 0 1 55 321
/**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "indexed" scalar set.  Returns the value of the indexed scalar
 * if it is found, or false if it is not.
 *
 * In other words, returns true if the "indexed" flag is in effect for the
 * indicated node, false otherwise.
 */
46
virtual bool EggNode::determine_indexed(void);

1096 15 determine_decal 0 6 2003 24 EggNode::determine_decal 0 1 56 311
/**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "decal" flag set.  Returns the value of the decal flag if it
 * is found, or false if it is not.
 *
 * In other words, returns true if the "decal" flag is in effect for the
 * indicated node, false otherwise.
 */
44
virtual bool EggNode::determine_decal(void);

1097 5 write 0 6 2003 14 EggNode::write 0 1 57 0
75
virtual void EggNode::write(std::ostream &out, int indent_level) const = 0;

1098 9 parse_egg 0 4 2003 18 EggNode::parse_egg 0 1 58 296
/**
 * Parses the egg syntax given in the indicate string as if it had been read
 * from the egg file within this object's definition.  Updates the object
 * accordingly.  Returns true if successful, false if there was some parse
 * error or if the object does not support this functionality.
 */
55
bool EggNode::parse_egg(std::string const &egg_syntax);

1099 20 test_under_integrity 0 4 2003 29 EggNode::test_under_integrity 0 1 59 0
47
void EggNode::test_under_integrity(void) const;

1100 10 __reduce__ 0 4 2003 19 EggNode::__reduce__ 0 1 60 0
42
PyObject *EggNode::__reduce__(void) const;

1101 14 get_class_type 0 4 2003 23 EggNode::get_class_type 0 1 61 0
48
static TypeHandle EggNode::get_class_type(void);

1102 8 ~EggNode 0 516 2003 17 EggNode::~EggNode 0 0 0
24
EggNode::~EggNode(void);

1103 10 operator = 0 4 2011 23 EggAnimData::operator = 0 1 102 10
/**
 *
 */
61
inline void EggAnimData::operator =(EggAnimData const &copy);

1104 7 set_fps 0 4 2011 20 EggAnimData::set_fps 0 1 103 10
/**
 *
 */
46
inline void EggAnimData::set_fps(double type);

1105 9 clear_fps 0 4 2011 22 EggAnimData::clear_fps 0 1 104 10
/**
 *
 */
41
inline void EggAnimData::clear_fps(void);

1106 7 has_fps 0 4 2011 20 EggAnimData::has_fps 0 1 105 10
/**
 *
 */
45
inline bool EggAnimData::has_fps(void) const;

1107 7 get_fps 0 4 2011 20 EggAnimData::get_fps 0 1 106 56
/**
 * This is only valid if has_fps() returns true.
 */
47
inline double EggAnimData::get_fps(void) const;

1108 10 clear_data 0 4 2011 23 EggAnimData::clear_data 0 1 107 50
/**
 * Removes all data and empties the table.
 */
42
inline void EggAnimData::clear_data(void);

1109 8 add_data 0 4 2011 21 EggAnimData::add_data 0 1 108 46
/**
 * Adds a single element to the table.
 */
48
inline void EggAnimData::add_data(double value);

1110 8 get_size 0 4 2011 21 EggAnimData::get_size 0 1 109 55
/**
 * Returns the number of elements in the table.
 */
45
inline int EggAnimData::get_size(void) const;

1111 8 quantize 0 4 2011 21 EggAnimData::quantize 0 1 110 79
/**
 * Rounds each element of the table to the nearest multiple of quantum.
 */
43
void EggAnimData::quantize(double quantum);

1112 14 get_class_type 0 4 2011 27 EggAnimData::get_class_type 0 1 111 0
52
static TypeHandle EggAnimData::get_class_type(void);

1113 12 ~EggAnimData 0 516 2011 25 EggAnimData::~EggAnimData 0 0 0
32
EggAnimData::~EggAnimData(void);

1114 14 EggAnimPreload 0 260 2012 30 EggAnimPreload::EggAnimPreload 0 2 112 113 22
/**
 *
 */

/**
 *
 */
144
inline explicit EggAnimPreload::EggAnimPreload(std::string const &name = "");
inline EggAnimPreload::EggAnimPreload(EggAnimPreload const &copy);

1115 10 operator = 0 4 2012 26 EggAnimPreload::operator = 0 1 114 10
/**
 *
 */
67
inline void EggAnimPreload::operator =(EggAnimPreload const &copy);

1116 7 set_fps 0 4 2012 23 EggAnimPreload::set_fps 0 1 115 10
/**
 *
 */
48
inline void EggAnimPreload::set_fps(double fps);

1117 9 clear_fps 0 4 2012 25 EggAnimPreload::clear_fps 0 1 116 10
/**
 *
 */
44
inline void EggAnimPreload::clear_fps(void);

1118 7 has_fps 0 4 2012 23 EggAnimPreload::has_fps 0 1 117 10
/**
 *
 */
48
inline bool EggAnimPreload::has_fps(void) const;

1119 7 get_fps 0 4 2012 23 EggAnimPreload::get_fps 0 1 118 56
/**
 * This is only valid if has_fps() returns true.
 */
50
inline double EggAnimPreload::get_fps(void) const;

1120 14 set_num_frames 0 4 2012 30 EggAnimPreload::set_num_frames 0 1 119 10
/**
 *
 */
59
inline void EggAnimPreload::set_num_frames(int num_frames);

1121 16 clear_num_frames 0 4 2012 32 EggAnimPreload::clear_num_frames 0 1 120 10
/**
 *
 */
51
inline void EggAnimPreload::clear_num_frames(void);

1122 14 has_num_frames 0 4 2012 30 EggAnimPreload::has_num_frames 0 1 121 10
/**
 *
 */
55
inline bool EggAnimPreload::has_num_frames(void) const;

1123 14 get_num_frames 0 4 2012 30 EggAnimPreload::get_num_frames 0 1 122 63
/**
 * This is only valid if has_num_frames() returns true.
 */
54
inline int EggAnimPreload::get_num_frames(void) const;

1124 14 get_class_type 0 4 2012 30 EggAnimPreload::get_class_type 0 1 123 0
55
static TypeHandle EggAnimPreload::get_class_type(void);

1125 15 ~EggAnimPreload 0 516 2012 31 EggAnimPreload::~EggAnimPreload 0 0 0
38
EggAnimPreload::~EggAnimPreload(void);

1126 20 upcast_to_MemoryBase 0 12 2014 35 EggAttributes::upcast_to_MemoryBase 0 1 144 39
upcast from EggAttributes to MemoryBase
54
MemoryBase *EggAttributes::upcast_to_MemoryBase(void);

1127 25 downcast_to_EggAttributes 0 12 2015 37 MemoryBase::downcast_to_EggAttributes 0 0 41
downcast from MemoryBase to EggAttributes
59
EggAttributes *MemoryBase::downcast_to_EggAttributes(void);

1128 13 EggAttributes 0 260 2014 28 EggAttributes::EggAttributes 0 2 124 125 22
/**
 *
 */

/**
 *
 */
92
EggAttributes::EggAttributes(void);
EggAttributes::EggAttributes(EggAttributes const &copy);

1129 10 operator = 0 4 2014 25 EggAttributes::operator = 0 1 126 10
/**
 *
 */
58
void EggAttributes::operator =(EggAttributes const &copy);

1130 14 ~EggAttributes 0 518 2014 29 EggAttributes::~EggAttributes 0 0 10
/**
 *
 */
44
virtual EggAttributes::~EggAttributes(void);

1131 10 has_normal 0 4 2014 25 EggAttributes::has_normal 0 1 127 10
/**
 *
 */
50
inline bool EggAttributes::has_normal(void) const;

1132 10 get_normal 0 4 2014 25 EggAttributes::get_normal 0 1 128 10
/**
 *
 */
61
inline LNormald const &EggAttributes::get_normal(void) const;

1133 10 set_normal 0 4 2014 25 EggAttributes::set_normal 0 1 129 10
/**
 *
 */
62
inline void EggAttributes::set_normal(LNormald const &normal);

1134 12 clear_normal 0 4 2014 27 EggAttributes::clear_normal 0 1 130 10
/**
 *
 */
46
inline void EggAttributes::clear_normal(void);

1135 14 matches_normal 0 4 2014 29 EggAttributes::matches_normal 0 1 131 113
/**
 * Returns true if this normal matches that of the other EggAttributes object,
 * include the morph list.
 */
76
inline bool EggAttributes::matches_normal(EggAttributes const &other) const;

1136 11 copy_normal 0 4 2014 26 EggAttributes::copy_normal 0 1 132 130
/**
 * Sets this normal to be the same as the other's, include morphs.  If the
 * other has no normal, this clears the normal.
 */
67
inline void EggAttributes::copy_normal(EggAttributes const &other);

1137 9 has_color 0 4 2014 24 EggAttributes::has_color 0 1 133 10
/**
 *
 */
49
inline bool EggAttributes::has_color(void) const;

1138 9 get_color 0 4 2014 24 EggAttributes::get_color 0 1 134 107
/**
 * Returns the color set on this particular attribute.  If there is no color
 * set, returns white.
 */
51
inline LColor EggAttributes::get_color(void) const;

1139 9 set_color 0 4 2014 24 EggAttributes::set_color 0 1 135 10
/**
 *
 */
58
inline void EggAttributes::set_color(LColor const &Color);

1140 11 clear_color 0 4 2014 26 EggAttributes::clear_color 0 1 136 10
/**
 *
 */
45
inline void EggAttributes::clear_color(void);

1141 13 matches_color 0 4 2014 28 EggAttributes::matches_color 0 1 137 112
/**
 * Returns true if this color matches that of the other EggAttributes object,
 * include the morph list.
 */
75
inline bool EggAttributes::matches_color(EggAttributes const &other) const;

1142 10 copy_color 0 4 2014 25 EggAttributes::copy_color 0 1 138 127
/**
 * Sets this color to be the same as the other's, include morphs.  If the
 * other has no color, this clears the color.
 */
66
inline void EggAttributes::copy_color(EggAttributes const &other);

1143 5 write 0 4 2014 20 EggAttributes::write 0 1 139 78
/**
 * Writes the attributes to the indicated output stream in Egg format.
 */
69
void EggAttributes::write(std::ostream &out, int indent_level) const;

1144 15 sorts_less_than 0 4 2014 30 EggAttributes::sorts_less_than 0 1 140 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
77
inline bool EggAttributes::sorts_less_than(EggAttributes const &other) const;

1145 10 compare_to 0 4 2014 25 EggAttributes::compare_to 0 1 141 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
64
int EggAttributes::compare_to(EggAttributes const &other) const;

1146 9 transform 0 4 2014 24 EggAttributes::transform 0 1 142 73
/**
 * Applies the indicated transformation matrix to the attributes.
 */
52
void EggAttributes::transform(LMatrix4d const &mat);

1147 12 get_dnormals 0 20 2014 27 EggAttributes::get_dnormals 0 0 55
getter for EggMorphNormalList EggAttributes::_dnormals;
59
EggMorphNormalList EggAttributes::get_dnormals(void) const;

1148 10 get_drgbas 0 20 2014 25 EggAttributes::get_drgbas 0 0 52
getter for EggMorphColorList EggAttributes::_drgbas;
56
EggMorphColorList EggAttributes::get_drgbas(void) const;

1149 14 get_class_type 0 4 2014 29 EggAttributes::get_class_type 0 1 143 0
54
static TypeHandle EggAttributes::get_class_type(void);

1150 11 EggVertexUV 0 260 2020 24 EggVertexUV::EggVertexUV 0 3 145 146 147 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
216
explicit EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv);
explicit EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw);
EggVertexUV::EggVertexUV(EggVertexUV const &copy);

1151 10 operator = 0 4 2020 23 EggVertexUV::operator = 0 1 148 10
/**
 *
 */
54
void EggVertexUV::operator =(EggVertexUV const &copy);

1152 11 filter_name 0 4 2020 24 EggVertexUV::filter_name 0 1 149 227
/**
 * Returns the actual name that should be set for a given name string.
 * Usually this is the same string that is input, but for historical reasons
 * the texture coordinate name "default" is mapped to the empty string.
 */
76
static inline std::string EggVertexUV::filter_name(std::string const &name);

1153 8 set_name 0 4 2020 21 EggVertexUV::set_name 0 1 150 10
/**
 *
 */
59
inline void EggVertexUV::set_name(std::string const &name);

1154 18 get_num_dimensions 0 4 2020 31 EggVertexUV::get_num_dimensions 0 1 151 150
/**
 * Returns the number of components of the texture coordinate set.  This is
 * either 2 (the normal case) or 3 (for a 3-d texture coordinate).
 */
55
inline int EggVertexUV::get_num_dimensions(void) const;

1155 5 has_w 0 4 2020 18 EggVertexUV::has_w 0 1 152 131
/**
 * Returns true if the texture coordinate has a third, w component, false if
 * it is just a normal 2-d texture coordinate.
 */
43
inline bool EggVertexUV::has_w(void) const;

1156 6 get_uv 0 4 2020 19 EggVertexUV::get_uv 0 1 153 77
/**
 * Returns the texture coordinate pair, if get_num_dimensions() is 2.
 */
50
inline LTexCoordd EggVertexUV::get_uv(void) const;

1157 7 get_uvw 0 4 2020 20 EggVertexUV::get_uvw 0 1 154 181
/**
 * Returns the texture coordinate triple, if get_num_dimensions() is 3.  This
 * is also legal to call if get_num_dimensions() is 2 (but the last dimension
 * will be zero).
 */
59
inline LTexCoord3d const &EggVertexUV::get_uvw(void) const;

1158 6 set_uv 0 4 2020 19 EggVertexUV::set_uv 0 1 155 133
/**
 * Sets the texture coordinate pair.  This makes the texture coordinate a 2-d
 * texture coordinate, which is the usual case.
 */
60
inline void EggVertexUV::set_uv(LTexCoordd const &texCoord);

1159 7 set_uvw 0 4 2020 20 EggVertexUV::set_uvw 0 1 156 110
/**
 * Sets the texture coordinate triple.  This makes the texture coordinate a
 * 3-d texture coordinate.
 */
62
inline void EggVertexUV::set_uvw(LTexCoord3d const &texCoord);

1160 11 has_tangent 0 4 2020 24 EggVertexUV::has_tangent 0 1 157 10
/**
 *
 */
49
inline bool EggVertexUV::has_tangent(void) const;

1161 12 has_tangent4 0 4 2020 25 EggVertexUV::has_tangent4 0 1 158 10
/**
 *
 */
50
inline bool EggVertexUV::has_tangent4(void) const;

1162 11 get_tangent 0 4 2020 24 EggVertexUV::get_tangent 0 1 159 10
/**
 *
 */
60
inline LNormald const &EggVertexUV::get_tangent(void) const;

1163 12 get_tangent4 0 4 2020 25 EggVertexUV::get_tangent4 0 1 160 10
/**
 *
 */
56
inline LVecBase4d EggVertexUV::get_tangent4(void) const;

1164 11 set_tangent 0 4 2020 24 EggVertexUV::set_tangent 0 1 161 10
/**
 *
 */
62
inline void EggVertexUV::set_tangent(LNormald const &tangent);

1165 12 set_tangent4 0 4 2020 25 EggVertexUV::set_tangent4 0 1 162 158
/**
 * Sets the tangent vector, along with a fourth parameter that is multiplied
 * with the result of cross(normal, tangent) when computing the binormal.
 */
65
inline void EggVertexUV::set_tangent4(LVecBase4d const &tangent);

1166 13 clear_tangent 0 4 2020 26 EggVertexUV::clear_tangent 0 1 163 10
/**
 *
 */
45
inline void EggVertexUV::clear_tangent(void);

1167 12 has_binormal 0 4 2020 25 EggVertexUV::has_binormal 0 1 164 10
/**
 *
 */
50
inline bool EggVertexUV::has_binormal(void) const;

1168 12 get_binormal 0 4 2020 25 EggVertexUV::get_binormal 0 1 165 10
/**
 *
 */
61
inline LNormald const &EggVertexUV::get_binormal(void) const;

1169 12 set_binormal 0 4 2020 25 EggVertexUV::set_binormal 0 1 166 10
/**
 *
 */
64
inline void EggVertexUV::set_binormal(LNormald const &binormal);

1170 14 clear_binormal 0 4 2020 27 EggVertexUV::clear_binormal 0 1 167 10
/**
 *
 */
46
inline void EggVertexUV::clear_binormal(void);

1171 12 make_average 0 4 2020 25 EggVertexUV::make_average 0 1 168 149
/**
 * Creates a new EggVertexUV that contains the averaged values of the two
 * given objects.  It is an error if they don't have the same name.
 */
111
static PointerTo< EggVertexUV > EggVertexUV::make_average(EggVertexUV const *first, EggVertexUV const *second);

1172 9 transform 0 4 2020 22 EggVertexUV::transform 0 1 169 149
/**
 * Applies the indicated transformation matrix to the UV's tangent and/or
 * binormal.  This does nothing if there is no tangent or binormal.
 */
50
void EggVertexUV::transform(LMatrix4d const &mat);

1173 5 write 0 4 2020 18 EggVertexUV::write 0 1 170 10
/**
 *
 */
67
void EggVertexUV::write(std::ostream &out, int indent_level) const;

1174 10 compare_to 0 4 2020 23 EggVertexUV::compare_to 0 1 171 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
60
int EggVertexUV::compare_to(EggVertexUV const &other) const;

1175 8 get_duvs 0 20 2020 21 EggVertexUV::get_duvs 0 0 51
getter for EggMorphTexCoordList EggVertexUV::_duvs;
55
EggMorphTexCoordList EggVertexUV::get_duvs(void) const;

1176 14 get_class_type 0 4 2020 27 EggVertexUV::get_class_type 0 1 172 0
52
static TypeHandle EggVertexUV::get_class_type(void);

1177 12 EggVertexAux 0 260 2023 26 EggVertexAux::EggVertexAux 0 2 173 174 22
/**
 *
 */

/**
 *
 */
138
explicit EggVertexAux::EggVertexAux(std::string const &name, LVecBase4d const &aux);
EggVertexAux::EggVertexAux(EggVertexAux const &copy);

1178 10 operator = 0 4 2023 24 EggVertexAux::operator = 0 1 175 10
/**
 *
 */
56
void EggVertexAux::operator =(EggVertexAux const &copy);

1179 8 set_name 0 4 2023 22 EggVertexAux::set_name 0 1 176 10
/**
 *
 */
60
inline void EggVertexAux::set_name(std::string const &name);

1180 7 get_aux 0 4 2023 21 EggVertexAux::get_aux 0 1 177 48
/**
 * Returns the auxiliary data quadruple.
 */
59
inline LVecBase4d const &EggVertexAux::get_aux(void) const;

1181 7 set_aux 0 4 2023 21 EggVertexAux::set_aux 0 1 178 45
/**
 * Sets the auxiliary data quadruple.
 */
57
inline void EggVertexAux::set_aux(LVecBase4d const &aux);

1182 12 make_average 0 4 2023 26 EggVertexAux::make_average 0 1 179 150
/**
 * Creates a new EggVertexAux that contains the averaged values of the two
 * given objects.  It is an error if they don't have the same name.
 */
115
static PointerTo< EggVertexAux > EggVertexAux::make_average(EggVertexAux const *first, EggVertexAux const *second);

1183 5 write 0 4 2023 19 EggVertexAux::write 0 1 180 10
/**
 *
 */
68
void EggVertexAux::write(std::ostream &out, int indent_level) const;

1184 10 compare_to 0 4 2023 24 EggVertexAux::compare_to 0 1 181 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
62
int EggVertexAux::compare_to(EggVertexAux const &other) const;

1185 14 get_class_type 0 4 2023 28 EggVertexAux::get_class_type 0 1 182 0
53
static TypeHandle EggVertexAux::get_class_type(void);

1186 19 upcast_to_EggObject 0 12 2024 30 EggVertex::upcast_to_EggObject 0 1 241 34
upcast from EggVertex to EggObject
48
EggObject *EggVertex::upcast_to_EggObject(void);

1187 21 downcast_to_EggVertex 0 12 2000 32 EggObject::downcast_to_EggVertex 0 0 36
downcast from EggObject to EggVertex
50
EggVertex *EggObject::downcast_to_EggVertex(void);

1188 23 upcast_to_EggAttributes 0 12 2024 34 EggVertex::upcast_to_EggAttributes 0 1 242 38
upcast from EggVertex to EggAttributes
56
EggAttributes *EggVertex::upcast_to_EggAttributes(void);

1189 21 downcast_to_EggVertex 0 12 2014 36 EggAttributes::downcast_to_EggVertex 0 0 40
downcast from EggAttributes to EggVertex
54
EggVertex *EggAttributes::downcast_to_EggVertex(void);

1190 9 EggVertex 0 260 2024 20 EggVertex::EggVertex 0 2 183 184 121
/**
 *
 */

/**
 * Copies all properties of the vertex except its vertex pool, index number,
 * and group membership.
 */
72
EggVertex::EggVertex(void);
EggVertex::EggVertex(EggVertex const &copy);

1191 10 operator = 0 4 2024 21 EggVertex::operator = 0 1 185 109
/**
 * Copies all properties of the vertex except its vertex pool, index number,
 * and group membership.
 */
50
void EggVertex::operator =(EggVertex const &copy);

1192 10 ~EggVertex 0 518 2024 21 EggVertex::~EggVertex 0 0 10
/**
 *
 */
36
virtual EggVertex::~EggVertex(void);

1193 8 get_pool 0 4 2024 19 EggVertex::get_pool 0 1 186 123
/**
 * Returns the vertex pool this vertex belongs in.  This may be NULL if the
 * vertex has not been added to a pool.
 */
54
inline EggVertexPool *EggVertex::get_pool(void) const;

1194 20 is_forward_reference 0 4 2024 31 EggVertex::is_forward_reference 0 1 187 386
/**
 * Returns true if the vertex is a forward reference to some vertex that
 * hasn't been defined yet.  In this case, the vertex may not have any
 * properties filled in yet.
 *
 * This can only happen if you implicitly create a vertex via
 * EggVertexPool::get_forward_vertex(). Presumably, when the vertex pool is
 * later filled in, this vertex will be replaced with real data.
 */
56
inline bool EggVertex::is_forward_reference(void) const;

1195 7 set_pos 0 4 2024 18 EggVertex::set_pos 0 4 188 189 190 191 485
// The pos might have 1, 2, 3, or 4 dimensions.  That complicates things a
// bit.

/**
 * Sets the vertex position.  This variant sets the vertex to a one-
 * dimensional value.
 */

/**
 * Sets the vertex position.  This variant sets the vertex to a two-
 * dimensional value.
 */

/**
 * Sets the vertex position.  This variant sets the vertex to a three-
 * dimensional value.
 */

/**
 * Sets the vertex position.  This variant sets the vertex to a four-
 * dimensional value.
 */
202
inline void EggVertex::set_pos(double pos);
inline void EggVertex::set_pos(LPoint2d const &pos);
inline void EggVertex::set_pos(LPoint3d const &pos);
inline void EggVertex::set_pos(LPoint4d const &pos);

1196 8 set_pos4 0 4 2024 19 EggVertex::set_pos4 0 1 192 319
/**
 * This special flavor of set_pos() sets the vertex as a four-component value,
 * but does not change the set number of dimensions.  It's handy for
 * retrieving the vertex position via get_pos4, manipulating it, then storing
 * it back again, without worrying about the number of dimensions it actually
 * had.
 */
53
inline void EggVertex::set_pos4(LPoint4d const &pos);

1197 18 get_num_dimensions 0 4 2024 29 EggVertex::get_num_dimensions 0 1 193 487
// get_pos[123] return the pos as the corresponding type.  It is an error to
// call any of these without first verifying that get_num_dimensions()
// matches the desired type.  However, get_pos4() may always be called; it
// returns the pos as a four-component point in homogeneous space (with a
// 1.0 in the last position if the pos has fewer than four components).

/**
 * Returns the number of dimensions the vertex uses.  Usually this will be 3,
 * but it may be 1, 2, 3, or 4.
 */
53
inline int EggVertex::get_num_dimensions(void) const;

1198 8 get_pos1 0 4 2024 19 EggVertex::get_pos1 0 1 194 108
/**
 * Only valid if get_num_dimensions() returns 1. Returns the position as a
 * one-dimensional value.
 */
46
inline double EggVertex::get_pos1(void) const;

1199 8 get_pos2 0 4 2024 19 EggVertex::get_pos2 0 1 195 108
/**
 * Only valid if get_num_dimensions() returns 2. Returns the position as a
 * two-dimensional value.
 */
48
inline LPoint2d EggVertex::get_pos2(void) const;

1200 8 get_pos3 0 4 2024 19 EggVertex::get_pos3 0 1 196 110
/**
 * Valid if get_num_dimensions() returns 3 or 4. Returns the position as a
 * three-dimensional value.
 */
48
inline LVertexd EggVertex::get_pos3(void) const;

1201 8 get_pos4 0 4 2024 19 EggVertex::get_pos4 0 1 197 309
/**
 * This is always valid, regardless of the value of get_num_dimensions.  It
 * returns the position as a four-dimensional value.  If the pos has fewer
 * than four dimensions, this value represents the pos extended into four-
 * dimensional homogenous space, e.g.  by adding 1 as the fourth component.
 */
48
inline LPoint4d EggVertex::get_pos4(void) const;

1202 6 has_uv 0 4 2024 17 EggVertex::has_uv 0 2 198 199 406
/**
 * Returns true if the vertex has an unnamed UV coordinate pair, false
 * otherwise.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see has_uv(name) for the interface that supports
 * multitexturing.
 */

/**
 * Returns true if the vertex has the named UV coordinate pair, and the named
 * UV coordinate pair is 2-d, false otherwise.
 */
97
inline bool EggVertex::has_uv(void) const;
bool EggVertex::has_uv(std::string const &name) const;

1203 6 get_uv 0 4 2024 17 EggVertex::get_uv 0 2 200 201 436
/**
 * Returns the unnamed UV coordinate pair on the vertex.  It is an error to
 * call this if has_uv() has returned false.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see get_uv(name) for the interface that supports
 * multitexturing.
 */

/**
 * Returns the named UV coordinate pair on the vertex.  It is an error to call
 * this if has_uv(name) returned false.
 */
109
inline LTexCoordd EggVertex::get_uv(void) const;
LTexCoordd EggVertex::get_uv(std::string const &name) const;

1204 6 set_uv 0 4 2024 17 EggVertex::set_uv 0 2 202 203 453
/**
 * Replaces the unnamed UV coordinate pair on the vertex with the indicated
 * value.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see set_uv(name, uv) for the interface that
 * supports multitexturing.
 */

/**
 * Sets the indicated UV coordinate pair on the vertex.  This replaces any UV
 * coordinate pair with the same name already on the vertex, but preserves UV
 * morphs.
 */
135
inline void EggVertex::set_uv(LTexCoordd const &texCoord);
void EggVertex::set_uv(std::string const &name, LTexCoordd const &texCoord);

1205 8 clear_uv 0 4 2024 19 EggVertex::clear_uv 0 2 204 205 154
/**
 * Removes all UV coordinate pairs from the vertex.
 */

/**
 * Removes the named UV coordinate pair from the vertex, along with any UV
 * morphs.
 */
89
inline void EggVertex::clear_uv(void);
void EggVertex::clear_uv(std::string const &name);

1206 7 has_uvw 0 4 2024 18 EggVertex::has_uvw 0 1 206 136
/**
 * Returns true if the vertex has the named UV coordinate triple, and the
 * named UV coordinate triple is 3-d, false otherwise.
 */
55
bool EggVertex::has_uvw(std::string const &name) const;

1207 7 get_uvw 0 4 2024 18 EggVertex::get_uvw 0 1 207 129
/**
 * Returns the named UV coordinate triple on the vertex.  It is an error to
 * call this if has_uvw(name) returned false.
 */
69
LTexCoord3d const &EggVertex::get_uvw(std::string const &name) const;

1208 7 set_uvw 0 4 2024 18 EggVertex::set_uvw 0 1 208 186
/**
 * Sets the indicated UV coordinate triple on the vertex.  This replaces any
 * UV coordinate pair or triple with the same name already on the vertex, but
 * preserves UV morphs.
 */
78
void EggVertex::set_uvw(std::string const &name, LTexCoord3d const &texCoord);

1209 10 get_uv_obj 0 4 2024 21 EggVertex::get_uv_obj 0 1 209 298
/**
 * Returns the named EggVertexUV object, which defines both the UV coordinate
 * pair for this name and the UV morphs.  This object might be shared between
 * multiple vertices.  You should not attempt to modify this object; instead,
 * call modify_uv_object to return a modifiable pointer.
 */
72
EggVertexUV const *EggVertex::get_uv_obj(std::string const &name) const;

1210 13 modify_uv_obj 0 4 2024 24 EggVertex::modify_uv_obj 0 1 210 204
/**
 * Returns a modifiable pointer to the named EggVertexUV object, which defines
 * both the UV coordinate pair for this name and the UV morphs.  Returns NULL
 * if there is no such named UV object.
 */
63
EggVertexUV *EggVertex::modify_uv_obj(std::string const &name);

1211 10 set_uv_obj 0 4 2024 21 EggVertex::set_uv_obj 0 1 211 163
/**
 * Sets the indicated EggVertexUV on the vertex.  This replaces any UV
 * coordinate pair with the same name already on the vertex, including UV
 * morphs.
 */
51
void EggVertex::set_uv_obj(EggVertexUV *vertex_uv);

1212 7 has_aux 0 4 2024 18 EggVertex::has_aux 0 2 212 213 157
/**
 * Returns true if the vertex has any auxiliary data, false otherwise.
 */

/**
 * Returns true if the vertex has the named auxiliary data quadruple.
 */
99
inline bool EggVertex::has_aux(void) const;
bool EggVertex::has_aux(std::string const &name) const;

1213 9 clear_aux 0 4 2024 20 EggVertex::clear_aux 0 2 214 215 116
/**
 * Removes all auxiliary data from the vertex.
 */

/**
 * Removes the named auxiliary data from the vertex.
 */
91
inline void EggVertex::clear_aux(void);
void EggVertex::clear_aux(std::string const &name);

1214 7 get_aux 0 4 2024 18 EggVertex::get_aux 0 1 216 133
/**
 * Returns the named auxiliary data quadruple on the vertex.  It is an error
 * to call this if has_aux(name) returned false.
 */
68
LVecBase4d const &EggVertex::get_aux(std::string const &name) const;

1215 7 set_aux 0 4 2024 18 EggVertex::set_aux 0 1 217 148
/**
 * Sets the indicated auxiliary data quadruple on the vertex.  This replaces
 * any auxiliary data with the same name already on the vertex.
 */
72
void EggVertex::set_aux(std::string const &name, LVecBase4d const &aux);

1216 11 get_aux_obj 0 4 2024 22 EggVertex::get_aux_obj 0 1 218 273
/**
 * Returns the named EggVertexAux object, which defines the auxiliary data for
 * this name.  This object might be shared between multiple vertices.  You
 * should not attempt to modify this object; instead, call modify_aux_object
 * to return a modifiable pointer.
 */
74
EggVertexAux const *EggVertex::get_aux_obj(std::string const &name) const;

1217 14 modify_aux_obj 0 4 2024 25 EggVertex::modify_aux_obj 0 1 219 178
/**
 * Returns a modifiable pointer to the named EggVertexAux object, which
 * defines the auxiliary data for this name.  Returns NULL if there is no such
 * named UV object.
 */
65
EggVertexAux *EggVertex::modify_aux_obj(std::string const &name);

1218 11 set_aux_obj 0 4 2024 22 EggVertex::set_aux_obj 0 1 220 136
/**
 * Sets the indicated EggVertexAux on the vertex.  This replaces any auxiliary
 * data with the same name already on the vertex.
 */
54
void EggVertex::set_aux_obj(EggVertexAux *vertex_aux);

1219 12 make_average 0 4 2024 23 EggVertex::make_average 0 1 221 284
/**
 * Creates a new vertex that lies in between the two given vertices.  The
 * attributes for the UV sets they have in common are averaged.
 *
 * Both vertices need to be either in no pool, or in the same pool.  In the
 * latter case, the new vertex will be placed in that pool.
 */
103
static PointerTo< EggVertex > EggVertex::make_average(EggVertex const *first, EggVertex const *second);

1220 9 get_index 0 4 2024 20 EggVertex::get_index 0 1 222 66
/**
 * Returns the index number of the vertex within its pool.
 */
44
inline int EggVertex::get_index(void) const;

1221 18 set_external_index 0 4 2024 29 EggVertex::set_external_index 0 1 223 486
/**
 * Sets a special index number that is associated with the EggVertex (but is
 * not written to the egg file). This number is not interpreted by any egg
 * code; it is simply maintained along with the vertex.  It *is* used to
 * differentiate otherwise identical vertices in
 * EggVertexPool::create_unique_vertex(), however.
 *
 * The intention of this number is as an aid for file converters, to associate
 * an EggVertex back to the index number of the original source vertex.
 */
62
inline void EggVertex::set_external_index(int external_index);

1222 18 get_external_index 0 4 2024 29 EggVertex::get_external_index 0 1 224 85
/**
 * Returns the number set by set_external_index().  See set_external_index().
 */
53
inline int EggVertex::get_external_index(void) const;

1223 19 set_external_index2 0 4 2024 30 EggVertex::set_external_index2 0 1 225 225
/**
 * Similar to set_external_index(), but this is a different number which may
 * be used for a different purpose by the calling code.  The egg library does
 * not assign any meaning to this number or use it in any way.
 */
64
inline void EggVertex::set_external_index2(int external_index2);

1224 19 get_external_index2 0 4 2024 30 EggVertex::get_external_index2 0 1 226 90
/**
 * Returns the number set by set_external_index2().  See
 * set_external_index2().
 */
54
inline int EggVertex::get_external_index2(void) const;

1225 5 write 0 4 2024 16 EggVertex::write 0 1 227 74
/**
 * Writes the vertex to the indicated output stream in Egg format.
 */
65
void EggVertex::write(std::ostream &out, int indent_level) const;

1226 15 sorts_less_than 0 4 2024 26 EggVertex::sorts_less_than 0 1 228 149
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */
69
inline bool EggVertex::sorts_less_than(EggVertex const &other) const;

1227 10 compare_to 0 4 2024 21 EggVertex::compare_to 0 1 229 746
/**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 *
 * Group membership is not considered in this comparison.  This is somewhat
 * problematic, but cannot easily be helped, because considering group
 * membership would make it difficult to add and remove groups from vertices.
 * It also makes it impossible to meaningfully compare with a concrete
 * EggVertex object (which cannot have group memberships).
 *
 * However, this is not altogether bad, because two vertices that are
 * identical in all other properties should generally also be identical in
 * group memberships, else the vertices will tend to fly apart when the joints
 * animate.
 */
56
int EggVertex::compare_to(EggVertex const &other) const;

1228 19 get_num_local_coord 0 4 2024 30 EggVertex::get_num_local_coord 0 1 230 134
/**
 * Returns the number of primitives that own this vertex whose vertices are
 * interpreted to be in a local coordinate system.
 */
47
int EggVertex::get_num_local_coord(void) const;

1229 20 get_num_global_coord 0 4 2024 31 EggVertex::get_num_global_coord 0 1 231 131
/**
 * Returns the number of primitives that own this vertex whose vertices are
 * interpreted in the global coordinate system.
 */
48
int EggVertex::get_num_global_coord(void) const;

1230 9 transform 0 4 2024 20 EggVertex::transform 0 1 232 69
/**
 * Applies the indicated transformation matrix to the vertex.
 */
48
void EggVertex::transform(LMatrix4d const &mat);

1231 8 has_gref 0 4 2024 19 EggVertex::has_gref 0 1 233 90
/**
 * Returns true if the indicated group references this vertex, false
 * otherwise.
 */
54
bool EggVertex::has_gref(EggGroup const *group) const;

1232 15 copy_grefs_from 0 4 2024 26 EggVertex::copy_grefs_from 0 1 234 406
/**
 * Copies all the group references from the other vertex onto this one.  This
 * assigns the current vertex to exactly the same groups, with exactly the
 * same memberships, as the given one.
 *
 * Warning: only an EggVertex allocated from the free store may have groups
 * assigned to it.  Do not attempt to call this on a temporary concrete
 * EggVertex object; a core dump will certainly result.
 */
56
void EggVertex::copy_grefs_from(EggVertex const &other);

1233 11 clear_grefs 0 4 2024 22 EggVertex::clear_grefs 0 1 235 100
/**
 * Removes all group references from the vertex, so that it is not assigned to
 * any group.
 */
34
void EggVertex::clear_grefs(void);

1234 8 has_pref 0 4 2024 19 EggVertex::has_pref 0 1 236 116
/**
 * Returns the number of times the vertex appears in the indicated primitive,
 * or 0 if it does not appear.
 */
56
int EggVertex::has_pref(EggPrimitive const *prim) const;

1235 19 test_gref_integrity 0 4 2024 30 EggVertex::test_gref_integrity 0 1 237 0
48
void EggVertex::test_gref_integrity(void) const;

1236 19 test_pref_integrity 0 4 2024 30 EggVertex::test_pref_integrity 0 1 238 0
48
void EggVertex::test_pref_integrity(void) const;

1237 6 output 0 4 2024 17 EggVertex::output 0 1 239 10
/**
 *
 */
48
void EggVertex::output(std::ostream &out) const;

1238 9 get_dxyzs 0 20 2024 20 EggVertex::get_dxyzs 0 0 48
getter for EggMorphVertexList EggVertex::_dxyzs;
52
EggMorphVertexList EggVertex::get_dxyzs(void) const;

1239 14 get_class_type 0 4 2024 25 EggVertex::get_class_type 0 1 240 0
50
static TypeHandle EggVertex::get_class_type(void);

1240 13 EggVertexPool 0 260 2027 28 EggVertexPool::EggVertexPool 0 2 243 244 210
/**
 *
 */

/**
 * Copying a vertex pool is of questionable value, since it will copy all of
 * the vertices and assign new pointers to them all.  There will be no
 * polygons referring to the new vertices.
 */
120
explicit EggVertexPool::EggVertexPool(std::string const &name);
EggVertexPool::EggVertexPool(EggVertexPool const &copy);

1241 10 has_vertex 0 4 2027 25 EggVertexPool::has_vertex 0 1 245 147
/**
 * Returns true if the indicated vertex has been defined in the vertex pool,
 * false otherwise.  This does not include forward references.
 */
55
inline bool EggVertexPool::has_vertex(int index) const;

1242 20 has_forward_vertices 0 4 2027 35 EggVertexPool::has_forward_vertices 0 1 246 131
/**
 * Returns true if any vertices in the pool are undefined forward-reference
 * vertices, false if all vertices are defined.
 */
53
bool EggVertexPool::has_forward_vertices(void) const;

1243 20 has_defined_vertices 0 4 2027 35 EggVertexPool::has_defined_vertices 0 1 247 128
/**
 * Returns true if any vertices in the pool are fully defined vertices, false
 * if all vertices are forward references.
 */
53
bool EggVertexPool::has_defined_vertices(void) const;

1244 10 get_vertex 0 4 2027 25 EggVertexPool::get_vertex 0 1 248 169
// Returns NULL if there is no such vertex.

/**
 * Returns the vertex in the pool with the indicated index number, or NULL if
 * no vertices have that index number.
 */
54
EggVertex *EggVertexPool::get_vertex(int index) const;

1245 11 operator [] 0 4 2027 26 EggVertexPool::operator [] 0 1 249 124
/**
 * Returns the vertex in the pool with the indicated index number, or NULL if
 * no vertices have that index number.
 */
62
inline EggVertex *EggVertexPool::operator [](int index) const;

1246 18 get_forward_vertex 0 4 2027 33 EggVertexPool::get_forward_vertex 0 1 250 387
// Returns a forward reference if there is no such vertex.

/**
 * Returns the vertex in the pool with the indicated index number.  If there
 * is not a vertex in the pool with the indicated index number, creates a
 * special forward-reference EggVertex that has no data, on the assumption
 * that the vertex pool has not yet been fully read and more data will be
 * available later.
 */
56
EggVertex *EggVertexPool::get_forward_vertex(int index);

1247 17 get_highest_index 0 4 2027 32 EggVertexPool::get_highest_index 0 1 251 176
// Returns 0 if the pool is empty.

/**
 * Returns the highest index number used by any vertex in the pool (except
 * forward references).  Returns -1 if the pool is empty.
 */
49
int EggVertexPool::get_highest_index(void) const;

1248 17 set_highest_index 0 4 2027 32 EggVertexPool::set_highest_index 0 1 252 276
/**
 * Artificially changes the "highest index number", so that a newly created
 * vertex will begin at this number plus 1.  This can be used to default a
 * vertex pool to start counting at 1 (or any other index number), instead of
 * the default of 0.  Use with caution.
 */
57
void EggVertexPool::set_highest_index(int highest_index);

1249 18 get_num_dimensions 0 4 2027 33 EggVertexPool::get_num_dimensions 0 1 253 83
/**
 * Returns the maximum number of dimensions used by any vertex in the pool.
 */
50
int EggVertexPool::get_num_dimensions(void) const;

1250 11 has_normals 0 6 2027 26 EggVertexPool::has_normals 0 1 254 100
/**
 * Returns true if any vertex in the pool has a normal defined, false if none
 * of them do.
 */
52
virtual bool EggVertexPool::has_normals(void) const;

1251 10 has_colors 0 4 2027 25 EggVertexPool::has_colors 0 1 255 99
/**
 * Returns true if any vertex in the pool has a color defined, false if none
 * of them do.
 */
43
bool EggVertexPool::has_colors(void) const;

1252 19 has_nonwhite_colors 0 4 2027 34 EggVertexPool::has_nonwhite_colors 0 1 256 152
/**
 * Returns true if any vertex in the pool has a color defined other than
 * white, false if no vertices have colors, or if all colors are white.
 */
52
bool EggVertexPool::has_nonwhite_colors(void) const;

1253 19 check_overall_color 0 4 2027 34 EggVertexPool::check_overall_color 0 0 376
/**
 * Scans the vertex pool for different colors on different vertices.  If all
 * vertices are the same color, sets has_overall_color to true and fills the
 * color into overall_color.  If no vertices have any color, set
 * has_overall_color to true and fills white into overall_color.  If at least
 * two vertices have different colors, sets has_overall_color to false.
 */
94
void EggVertexPool::check_overall_color(bool &has_overall_color, LColor &overall_color) const;

1254 7 has_uvs 0 4 2027 22 EggVertexPool::has_uvs 0 1 257 96
/**
 * Returns true if any vertex in the pool has a uv defined, false if none of
 * them do.
 */
40
bool EggVertexPool::has_uvs(void) const;

1255 7 has_aux 0 4 2027 22 EggVertexPool::has_aux 0 1 258 106
/**
 * Returns true if any vertex in the pool has auxiliary data defined, false if
 * none of them do.
 */
40
bool EggVertexPool::has_aux(void) const;

1256 12 get_uv_names 0 4 2027 27 EggVertexPool::get_uv_names 0 1 259 351
/**
 * Returns the list of UV names that are defined by any vertices in the pool,
 * as well as the subset of UV names that actually define 3-d texture
 * coordinates ("uvw_names").  Also returns the subset of UV/UVW names that
 * define a tangent and binormal.  It is the user's responsibility to clear
 * both vectors before calling this method.
 */
116
void EggVertexPool::get_uv_names(vector_string &uv_names, vector_string &uvw_names, vector_string &tbn_names) const;

1257 13 get_aux_names 0 4 2027 28 EggVertexPool::get_aux_names 0 1 260 100
/**
 * Returns the list of auxiliary data names that are defined by any vertices
 * in the pool.
 */
66
void EggVertexPool::get_aux_names(vector_string &aux_names) const;

1258 4 size 0 4 2027 19 EggVertexPool::size 0 1 261 54
/**
 * Returns the number of vertices in the pool.
 */
57
EggVertexPool::size_type EggVertexPool::size(void) const;

1259 10 add_vertex 0 4 2027 25 EggVertexPool::add_vertex 0 1 262 908
// add_vertex() adds a freshly-allocated vertex.  It is up to the user to
// allocate the vertex.

/**
 * Adds the indicated vertex to the pool.  It is an error if the vertex is
 * already a member of this or any other pool.  The vertex must have been
 * allocated from the free store; its pointer will now be owned by the vertex
 * pool.  If the index number is supplied, tries to assign that index number;
 * it is an error if the index number is already in use.
 *
 * It is possible that a forward reference to this vertex was requested in the
 * past; if so, the data from the supplied vertex is copied onto the forward
 * reference, which becomes the actual vertex.  In this case, a different
 * pointer is saved (and returned) than the one actually passed in.  In the
 * usual case, however, the vertex pointer passed in is the one that is saved
 * in the vertex pool and returned from this method.
 */
72
EggVertex *EggVertexPool::add_vertex(EggVertex *vertex, int index = -1);

1260 15 make_new_vertex 0 4 2027 30 EggVertexPool::make_new_vertex 0 5 263 264 265 266 267 1272
// make_new_vertex() allocates and returns a new vertex from the pool.

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 */

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */

/**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */
330
inline EggVertex *EggVertexPool::make_new_vertex(void);
inline EggVertex *EggVertexPool::make_new_vertex(double pos);
inline EggVertex *EggVertexPool::make_new_vertex(LPoint2d const &pos);
inline EggVertex *EggVertexPool::make_new_vertex(LPoint3d const &pos);
inline EggVertex *EggVertexPool::make_new_vertex(LPoint4d const &pos);

1261 20 create_unique_vertex 0 4 2027 35 EggVertexPool::create_unique_vertex 0 1 268 350
// create_unique_vertex() creates a new vertex if there is not already one
// identical to the indicated vertex, or returns the existing one if there
// is.

/**
 * Creates a new vertex in the pool that is a copy of the indicated one and
 * returns it.  If there is already a vertex in the pool like the indicated
 * one, simply returns that one.
 */
70
EggVertex *EggVertexPool::create_unique_vertex(EggVertex const &copy);

1262 20 find_matching_vertex 0 4 2027 35 EggVertexPool::find_matching_vertex 0 1 269 212
/**
 * If the EggVertexPool already has a vertex matching the indicated vertex,
 * returns it; otherwise, returns NULL.  This is similar to
 * create_unique_vertex() except that a new vertex is never created.
 */
70
EggVertex *EggVertexPool::find_matching_vertex(EggVertex const &copy);

1263 13 remove_vertex 0 4 2027 28 EggVertexPool::remove_vertex 0 1 270 114
/**
 * Removes the vertex from the pool.  It is an error if the vertex is not
 * already a member of the pool.
 */
53
void EggVertexPool::remove_vertex(EggVertex *vertex);

1264 22 remove_unused_vertices 0 4 2027 37 EggVertexPool::remove_unused_vertices 0 1 271 292
/**
 * Removes all vertices from the pool that are not referenced by at least one
 * primitive.  Also collapses together equivalent vertices, and renumbers all
 * vertices after the operation so their indices are consecutive, beginning at
 * zero.  Returns the number of vertices removed.
 */
48
int EggVertexPool::remove_unused_vertices(void);

1265 27 add_unused_vertices_to_prim 0 4 2027 42 EggVertexPool::add_unused_vertices_to_prim 0 1 272 113
/**
 * Adds all of the unused vertices in this vertex pool to the indicated
 * primitive, in ascending order.
 */
68
void EggVertexPool::add_unused_vertices_to_prim(EggPrimitive *prim);

1266 9 transform 0 4 2027 24 EggVertexPool::transform 0 1 273 419
/**
 * Applies the indicated transformation matrix to all the vertices.  However,
 * vertices that are attached to primitives that believe their vertices are in
 * a local coordinate system are transformed only by the scale and rotation
 * component.  If a vertex happens to be attached both to a local and a global
 * primitive, and the transformation includes a translation component, the
 * vertex will be split.
 */
52
void EggVertexPool::transform(LMatrix4d const &mat);

1267 22 sort_by_external_index 0 4 2027 37 EggVertexPool::sort_by_external_index 0 1 274 186
/**
 * Re-orders (and re-numbers) the vertices in this vertex pool so that they
 * appear in increasing order by the optional external_index that has been
 * assigned to each vertex.
 */
49
void EggVertexPool::sort_by_external_index(void);

1268 14 get_class_type 0 4 2027 29 EggVertexPool::get_class_type 0 1 275 0
54
static TypeHandle EggVertexPool::get_class_type(void);

1269 13 EggRenderMode 0 260 2028 28 EggRenderMode::EggRenderMode 0 2 276 277 22
/**
 *
 */

/**
 *
 */
99
EggRenderMode::EggRenderMode(void);
inline EggRenderMode::EggRenderMode(EggRenderMode const &copy);

1270 10 operator = 0 4 2028 25 EggRenderMode::operator = 0 1 278 10
/**
 *
 */
58
void EggRenderMode::operator =(EggRenderMode const &copy);

1271 5 write 0 4 2028 20 EggRenderMode::write 0 1 279 78
/**
 * Writes the attributes to the indicated output stream in Egg format.
 */
69
void EggRenderMode::write(std::ostream &out, int indent_level) const;

1272 14 set_alpha_mode 0 4 2028 29 EggRenderMode::set_alpha_mode 0 1 280 500
/**
 * Specifies precisely how the transparency for this geometry should be
 * achieved, or if it should be used.  The default, AM_unspecified, is to use
 * transparency if the geometry has a color whose alpha value is non-1, or if
 * it has a four-channel texture applied; otherwise, AM_on forces transparency
 * on, and AM_off forces it off.  The other flavors of transparency are
 * specific ways to turn on transparency, which may or may not be supported by
 * a particular rendering backend.
 */
73
inline void EggRenderMode::set_alpha_mode(EggRenderMode::AlphaMode mode);

1273 14 get_alpha_mode 0 4 2028 29 EggRenderMode::get_alpha_mode 0 1 281 110
/**
 * Returns the alpha mode that was set, or AM_unspecified if nothing was set.
 * See set_alpha_mode().
 */
74
inline EggRenderMode::AlphaMode EggRenderMode::get_alpha_mode(void) const;

1274 20 set_depth_write_mode 0 4 2028 35 EggRenderMode::set_depth_write_mode 0 1 282 160
/**
 * Specifies whether writes should be made to the depth buffer (assuming the
 * rendering backend provides a depth buffer) when rendering this geometry.
 */
84
inline void EggRenderMode::set_depth_write_mode(EggRenderMode::DepthWriteMode mode);

1275 20 get_depth_write_mode 0 4 2028 35 EggRenderMode::get_depth_write_mode 0 1 283 124
/**
 * Returns the depth_write mode that was set, or DWM_unspecified if nothing
 * was set.  See set_depth_write_mode().
 */
85
inline EggRenderMode::DepthWriteMode EggRenderMode::get_depth_write_mode(void) const;

1276 19 set_depth_test_mode 0 4 2028 34 EggRenderMode::set_depth_test_mode 0 1 284 238
/**
 * Specifies whether this geometry should be tested against the depth buffer
 * when it is drawn (assuming the rendering backend provides a depth buffer).
 * Note that this is different, and independent from, the depth_write mode.
 */
82
inline void EggRenderMode::set_depth_test_mode(EggRenderMode::DepthTestMode mode);

1277 19 get_depth_test_mode 0 4 2028 34 EggRenderMode::get_depth_test_mode 0 1 285 122
/**
 * Returns the depth_test mode that was set, or DTM_unspecified if nothing was
 * set.  See set_depth_test_mode().
 */
83
inline EggRenderMode::DepthTestMode EggRenderMode::get_depth_test_mode(void) const;

1278 19 set_visibility_mode 0 4 2028 34 EggRenderMode::set_visibility_mode 0 1 286 252
/**
 * Specifies whether this geometry is to be considered normally visible, or
 * hidden.  If it is hidden, it is either not loaded into the scene graph at
 * all, or loaded as a "stashed" node, according to the setting of egg-
 * suppress-hidden.
 */
83
inline void EggRenderMode::set_visibility_mode(EggRenderMode::VisibilityMode mode);

1279 19 get_visibility_mode 0 4 2028 34 EggRenderMode::get_visibility_mode 0 1 287 121
/**
 * Returns the visibility mode that was set, or VM_unspecified if nothing was
 * set.  See set_visibility_mode().
 */
84
inline EggRenderMode::VisibilityMode EggRenderMode::get_visibility_mode(void) const;

1280 16 set_depth_offset 0 4 2028 31 EggRenderMode::set_depth_offset 0 1 288 198
/**
 * Sets the "depth-offset" flag associated with this object.  This adds or
 * subtracts an offset bias into the depth buffer.  See also DepthOffsetAttrib
 * and NodePath::set_depth_offset().
 */
54
inline void EggRenderMode::set_depth_offset(int bias);

1281 16 get_depth_offset 0 4 2028 31 EggRenderMode::get_depth_offset 0 1 289 105
/**
 * Returns the "depth-offset" flag as set for this particular object.  See
 * set_depth_offset().
 */
55
inline int EggRenderMode::get_depth_offset(void) const;

1282 16 has_depth_offset 0 4 2028 31 EggRenderMode::has_depth_offset 0 1 290 117
/**
 * Returns true if the depth-offset flag has been set for this particular
 * object.  See set_depth_offset().
 */
56
inline bool EggRenderMode::has_depth_offset(void) const;

1283 18 clear_depth_offset 0 4 2028 33 EggRenderMode::clear_depth_offset 0 1 291 97
/**
 * Removes the depth-offset flag from this particular object.  See
 * set_depth_offset().
 */
52
inline void EggRenderMode::clear_depth_offset(void);

1284 14 set_draw_order 0 4 2028 29 EggRenderMode::set_draw_order 0 1 292 260
/**
 * Sets the "draw-order" flag associated with this object.  This specifies a
 * particular order in which objects of this type should be drawn, within the
 * specified bin.  If a bin is not explicitly specified, "fixed" is used.  See
 * also set_bin().
 */
53
inline void EggRenderMode::set_draw_order(int order);

1285 14 get_draw_order 0 4 2028 29 EggRenderMode::get_draw_order 0 1 293 101
/**
 * Returns the "draw-order" flag as set for this particular object.  See
 * set_draw_order().
 */
53
inline int EggRenderMode::get_draw_order(void) const;

1286 14 has_draw_order 0 4 2028 29 EggRenderMode::has_draw_order 0 1 294 113
/**
 * Returns true if the draw-order flag has been set for this particular
 * object.  See set_draw_order().
 */
54
inline bool EggRenderMode::has_draw_order(void) const;

1287 16 clear_draw_order 0 4 2028 31 EggRenderMode::clear_draw_order 0 1 295 93
/**
 * Removes the draw-order flag from this particular object.  See
 * set_draw_order().
 */
50
inline void EggRenderMode::clear_draw_order(void);

1288 7 set_bin 0 4 2028 22 EggRenderMode::set_bin 0 1 296 378
/**
 * Sets the "bin" string for this particular object.  This names a particular
 * bin in which the object should be rendered.  The exact meaning of a bin is
 * implementation defined, but generally a GeomBin matching each bin name must
 * also be specifically added to the rendering engine (e.g.  the
 * CullTraverser) in use for this to work.  See also set_draw_order().
 */
59
inline void EggRenderMode::set_bin(std::string const &bin);

1289 7 get_bin 0 4 2028 22 EggRenderMode::get_bin 0 1 297 103
/**
 * Returns the bin name that has been set for this particular object, if any.
 * See set_bin().
 */
54
inline std::string EggRenderMode::get_bin(void) const;

1290 7 has_bin 0 4 2028 22 EggRenderMode::has_bin 0 1 298 97
/**
 * Returns true if a bin name has been set for this particular object.  See
 * set_bin().
 */
47
inline bool EggRenderMode::has_bin(void) const;

1291 9 clear_bin 0 4 2028 24 EggRenderMode::clear_bin 0 1 299 91
/**
 * Removes the bin name that was set for this particular object.  See
 * set_bin().
 */
43
inline void EggRenderMode::clear_bin(void);

1292 11 operator == 0 4 2028 26 EggRenderMode::operator == 0 1 300 34
// Comparison operators are handy.
66
bool EggRenderMode::operator ==(EggRenderMode const &other) const;

1293 11 operator != 0 4 2028 26 EggRenderMode::operator != 0 1 301 0
73
inline bool EggRenderMode::operator !=(EggRenderMode const &other) const;

1294 10 operator < 0 4 2028 25 EggRenderMode::operator < 0 1 302 0
65
bool EggRenderMode::operator <(EggRenderMode const &other) const;

1295 17 string_alpha_mode 0 4 2028 32 EggRenderMode::string_alpha_mode 0 1 303 167
/**
 * Returns the AlphaMode value associated with the given string
 * representation, or AM_unspecified if the string does not match any known
 * AlphaMode value.
 */
92
static EggRenderMode::AlphaMode EggRenderMode::string_alpha_mode(std::string const &string);

1296 23 string_depth_write_mode 0 4 2028 38 EggRenderMode::string_depth_write_mode 0 1 304 178
/**
 * Returns the DepthWriteMode value associated with the given string
 * representation, or DWM_unspecified if the string does not match any known
 * DepthWriteMode value.
 */
103
static EggRenderMode::DepthWriteMode EggRenderMode::string_depth_write_mode(std::string const &string);

1297 22 string_depth_test_mode 0 4 2028 37 EggRenderMode::string_depth_test_mode 0 1 305 176
/**
 * Returns the DepthTestMode value associated with the given string
 * representation, or DTM_unspecified if the string does not match any known
 * DepthTestMode value.
 */
101
static EggRenderMode::DepthTestMode EggRenderMode::string_depth_test_mode(std::string const &string);

1298 22 string_visibility_mode 0 4 2028 37 EggRenderMode::string_visibility_mode 0 1 306 169
/**
 * Returns the HiddenMode value associated with the given string
 * representation, or VM_unspecified if the string does not match any known
 * HiddenMode value.
 */
102
static EggRenderMode::VisibilityMode EggRenderMode::string_visibility_mode(std::string const &string);

1299 14 get_class_type 0 4 2028 29 EggRenderMode::get_class_type 0 1 307 0
54
static TypeHandle EggRenderMode::get_class_type(void);

1300 14 ~EggRenderMode 0 516 2028 29 EggRenderMode::~EggRenderMode 0 0 0
36
EggRenderMode::~EggRenderMode(void);

1301 20 upcast_to_MemoryBase 0 12 2033 34 EggTransform::upcast_to_MemoryBase 0 1 341 38
upcast from EggTransform to MemoryBase
53
MemoryBase *EggTransform::upcast_to_MemoryBase(void);

1302 24 downcast_to_EggTransform 0 12 2015 36 MemoryBase::downcast_to_EggTransform 0 0 40
downcast from MemoryBase to EggTransform
57
EggTransform *MemoryBase::downcast_to_EggTransform(void);

1303 12 EggTransform 0 260 2033 26 EggTransform::EggTransform 0 2 308 309 22
/**
 *
 */

/**
 *
 */
87
EggTransform::EggTransform(void);
EggTransform::EggTransform(EggTransform const &copy);

1304 10 operator = 0 4 2033 24 EggTransform::operator = 0 1 310 10
/**
 *
 */
56
void EggTransform::operator =(EggTransform const &copy);

1305 13 ~EggTransform 0 518 2033 27 EggTransform::~EggTransform 0 0 10
/**
 *
 */
42
virtual EggTransform::~EggTransform(void);

1306 15 clear_transform 0 4 2033 29 EggTransform::clear_transform 0 1 311 51
/**
 * Resets the transform to empty, identity.
 */
48
inline void EggTransform::clear_transform(void);

1307 15 add_translate2d 0 4 2033 29 EggTransform::add_translate2d 0 1 312 72
/**
 * Appends a 2-d translation operation to the current transform.
 */
63
void EggTransform::add_translate2d(LVector2d const &translate);

1308 15 add_translate3d 0 4 2033 29 EggTransform::add_translate3d 0 1 313 72
/**
 * Appends a 3-d translation operation to the current transform.
 */
63
void EggTransform::add_translate3d(LVector3d const &translate);

1309 12 add_rotate2d 0 4 2033 26 EggTransform::add_rotate2d 0 1 314 141
/**
 * Appends a 2-d rotation to the current transform.  The rotation angle is
 * specified in degrees counterclockwise about the origin.
 */
46
void EggTransform::add_rotate2d(double angle);

1310 8 add_rotx 0 4 2033 22 EggTransform::add_rotx 0 1 315 152
/**
 * Appends a rotation about the X axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */
42
void EggTransform::add_rotx(double angle);

1311 8 add_roty 0 4 2033 22 EggTransform::add_roty 0 1 316 152
/**
 * Appends a rotation about the Y axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */
42
void EggTransform::add_roty(double angle);

1312 8 add_rotz 0 4 2033 22 EggTransform::add_rotz 0 1 317 152
/**
 * Appends a rotation about the Z axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */
42
void EggTransform::add_rotz(double angle);

1313 12 add_rotate3d 0 4 2033 26 EggTransform::add_rotate3d 0 2 318 319 324
/**
 * Appends a 3-d rotation about an arbitrary axis to the current transform.
 * The rotation angle is specified in degrees counterclockwise about the axis.
 */

/**
 * Appends an arbitrary 3-d rotation to the current transform, expressed as a
 * quaternion.  This is converted to axis-angle notation for the egg file.
 */
128
void EggTransform::add_rotate3d(double angle, LVector3d const &axis);
void EggTransform::add_rotate3d(LQuaterniond const &quat);

1314 11 add_scale2d 0 4 2033 25 EggTransform::add_scale2d 0 1 320 73
/**
 * Appends a possibly non-uniform scale to the current transform.
 */
56
void EggTransform::add_scale2d(LVecBase2d const &scale);

1315 11 add_scale3d 0 4 2033 25 EggTransform::add_scale3d 0 1 321 73
/**
 * Appends a possibly non-uniform scale to the current transform.
 */
56
void EggTransform::add_scale3d(LVecBase3d const &scale);

1316 17 add_uniform_scale 0 4 2033 31 EggTransform::add_uniform_scale 0 1 322 60
/**
 * Appends a uniform scale to the current transform.
 */
51
void EggTransform::add_uniform_scale(double scale);

1317 11 add_matrix3 0 4 2033 25 EggTransform::add_matrix3 0 1 323 68
/**
 * Appends an arbitrary 3x3 matrix to the current transform.
 */
60
inline void EggTransform::add_matrix3(LMatrix3d const &mat);

1318 11 add_matrix4 0 4 2033 25 EggTransform::add_matrix4 0 1 324 68
/**
 * Appends an arbitrary 4x4 matrix to the current transform.
 */
60
inline void EggTransform::add_matrix4(LMatrix4d const &mat);

1319 13 has_transform 0 4 2033 27 EggTransform::has_transform 0 1 325 174
/**
 * Returns true if the transform is nonempty, false if it is empty (no
 * transform components have been added).  This is true for either a 2-d or a
 * 3-d transform.
 */
52
inline bool EggTransform::has_transform(void) const;

1320 15 has_transform2d 0 4 2033 29 EggTransform::has_transform2d 0 1 326 328
/**
 * Returns true if the transform is specified as a 2-d transform, e.g.  with a
 * 3x3 matrix, or false if it is specified as a 3-d transform (with a 4x4
 * matrix), or not specified at all.
 *
 * Normally, EggTextures have a 2-d matrix (but occasionally they use a 3-d
 * matrix), and EggGroups always have a 3-d matrix.
 */
54
inline bool EggTransform::has_transform2d(void) const;

1321 15 set_transform2d 0 4 2033 29 EggTransform::set_transform2d 0 1 327 139
/**
 * Sets the overall transform as a 3x3 matrix.  This completely replaces
 * whatever componentwise transform may have been defined.
 */
64
inline void EggTransform::set_transform2d(LMatrix3d const &mat);

1322 15 has_transform3d 0 4 2033 29 EggTransform::has_transform3d 0 1 328 328
/**
 * Returns true if the transform is specified as a 3-d transform, e.g.  with a
 * 4x4 matrix, or false if it is specified as a 2-d transform (with a 2x2
 * matrix), or not specified at all.
 *
 * Normally, EggTextures have a 3-d matrix (but occasionally they use a 3-d
 * matrix), and EggGroups always have a 3-d matrix.
 */
54
inline bool EggTransform::has_transform3d(void) const;

1323 15 set_transform3d 0 4 2033 29 EggTransform::set_transform3d 0 1 329 139
/**
 * Sets the overall transform as a 4x4 matrix.  This completely replaces
 * whatever componentwise transform may have been defined.
 */
64
inline void EggTransform::set_transform3d(LMatrix4d const &mat);

1324 15 get_transform2d 0 4 2033 29 EggTransform::get_transform2d 0 1 330 119
/**
 * Returns the overall transform as a 3x3 matrix.  It is an error to call this
 * if has_transform3d() is true.
 */
59
inline LMatrix3d EggTransform::get_transform2d(void) const;

1325 15 get_transform3d 0 4 2033 29 EggTransform::get_transform3d 0 1 331 190
/**
 * Returns the overall transform as a 4x4 matrix.  It is valid to call this
 * even if has_transform2d() is true; in this case, the 3x3 transform will be
 * expanded to a 4x4 matrix.
 */
66
inline LMatrix4d const &EggTransform::get_transform3d(void) const;

1326 21 transform_is_identity 0 4 2033 35 EggTransform::transform_is_identity 0 1 332 80
/**
 * Returns true if the described transform is identity, false otherwise.
 */
60
inline bool EggTransform::transform_is_identity(void) const;

1327 18 get_num_components 0 4 2033 32 EggTransform::get_num_components 0 1 333 71
/**
 * Returns the number of components that make up the transform.
 */
56
inline int EggTransform::get_num_components(void) const;

1328 18 get_component_type 0 4 2033 32 EggTransform::get_component_type 0 1 334 49
/**
 * Returns the type of the nth component.
 */
81
inline EggTransform::ComponentType EggTransform::get_component_type(int n) const;

1329 20 get_component_number 0 4 2033 34 EggTransform::get_component_number 0 1 335 252
/**
 * Returns the solitary number associated with the nth component.  In the case
 * of a rotation, this is the angle in degrees to rotate; in the case of
 * uniform scale, this is the amount of the scale.  Other types do not use
 * this property.
 */
62
inline double EggTransform::get_component_number(int n) const;

1330 18 get_component_vec2 0 4 2033 32 EggTransform::get_component_vec2 0 1 336 239
/**
 * Returns the 2-component vector associated with the nth component.  This may
 * be the translate vector, rotate axis, or non-uniform scale.  It is an error
 * to call this if the component type does not use a 2-d vector property.
 */
71
inline LVecBase2d const &EggTransform::get_component_vec2(int n) const;

1331 18 get_component_vec3 0 4 2033 32 EggTransform::get_component_vec3 0 1 337 239
/**
 * Returns the 3-component vector associated with the nth component.  This may
 * be the translate vector, rotate axis, or non-uniform scale.  It is an error
 * to call this if the component type does not use a 3-d vector property.
 */
71
inline LVecBase3d const &EggTransform::get_component_vec3(int n) const;

1332 18 get_component_mat3 0 4 2033 32 EggTransform::get_component_mat3 0 1 338 141
/**
 * Returns the 3x3 matrix associated with the nth component.  It is an error
 * to call this if the component type is not CT_matrix3.
 */
70
inline LMatrix3d const &EggTransform::get_component_mat3(int n) const;

1333 18 get_component_mat4 0 4 2033 32 EggTransform::get_component_mat4 0 1 339 141
/**
 * Returns the 4x4 matrix associated with the nth component.  It is an error
 * to call this if the component type is not CT_matrix4.
 */
70
inline LMatrix4d const &EggTransform::get_component_mat4(int n) const;

1334 5 write 0 4 2033 19 EggTransform::write 0 1 340 70
/**
 * Writes the transform to the indicated stream in Egg format.
 */
94
void EggTransform::write(std::ostream &out, int indent_level, std::string const &label) const;

1335 9 make_copy 0 6 2035 29 EggSwitchCondition::make_copy 0 1 342 0
74
virtual EggSwitchCondition *EggSwitchCondition::make_copy(void) const = 0;

1336 5 write 0 6 2035 25 EggSwitchCondition::write 0 1 343 0
86
virtual void EggSwitchCondition::write(std::ostream &out, int indent_level) const = 0;

1337 9 transform 0 6 2035 29 EggSwitchCondition::transform 0 1 344 0
69
virtual void EggSwitchCondition::transform(LMatrix4d const &mat) = 0;

1338 14 get_class_type 0 4 2035 34 EggSwitchCondition::get_class_type 0 1 345 0
59
static TypeHandle EggSwitchCondition::get_class_type(void);

1339 19 ~EggSwitchCondition 0 516 2035 39 EggSwitchCondition::~EggSwitchCondition 0 0 0
46
EggSwitchCondition::~EggSwitchCondition(void);

1340 26 EggSwitchConditionDistance 0 260 2036 54 EggSwitchConditionDistance::EggSwitchConditionDistance 0 1 346 10
/**
 *
 */
144
explicit EggSwitchConditionDistance::EggSwitchConditionDistance(double switch_in, double switch_out, LPoint3d const &center, double fade = 0.0);

1341 14 get_class_type 0 4 2036 42 EggSwitchConditionDistance::get_class_type 0 1 347 0
67
static TypeHandle EggSwitchConditionDistance::get_class_type(void);

1342 27 ~EggSwitchConditionDistance 0 516 2036 55 EggSwitchConditionDistance::~EggSwitchConditionDistance 0 0 0
62
EggSwitchConditionDistance::~EggSwitchConditionDistance(void);

1343 22 upcast_to_EggGroupNode 0 12 2037 32 EggGroup::upcast_to_EggGroupNode 0 1 486 36
upcast from EggGroup to EggGroupNode
53
EggGroupNode *EggGroup::upcast_to_EggGroupNode(void);

1344 20 downcast_to_EggGroup 0 12 2005 34 EggGroupNode::downcast_to_EggGroup 0 0 38
downcast from EggGroupNode to EggGroup
51
EggGroup *EggGroupNode::downcast_to_EggGroup(void);

1345 23 upcast_to_EggRenderMode 0 12 2037 33 EggGroup::upcast_to_EggRenderMode 0 1 487 37
upcast from EggGroup to EggRenderMode
55
EggRenderMode *EggGroup::upcast_to_EggRenderMode(void);

1346 20 downcast_to_EggGroup 0 12 2028 35 EggRenderMode::downcast_to_EggGroup 0 0 39
downcast from EggRenderMode to EggGroup
52
EggGroup *EggRenderMode::downcast_to_EggGroup(void);

1347 22 upcast_to_EggTransform 0 12 2037 32 EggGroup::upcast_to_EggTransform 0 1 488 36
upcast from EggGroup to EggTransform
53
EggTransform *EggGroup::upcast_to_EggTransform(void);

1348 20 downcast_to_EggGroup 0 12 2033 34 EggTransform::downcast_to_EggGroup 0 0 38
downcast from EggTransform to EggGroup
51
EggGroup *EggTransform::downcast_to_EggGroup(void);

1349 8 EggGroup 0 260 2037 18 EggGroup::EggGroup 0 2 348 349 22
/**
 *
 */

/**
 *
 */
100
explicit EggGroup::EggGroup(std::string const &name = "");
EggGroup::EggGroup(EggGroup const &copy);

1350 10 operator = 0 4 2037 20 EggGroup::operator = 0 1 350 10
/**
 *
 */
48
void EggGroup::operator =(EggGroup const &copy);

1351 9 ~EggGroup 0 518 2037 19 EggGroup::~EggGroup 0 0 10
/**
 *
 */
34
virtual EggGroup::~EggGroup(void);

1352 5 write 0 6 2037 15 EggGroup::write 0 1 351 100
/**
 * Writes the group and all of its children to the indicated output stream in
 * Egg format.
 */
72
virtual void EggGroup::write(std::ostream &out, int indent_level) const;

1353 21 write_billboard_flags 0 4 2037 31 EggGroup::write_billboard_flags 0 1 352 92
/**
 * Writes just the <Billboard> entry and related fields to the indicated
 * ostream.
 */
80
void EggGroup::write_billboard_flags(std::ostream &out, int indent_level) const;

1354 19 write_collide_flags 0 4 2037 29 EggGroup::write_collide_flags 0 1 353 90
/**
 * Writes just the <Collide> entry and related fields to the indicated
 * ostream.
 */
78
void EggGroup::write_collide_flags(std::ostream &out, int indent_level) const;

1355 17 write_model_flags 0 4 2037 27 EggGroup::write_model_flags 0 1 354 78
/**
 * Writes the <Model> flag and related flags to the indicated ostream.
 */
76
void EggGroup::write_model_flags(std::ostream &out, int indent_level) const;

1356 18 write_switch_flags 0 4 2037 28 EggGroup::write_switch_flags 0 1 355 79
/**
 * Writes the <Switch> flag and related flags to the indicated ostream.
 */
77
void EggGroup::write_switch_flags(std::ostream &out, int indent_level) const;

1357 18 write_object_types 0 4 2037 28 EggGroup::write_object_types 0 1 356 83
/**
 * Writes just the <ObjectTypes> entries, if any, to the indicated ostream.
 */
77
void EggGroup::write_object_types(std::ostream &out, int indent_level) const;

1358 17 write_decal_flags 0 4 2037 27 EggGroup::write_decal_flags 0 1 357 56
/**
 * Writes the flags related to decaling, if any.
 */
76
void EggGroup::write_decal_flags(std::ostream &out, int indent_level) const;

1359 10 write_tags 0 4 2037 20 EggGroup::write_tags 0 1 358 75
/**
 * Writes just the <Tag> entries, if any, to the indicated ostream.
 */
69
void EggGroup::write_tags(std::ostream &out, int indent_level) const;

1360 17 write_render_mode 0 4 2037 27 EggGroup::write_render_mode 0 1 359 114
/**
 * Writes the flags inherited from EggRenderMode and similar flags that
 * control obscure render effects.
 */
76
void EggGroup::write_render_mode(std::ostream &out, int indent_level) const;

1361 8 is_joint 0 6 2037 18 EggGroup::is_joint 0 1 360 229
/**
 * Returns true if this particular node represents a <Joint> entry or not.
 * This is a handy thing to know since Joints are sorted to the end of their
 * sibling list when writing an egg file.  See EggGroupNode::write().
 */
44
virtual bool EggGroup::is_joint(void) const;

1362 20 determine_alpha_mode 0 6 2037 30 EggGroup::determine_alpha_mode 0 1 361 267
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has an alpha_mode
 * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */
60
virtual EggRenderMode *EggGroup::determine_alpha_mode(void);

1363 26 determine_depth_write_mode 0 6 2037 36 EggGroup::determine_depth_write_mode 0 1 362 273
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
66
virtual EggRenderMode *EggGroup::determine_depth_write_mode(void);

1364 25 determine_depth_test_mode 0 6 2037 35 EggGroup::determine_depth_test_mode 0 1 363 272
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
65
virtual EggRenderMode *EggGroup::determine_depth_test_mode(void);

1365 25 determine_visibility_mode 0 6 2037 35 EggGroup::determine_visibility_mode 0 1 364 271
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
65
virtual EggRenderMode *EggGroup::determine_visibility_mode(void);

1366 22 determine_depth_offset 0 6 2037 32 EggGroup::determine_depth_offset 0 1 365 252
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a depth_offset
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
62
virtual EggRenderMode *EggGroup::determine_depth_offset(void);

1367 20 determine_draw_order 0 6 2037 30 EggGroup::determine_draw_order 0 1 366 250
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a draw_order
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
60
virtual EggRenderMode *EggGroup::determine_draw_order(void);

1368 13 determine_bin 0 6 2037 23 EggGroup::determine_bin 0 1 367 243
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a bin
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
53
virtual EggRenderMode *EggGroup::determine_bin(void);

1369 17 determine_indexed 0 6 2037 27 EggGroup::determine_indexed 0 1 368 321
/**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "indexed" scalar set.  Returns the value of the indexed scalar
 * if it is found, or false if it is not.
 *
 * In other words, returns true if the "indexed" flag is in effect for the
 * indicated node, false otherwise.
 */
47
virtual bool EggGroup::determine_indexed(void);

1370 15 determine_decal 0 6 2037 25 EggGroup::determine_decal 0 1 369 311
/**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "decal" flag set.  Returns the value of the decal flag if it
 * is found, or false if it is not.
 *
 * In other words, returns true if the "decal" flag is in effect for the
 * indicated node, false otherwise.
 */
45
virtual bool EggGroup::determine_decal(void);

1371 14 set_group_type 0 4 2037 24 EggGroup::set_group_type 0 1 370 10
/**
 *
 */
56
void EggGroup::set_group_type(EggGroup::GroupType type);

1372 14 get_group_type 0 4 2037 24 EggGroup::get_group_type 0 1 371 10
/**
 *
 */
64
inline EggGroup::GroupType EggGroup::get_group_type(void) const;

1373 16 is_instance_type 0 4 2037 26 EggGroup::is_instance_type 0 1 372 368
/**
 * Returns true if this group is an instance type node; i.e.  it begins the
 * root of a local coordinate space.  This is not related to instancing
 * (multiple copies of a node in a scene graph).
 *
 * This also includes the case of the node including a billboard flag without
 * an explicit center, which implicitly makes the node behave like an
 * instance.
 */
51
inline bool EggGroup::is_instance_type(void) const;

1374 18 set_billboard_type 0 4 2037 28 EggGroup::set_billboard_type 0 1 373 10
/**
 *
 */
71
inline void EggGroup::set_billboard_type(EggGroup::BillboardType type);

1375 18 get_billboard_type 0 4 2037 28 EggGroup::get_billboard_type 0 1 374 10
/**
 *
 */
72
inline EggGroup::BillboardType EggGroup::get_billboard_type(void) const;

1376 20 set_billboard_center 0 4 2037 30 EggGroup::set_billboard_center 0 1 375 694
/**
 * Sets the point around which the billboard will rotate, if this node
 * contains a billboard specification.
 *
 * If a billboard type is given but no billboard_center is specified, then the
 * group node is treated as an <Instance>, and the billboard rotates around
 * the origin.  If, however, a billboard_center is specified, then the group
 * node is *not* treated as an <Instance>, and the billboard rotates around
 * the specified point.
 *
 * The point is in the same coordinate system as the vertices of this node:
 * usually global, but possibly local if there is an <Instance> somewhere
 * above.  Specifically, this is the coordinate system defined by
 * get_vertex_frame().
 */
77
inline void EggGroup::set_billboard_center(LPoint3d const &billboard_center);

1377 22 clear_billboard_center 0 4 2037 32 EggGroup::clear_billboard_center 0 1 376 10
/**
 *
 */
51
inline void EggGroup::clear_billboard_center(void);

1378 20 has_billboard_center 0 4 2037 30 EggGroup::has_billboard_center 0 1 377 10
/**
 *
 */
55
inline bool EggGroup::has_billboard_center(void) const;

1379 20 get_billboard_center 0 4 2037 30 EggGroup::get_billboard_center 0 1 378 10
/**
 *
 */
66
inline LPoint3d const &EggGroup::get_billboard_center(void) const;

1380 11 set_cs_type 0 4 2037 21 EggGroup::set_cs_type 0 1 379 10
/**
 *
 */
69
inline void EggGroup::set_cs_type(EggGroup::CollisionSolidType type);

1381 11 get_cs_type 0 4 2037 21 EggGroup::get_cs_type 0 1 380 10
/**
 *
 */
70
inline EggGroup::CollisionSolidType EggGroup::get_cs_type(void) const;

1382 17 set_collide_flags 0 4 2037 27 EggGroup::set_collide_flags 0 1 381 10
/**
 *
 */
51
inline void EggGroup::set_collide_flags(int flags);

1383 17 get_collide_flags 0 4 2037 27 EggGroup::get_collide_flags 0 1 382 10
/**
 *
 */
70
inline EggGroup::CollideFlags EggGroup::get_collide_flags(void) const;

1384 18 set_collision_name 0 4 2037 28 EggGroup::set_collision_name 0 1 383 10
/**
 *
 */
76
inline void EggGroup::set_collision_name(std::string const &collision_name);

1385 20 clear_collision_name 0 4 2037 30 EggGroup::clear_collision_name 0 1 384 10
/**
 *
 */
49
inline void EggGroup::clear_collision_name(void);

1386 18 has_collision_name 0 4 2037 28 EggGroup::has_collision_name 0 1 385 10
/**
 *
 */
53
inline bool EggGroup::has_collision_name(void) const;

1387 18 get_collision_name 0 4 2037 28 EggGroup::get_collision_name 0 1 386 10
/**
 *
 */
67
inline std::string const &EggGroup::get_collision_name(void) const;

1388 12 set_dcs_type 0 4 2037 22 EggGroup::set_dcs_type 0 1 387 10
/**
 *
 */
59
inline void EggGroup::set_dcs_type(EggGroup::DCSType type);

1389 12 get_dcs_type 0 4 2037 22 EggGroup::get_dcs_type 0 1 388 10
/**
 *
 */
60
inline EggGroup::DCSType EggGroup::get_dcs_type(void) const;

1390 12 has_dcs_type 0 4 2037 22 EggGroup::has_dcs_type 0 1 389 91
/**
 * Returns true if the specified DCS type is not DC_none and not
 * DC_unspecified.
 */
47
inline bool EggGroup::has_dcs_type(void) const;

1391 13 set_dart_type 0 4 2037 23 EggGroup::set_dart_type 0 1 390 10
/**
 *
 */
61
inline void EggGroup::set_dart_type(EggGroup::DartType type);

1392 13 get_dart_type 0 4 2037 23 EggGroup::get_dart_type 0 1 391 10
/**
 *
 */
62
inline EggGroup::DartType EggGroup::get_dart_type(void) const;

1393 15 set_switch_flag 0 4 2037 25 EggGroup::set_switch_flag 0 1 392 10
/**
 *
 */
49
inline void EggGroup::set_switch_flag(bool flag);

1394 15 get_switch_flag 0 4 2037 25 EggGroup::get_switch_flag 0 1 393 10
/**
 *
 */
50
inline bool EggGroup::get_switch_flag(void) const;

1395 14 set_switch_fps 0 4 2037 24 EggGroup::set_switch_fps 0 1 394 10
/**
 *
 */
49
inline void EggGroup::set_switch_fps(double fps);

1396 14 get_switch_fps 0 4 2037 24 EggGroup::get_switch_fps 0 1 395 10
/**
 *
 */
51
inline double EggGroup::get_switch_fps(void) const;

1397 15 add_object_type 0 4 2037 25 EggGroup::add_object_type 0 1 396 10
/**
 *
 */
70
inline void EggGroup::add_object_type(std::string const &object_type);

1398 18 clear_object_types 0 4 2037 28 EggGroup::clear_object_types 0 1 397 10
/**
 *
 */
47
inline void EggGroup::clear_object_types(void);

1399 20 get_num_object_types 0 4 2037 30 EggGroup::get_num_object_types 0 1 398 10
/**
 *
 */
54
inline int EggGroup::get_num_object_types(void) const;

1400 15 get_object_type 0 4 2037 25 EggGroup::get_object_type 0 1 399 10
/**
 *
 */
62
inline std::string EggGroup::get_object_type(int index) const;

1401 15 has_object_type 0 4 2037 25 EggGroup::has_object_type 0 1 400 104
/**
 * Returns true if the indicated object type has been added to the group, or
 * false otherwise.
 */
69
bool EggGroup::has_object_type(std::string const &object_type) const;

1402 18 remove_object_type 0 4 2037 28 EggGroup::remove_object_type 0 1 401 178
/**
 * Removes the first instance of the indicated object type from the group if
 * it is present.  Returns true if the object type was found and removed,
 * false otherwise.
 */
66
bool EggGroup::remove_object_type(std::string const &object_type);

1403 14 set_model_flag 0 4 2037 24 EggGroup::set_model_flag 0 1 402 10
/**
 *
 */
48
inline void EggGroup::set_model_flag(bool flag);

1404 14 get_model_flag 0 4 2037 24 EggGroup::get_model_flag 0 1 403 10
/**
 *
 */
49
inline bool EggGroup::get_model_flag(void) const;

1405 16 set_texlist_flag 0 4 2037 26 EggGroup::set_texlist_flag 0 1 404 10
/**
 *
 */
50
inline void EggGroup::set_texlist_flag(bool flag);

1406 16 get_texlist_flag 0 4 2037 26 EggGroup::get_texlist_flag 0 1 405 10
/**
 *
 */
51
inline bool EggGroup::get_texlist_flag(void) const;

1407 14 set_nofog_flag 0 4 2037 24 EggGroup::set_nofog_flag 0 1 406 10
/**
 *
 */
48
inline void EggGroup::set_nofog_flag(bool flag);

1408 14 get_nofog_flag 0 4 2037 24 EggGroup::get_nofog_flag 0 1 407 10
/**
 *
 */
49
inline bool EggGroup::get_nofog_flag(void) const;

1409 14 set_decal_flag 0 4 2037 24 EggGroup::set_decal_flag 0 1 408 10
/**
 *
 */
48
inline void EggGroup::set_decal_flag(bool flag);

1410 14 get_decal_flag 0 4 2037 24 EggGroup::get_decal_flag 0 1 409 10
/**
 *
 */
49
inline bool EggGroup::get_decal_flag(void) const;

1411 15 set_direct_flag 0 4 2037 25 EggGroup::set_direct_flag 0 1 410 10
/**
 *
 */
49
inline void EggGroup::set_direct_flag(bool flag);

1412 15 get_direct_flag 0 4 2037 25 EggGroup::get_direct_flag 0 1 411 10
/**
 *
 */
50
inline bool EggGroup::get_direct_flag(void) const;

1413 15 set_portal_flag 0 4 2037 25 EggGroup::set_portal_flag 0 1 412 10
/**
 *
 */
49
inline void EggGroup::set_portal_flag(bool flag);

1414 15 get_portal_flag 0 4 2037 25 EggGroup::get_portal_flag 0 1 413 10
/**
 *
 */
50
inline bool EggGroup::get_portal_flag(void) const;

1415 17 set_occluder_flag 0 4 2037 27 EggGroup::set_occluder_flag 0 1 414 10
/**
 *
 */
51
inline void EggGroup::set_occluder_flag(bool flag);

1416 17 get_occluder_flag 0 4 2037 27 EggGroup::get_occluder_flag 0 1 415 10
/**
 *
 */
52
inline bool EggGroup::get_occluder_flag(void) const;

1417 18 set_polylight_flag 0 4 2037 28 EggGroup::set_polylight_flag 0 1 416 10
/**
 *
 */
52
inline void EggGroup::set_polylight_flag(bool flag);

1418 18 get_polylight_flag 0 4 2037 28 EggGroup::get_polylight_flag 0 1 417 10
/**
 *
 */
53
inline bool EggGroup::get_polylight_flag(void) const;

1419 16 set_indexed_flag 0 4 2037 26 EggGroup::set_indexed_flag 0 1 418 106
/**
 * If this flag is true, geometry at this node and below will be generated as
 * indexed geometry.
 */
50
inline void EggGroup::set_indexed_flag(bool flag);

1420 18 clear_indexed_flag 0 4 2037 28 EggGroup::clear_indexed_flag 0 1 419 10
/**
 *
 */
47
inline void EggGroup::clear_indexed_flag(void);

1421 16 has_indexed_flag 0 4 2037 26 EggGroup::has_indexed_flag 0 1 420 10
/**
 *
 */
51
inline bool EggGroup::has_indexed_flag(void) const;

1422 16 get_indexed_flag 0 4 2037 26 EggGroup::get_indexed_flag 0 1 421 10
/**
 *
 */
51
inline bool EggGroup::get_indexed_flag(void) const;

1423 16 set_collide_mask 0 4 2037 26 EggGroup::set_collide_mask 0 1 422 10
/**
 *
 */
57
inline void EggGroup::set_collide_mask(CollideMask mask);

1424 18 clear_collide_mask 0 4 2037 28 EggGroup::clear_collide_mask 0 1 423 10
/**
 *
 */
47
inline void EggGroup::clear_collide_mask(void);

1425 16 has_collide_mask 0 4 2037 26 EggGroup::has_collide_mask 0 1 424 10
/**
 *
 */
51
inline bool EggGroup::has_collide_mask(void) const;

1426 16 get_collide_mask 0 4 2037 26 EggGroup::get_collide_mask 0 1 425 10
/**
 *
 */
58
inline CollideMask EggGroup::get_collide_mask(void) const;

1427 21 set_from_collide_mask 0 4 2037 31 EggGroup::set_from_collide_mask 0 1 426 10
/**
 *
 */
62
inline void EggGroup::set_from_collide_mask(CollideMask mask);

1428 23 clear_from_collide_mask 0 4 2037 33 EggGroup::clear_from_collide_mask 0 1 427 10
/**
 *
 */
52
inline void EggGroup::clear_from_collide_mask(void);

1429 21 has_from_collide_mask 0 4 2037 31 EggGroup::has_from_collide_mask 0 1 428 10
/**
 *
 */
56
inline bool EggGroup::has_from_collide_mask(void) const;

1430 21 get_from_collide_mask 0 4 2037 31 EggGroup::get_from_collide_mask 0 1 429 10
/**
 *
 */
63
inline CollideMask EggGroup::get_from_collide_mask(void) const;

1431 21 set_into_collide_mask 0 4 2037 31 EggGroup::set_into_collide_mask 0 1 430 10
/**
 *
 */
62
inline void EggGroup::set_into_collide_mask(CollideMask mask);

1432 23 clear_into_collide_mask 0 4 2037 33 EggGroup::clear_into_collide_mask 0 1 431 10
/**
 *
 */
52
inline void EggGroup::clear_into_collide_mask(void);

1433 21 has_into_collide_mask 0 4 2037 31 EggGroup::has_into_collide_mask 0 1 432 10
/**
 *
 */
56
inline bool EggGroup::has_into_collide_mask(void) const;

1434 21 get_into_collide_mask 0 4 2037 31 EggGroup::get_into_collide_mask 0 1 433 10
/**
 *
 */
63
inline CollideMask EggGroup::get_into_collide_mask(void) const;

1435 14 set_blend_mode 0 4 2037 24 EggGroup::set_blend_mode 0 1 434 10
/**
 *
 */
69
inline void EggGroup::set_blend_mode(EggGroup::BlendMode blend_mode);

1436 14 get_blend_mode 0 4 2037 24 EggGroup::get_blend_mode 0 1 435 10
/**
 *
 */
64
inline EggGroup::BlendMode EggGroup::get_blend_mode(void) const;

1437 19 set_blend_operand_a 0 4 2037 29 EggGroup::set_blend_operand_a 0 1 436 10
/**
 *
 */
82
inline void EggGroup::set_blend_operand_a(EggGroup::BlendOperand blend_operand_a);

1438 19 get_blend_operand_a 0 4 2037 29 EggGroup::get_blend_operand_a 0 1 437 10
/**
 *
 */
72
inline EggGroup::BlendOperand EggGroup::get_blend_operand_a(void) const;

1439 19 set_blend_operand_b 0 4 2037 29 EggGroup::set_blend_operand_b 0 1 438 10
/**
 *
 */
82
inline void EggGroup::set_blend_operand_b(EggGroup::BlendOperand blend_operand_b);

1440 19 get_blend_operand_b 0 4 2037 29 EggGroup::get_blend_operand_b 0 1 439 10
/**
 *
 */
72
inline EggGroup::BlendOperand EggGroup::get_blend_operand_b(void) const;

1441 15 set_blend_color 0 4 2037 25 EggGroup::set_blend_color 0 1 440 10
/**
 *
 */
65
inline void EggGroup::set_blend_color(LColor const &blend_color);

1442 17 clear_blend_color 0 4 2037 27 EggGroup::clear_blend_color 0 1 441 49
/**
 * Removes the blend color specification.
 */
46
inline void EggGroup::clear_blend_color(void);

1443 15 has_blend_color 0 4 2037 25 EggGroup::has_blend_color 0 1 442 79
/**
 * Returns true if the blend color has been specified, false otherwise.
 */
50
inline bool EggGroup::has_blend_color(void) const;

1444 15 get_blend_color 0 4 2037 25 EggGroup::get_blend_color 0 1 443 96
/**
 * Returns the blend color if one has been specified, or (0, 0, 0, 0) if one
 * has not.
 */
59
inline LColor const &EggGroup::get_blend_color(void) const;

1445 7 set_lod 0 4 2037 17 EggGroup::set_lod 0 1 444 10
/**
 *
 */
61
inline void EggGroup::set_lod(EggSwitchCondition const &lod);

1446 9 clear_lod 0 4 2037 19 EggGroup::clear_lod 0 1 445 10
/**
 *
 */
38
inline void EggGroup::clear_lod(void);

1447 7 has_lod 0 4 2037 17 EggGroup::has_lod 0 1 446 10
/**
 *
 */
42
inline bool EggGroup::has_lod(void) const;

1448 7 get_lod 0 4 2037 17 EggGroup::get_lod 0 1 447 10
/**
 *
 */
63
inline EggSwitchCondition const &EggGroup::get_lod(void) const;

1449 7 set_tag 0 4 2037 17 EggGroup::set_tag 0 1 448 524
/**
 * Associates a user-defined value with a user-defined key which is stored on
 * the node.  This value has no meaning to Panda; but it is stored
 * indefinitely on the node until it is requested again.  This value will be
 * copied to the PandaNode that is created for this particular EggGroup if the
 * egg file is loaded as a scene.
 *
 * Each unique key stores a different string value.  There is no effective
 * limit on the number of different keys that may be stored or on the length
 * of any one key's value.
 */
80
inline void EggGroup::set_tag(std::string const &key, std::string const &value);

1450 7 get_tag 0 4 2037 17 EggGroup::get_tag 0 1 449 182
/**
 * Retrieves the user-defined value that was previously set on this node for
 * the particular key, if any.  If no value has been previously set, returns
 * the empty string.
 */
67
inline std::string EggGroup::get_tag(std::string const &key) const;

1451 7 has_tag 0 4 2037 17 EggGroup::has_tag 0 1 450 170
/**
 * Returns true if a value has been defined on this node for the particular
 * key (even if that value is the empty string), or false if no value has been
 * set.
 */
60
inline bool EggGroup::has_tag(std::string const &key) const;

1452 9 clear_tag 0 4 2037 19 EggGroup::clear_tag 0 1 451 158
/**
 * Removes the value defined for this key on this particular node.  After a
 * call to clear_tag(), has_tag() will return false for the indicated key.
 */
56
inline void EggGroup::clear_tag(std::string const &key);

1453 16 get_default_pose 0 4 2037 26 EggGroup::get_default_pose 0 1 452 315
/**
 * Returns a read-only accessor to the initial pose transform.  This is the
 * <DefaultPose> entry for a Joint, and defines only the initial transform
 * pose for the unanimated joint; it has nothing to do with the group's
 * <Transform> entry, which defines the (eventual) space of the group's
 * vertices.
 */
66
inline EggTransform const &EggGroup::get_default_pose(void) const;

1454 19 modify_default_pose 0 4 2037 29 EggGroup::modify_default_pose 0 1 453 314
/**
 * Returns a writable accessor to the initial pose transform.  This is the
 * <DefaultPose> entry for a Joint, and defines only the initial transform
 * pose for the unanimated joint; it has nothing to do with the group's
 * <Transform> entry, which defines the (eventual) space of the group's
 * vertices.
 */
57
inline EggTransform &EggGroup::modify_default_pose(void);

1455 16 set_default_pose 0 4 2037 26 EggGroup::set_default_pose 0 1 454 289
/**
 * Replaces the initial pose transform.  This is the <DefaultPose> entry for a
 * Joint, and defines only the initial transform pose for the unanimated
 * joint; it has nothing to do with the group's <Transform> entry, which
 * defines the (eventual) space of the group's vertices.
 */
70
inline void EggGroup::set_default_pose(EggTransform const &transform);

1456 18 clear_default_pose 0 4 2037 28 EggGroup::clear_default_pose 0 1 455 71
/**
 * Removes the initial pose transform.  See set_default_pose().
 */
47
inline void EggGroup::clear_default_pose(void);

1457 12 set_scroll_u 0 4 2037 22 EggGroup::set_scroll_u 0 1 456 0
57
inline void EggGroup::set_scroll_u(double const u_speed);

1458 12 set_scroll_v 0 4 2037 22 EggGroup::set_scroll_v 0 1 457 0
57
inline void EggGroup::set_scroll_v(double const v_speed);

1459 12 set_scroll_w 0 4 2037 22 EggGroup::set_scroll_w 0 1 458 0
57
inline void EggGroup::set_scroll_w(double const w_speed);

1460 12 set_scroll_r 0 4 2037 22 EggGroup::set_scroll_r 0 1 459 0
57
inline void EggGroup::set_scroll_r(double const r_speed);

1461 12 get_scroll_u 0 4 2037 22 EggGroup::get_scroll_u 0 1 460 0
49
inline double EggGroup::get_scroll_u(void) const;

1462 12 get_scroll_v 0 4 2037 22 EggGroup::get_scroll_v 0 1 461 0
49
inline double EggGroup::get_scroll_v(void) const;

1463 12 get_scroll_w 0 4 2037 22 EggGroup::get_scroll_w 0 1 462 0
49
inline double EggGroup::get_scroll_w(void) const;

1464 12 get_scroll_r 0 4 2037 22 EggGroup::get_scroll_r 0 1 463 0
49
inline double EggGroup::get_scroll_r(void) const;

1465 17 has_scrolling_uvs 0 4 2037 27 EggGroup::has_scrolling_uvs 0 1 464 0
46
inline bool EggGroup::has_scrolling_uvs(void);

1466 10 ref_vertex 0 4 2037 20 EggGroup::ref_vertex 0 1 465 213
/**
 * Adds the vertex to the set of those referenced by the group, at the
 * indicated membership level.  If the vertex is already being referenced,
 * increases the membership amount by the indicated amount.
 */
68
void EggGroup::ref_vertex(EggVertex *vert, double membership = 1.0);

1467 12 unref_vertex 0 4 2037 22 EggGroup::unref_vertex 0 1 466 130
/**
 * Removes the vertex from the set of those referenced by the group.  Does
 * nothing if the vertex is not already reffed.
 */
45
void EggGroup::unref_vertex(EggVertex *vert);

1468 18 unref_all_vertices 0 4 2037 28 EggGroup::unref_all_vertices 0 1 467 56
/**
 * Removes all vertices from the reference list.
 */
40
void EggGroup::unref_all_vertices(void);

1469 21 get_vertex_membership 0 4 2037 31 EggGroup::get_vertex_membership 0 1 468 139
/**
 * Returns the amount of membership of the indicated vertex in this group.  If
 * the vertex is not reffed by the group, returns 0.
 */
68
double EggGroup::get_vertex_membership(EggVertex const *vert) const;

1470 21 set_vertex_membership 0 4 2037 31 EggGroup::set_vertex_membership 0 1 469 106
/**
 * Explicitly sets the net membership of the indicated vertex in this group to
 * the given value.
 */
73
void EggGroup::set_vertex_membership(EggVertex *vert, double membership);

1471 11 steal_vrefs 0 4 2037 21 EggGroup::steal_vrefs 0 1 470 195
/**
 * Moves all of the vertex references from the indicated other group into this
 * one.  If a given vertex was previously shared by both groups, the relative
 * memberships will be summed.
 */
44
void EggGroup::steal_vrefs(EggGroup *other);

1472 19 test_vref_integrity 0 4 2037 29 EggGroup::test_vref_integrity 0 1 471 0
47
void EggGroup::test_vref_integrity(void) const;

1473 13 add_group_ref 0 4 2037 23 EggGroup::add_group_ref 0 1 472 207
/**
 * Adds a new <Ref> entry to the group.  This declares an internal reference
 * to another node, and is used to implement scene-graph instancing; it is
 * only valid if the group_type is GT_instance.
 */
46
void EggGroup::add_group_ref(EggGroup *group);

1474 18 get_num_group_refs 0 4 2037 28 EggGroup::get_num_group_refs 0 1 473 90
/**
 * Returns the number of <Ref> entries within this group.  See
 * add_group_ref().
 */
45
int EggGroup::get_num_group_refs(void) const;

1475 13 get_group_ref 0 4 2037 23 EggGroup::get_group_ref 0 1 474 79
/**
 * Returns the nth <Ref> entry within this group.  See add_group_ref().
 */
47
EggGroup *EggGroup::get_group_ref(int n) const;

1476 16 remove_group_ref 0 4 2037 26 EggGroup::remove_group_ref 0 1 475 79
/**
 * Removes the nth <Ref> entry within this group.  See add_group_ref().
 */
39
void EggGroup::remove_group_ref(int n);

1477 16 clear_group_refs 0 4 2037 26 EggGroup::clear_group_refs 0 1 476 84
/**
 * Removes all of the <Ref> entries within this group.  See add_group_ref().
 */
38
void EggGroup::clear_group_refs(void);

1478 17 string_group_type 0 4 2037 27 EggGroup::string_group_type 0 1 477 163
/**
 * Returns the GroupType value associated with the given string
 * representation, or GT_invalid if the string does not match any known
 * GroupType value.
 */
82
static EggGroup::GroupType EggGroup::string_group_type(std::string const &strval);

1479 16 string_dart_type 0 4 2037 26 EggGroup::string_dart_type 0 1 478 155
/**
 * Returns the DartType value associated with the given string representation,
 * or DT_none if the string does not match any known DartType value.
 */
80
static EggGroup::DartType EggGroup::string_dart_type(std::string const &strval);

1480 15 string_dcs_type 0 4 2037 25 EggGroup::string_dcs_type 0 1 479 160
/**
 * Returns the DCSType value associated with the given string representation,
 * or DC_unspecified if the string does not match any known DCSType value.
 */
78
static EggGroup::DCSType EggGroup::string_dcs_type(std::string const &strval);

1481 21 string_billboard_type 0 4 2037 31 EggGroup::string_billboard_type 0 1 480 168
/**
 * Returns the BillboardType value associated with the given string
 * representation, or BT_none if the string does not match any known
 * BillboardType value.
 */
90
static EggGroup::BillboardType EggGroup::string_billboard_type(std::string const &strval);

1482 14 string_cs_type 0 4 2037 24 EggGroup::string_cs_type 0 1 481 179
/**
 * Returns the CollisionSolidType value associated with the given string
 * representation, or CST_none if the string does not match any known
 * CollisionSolidType value.
 */
88
static EggGroup::CollisionSolidType EggGroup::string_cs_type(std::string const &strval);

1483 20 string_collide_flags 0 4 2037 30 EggGroup::string_collide_flags 0 1 482 260
/**
 * Returns the CollideFlags value associated with the given string
 * representation, or CF_none if the string does not match any known
 * CollideFlags value.  This only recognizes a single keyword; it does not
 * attempt to parse a string of keywords.
 */
88
static EggGroup::CollideFlags EggGroup::string_collide_flags(std::string const &strval);

1484 17 string_blend_mode 0 4 2037 27 EggGroup::string_blend_mode 0 1 483 154
/**
 * Returns the BlendMode value associated with the given string
 * representation, or BM_none if the string does not match any known
 * BlendMode.
 */
82
static EggGroup::BlendMode EggGroup::string_blend_mode(std::string const &strval);

1485 20 string_blend_operand 0 4 2037 30 EggGroup::string_blend_operand 0 1 484 160
/**
 * Returns the BlendOperand value associated with the given string
 * representation, or BO_none if the string does not match any known
 * BlendOperand.
 */
88
static EggGroup::BlendOperand EggGroup::string_blend_operand(std::string const &strval);

1486 14 get_class_type 0 4 2037 24 EggGroup::get_class_type 0 1 485 0
49
static TypeHandle EggGroup::get_class_type(void);

1487 6 EggBin 0 260 2065 14 EggBin::EggBin 0 3 489 490 491 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
128
explicit EggBin::EggBin(std::string const &name = "");
EggBin::EggBin(EggGroup const &copy);
EggBin::EggBin(EggBin const &copy);

1488 14 set_bin_number 0 4 2065 22 EggBin::set_bin_number 0 1 492 10
/**
 *
 */
44
void EggBin::set_bin_number(int bin_number);

1489 14 get_bin_number 0 4 2065 22 EggBin::get_bin_number 0 1 493 10
/**
 *
 */
39
int EggBin::get_bin_number(void) const;

1490 14 get_class_type 0 4 2065 22 EggBin::get_class_type 0 1 494 0
47
static TypeHandle EggBin::get_class_type(void);

1491 7 ~EggBin 0 516 2065 15 EggBin::~EggBin 0 0 0
22
EggBin::~EggBin(void);

1492 9 make_bins 0 4 2066 22 EggBinMaker::make_bins 0 1 495 208
/**
 * The main entry point to EggBinMaker.  Walks the egg scene graph beginning
 * at the indicated root node, and moves all binnable nodes into EggBin
 * objects.  Returns the number of EggBins created.
 */
53
int EggBinMaker::make_bins(EggGroupNode *root_group);

1493 12 prepare_node 0 6 2066 25 EggBinMaker::prepare_node 0 1 496 171
/**
 * May be overridden in derived classes to perform some setup work as each
 * node is encountered.  This will be called once for each node in the egg
 * hierarchy.
 */
54
virtual void EggBinMaker::prepare_node(EggNode *node);

1494 14 get_bin_number 0 6 2066 27 EggBinMaker::get_bin_number 0 1 497 0
65
virtual int EggBinMaker::get_bin_number(EggNode const *node) = 0;

1495 10 sorts_less 0 6 2066 23 EggBinMaker::sorts_less 0 1 498 361
/**
 * May be overridden in derived classes to create additional bins within a
 * particular bin number, based on some arbitrary property of nodes.  This
 * function establishes an arbitrary but fixed ordering between nodes; if two
 * nodes do not sort to the same position, different bins are created for each
 * one (with the same bin number on each bin).
 */
89
virtual bool EggBinMaker::sorts_less(int bin_number, EggNode const *a, EggNode const *b);

1496 14 collapse_group 0 6 2066 27 EggBinMaker::collapse_group 0 1 499 145
/**
 * May be overridden in derived classes to specify whether a particular group
 * node, apparently redundant, may be safely collapsed out.
 */
80
virtual bool EggBinMaker::collapse_group(EggGroup const *group, int bin_number);

1497 12 get_bin_name 0 6 2066 25 EggBinMaker::get_bin_name 0 1 500 130
/**
 * May be overridden in derived classes to define a name for each new bin,
 * based on its bin number, and a sample child.
 */
84
virtual std::string EggBinMaker::get_bin_name(int bin_number, EggNode const *child);

1498 8 make_bin 0 6 2066 21 EggBinMaker::make_bin 0 1 501 352
/**
 * May be overridden in derived classes to construct a new EggBin object (or
 * some derived class, if needed), and preload some initial data into as
 * required.
 *
 * child is an arbitrary child of the bin, and collapse_from is the group the
 * bin is being collapsed with, if any (implying collapse_group() returned
 * true), or NULL if not.
 */
113
virtual PointerTo< EggBin > EggBinMaker::make_bin(int bin_number, EggNode const *child, EggGroup *collapse_from);

1499 14 get_class_type 0 4 2066 27 EggBinMaker::get_class_type 0 1 502 0
52
static TypeHandle EggBinMaker::get_class_type(void);

1500 10 EggComment 0 260 2067 22 EggComment::EggComment 0 2 503 504 22
/**
 *
 */

/**
 *
 */
152
inline explicit EggComment::EggComment(std::string const &node_name, std::string const &comment);
inline EggComment::EggComment(EggComment const &copy);

1501 10 operator = 0 4 2067 22 EggComment::operator = 0 2 505 506 22
/**
 *
 */

/**
 *
 */
123
inline void EggComment::operator =(std::string const &comment);
inline void EggComment::operator =(EggComment const &copy);

1502 17 operator typecast 0 132 2067 29 EggComment::operator typecast 0 1 511 0
48
inline operator std::string const &(void) const;

1503 11 set_comment 0 4 2067 23 EggComment::set_comment 0 1 507 10
/**
 *
 */
64
inline void EggComment::set_comment(std::string const &comment);

1504 11 get_comment 0 4 2067 23 EggComment::get_comment 0 1 508 10
/**
 *
 */
55
inline std::string EggComment::get_comment(void) const;

1505 10 __reduce__ 0 4 2067 22 EggComment::__reduce__ 0 1 509 0
45
PyObject *EggComment::__reduce__(void) const;

1506 14 get_class_type 0 4 2067 26 EggComment::get_class_type 0 1 510 0
51
static TypeHandle EggComment::get_class_type(void);

1507 11 ~EggComment 0 516 2067 23 EggComment::~EggComment 0 0 0
30
EggComment::~EggComment(void);

1508 10 operator = 0 4 2068 27 EggFilenameNode::operator = 0 1 512 10
/**
 *
 */
69
inline void EggFilenameNode::operator =(EggFilenameNode const &copy);

1509 21 get_default_extension 0 6 2068 38 EggFilenameNode::get_default_extension 0 1 513 64
/**
 * Returns the default extension for this filename type.
 */
71
virtual std::string EggFilenameNode::get_default_extension(void) const;

1510 12 get_filename 0 4 2068 29 EggFilenameNode::get_filename 0 1 514 61
/**
 * Returns a nonmodifiable reference to the filename.
 */
65
inline Filename const &EggFilenameNode::get_filename(void) const;

1511 12 set_filename 0 4 2068 29 EggFilenameNode::set_filename 0 1 515 10
/**
 *
 */
68
inline void EggFilenameNode::set_filename(Filename const &filename);

1512 12 get_fullpath 0 4 2068 29 EggFilenameNode::get_fullpath 0 1 516 472
/**
 * Returns the full pathname to the file, if it is known; otherwise, returns
 * the same thing as get_filename().
 *
 * This function simply returns whatever was set by the last call to
 * set_fullpath().  This string is not written to the egg file; its main
 * purpose is to record the full path to a filename (for instance, a texture
 * filename) if it is known, for egg structures that are generated in-memory
 * and then immediately converted to a scene graph.
 */
65
inline Filename const &EggFilenameNode::get_fullpath(void) const;

1513 12 set_fullpath 0 4 2068 29 EggFilenameNode::set_fullpath 0 1 517 84
/**
 * Records the full pathname to the file, for the benefit of get_fullpath().
 */
68
inline void EggFilenameNode::set_fullpath(Filename const &fullpath);

1514 14 get_class_type 0 4 2068 31 EggFilenameNode::get_class_type 0 1 518 0
56
static TypeHandle EggFilenameNode::get_class_type(void);

1515 16 ~EggFilenameNode 0 516 2068 33 EggFilenameNode::~EggFilenameNode 0 0 0
40
EggFilenameNode::~EggFilenameNode(void);

1516 25 upcast_to_EggFilenameNode 0 12 2069 37 EggTexture::upcast_to_EggFilenameNode 0 1 639 41
upcast from EggTexture to EggFilenameNode
61
EggFilenameNode *EggTexture::upcast_to_EggFilenameNode(void);

1517 22 downcast_to_EggTexture 0 12 2068 39 EggFilenameNode::downcast_to_EggTexture 0 0 43
downcast from EggFilenameNode to EggTexture
58
EggTexture *EggFilenameNode::downcast_to_EggTexture(void);

1518 23 upcast_to_EggRenderMode 0 12 2069 35 EggTexture::upcast_to_EggRenderMode 0 1 640 39
upcast from EggTexture to EggRenderMode
57
EggRenderMode *EggTexture::upcast_to_EggRenderMode(void);

1519 22 downcast_to_EggTexture 0 12 2028 37 EggRenderMode::downcast_to_EggTexture 0 0 41
downcast from EggRenderMode to EggTexture
56
EggTexture *EggRenderMode::downcast_to_EggTexture(void);

1520 22 upcast_to_EggTransform 0 12 2069 34 EggTexture::upcast_to_EggTransform 0 1 641 38
upcast from EggTexture to EggTransform
55
EggTransform *EggTexture::upcast_to_EggTransform(void);

1521 22 downcast_to_EggTexture 0 12 2033 36 EggTransform::downcast_to_EggTexture 0 0 40
downcast from EggTransform to EggTexture
55
EggTexture *EggTransform::downcast_to_EggTexture(void);

1522 10 EggTexture 0 260 2069 22 EggTexture::EggTexture 0 2 519 520 22
/**
 *
 */

/**
 *
 */
136
explicit EggTexture::EggTexture(std::string const &tref_name, Filename const &filename);
EggTexture::EggTexture(EggTexture const &copy);

1523 10 operator = 0 4 2069 22 EggTexture::operator = 0 1 521 10
/**
 *
 */
52
void EggTexture::operator =(EggTexture const &copy);

1524 11 ~EggTexture 0 518 2069 23 EggTexture::~EggTexture 0 0 10
/**
 *
 */
38
virtual EggTexture::~EggTexture(void);

1525 5 write 0 6 2069 17 EggTexture::write 0 1 522 86
/**
 * Writes the texture definition to the indicated output stream in Egg format.
 */
74
virtual void EggTexture::write(std::ostream &out, int indent_level) const;

1526 16 is_equivalent_to 0 4 2069 28 EggTexture::is_equivalent_to 0 1 523 899
/**
 * Returns true if the two textures are equivalent in all relevant properties
 * (according to eq), false otherwise.
 *
 * The Equivalence parameter, eq, should be set to the bitwise OR of the
 * following properties, according to what you consider relevant:
 *
 * EggTexture::E_basename: The basename part of the texture filename, without
 * the directory prefix *or* the filename extension.
 *
 * EggTexture::E_extension: The extension part of the texture filename.
 *
 * EggTexture::E_dirname: The directory prefix of the texture filename.
 *
 * EggTexture::E_complete_filename: The union of the above three; that is, the
 * complete filename, with directory, basename, and extension.
 *
 * EggTexture::E_transform: The texture matrix.
 *
 * EggTexture::E_attributes: All remaining texture attributes (mode, mipmap,
 * etc.) except TRef name.
 *
 * EggTexture::E_tref_name: The TRef name.
 */
73
bool EggTexture::is_equivalent_to(EggTexture const &other, int eq) const;

1527 15 sorts_less_than 0 4 2069 27 EggTexture::sorts_less_than 0 1 524 224
/**
 * An ordering operator to compare two textures for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique textures, according
 * to the indicated Equivalence factor.  See is_equivalent_to().
 */
72
bool EggTexture::sorts_less_than(EggTexture const &other, int eq) const;

1528 17 has_alpha_channel 0 4 2069 29 EggTexture::has_alpha_channel 0 1 525 260
/**
 * Given the number of color components (channels) in the image file as
 * actually read from the disk, return true if this texture seems to have an
 * alpha channel or not.  This depends on the EggTexture's format as well as
 * the number of channels.
 */
61
bool EggTexture::has_alpha_channel(int num_components) const;

1529 16 set_texture_type 0 4 2069 28 EggTexture::set_texture_type 0 1 526 10
/**
 *
 */
79
inline void EggTexture::set_texture_type(EggTexture::TextureType texture_type);

1530 16 get_texture_type 0 4 2069 28 EggTexture::get_texture_type 0 1 527 10
/**
 *
 */
72
inline EggTexture::TextureType EggTexture::get_texture_type(void) const;

1531 10 set_format 0 4 2069 22 EggTexture::set_format 0 1 528 10
/**
 *
 */
62
inline void EggTexture::set_format(EggTexture::Format format);

1532 10 get_format 0 4 2069 22 EggTexture::get_format 0 1 529 10
/**
 *
 */
61
inline EggTexture::Format EggTexture::get_format(void) const;

1533 20 set_compression_mode 0 4 2069 32 EggTexture::set_compression_mode 0 1 530 10
/**
 *
 */
79
inline void EggTexture::set_compression_mode(EggTexture::CompressionMode mode);

1534 20 get_compression_mode 0 4 2069 32 EggTexture::get_compression_mode 0 1 531 10
/**
 *
 */
80
inline EggTexture::CompressionMode EggTexture::get_compression_mode(void) const;

1535 13 set_wrap_mode 0 4 2069 25 EggTexture::set_wrap_mode 0 1 532 10
/**
 *
 */
65
inline void EggTexture::set_wrap_mode(EggTexture::WrapMode mode);

1536 13 get_wrap_mode 0 4 2069 25 EggTexture::get_wrap_mode 0 1 533 10
/**
 *
 */
66
inline EggTexture::WrapMode EggTexture::get_wrap_mode(void) const;

1537 10 set_wrap_u 0 4 2069 22 EggTexture::set_wrap_u 0 1 534 10
/**
 *
 */
62
inline void EggTexture::set_wrap_u(EggTexture::WrapMode mode);

1538 10 get_wrap_u 0 4 2069 22 EggTexture::get_wrap_u 0 1 535 120
/**
 * Returns the amount specified for U wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */
63
inline EggTexture::WrapMode EggTexture::get_wrap_u(void) const;

1539 16 determine_wrap_u 0 4 2069 28 EggTexture::determine_wrap_u 0 1 536 178
/**
 * Determines the appropriate wrap in the U direction.  This is different from
 * get_wrap_u() in that if the U wrap is unspecified, it returns the overall
 * wrap value.
 */
69
inline EggTexture::WrapMode EggTexture::determine_wrap_u(void) const;

1540 10 set_wrap_v 0 4 2069 22 EggTexture::set_wrap_v 0 1 537 10
/**
 *
 */
62
inline void EggTexture::set_wrap_v(EggTexture::WrapMode mode);

1541 10 get_wrap_v 0 4 2069 22 EggTexture::get_wrap_v 0 1 538 120
/**
 * Returns the amount specified for V wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */
63
inline EggTexture::WrapMode EggTexture::get_wrap_v(void) const;

1542 16 determine_wrap_v 0 4 2069 28 EggTexture::determine_wrap_v 0 1 539 178
/**
 * Determines the appropriate wrap in the V direction.  This is different from
 * get_wrap_v() in that if the V wrap is unspecified, it returns the overall
 * wrap value.
 */
69
inline EggTexture::WrapMode EggTexture::determine_wrap_v(void) const;

1543 10 set_wrap_w 0 4 2069 22 EggTexture::set_wrap_w 0 1 540 10
/**
 *
 */
62
inline void EggTexture::set_wrap_w(EggTexture::WrapMode mode);

1544 10 get_wrap_w 0 4 2069 22 EggTexture::get_wrap_w 0 1 541 120
/**
 * Returns the amount specified for W wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */
63
inline EggTexture::WrapMode EggTexture::get_wrap_w(void) const;

1545 16 determine_wrap_w 0 4 2069 28 EggTexture::determine_wrap_w 0 1 542 178
/**
 * Determines the appropriate wrap in the W direction.  This is different from
 * get_wrap_w() in that if the W wrap is unspecified, it returns the overall
 * wrap value.
 */
69
inline EggTexture::WrapMode EggTexture::determine_wrap_w(void) const;

1546 13 set_minfilter 0 4 2069 25 EggTexture::set_minfilter 0 1 543 10
/**
 *
 */
67
inline void EggTexture::set_minfilter(EggTexture::FilterType type);

1547 13 get_minfilter 0 4 2069 25 EggTexture::get_minfilter 0 1 544 10
/**
 *
 */
68
inline EggTexture::FilterType EggTexture::get_minfilter(void) const;

1548 13 set_magfilter 0 4 2069 25 EggTexture::set_magfilter 0 1 545 10
/**
 *
 */
67
inline void EggTexture::set_magfilter(EggTexture::FilterType type);

1549 13 get_magfilter 0 4 2069 25 EggTexture::get_magfilter 0 1 546 10
/**
 *
 */
68
inline EggTexture::FilterType EggTexture::get_magfilter(void) const;

1550 22 set_anisotropic_degree 0 4 2069 34 EggTexture::set_anisotropic_degree 0 1 547 127
/**
 * Sets the degree of anisotropic filtering for this texture.  1 is off;
 * higher levels indicate filtering in effect.
 */
71
inline void EggTexture::set_anisotropic_degree(int anisotropic_degree);

1551 24 clear_anisotropic_degree 0 4 2069 36 EggTexture::clear_anisotropic_degree 0 1 548 79
/**
 * Removes the specification of anisotropic filtering from the texture.
 */
55
inline void EggTexture::clear_anisotropic_degree(void);

1552 22 has_anisotropic_degree 0 4 2069 34 EggTexture::has_anisotropic_degree 0 1 549 128
/**
 * Returns true if a value for the anisotropic filtering degree has been
 * specified for this texture, false otherwise.
 */
59
inline bool EggTexture::has_anisotropic_degree(void) const;

1553 22 get_anisotropic_degree 0 4 2069 34 EggTexture::get_anisotropic_degree 0 1 550 132
/**
 * Returns the anisotropic filtering degree that has been specified for this
 * texture, or 0 if nothing has been specified.
 */
58
inline int EggTexture::get_anisotropic_degree(void) const;

1554 12 set_env_type 0 4 2069 24 EggTexture::set_env_type 0 1 551 10
/**
 *
 */
63
inline void EggTexture::set_env_type(EggTexture::EnvType type);

1555 12 get_env_type 0 4 2069 24 EggTexture::get_env_type 0 1 552 10
/**
 *
 */
64
inline EggTexture::EnvType EggTexture::get_env_type(void) const;

1556 21 affects_polygon_alpha 0 4 2069 33 EggTexture::affects_polygon_alpha 0 1 553 162
/**
 * Returns true if this texture's environment type or combine mode allows the
 * texture to have an effect on the polygon's alpha values, false otherwise.
 */
51
bool EggTexture::affects_polygon_alpha(void) const;

1557 16 set_combine_mode 0 4 2069 28 EggTexture::set_combine_mode 0 1 554 10
/**
 *
 */
105
inline void EggTexture::set_combine_mode(EggTexture::CombineChannel channel, EggTexture::CombineMode cm);

1558 16 get_combine_mode 0 4 2069 28 EggTexture::get_combine_mode 0 1 555 10
/**
 *
 */
102
inline EggTexture::CombineMode EggTexture::get_combine_mode(EggTexture::CombineChannel channel) const;

1559 18 set_combine_source 0 4 2069 30 EggTexture::set_combine_source 0 1 556 10
/**
 *
 */
116
inline void EggTexture::set_combine_source(EggTexture::CombineChannel channel, int n, EggTexture::CombineSource cs);

1560 18 get_combine_source 0 4 2069 30 EggTexture::get_combine_source 0 1 557 10
/**
 *
 */
113
inline EggTexture::CombineSource EggTexture::get_combine_source(EggTexture::CombineChannel channel, int n) const;

1561 19 set_combine_operand 0 4 2069 31 EggTexture::set_combine_operand 0 1 558 10
/**
 *
 */
118
inline void EggTexture::set_combine_operand(EggTexture::CombineChannel channel, int n, EggTexture::CombineOperand co);

1562 19 get_combine_operand 0 4 2069 31 EggTexture::get_combine_operand 0 1 559 10
/**
 *
 */
115
inline EggTexture::CombineOperand EggTexture::get_combine_operand(EggTexture::CombineChannel channel, int n) const;

1563 16 set_saved_result 0 4 2069 28 EggTexture::set_saved_result 0 1 560 614
/**
 * Sets the saved_result flag.  When this is true, the output of this stage is
 * not part of the normal pipeline--that is, it will not be supplied as the
 * "previous" source for the next texture stage--but it will instead be
 * supplied as the "last_saved_result" source for any future stages, until the
 * next TextureStage with a saved_result set true is encountered.
 *
 * This can be used to reuse the results of this texture stage as input to
 * more than one stage later in the pipeline.
 *
 * The last texture in the pipeline (the one with the highest sort value)
 * should not have this flag set.
 */
60
inline void EggTexture::set_saved_result(bool saved_result);

1564 16 get_saved_result 0 4 2069 28 EggTexture::get_saved_result 0 1 561 92
/**
 * Returns the current setting of the saved_result flag.  See
 * set_saved_result().
 */
53
inline bool EggTexture::get_saved_result(void) const;

1565 11 set_tex_gen 0 4 2069 23 EggTexture::set_tex_gen 0 1 562 10
/**
 *
 */
64
inline void EggTexture::set_tex_gen(EggTexture::TexGen tex_gen);

1566 11 get_tex_gen 0 4 2069 23 EggTexture::get_tex_gen 0 1 563 10
/**
 *
 */
62
inline EggTexture::TexGen EggTexture::get_tex_gen(void) const;

1567 17 set_quality_level 0 4 2069 29 EggTexture::set_quality_level 0 1 564 10
/**
 *
 */
82
inline void EggTexture::set_quality_level(EggTexture::QualityLevel quality_level);

1568 17 get_quality_level 0 4 2069 29 EggTexture::get_quality_level 0 1 565 10
/**
 *
 */
74
inline EggTexture::QualityLevel EggTexture::get_quality_level(void) const;

1569 14 set_stage_name 0 4 2069 26 EggTexture::set_stage_name 0 1 566 442
/**
 * Specifies the particular TextureStage this texture will be rendered on by
 * name.  If this is omitted, the texture will be rendered on the default
 * TextureStage, unless some other stage-specific property is specificied, in
 * which case the texture will be rendered on a TextureStage with the same
 * name as the tref.  This is in support of multitexturing.
 *
 * Each different TextureStage in the world must be uniquely named.
 */
70
inline void EggTexture::set_stage_name(std::string const &stage_name);

1570 16 clear_stage_name 0 4 2069 28 EggTexture::clear_stage_name 0 1 567 56
/**
 * Removes the named TextureStage specification.
 */
47
inline void EggTexture::clear_stage_name(void);

1571 14 has_stage_name 0 4 2069 26 EggTexture::has_stage_name 0 1 568 107
/**
 * Returns true if a stage name has been explicitly specified for this
 * texture, false otherwise.
 */
51
inline bool EggTexture::has_stage_name(void) const;

1572 14 get_stage_name 0 4 2069 26 EggTexture::get_stage_name 0 1 569 146
/**
 * Returns the stage name that has been specified for this texture, or the
 * tref name if no texture stage has explicitly been specified.
 */
65
inline std::string const &EggTexture::get_stage_name(void) const;

1573 12 set_priority 0 4 2069 24 EggTexture::set_priority 0 1 570 178
/**
 * Sets the importance of this texture with respect to other textures also
 * applied on the same geometry.  This is only meaningful in the presence of
 * multitexturing.
 */
51
inline void EggTexture::set_priority(int priority);

1574 14 clear_priority 0 4 2069 26 EggTexture::clear_priority 0 1 571 116
/**
 * Removes the specification of multitexture priority from the texture.  The
 * default priority value is 0.
 */
45
inline void EggTexture::clear_priority(void);

1575 12 has_priority 0 4 2069 24 EggTexture::has_priority 0 1 572 127
/**
 * Returns true if a priority value for multitexture importance has been
 * specified for the texture, false otherwise.
 */
49
inline bool EggTexture::has_priority(void) const;

1576 12 get_priority 0 4 2069 24 EggTexture::get_priority 0 1 573 142
/**
 * Returns the multitexture importance value that has been specified for the
 * texture, or 0 if no priority value has been specified.
 */
48
inline int EggTexture::get_priority(void) const;

1577 9 set_color 0 4 2069 21 EggTexture::set_color 0 1 574 10
/**
 *
 */
55
inline void EggTexture::set_color(LColor const &color);

1578 11 clear_color 0 4 2069 23 EggTexture::clear_color 0 1 575 10
/**
 *
 */
42
inline void EggTexture::clear_color(void);

1579 9 has_color 0 4 2069 21 EggTexture::has_color 0 1 576 76
/**
 * Returns true if a blend color has been specified for the texture.
 */
46
inline bool EggTexture::has_color(void) const;

1580 9 get_color 0 4 2069 21 EggTexture::get_color 0 1 577 91
/**
 * Returns the blend color if one has been specified, or (0, 0, 0, 1)
 * otherwise.
 */
55
inline LColor const &EggTexture::get_color(void) const;

1581 16 set_border_color 0 4 2069 28 EggTexture::set_border_color 0 1 578 10
/**
 *
 */
69
inline void EggTexture::set_border_color(LColor const &border_color);

1582 18 clear_border_color 0 4 2069 30 EggTexture::clear_border_color 0 1 579 10
/**
 *
 */
49
inline void EggTexture::clear_border_color(void);

1583 16 has_border_color 0 4 2069 28 EggTexture::has_border_color 0 1 580 77
/**
 * Returns true if a border color has been specified for the texture.
 */
53
inline bool EggTexture::has_border_color(void) const;

1584 16 get_border_color 0 4 2069 28 EggTexture::get_border_color 0 1 581 92
/**
 * Returns the border color if one has been specified, or (0, 0, 0, 1)
 * otherwise.
 */
62
inline LColor const &EggTexture::get_border_color(void) const;

1585 11 set_uv_name 0 4 2069 23 EggTexture::set_uv_name 0 1 582 309
/**
 * Specifies the named set of texture coordinates that this texture will use
 * when it is applied to geometry.  Geometry may have multiple sets of texture
 * coordinates defined, by name.
 *
 * If this is not specified for a particular texture, the default set of
 * texture coordinates will be used.
 */
64
inline void EggTexture::set_uv_name(std::string const &uv_name);

1586 13 clear_uv_name 0 4 2069 25 EggTexture::clear_uv_name 0 1 583 153
/**
 * Removes the restriction to a particular named set of texture coordinates
 * and restores the texture to using the default texture coordinates.
 */
44
inline void EggTexture::clear_uv_name(void);

1587 11 has_uv_name 0 4 2069 23 EggTexture::has_uv_name 0 1 584 110
/**
 * Returns true if a texcoord name has been explicitly specified for this
 * texture, false otherwise.
 */
48
inline bool EggTexture::has_uv_name(void) const;

1588 11 get_uv_name 0 4 2069 23 EggTexture::get_uv_name 0 1 585 152
/**
 * Returns the texcoord name that has been specified for this texture, or the
 * empty string if no texcoord name has explicitly been specified.
 */
62
inline std::string const &EggTexture::get_uv_name(void) const;

1589 13 set_rgb_scale 0 4 2069 25 EggTexture::set_rgb_scale 0 1 586 220
/**
 * Sets an additional factor that will scale all three r, g, b components
 * after the texture has been applied.  This is used only when a combine mode
 * is in effect.
 *
 * The only legal values are 1, 2, or 4.
 */
53
inline void EggTexture::set_rgb_scale(int rgb_scale);

1590 15 clear_rgb_scale 0 4 2069 27 EggTexture::clear_rgb_scale 0 1 587 95
/**
 * Removes the rgb_scale from the texture and restores it to the default value
 * of 1.
 */
46
inline void EggTexture::clear_rgb_scale(void);

1591 13 has_rgb_scale 0 4 2069 25 EggTexture::has_rgb_scale 0 1 588 95
/**
 * Returns true if an rgb_scale has been specified for the texture, false
 * otherwise.
 */
50
inline bool EggTexture::has_rgb_scale(void) const;

1592 13 get_rgb_scale 0 4 2069 25 EggTexture::get_rgb_scale 0 1 589 129
/**
 * Returns the rgb_scale value that has been specified for the texture, or 1
 * if no rgb_scale value has been specified.
 */
49
inline int EggTexture::get_rgb_scale(void) const;

1593 15 set_alpha_scale 0 4 2069 27 EggTexture::set_alpha_scale 0 1 590 211
/**
 * Sets an additional factor that will scale the alpha component after the
 * texture has been applied.  This is used only when a combine mode is in
 * effect.
 *
 * The only legal values are 1, 2, or 4.
 */
57
inline void EggTexture::set_alpha_scale(int alpha_scale);

1594 17 clear_alpha_scale 0 4 2069 29 EggTexture::clear_alpha_scale 0 1 591 97
/**
 * Removes the alpha_scale from the texture and restores it to the default
 * value of 1.
 */
48
inline void EggTexture::clear_alpha_scale(void);

1595 15 has_alpha_scale 0 4 2069 27 EggTexture::has_alpha_scale 0 1 592 97
/**
 * Returns true if an alpha_scale has been specified for the texture, false
 * otherwise.
 */
52
inline bool EggTexture::has_alpha_scale(void) const;

1596 15 get_alpha_scale 0 4 2069 27 EggTexture::get_alpha_scale 0 1 593 133
/**
 * Returns the alpha_scale value that has been specified for the texture, or 1
 * if no alpha_scale value has been specified.
 */
51
inline int EggTexture::get_alpha_scale(void) const;

1597 18 set_alpha_filename 0 4 2069 30 EggTexture::set_alpha_filename 0 1 594 235
/**
 * Specifies a separate file that will be loaded in with the 1- or 3-component
 * texture and applied as the alpha channel.  This is useful when loading
 * textures from file formats that do not support alpha, for instance jpg.
 */
69
inline void EggTexture::set_alpha_filename(Filename const &filename);

1598 20 clear_alpha_filename 0 4 2069 32 EggTexture::clear_alpha_filename 0 1 595 10
/**
 *
 */
51
inline void EggTexture::clear_alpha_filename(void);

1599 18 has_alpha_filename 0 4 2069 30 EggTexture::has_alpha_filename 0 1 596 131
/**
 * Returns true if a separate file for the alpha component has been applied,
 * false otherwise.  See set_alpha_filename().
 */
55
inline bool EggTexture::has_alpha_filename(void) const;

1600 18 get_alpha_filename 0 4 2069 30 EggTexture::get_alpha_filename 0 1 597 172
/**
 * Returns the separate file assigned for the alpha channel.  It is an error
 * to call this unless has_alpha_filename() returns true.  See
 * set_alpha_filename().
 */
66
inline Filename const &EggTexture::get_alpha_filename(void) const;

1601 18 set_alpha_fullpath 0 4 2069 30 EggTexture::set_alpha_fullpath 0 1 598 93
/**
 * Records the full pathname to the file, for the benefit of
 * get_alpha_fullpath().
 */
69
inline void EggTexture::set_alpha_fullpath(Filename const &fullpath);

1602 18 get_alpha_fullpath 0 4 2069 30 EggTexture::get_alpha_fullpath 0 1 599 463
/**
 * Returns the full pathname to the alpha file, if it is known; otherwise,
 * returns the same thing as get_alpha_filename().
 *
 * This function simply returns whatever was set by the last call to
 * set_alpha_fullpath().  This string is not written to the egg file; its main
 * purpose is to record the full path to the alpha filename if it is known,
 * for egg structures that are generated in-memory and then immediately
 * converted to a scene graph.
 */
66
inline Filename const &EggTexture::get_alpha_fullpath(void) const;

1603 22 set_alpha_file_channel 0 4 2069 34 EggTexture::set_alpha_file_channel 0 1 600 416
/**
 * If a separate alpha-file is specified, this indicates which channel number
 * should be extracted from this file to derive the alpha channel for the
 * final image.  The default is 0, which means the grayscale combination of r,
 * g, b.  Otherwise, this should be the 1-based channel number, for instance
 * 1, 2, or 3 for r, g, or b, respectively, or 4 for the alpha channel of a
 * four-component image.
 */
71
inline void EggTexture::set_alpha_file_channel(int alpha_file_channel);

1604 24 clear_alpha_file_channel 0 4 2069 36 EggTexture::clear_alpha_file_channel 0 1 601 98
/**
 * Removes the specification of a particular channel to use from the alpha-
 * file image.
 */
55
inline void EggTexture::clear_alpha_file_channel(void);

1605 22 has_alpha_file_channel 0 4 2069 34 EggTexture::has_alpha_file_channel 0 1 602 112
/**
 * Returns true if a particular channel has been specified for the alpha-file
 * image, false otherwise.
 */
59
inline bool EggTexture::has_alpha_file_channel(void) const;

1606 22 get_alpha_file_channel 0 4 2069 34 EggTexture::get_alpha_file_channel 0 1 603 167
/**
 * Returns the particular channel that has been specified for the alpha-file
 * image, or 0 if no channel has been specified.  See
 * set_alpha_file_channel().
 */
58
inline int EggTexture::get_alpha_file_channel(void) const;

1607 13 set_multiview 0 4 2069 25 EggTexture::set_multiview 0 1 604 380
/**
 * Sets the multiview flag.
 *
 * If multiview is true, the filename should contain a hash mark ('#'), which
 * will be filled in with the view number; and a multiview texture will be
 * defined with a series of images, one for each view.
 *
 * A multiview texture is most often used for stereo textures, but other uses
 * are also possible, such as for texture animation.
 */
54
inline void EggTexture::set_multiview(bool multiview);

1608 13 get_multiview 0 4 2069 25 EggTexture::get_multiview 0 1 605 83
/**
 * Returns the current setting of the multiview flag.  See set_multiview().
 */
50
inline bool EggTexture::get_multiview(void) const;

1609 13 set_num_views 0 4 2069 25 EggTexture::set_num_views 0 1 606 197
/**
 * When loading a 3-D multiview texture, this parameter is necessary to
 * specify how many views will be expected.  The z size is determined
 * implicitly from the number of images loaded.
 */
53
inline void EggTexture::set_num_views(int num_views);

1610 15 clear_num_views 0 4 2069 27 EggTexture::clear_num_views 0 1 607 91
/**
 * Removes the specification of the number of views for a 3-D multiview
 * texture.
 */
46
inline void EggTexture::clear_num_views(void);

1611 13 has_num_views 0 4 2069 25 EggTexture::has_num_views 0 1 608 116
/**
 * Returns true if the number of views has been specified for the 3-D
 * multiview texture, false otherwise.
 */
50
inline bool EggTexture::has_num_views(void) const;

1612 13 get_num_views 0 4 2069 25 EggTexture::get_num_views 0 1 609 114
/**
 * Returns the specified number of views specified for the 3-D multiview
 * texture.  See set_num_views().
 */
49
inline int EggTexture::get_num_views(void) const;

1613 16 set_read_mipmaps 0 4 2069 28 EggTexture::set_read_mipmaps 0 1 610 546
/**
 * Sets the read_mipmaps flag.
 *
 * If read_mipmaps is true, the filename should contain a hash mark ('#'),
 * which will be filled in with the mipmap level number; and the texture will
 * be defined with a series of images, one for each mipmap level.
 *
 * If the filename is of a type that already requires a hash mark, such as a
 * cube map or a 3-d texture, then the filename should now require two hash
 * marks, and the first one indicates the mipmap level number, while the
 * second indicates the face number or 3-d level number.
 */
60
inline void EggTexture::set_read_mipmaps(bool read_mipmaps);

1614 16 get_read_mipmaps 0 4 2069 28 EggTexture::get_read_mipmaps 0 1 611 92
/**
 * Returns the current setting of the read_mipmaps flag.  See
 * set_read_mipmaps().
 */
53
inline bool EggTexture::get_read_mipmaps(void) const;

1615 11 set_min_lod 0 4 2069 23 EggTexture::set_min_lod 0 1 612 61
/**
 * Sets the minimum mipmap level that may be sampled.
 */
52
inline void EggTexture::set_min_lod(double min_lod);

1616 13 clear_min_lod 0 4 2069 25 EggTexture::clear_min_lod 0 1 613 80
/**
 * Removes the specification of a minimum mipmap level from the texture.
 */
44
inline void EggTexture::clear_min_lod(void);

1617 11 has_min_lod 0 4 2069 23 EggTexture::has_min_lod 0 1 614 120
/**
 * Returns true if a value for the minimum mipmap level has been specified for
 * this texture, false otherwise.
 */
48
inline bool EggTexture::has_min_lod(void) const;

1618 11 get_min_lod 0 4 2069 23 EggTexture::get_min_lod 0 1 615 85
/**
 * Returns the minimum mipmap level that has been specified for this texture.
 */
50
inline double EggTexture::get_min_lod(void) const;

1619 11 set_max_lod 0 4 2069 23 EggTexture::set_max_lod 0 1 616 61
/**
 * Sets the maximum mipmap level that may be sampled.
 */
52
inline void EggTexture::set_max_lod(double max_lod);

1620 13 clear_max_lod 0 4 2069 25 EggTexture::clear_max_lod 0 1 617 80
/**
 * Removes the specification of a maximum mipmap level from the texture.
 */
44
inline void EggTexture::clear_max_lod(void);

1621 11 has_max_lod 0 4 2069 23 EggTexture::has_max_lod 0 1 618 120
/**
 * Returns true if a value for the maximum mipmap level has been specified for
 * this texture, false otherwise.
 */
48
inline bool EggTexture::has_max_lod(void) const;

1622 11 get_max_lod 0 4 2069 23 EggTexture::get_max_lod 0 1 619 85
/**
 * Returns the maximum mipmap level that has been specified for this texture.
 */
50
inline double EggTexture::get_max_lod(void) const;

1623 12 set_lod_bias 0 4 2069 24 EggTexture::set_lod_bias 0 1 620 86
/**
 * Sets the mipmap level bias that is added to the mipmap level to be sampled.
 */
54
inline void EggTexture::set_lod_bias(double lod_bias);

1624 14 clear_lod_bias 0 4 2069 26 EggTexture::clear_lod_bias 0 1 621 80
/**
 * Removes the specification of a maximum mipmap level from the texture.
 */
45
inline void EggTexture::clear_lod_bias(void);

1625 12 has_lod_bias 0 4 2069 24 EggTexture::has_lod_bias 0 1 622 120
/**
 * Returns true if a value for the maximum mipmap level has been specified for
 * this texture, false otherwise.
 */
49
inline bool EggTexture::has_lod_bias(void) const;

1626 12 get_lod_bias 0 4 2069 24 EggTexture::get_lod_bias 0 1 623 85
/**
 * Returns the maximum mipmap level that has been specified for this texture.
 */
51
inline double EggTexture::get_lod_bias(void) const;

1627 18 clear_multitexture 0 4 2069 30 EggTexture::clear_multitexture 0 1 624 173
/**
 * Resets the multitexture flags set by multitexture_over().  After this call,
 * get_multitexture() will return false, and get_multitexture_sort() will
 * return 0.
 */
42
void EggTexture::clear_multitexture(void);

1628 17 multitexture_over 0 4 2069 29 EggTexture::multitexture_over 0 1 625 434
/**
 * Indicates that this texture should be layered on top of the other texture.
 * This will guarantee that this->get_multitexture_sort() >
 * other->get_multitexture_sort(), at least until clear_multitexture() is
 * called on either one.
 *
 * The return value is true if successful, or false if there is a failure
 * because the other texture was already layered on top of this one (or there
 * is a three- or more-way cycle).
 */
54
bool EggTexture::multitexture_over(EggTexture *other);

1629 21 get_multitexture_sort 0 4 2069 33 EggTexture::get_multitexture_sort 0 1 626 333
/**
 * Returns an integer that represents the depth to which this texture is
 * layered on all other textures in the egg file.  In general, if texture A is
 * layered over texture B, then sort(A) > sort(B).  If texture A is never
 * layered over any other texture, then sort(A) == 0.  More than that is
 * difficult to guarantee.
 */
57
inline int EggTexture::get_multitexture_sort(void) const;

1630 19 string_texture_type 0 4 2069 31 EggTexture::string_texture_type 0 1 627 171
/**
 * Returns the Texture_ype value associated with the given string
 * representation, or TT_unspecified if the string does not match any known
 * TextureType value.
 */
90
static EggTexture::TextureType EggTexture::string_texture_type(std::string const &string);

1631 13 string_format 0 4 2069 25 EggTexture::string_format 0 1 628 157
/**
 * Returns the Format value associated with the given string representation,
 * or F_unspecified if the string does not match any known Format value.
 */
79
static EggTexture::Format EggTexture::string_format(std::string const &string);

1632 23 string_compression_mode 0 4 2069 35 EggTexture::string_compression_mode 0 1 629 175
/**
 * Returns the CompressionMode value associated with the given string
 * representation, or CM_default if the string does not match any known
 * CompressionMode value.
 */
98
static EggTexture::CompressionMode EggTexture::string_compression_mode(std::string const &string);

1633 16 string_wrap_mode 0 4 2069 28 EggTexture::string_wrap_mode 0 1 630 162
/**
 * Returns the WrapMode value associated with the given string representation,
 * or WM_unspecified if the string does not match any known WrapMode value.
 */
84
static EggTexture::WrapMode EggTexture::string_wrap_mode(std::string const &string);

1634 18 string_filter_type 0 4 2069 30 EggTexture::string_filter_type 0 1 631 169
/**
 * Returns the FilterType value associated with the given string
 * representation, or FT_unspecified if the string does not match any known
 * FilterType value.
 */
88
static EggTexture::FilterType EggTexture::string_filter_type(std::string const &string);

1635 15 string_env_type 0 4 2069 27 EggTexture::string_env_type 0 1 632 160
/**
 * Returns the EnvType value associated with the given string representation,
 * or ET_unspecified if the string does not match any known EnvType value.
 */
82
static EggTexture::EnvType EggTexture::string_env_type(std::string const &string);

1636 19 string_combine_mode 0 4 2069 31 EggTexture::string_combine_mode 0 1 633 171
/**
 * Returns the CombineMode value associated with the given string
 * representation, or CM_unspecified if the string does not match any known
 * CombineMode value.
 */
90
static EggTexture::CombineMode EggTexture::string_combine_mode(std::string const &string);

1637 21 string_combine_source 0 4 2069 33 EggTexture::string_combine_source 0 1 634 175
/**
 * Returns the CombineSource value associated with the given string
 * representation, or CS_unspecified if the string does not match any known
 * CombineSource value.
 */
94
static EggTexture::CombineSource EggTexture::string_combine_source(std::string const &string);

1638 22 string_combine_operand 0 4 2069 34 EggTexture::string_combine_operand 0 1 635 177
/**
 * Returns the CombineOperand value associated with the given string
 * representation, or CO_unspecified if the string does not match any known
 * CombineOperand value.
 */
96
static EggTexture::CombineOperand EggTexture::string_combine_operand(std::string const &string);

1639 14 string_tex_gen 0 4 2069 26 EggTexture::string_tex_gen 0 1 636 158
/**
 * Returns the TexGen value associated with the given string representation,
 * or ET_unspecified if the string does not match any known TexGen value.
 */
80
static EggTexture::TexGen EggTexture::string_tex_gen(std::string const &string);

1640 20 string_quality_level 0 4 2069 32 EggTexture::string_quality_level 0 1 637 158
/**
 * Returns the TexGen value associated with the given string representation,
 * or ET_unspecified if the string does not match any known TexGen value.
 */
92
static EggTexture::QualityLevel EggTexture::string_quality_level(std::string const &string);

1641 14 get_class_type 0 4 2069 26 EggTexture::get_class_type 0 1 638 0
51
static TypeHandle EggTexture::get_class_type(void);

1642 11 EggMaterial 0 260 2086 24 EggMaterial::EggMaterial 0 2 642 643 22
/**
 *
 */

/**
 *
 */
115
explicit EggMaterial::EggMaterial(std::string const &mref_name);
EggMaterial::EggMaterial(EggMaterial const &copy);

1643 16 is_equivalent_to 0 4 2086 29 EggMaterial::is_equivalent_to 0 1 644 411
/**
 * Returns true if the two materials are equivalent in all relevant properties
 * (according to eq), false otherwise.
 *
 * The Equivalence parameter, eq, should be set to the bitwise OR of the
 * following properties, according to what you consider relevant:
 *
 * EggMaterial::E_attributes: All material attributes (diff, spec, etc.)
 * except MRef name.
 *
 * EggMaterial::E_mref_name: The MRef name.
 */
75
bool EggMaterial::is_equivalent_to(EggMaterial const &other, int eq) const;

1644 15 sorts_less_than 0 4 2086 28 EggMaterial::sorts_less_than 0 1 645 226
/**
 * An ordering operator to compare two materials for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique materials,
 * according to the indicated Equivalence factor.  See is_equivalent_to().
 */
74
bool EggMaterial::sorts_less_than(EggMaterial const &other, int eq) const;

1645 8 set_base 0 4 2086 21 EggMaterial::set_base 0 1 646 24
/**
 * @since 1.10.0
 */
54
inline void EggMaterial::set_base(LColor const &base);

1646 10 clear_base 0 4 2086 23 EggMaterial::clear_base 0 1 647 24
/**
 * @since 1.10.0
 */
42
inline void EggMaterial::clear_base(void);

1647 8 has_base 0 4 2086 21 EggMaterial::has_base 0 1 648 24
/**
 * @since 1.10.0
 */
46
inline bool EggMaterial::has_base(void) const;

1648 8 get_base 0 4 2086 21 EggMaterial::get_base 0 1 649 142
/**
 * It is legal to call this even if has_base() returns false.  If so, it
 * simply returns the default base color.
 *
 * @since 1.10.0
 */
48
inline LColor EggMaterial::get_base(void) const;

1649 8 set_diff 0 4 2086 21 EggMaterial::set_diff 0 1 650 10
/**
 *
 */
54
inline void EggMaterial::set_diff(LColor const &diff);

1650 10 clear_diff 0 4 2086 23 EggMaterial::clear_diff 0 1 651 10
/**
 *
 */
42
inline void EggMaterial::clear_diff(void);

1651 8 has_diff 0 4 2086 21 EggMaterial::has_diff 0 1 652 10
/**
 *
 */
46
inline bool EggMaterial::has_diff(void) const;

1652 8 get_diff 0 4 2086 21 EggMaterial::get_diff 0 1 653 122
/**
 * It is legal to call this even if has_diff() returns false.  If so, it
 * simply returns the default diff color.
 */
48
inline LColor EggMaterial::get_diff(void) const;

1653 7 set_amb 0 4 2086 20 EggMaterial::set_amb 0 1 654 10
/**
 *
 */
52
inline void EggMaterial::set_amb(LColor const &amb);

1654 9 clear_amb 0 4 2086 22 EggMaterial::clear_amb 0 1 655 10
/**
 *
 */
41
inline void EggMaterial::clear_amb(void);

1655 7 has_amb 0 4 2086 20 EggMaterial::has_amb 0 1 656 10
/**
 *
 */
45
inline bool EggMaterial::has_amb(void) const;

1656 7 get_amb 0 4 2086 20 EggMaterial::get_amb 0 1 657 120
/**
 * It is legal to call this even if has_amb() returns false.  If so, it simply
 * returns the default amb color.
 */
47
inline LColor EggMaterial::get_amb(void) const;

1657 8 set_emit 0 4 2086 21 EggMaterial::set_emit 0 1 658 10
/**
 *
 */
54
inline void EggMaterial::set_emit(LColor const &emit);

1658 10 clear_emit 0 4 2086 23 EggMaterial::clear_emit 0 1 659 10
/**
 *
 */
42
inline void EggMaterial::clear_emit(void);

1659 8 has_emit 0 4 2086 21 EggMaterial::has_emit 0 1 660 10
/**
 *
 */
46
inline bool EggMaterial::has_emit(void) const;

1660 8 get_emit 0 4 2086 21 EggMaterial::get_emit 0 1 661 122
/**
 * It is legal to call this even if has_emit() returns false.  If so, it
 * simply returns the default emit color.
 */
48
inline LColor EggMaterial::get_emit(void) const;

1661 8 set_spec 0 4 2086 21 EggMaterial::set_spec 0 1 662 10
/**
 *
 */
54
inline void EggMaterial::set_spec(LColor const &spec);

1662 10 clear_spec 0 4 2086 23 EggMaterial::clear_spec 0 1 663 10
/**
 *
 */
42
inline void EggMaterial::clear_spec(void);

1663 8 has_spec 0 4 2086 21 EggMaterial::has_spec 0 1 664 10
/**
 *
 */
46
inline bool EggMaterial::has_spec(void) const;

1664 8 get_spec 0 4 2086 21 EggMaterial::get_spec 0 1 665 122
/**
 * It is legal to call this even if has_spec() returns false.  If so, it
 * simply returns the default spec color.
 */
48
inline LColor EggMaterial::get_spec(void) const;

1665 13 set_shininess 0 4 2086 26 EggMaterial::set_shininess 0 1 666 10
/**
 *
 */
57
inline void EggMaterial::set_shininess(double shininess);

1666 15 clear_shininess 0 4 2086 28 EggMaterial::clear_shininess 0 1 667 10
/**
 *
 */
47
inline void EggMaterial::clear_shininess(void);

1667 13 has_shininess 0 4 2086 26 EggMaterial::has_shininess 0 1 668 10
/**
 *
 */
51
inline bool EggMaterial::has_shininess(void) const;

1668 13 get_shininess 0 4 2086 26 EggMaterial::get_shininess 0 1 669 10
/**
 *
 */
53
inline double EggMaterial::get_shininess(void) const;

1669 13 set_roughness 0 4 2086 26 EggMaterial::set_roughness 0 1 670 24
/**
 * @since 1.10.0
 */
57
inline void EggMaterial::set_roughness(double roughness);

1670 15 clear_roughness 0 4 2086 28 EggMaterial::clear_roughness 0 1 671 24
/**
 * @since 1.10.0
 */
47
inline void EggMaterial::clear_roughness(void);

1671 13 has_roughness 0 4 2086 26 EggMaterial::has_roughness 0 1 672 24
/**
 * @since 1.10.0
 */
51
inline bool EggMaterial::has_roughness(void) const;

1672 13 get_roughness 0 4 2086 26 EggMaterial::get_roughness 0 1 673 24
/**
 * @since 1.10.0
 */
53
inline double EggMaterial::get_roughness(void) const;

1673 12 set_metallic 0 4 2086 25 EggMaterial::set_metallic 0 1 674 24
/**
 * @since 1.10.0
 */
55
inline void EggMaterial::set_metallic(double metallic);

1674 14 clear_metallic 0 4 2086 27 EggMaterial::clear_metallic 0 1 675 24
/**
 * @since 1.10.0
 */
46
inline void EggMaterial::clear_metallic(void);

1675 12 has_metallic 0 4 2086 25 EggMaterial::has_metallic 0 1 676 24
/**
 * @since 1.10.0
 */
50
inline bool EggMaterial::has_metallic(void) const;

1676 12 get_metallic 0 4 2086 25 EggMaterial::get_metallic 0 1 677 24
/**
 * @since 1.10.0
 */
52
inline double EggMaterial::get_metallic(void) const;

1677 7 set_ior 0 4 2086 20 EggMaterial::set_ior 0 1 678 24
/**
 * @since 1.10.0
 */
45
inline void EggMaterial::set_ior(double ior);

1678 9 clear_ior 0 4 2086 22 EggMaterial::clear_ior 0 1 679 24
/**
 * @since 1.10.0
 */
41
inline void EggMaterial::clear_ior(void);

1679 7 has_ior 0 4 2086 20 EggMaterial::has_ior 0 1 680 24
/**
 * @since 1.10.0
 */
45
inline bool EggMaterial::has_ior(void) const;

1680 7 get_ior 0 4 2086 20 EggMaterial::get_ior 0 1 681 24
/**
 * @since 1.10.0
 */
47
inline double EggMaterial::get_ior(void) const;

1681 9 set_local 0 4 2086 22 EggMaterial::set_local 0 1 682 10
/**
 *
 */
47
inline void EggMaterial::set_local(bool local);

1682 11 clear_local 0 4 2086 24 EggMaterial::clear_local 0 1 683 10
/**
 *
 */
43
inline void EggMaterial::clear_local(void);

1683 9 has_local 0 4 2086 22 EggMaterial::has_local 0 1 684 10
/**
 *
 */
47
inline bool EggMaterial::has_local(void) const;

1684 9 get_local 0 4 2086 22 EggMaterial::get_local 0 1 685 10
/**
 *
 */
47
inline bool EggMaterial::get_local(void) const;

1685 14 get_class_type 0 4 2086 27 EggMaterial::get_class_type 0 1 686 0
52
static TypeHandle EggMaterial::get_class_type(void);

1686 12 ~EggMaterial 0 516 2086 25 EggMaterial::~EggMaterial 0 0 0
32
EggMaterial::~EggMaterial(void);

1687 17 upcast_to_EggNode 0 12 2088 31 EggPrimitive::upcast_to_EggNode 0 1 742 35
upcast from EggPrimitive to EggNode
47
EggNode *EggPrimitive::upcast_to_EggNode(void);

1688 24 downcast_to_EggPrimitive 0 12 2003 33 EggNode::downcast_to_EggPrimitive 0 0 37
downcast from EggNode to EggPrimitive
54
EggPrimitive *EggNode::downcast_to_EggPrimitive(void);

1689 23 upcast_to_EggAttributes 0 12 2088 37 EggPrimitive::upcast_to_EggAttributes 0 1 743 41
upcast from EggPrimitive to EggAttributes
59
EggAttributes *EggPrimitive::upcast_to_EggAttributes(void);

1690 24 downcast_to_EggPrimitive 0 12 2014 39 EggAttributes::downcast_to_EggPrimitive 0 0 43
downcast from EggAttributes to EggPrimitive
60
EggPrimitive *EggAttributes::downcast_to_EggPrimitive(void);

1691 23 upcast_to_EggRenderMode 0 12 2088 37 EggPrimitive::upcast_to_EggRenderMode 0 1 744 41
upcast from EggPrimitive to EggRenderMode
59
EggRenderMode *EggPrimitive::upcast_to_EggRenderMode(void);

1692 24 downcast_to_EggPrimitive 0 12 2028 39 EggRenderMode::downcast_to_EggPrimitive 0 0 43
downcast from EggRenderMode to EggPrimitive
60
EggPrimitive *EggRenderMode::downcast_to_EggPrimitive(void);

1693 10 operator = 0 4 2088 24 EggPrimitive::operator = 0 1 687 10
/**
 *
 */
63
inline void EggPrimitive::operator =(EggPrimitive const &copy);

1694 13 ~EggPrimitive 0 518 2088 27 EggPrimitive::~EggPrimitive 0 0 10
/**
 *
 */
49
virtual inline EggPrimitive::~EggPrimitive(void);

1695 9 make_copy 0 6 2088 23 EggPrimitive::make_copy 0 1 688 0
62
virtual EggPrimitive *EggPrimitive::make_copy(void) const = 0;

1696 20 determine_alpha_mode 0 6 2088 34 EggPrimitive::determine_alpha_mode 0 1 689 271
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has an
 * alpha_mode other than AM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
64
virtual EggRenderMode *EggPrimitive::determine_alpha_mode(void);

1697 26 determine_depth_write_mode 0 6 2088 40 EggPrimitive::determine_depth_write_mode 0 1 690 272
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
70
virtual EggRenderMode *EggPrimitive::determine_depth_write_mode(void);

1698 25 determine_depth_test_mode 0 6 2088 39 EggPrimitive::determine_depth_test_mode 0 1 691 271
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
69
virtual EggRenderMode *EggPrimitive::determine_depth_test_mode(void);

1699 25 determine_visibility_mode 0 6 2088 39 EggPrimitive::determine_visibility_mode 0 1 692 270
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */
69
virtual EggRenderMode *EggPrimitive::determine_visibility_mode(void);

1700 22 determine_depth_offset 0 6 2088 36 EggPrimitive::determine_depth_offset 0 1 693 256
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a
 * depth_offset specified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */
66
virtual EggRenderMode *EggPrimitive::determine_depth_offset(void);

1701 20 determine_draw_order 0 6 2088 34 EggPrimitive::determine_draw_order 0 1 694 254
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a
 * draw_order specified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */
64
virtual EggRenderMode *EggPrimitive::determine_draw_order(void);

1702 13 determine_bin 0 6 2088 27 EggPrimitive::determine_bin 0 1 695 247
/**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a bin
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */
57
virtual EggRenderMode *EggPrimitive::determine_bin(void);

1703 13 get_sort_name 0 4 2088 27 EggPrimitive::get_sort_name 0 1 696 223
/**
 * Returns the name of the primitive for the purposes of sorting primitives
 * into different groups, if there is one.
 *
 * Presently, this is defined as the primitive name itself, unless it begins
 * with a digit.
 */
59
inline std::string EggPrimitive::get_sort_name(void) const;

1704 11 get_shading 0 6 2088 25 EggPrimitive::get_shading 0 1 697 696
/**
 * Returns the shading properties apparent on this particular primitive.  This
 * returns S_per_vertex if the vertices have colors or normals (and they are
 * not all the same values), or for a simple primitive, S_overall otherwise.
 * A composite primitive may also return S_per_face if the individual
 * component primitives have colors or normals that are not all the same
 * values.
 *
 * To get the most accurate results, you should call clear_shading() on all
 * connected primitives (or on all primitives in the egg file), followed by
 * get_shading() on each primitive.  You may find it easiest to call these
 * methods on the EggData root node (they are defined on EggGroupNode).
 */
68
virtual EggPrimitive::Shading EggPrimitive::get_shading(void) const;

1705 23 clear_connected_shading 0 4 2088 37 EggPrimitive::clear_connected_shading 0 1 698 128
/**
 * Resets the connected_shading member in this primitive, so that
 * get_connected_shading() will recompute a new value.
 */
56
inline void EggPrimitive::clear_connected_shading(void);

1706 21 get_connected_shading 0 4 2088 35 EggPrimitive::get_connected_shading 0 1 699 479
/**
 * Determines what sort of shading properties this primitive's connected
 * neighbors have.
 *
 * To get the most accurate results, you should first call
 * clear_connected_shading() on all connected primitives (or on all primitives
 * in the egg file). It might also be a good idea to call
 * remove_unused_vertices() to ensure proper connectivity.
 *
 * You may find it easiest to call these other methods on the EggData root
 * node (they are defined on EggGroupNode).
 */
77
inline EggPrimitive::Shading EggPrimitive::get_connected_shading(void) const;

1707 11 set_texture 0 4 2088 25 EggPrimitive::set_texture 0 1 700 211
/**
 * Replaces the current list of textures with the indicated texture.
 *
 * @deprecated This method is used in support of single-texturing only.
 * Please use the multitexture variant add_texture instead.
 */
59
inline void EggPrimitive::set_texture(EggTexture *texture);

1708 11 has_texture 0 4 2088 25 EggPrimitive::has_texture 0 2 701 702 332
/**
 * Returns true if the primitive has any textures specified, false otherwise.
 *
 * @deprecated This method is used in support of single-texturing only.
 * New code should be written to use the multitexture variants instead.
 */

/**
 * Returns true if the primitive has the particular indicated texture, false
 * otherwise.
 */
116
inline bool EggPrimitive::has_texture(void) const;
inline bool EggPrimitive::has_texture(EggTexture *texture) const;

1709 11 get_texture 0 4 2088 25 EggPrimitive::get_texture 0 2 703 704 339
/**
 * Returns the first texture on the primitive, if any, or NULL if there are no
 * textures on the primitive.
 *
 * @deprecated This method is used in support of single-texturing only.
 * New code should be written to use the multitexture variants instead.
 */

/**
 * Returns the nth texture that has been applied to the primitive.
 */
116
inline EggTexture *EggPrimitive::get_texture(void) const;
inline EggTexture *EggPrimitive::get_texture(int n) const;

1710 11 add_texture 0 4 2088 25 EggPrimitive::add_texture 0 1 705 276
/**
 * Applies the indicated texture to the primitive.
 *
 * Note that, in the case of multiple textures being applied to a single
 * primitive, the order in which the textures are applied does not affect the
 * rendering order; use EggTexture::set_sort() to specify that.
 */
59
inline void EggPrimitive::add_texture(EggTexture *texture);

1711 13 clear_texture 0 4 2088 27 EggPrimitive::clear_texture 0 1 706 52
/**
 * Removes any texturing from the primitive.
 */
46
inline void EggPrimitive::clear_texture(void);

1712 16 get_num_textures 0 4 2088 30 EggPrimitive::get_num_textures 0 1 707 67
/**
 * Returns the number of textures applied to the primitive.
 */
54
inline int EggPrimitive::get_num_textures(void) const;

1713 12 set_material 0 4 2088 26 EggPrimitive::set_material 0 1 708 59
/**
 * Applies the indicated material to the primitive.
 */
62
inline void EggPrimitive::set_material(EggMaterial *material);

1714 14 clear_material 0 4 2088 28 EggPrimitive::clear_material 0 1 709 51
/**
 * Removes any material from the primitive.
 */
47
inline void EggPrimitive::clear_material(void);

1715 12 get_material 0 4 2088 26 EggPrimitive::get_material 0 1 710 97
/**
 * Returns a pointer to the applied material, or NULL if there is no material
 * applied.
 */
59
inline EggMaterial *EggPrimitive::get_material(void) const;

1716 12 has_material 0 4 2088 26 EggPrimitive::has_material 0 1 711 160
/**
 * Returns true if the primitive is materiald (and get_material() will return
 * a real pointer), false otherwise (and get_material() will return NULL).
 */
51
inline bool EggPrimitive::has_material(void) const;

1717 14 set_bface_flag 0 4 2088 28 EggPrimitive::set_bface_flag 0 1 712 204
/**
 * Sets the backfacing flag of the polygon.  If this is true, the polygon will
 * be rendered so that both faces are visible; if it is false, only the front
 * face of the polygon will be visible.
 */
52
inline void EggPrimitive::set_bface_flag(bool flag);

1718 14 get_bface_flag 0 4 2088 28 EggPrimitive::get_bface_flag 0 1 713 79
/**
 * Retrieves the backfacing flag of the polygon.  See set_bface_flag().
 */
53
inline bool EggPrimitive::get_bface_flag(void) const;

1719 15 copy_attributes 0 4 2088 29 EggPrimitive::copy_attributes 0 2 714 715 146
/**
 * Copies the rendering attributes from the indicated primitive.
 */

/**
 * Copies the rendering attributes from the indicated primitive.
 */
126
void EggPrimitive::copy_attributes(EggAttributes const &other);
void EggPrimitive::copy_attributes(EggPrimitive const &other);

1720 17 has_vertex_normal 0 4 2088 31 EggPrimitive::has_vertex_normal 0 1 716 295
/**
 * Returns true if any vertex on the primitive has a specific normal set,
 * false otherwise.
 *
 * If you call unify_attributes() first, this will also return false even if
 * all the vertices were set to the same value (since unify_attributes()
 * removes redundant vertex properties).
 */
49
bool EggPrimitive::has_vertex_normal(void) const;

1721 16 has_vertex_color 0 4 2088 30 EggPrimitive::has_vertex_color 0 1 717 294
/**
 * Returns true if any vertex on the primitive has a specific color set, false
 * otherwise.
 *
 * If you call unify_attributes() first, this will also return false even if
 * all the vertices were set to the same value (since unify_attributes()
 * removes redundant vertex properties).
 */
48
bool EggPrimitive::has_vertex_color(void) const;

1722 16 unify_attributes 0 6 2088 30 EggPrimitive::unify_attributes 0 1 718 766
/**
 * If the shading property is S_per_vertex, ensures that all vertices have a
 * normal and a color, and the overall primitive does not.
 *
 * If the shading property is S_per_face, and this is a composite primitive,
 * ensures that all components have a normal and a color, and the vertices and
 * overall primitive do not.  (If this is a simple primitive, S_per_face works
 * the same as S_overall, below).
 *
 * If the shading property is S_overall, ensures that no vertices or
 * components have a normal or a color, and the overall primitive does (if any
 * exists at all).
 *
 * After this call, either the primitive will have normals or its vertices
 * will, but not both.  Ditto for colors.
 *
 * This may create redundant vertices in the vertex pool.
 */
75
virtual void EggPrimitive::unify_attributes(EggPrimitive::Shading shading);

1723 20 apply_last_attribute 0 6 2088 34 EggPrimitive::apply_last_attribute 0 1 719 350
/**
 * Sets the last vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * OpenGL convention of storing flat-shaded properties on the last vertex,
 * although it is not usually a convention in Egg.
 *
 * This may introduce redundant vertices to the vertex pool.
 */
54
virtual void EggPrimitive::apply_last_attribute(void);

1724 21 apply_first_attribute 0 6 2088 35 EggPrimitive::apply_first_attribute 0 1 720 353
/**
 * Sets the first vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * DirectX convention of storing flat-shaded properties on the first vertex,
 * although it is not usually a convention in Egg.
 *
 * This may introduce redundant vertices to the vertex pool.
 */
55
virtual void EggPrimitive::apply_first_attribute(void);

1725 25 post_apply_flat_attribute 0 6 2088 39 EggPrimitive::post_apply_flat_attribute 0 1 721 217
/**
 * Intended as a followup to apply_last_attribute(), this also sets an
 * attribute on the first vertices of the primitive, if they don't already
 * have an attribute set, just so they end up with *something*.
 */
59
virtual void EggPrimitive::post_apply_flat_attribute(void);

1726 23 reverse_vertex_ordering 0 6 2088 37 EggPrimitive::reverse_vertex_ordering 0 1 722 201
/**
 * Reverses the ordering of the vertices in this primitive, if appropriate, in
 * order to change the direction the polygon appears to be facing.  Does not
 * adjust the surface normal, if any.
 */
57
virtual void EggPrimitive::reverse_vertex_ordering(void);

1727 7 cleanup 0 6 2088 21 EggPrimitive::cleanup 0 1 723 272
/**
 * Cleans up modeling errors in whatever context this makes sense.  For
 * instance, for a polygon, this calls remove_doubled_verts(true).  For a
 * point, it calls remove_nonunique_verts().  Returns true if the primitive is
 * valid, or false if it is degenerate.
 */
41
virtual bool EggPrimitive::cleanup(void);

1728 20 remove_doubled_verts 0 4 2088 34 EggPrimitive::remove_doubled_verts 0 1 724 559
/**
 * Certain kinds of primitives, particularly polygons, don't like to have the
 * same vertex repeated consecutively.  Unfortunately, some modeling programs
 * (like MultiGen) make this an easy mistake to make.
 *
 * It's handy to have a function to remove these redundant vertices.  If
 * closed is true, it also checks that the first and last vertices are not the
 * same.
 *
 * This function identifies repeated vertices by position only; it does not
 * consider any other properties, such as color or UV, significant in
 * differentiating vertices.
 */
53
void EggPrimitive::remove_doubled_verts(bool closed);

1729 22 remove_nonunique_verts 0 4 2088 36 EggPrimitive::remove_nonunique_verts 0 1 725 256
/**
 * Removes any multiple appearances of the same vertex from the primitive.
 * This primarily makes sense for a point primitive, which is really a
 * collection of points and which doesn't make sense to include the same point
 * twice, in any order.
 */
48
void EggPrimitive::remove_nonunique_verts(void);

1730 14 has_primitives 0 6 2088 28 EggPrimitive::has_primitives 0 1 726 124
/**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, false otherwise.
 */
54
virtual bool EggPrimitive::has_primitives(void) const;

1731 20 joint_has_primitives 0 6 2088 34 EggPrimitive::joint_has_primitives 0 1 727 154
/**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, but the search does not include nested joints.
 */
60
virtual bool EggPrimitive::joint_has_primitives(void) const;

1732 11 has_normals 0 6 2088 25 EggPrimitive::has_normals 0 1 728 164
/**
 * Returns true if any of the primitives (e.g.  polygons) defined within this
 * group or below have either face or vertex normals defined, false otherwise.
 */
51
virtual bool EggPrimitive::has_normals(void) const;

1733 5 clear 0 4 2088 19 EggPrimitive::clear 0 1 729 58
/**
 * Removes all of the vertices from the primitive.
 */
38
inline void EggPrimitive::clear(void);

1734 10 add_vertex 0 4 2088 24 EggPrimitive::add_vertex 0 1 730 103
/**
 * Adds the indicated vertex to the end of the primitive's list of vertices,
 * and returns it.
 */
55
EggVertex *EggPrimitive::add_vertex(EggVertex *vertex);

1735 13 remove_vertex 0 4 2088 27 EggPrimitive::remove_vertex 0 2 731 732 218
/**
 * Removes the indicated vertex from the primitive and returns it.  If the
 * vertex was not already in the primitive, does nothing and returns NULL.
 */

/**
 * Removes the indicated vertex from the primitive.
 */
111
EggVertex *EggPrimitive::remove_vertex(EggVertex *vertex);
void EggPrimitive::remove_vertex(std::size_t index);

1736 13 copy_vertices 0 4 2088 27 EggPrimitive::copy_vertices 0 1 733 123
/**
 * Replaces the current primitive's list of vertices with a copy of the list
 * of vertices on the other primitive.
 */
60
void EggPrimitive::copy_vertices(EggPrimitive const &other);

1737 16 get_num_vertices 0 4 2088 30 EggPrimitive::get_num_vertices 0 1 734 205
// These are shorthands if you don't want to use the iterators.

// These are shorthands if you don't want to use the iterators.

// These are shorthands if you don't want to use the iterators.

/**
 *
 */
62
inline std::size_t EggPrimitive::get_num_vertices(void) const;

1738 10 get_vertex 0 4 2088 24 EggPrimitive::get_vertex 0 1 735 64
/**
 * Returns a particular index based on its index number.
 */
68
inline EggVertex *EggPrimitive::get_vertex(std::size_t index) const;

1739 10 set_vertex 0 4 2088 24 EggPrimitive::set_vertex 0 1 736 187
/**
 * Replaces a particular vertex based on its index number in the list of
 * vertices.  This is just a convenience function for people who don't want to
 * mess with the iterators.
 */
75
inline void EggPrimitive::set_vertex(std::size_t index, EggVertex *vertex);

1740 13 insert_vertex 0 4 2088 27 EggPrimitive::insert_vertex 0 1 737 50
/**
 * Inserts a vertex at the given position.
 */
78
inline void EggPrimitive::insert_vertex(std::size_t index, EggVertex *vertex);

1741 8 get_pool 0 4 2088 22 EggPrimitive::get_pool 0 1 738 126
/**
 * Returns the vertex pool associated with the vertices of the primitive, or
 * NULL if the primitive has no vertices.
 */
57
inline EggVertexPool *EggPrimitive::get_pool(void) const;

1742 5 write 0 6 2088 19 EggPrimitive::write 0 1 739 0
80
virtual void EggPrimitive::write(std::ostream &out, int indent_level) const = 0;

1743 19 test_vref_integrity 0 4 2088 33 EggPrimitive::test_vref_integrity 0 1 740 0
51
void EggPrimitive::test_vref_integrity(void) const;

1744 14 get_class_type 0 4 2088 28 EggPrimitive::get_class_type 0 1 741 0
53
static TypeHandle EggPrimitive::get_class_type(void);

1745 10 operator = 0 4 2094 33 EggCompositePrimitive::operator = 0 1 745 10
/**
 *
 */
81
inline void EggCompositePrimitive::operator =(EggCompositePrimitive const &copy);

1746 18 get_num_components 0 4 2094 41 EggCompositePrimitive::get_num_components 0 1 746 148
/**
 * Returns the number of individual component triangles within the composite.
 * Each one of these might have a different set of attributes.
 */
73
inline std::size_t EggCompositePrimitive::get_num_components(void) const;

1747 13 get_component 0 4 2094 36 EggCompositePrimitive::get_component 0 2 747 748 132
/**
 * Returns the attributes for the nth component triangle.
 */

/**
 * Returns the attributes for the nth component triangle.
 */
161
inline EggAttributes const *EggCompositePrimitive::get_component(std::size_t i) const;
inline EggAttributes *EggCompositePrimitive::get_component(std::size_t i);

1748 13 set_component 0 4 2094 36 EggCompositePrimitive::set_component 0 1 749 65
/**
 * Changes the attributes for the nth component triangle.
 */
93
inline void EggCompositePrimitive::set_component(std::size_t i, EggAttributes const *attrib);

1749 16 triangulate_into 0 4 2094 39 EggCompositePrimitive::triangulate_into 0 1 750 361
/**
 * Subdivides the composite primitive into triangles and adds those triangles
 * to the indicated container.  Does not remove the primitive from its
 * existing parent or modify it in any way.
 *
 * Returns true if the triangulation is successful, or false if there was some
 * error (in which case the container may contain some partial triangulation).
 */
83
inline bool EggCompositePrimitive::triangulate_into(EggGroupNode *container) const;

1750 20 triangulate_in_place 0 4 2094 43 EggCompositePrimitive::triangulate_in_place 0 1 751 460
/**
 * Subdivides the composite primitive into triangles and adds those triangles
 * to the parent group node in place of the original primitive.  Returns a
 * pointer to the original primitive, which is likely about to be destructed.
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */
85
PointerTo< EggCompositePrimitive > EggCompositePrimitive::triangulate_in_place(void);

1751 14 get_class_type 0 4 2094 37 EggCompositePrimitive::get_class_type 0 1 752 0
62
static TypeHandle EggCompositePrimitive::get_class_type(void);

1752 7 EggData 0 260 2096 16 EggData::EggData 0 2 753 754 22
/**
 *
 */

/**
 *
 */
76
inline EggData::EggData(void);
inline EggData::EggData(EggData const &copy);

1753 10 operator = 0 4 2096 19 EggData::operator = 0 1 755 10
/**
 *
 */
53
inline void EggData::operator =(EggData const &copy);

1754 20 resolve_egg_filename 0 4 2096 29 EggData::resolve_egg_filename 0 1 756 212
/**
 * Looks for the indicated filename, first along the indicated searchpath, and
 * then along the model_path.  If found, updates the filename to the full path
 * and returns true; otherwise, returns false.
 */
113
static bool EggData::resolve_egg_filename(Filename &egg_filename, DSearchPath const &searchpath = DSearchPath());

1755 4 read 0 4 2096 13 EggData::read 0 2 757 758 735
/**
 * Opens the indicated filename and reads the egg data contents from it.
 * Returns true if the file was successfully opened and read, false if there
 * were some errors, in which case the data may be partially read.
 *
 * error is the output stream to which to write error messages.
 */

/**
 * Parses the egg syntax contained in the indicated input stream.  Returns
 * true if the stream was a completely valid egg file, false if there were
 * some errors, in which case the data may be partially read.
 *
 * Before you call this routine, you should probably call set_egg_filename()
 * to set the name of the egg file we're processing, if at all possible.  If
 * there is no such filename, you may set it to the empty string.
 */
113
bool EggData::read(Filename filename, std::string display_name = string());
bool EggData::read(std::istream &in);

1756 5 merge 0 4 2096 14 EggData::merge 0 1 759 110
/**
 * Appends the other egg structure to the end of this one.  The other egg
 * structure is invalidated.
 */
36
void EggData::merge(EggData &other);

1757 14 load_externals 0 4 2096 23 EggData::load_externals 0 2 760 761 714
/**
 * Loads up all the egg files referenced by <File> entries within the egg
 * structure, and inserts their contents in place of the <File> entries.
 * Searches for files in the searchpath, if not found directly, and writes
 * error messages to the indicated output stream.  Returns true if all
 * externals were loaded successfully, false otherwise.
 */

/**
 * Loads up all the egg files referenced by <File> entries within the egg
 * structure, and inserts their contents in place of the <File> entries.
 * Searches for files in the searchpath, if not found directly, and writes
 * error messages to the indicated output stream.  Returns true if all
 * externals were loaded successfully, false otherwise.
 */
161
bool EggData::load_externals(DSearchPath const &searchpath = DSearchPath());
bool EggData::load_externals(DSearchPath const &searchpath, BamCacheRecord *record);

1758 28 collapse_equivalent_textures 0 4 2096 37 EggData::collapse_equivalent_textures 0 1 762 310
/**
 * Removes duplicate references to the same texture image with the same
 * properties.  Considers two texture references with identical properties,
 * but different tref names, to be equivalent, and collapses them, choosing
 * one tref name to keep arbitrarily.  Returns the number of textures removed.
 */
48
int EggData::collapse_equivalent_textures(void);

1759 29 collapse_equivalent_materials 0 4 2096 38 EggData::collapse_equivalent_materials 0 1 763 306
/**
 * Removes duplicate references to the same material with the same properties.
 * Considers two material references with identical properties, but different
 * mref names, to be equivalent, and collapses them, choosing one mref name to
 * keep arbitrarily.  Returns the number of materials removed.
 */
49
int EggData::collapse_equivalent_materials(void);

1760 9 write_egg 0 4 2096 18 EggData::write_egg 0 2 764 765 124
/**
 * The main interface for writing complete egg files.
 */

/**
 * The main interface for writing complete egg files.
 */
87
bool EggData::write_egg(Filename filename);
bool EggData::write_egg(std::ostream &out);

1761 26 set_auto_resolve_externals 0 4 2096 35 EggData::set_auto_resolve_externals 0 1 766 147
/**
 * Indicates whether the EggData object will automatically resolve any
 * external references when read() is called.  The default is false.
 */
62
inline void EggData::set_auto_resolve_externals(bool resolve);

1762 26 get_auto_resolve_externals 0 4 2096 35 EggData::get_auto_resolve_externals 0 1 767 147
/**
 * Indicates whether the EggData object will automatically resolve any
 * external references when read() is called.  The default is false.
 */
60
inline bool EggData::get_auto_resolve_externals(void) const;

1763 31 original_had_absolute_pathnames 0 4 2096 40 EggData::original_had_absolute_pathnames 0 1 768 411
/**
 * Returns true if the data processed in the last call to read() contained
 * absolute pathnames, or false if those pathnames were all relative.
 *
 * This method is necessary because if auto_resolve_externals() is in effect,
 * it may modify the pathnames to be absolute whether or not they were as
 * loaded from disk.  This method can be used to query the state of the
 * original egg file from disk.
 */
65
inline bool EggData::original_had_absolute_pathnames(void) const;

1764 21 set_coordinate_system 0 4 2096 30 EggData::set_coordinate_system 0 1 769 156
/**
 * Changes the coordinate system of the EggData.  If the coordinate system was
 * previously different, this may result in a conversion of the data.
 */
63
void EggData::set_coordinate_system(CoordinateSystem coordsys);

1765 21 get_coordinate_system 0 4 2096 30 EggData::get_coordinate_system 0 1 770 74
/**
 * Returns the coordinate system in which the egg file is defined.
 */
67
inline CoordinateSystem EggData::get_coordinate_system(void) const;

1766 16 set_egg_filename 0 4 2096 25 EggData::set_egg_filename 0 1 771 150
/**
 * Sets the filename--especially the directory part--in which the egg file is
 * considered to reside.  This is also implicitly set by read().
 */
68
inline void EggData::set_egg_filename(Filename const &egg_filename);

1767 16 get_egg_filename 0 4 2096 25 EggData::get_egg_filename 0 1 772 79
/**
 * Returns the directory in which the egg file is considered to reside.
 */
61
inline Filename const &EggData::get_egg_filename(void) const;

1768 17 set_egg_timestamp 0 4 2096 26 EggData::set_egg_timestamp 0 1 773 136
/**
 * Sets the timestamp of the egg file on disk, at the time it was opened for
 * reading.  This is also implicitly set by read().
 */
61
inline void EggData::set_egg_timestamp(time_t egg_timestamp);

1769 17 get_egg_timestamp 0 4 2096 26 EggData::get_egg_timestamp 0 1 774 142
/**
 * Returns the timestamp of the egg file on disk, at the time it was opened
 * for reading, or 0 if this information is not available.
 */
53
inline time_t EggData::get_egg_timestamp(void) const;

1770 24 recompute_vertex_normals 0 4 2096 33 EggData::recompute_vertex_normals 0 1 775 711
/**
 * Recomputes all the vertex normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  A shared
 * edge between two polygons (even in different groups) is considered smooth
 * if the angle between the two edges is less than threshold degrees.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the correct normals.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */
64
inline void EggData::recompute_vertex_normals(double threshold);

1771 25 recompute_polygon_normals 0 4 2096 34 EggData::recompute_polygon_normals 0 1 776 672
/**
 * Recomputes all the polygon normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  Normals
 * are removed from the vertices and defined only on polygons, giving the
 * geometry a faceted appearance.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normals removed.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */
53
inline void EggData::recompute_polygon_normals(void);

1772 13 strip_normals 0 4 2096 22 EggData::strip_normals 0 1 777 317
/**
 * Removes all normals from primitives, and the vertices they reference, at
 * this node and below.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normal removed.  Thus, it is a good idea to
 * call remove_unused_vertices() after calling this.
 */
41
inline void EggData::strip_normals(void);

1773 14 get_class_type 0 4 2096 23 EggData::get_class_type 0 1 778 0
48
static TypeHandle EggData::get_class_type(void);

1774 8 ~EggData 0 516 2096 17 EggData::~EggData 0 0 0
24
EggData::~EggData(void);

1775 19 EggCoordinateSystem 0 260 2100 40 EggCoordinateSystem::EggCoordinateSystem 0 2 779 780 22
/**
 *
 */

/**
 *
 */
169
inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value = ::CS_default);
inline EggCoordinateSystem::EggCoordinateSystem(EggCoordinateSystem const &copy);

1776 9 set_value 0 4 2100 30 EggCoordinateSystem::set_value 0 1 781 10
/**
 *
 */
67
inline void EggCoordinateSystem::set_value(CoordinateSystem value);

1777 9 get_value 0 4 2100 30 EggCoordinateSystem::get_value 0 1 782 10
/**
 *
 */
67
inline CoordinateSystem EggCoordinateSystem::get_value(void) const;

1778 10 __reduce__ 0 4 2100 31 EggCoordinateSystem::__reduce__ 0 1 783 0
54
PyObject *EggCoordinateSystem::__reduce__(void) const;

1779 14 get_class_type 0 4 2100 35 EggCoordinateSystem::get_class_type 0 1 784 0
60
static TypeHandle EggCoordinateSystem::get_class_type(void);

1780 20 ~EggCoordinateSystem 0 516 2100 41 EggCoordinateSystem::~EggCoordinateSystem 0 0 0
48
EggCoordinateSystem::~EggCoordinateSystem(void);

1781 10 operator = 0 4 2101 20 EggCurve::operator = 0 1 785 10
/**
 *
 */
55
inline void EggCurve::operator =(EggCurve const &copy);

1782 10 set_subdiv 0 4 2101 20 EggCurve::set_subdiv 0 1 786 276
/**
 * Sets the number of subdivisions that will be requested across the curve.
 * (This doesn't necessary guarantee that this number of subdivisions will be
 * made; it's just a hint to any curve renderer or quick tesselator.)  Set the
 * number to 0 to disable the hint.
 */
45
inline void EggCurve::set_subdiv(int subdiv);

1783 10 get_subdiv 0 4 2101 20 EggCurve::get_subdiv 0 1 787 115
/**
 * Returns the requested number of subdivisions, or 0 if no particular
 * subdivisions have been requested.
 */
44
inline int EggCurve::get_subdiv(void) const;

1784 14 set_curve_type 0 4 2101 24 EggCurve::set_curve_type 0 1 788 126
/**
 * Sets the type of the curve.  This is primarily used as a hint to any code
 * that may need to deal with this curve.
 */
63
inline void EggCurve::set_curve_type(EggCurve::CurveType type);

1785 14 get_curve_type 0 4 2101 24 EggCurve::get_curve_type 0 1 789 51
/**
 * Returns the indicated type of the curve.
 */
64
inline EggCurve::CurveType EggCurve::get_curve_type(void) const;

1786 17 string_curve_type 0 4 2101 27 EggCurve::string_curve_type 0 1 790 163
/**
 * Returns the CurveType value associated with the given string
 * representation, or CT_invalid if the string does not match any known
 * CurveType value.
 */
82
static EggCurve::CurveType EggCurve::string_curve_type(std::string const &string);

1787 14 get_class_type 0 4 2101 24 EggCurve::get_class_type 0 1 791 0
49
static TypeHandle EggCurve::get_class_type(void);

1788 9 ~EggCurve 0 516 2101 19 EggCurve::~EggCurve 0 0 0
26
EggCurve::~EggCurve(void);

1789 20 EggExternalReference 0 260 2103 42 EggExternalReference::EggExternalReference 0 2 792 793 22
/**
 *
 */

/**
 *
 */
189
explicit EggExternalReference::EggExternalReference(std::string const &node_name, std::string const &filename);
EggExternalReference::EggExternalReference(EggExternalReference const &copy);

1790 10 operator = 0 4 2103 32 EggExternalReference::operator = 0 1 794 10
/**
 *
 */
72
void EggExternalReference::operator =(EggExternalReference const &copy);

1791 14 get_class_type 0 4 2103 36 EggExternalReference::get_class_type 0 1 795 0
61
static TypeHandle EggExternalReference::get_class_type(void);

1792 21 ~EggExternalReference 0 516 2103 43 EggExternalReference::~EggExternalReference 0 0 0
50
EggExternalReference::~EggExternalReference(void);

1793 5 clear 0 4 2104 24 EggNameUniquifier::clear 0 1 796 86
/**
 * Empties the table of used named and prepares the Uniquifier for a new tree.
 */
36
void EggNameUniquifier::clear(void);

1794 8 uniquify 0 4 2104 27 EggNameUniquifier::uniquify 0 1 797 56
/**
 * Begins the traversal from the indicated node.
 */
48
void EggNameUniquifier::uniquify(EggNode *node);

1795 8 get_node 0 4 2104 27 EggNameUniquifier::get_node 0 1 798 114
/**
 * Returns the node associated with the given category and name, or NULL if
 * the name has not been used.
 */
97
EggNode *EggNameUniquifier::get_node(std::string const &category, std::string const &name) const;

1796 8 has_name 0 4 2104 27 EggNameUniquifier::has_name 0 1 799 105
/**
 * Returns true if the name has been used for the indicated category already,
 * false otherwise.
 */
93
bool EggNameUniquifier::has_name(std::string const &category, std::string const &name) const;

1797 8 add_name 0 4 2104 27 EggNameUniquifier::add_name 0 1 800 219
/**
 * Adds the name to the indicated category.  This name will not be used for
 * any other egg node within this category.  Returns true if the name was
 * added, or false if it was already in use for the category.
 */
112
bool EggNameUniquifier::add_name(std::string const &category, std::string const &name, EggNode *node = nullptr);

1798 12 get_category 0 6 2104 31 EggNameUniquifier::get_category 0 1 801 0
71
virtual std::string EggNameUniquifier::get_category(EggNode *node) = 0;

1799 11 filter_name 0 6 2104 30 EggNameUniquifier::filter_name 0 1 802 216
/**
 * Returns the name of the given node, or at least the name it should be.
 * This provides a hook to adjust the name before attempting to uniquify it,
 * if desired, for instance to remove invalid characters.
 */
66
virtual std::string EggNameUniquifier::filter_name(EggNode *node);

1800 13 generate_name 0 6 2104 32 EggNameUniquifier::generate_name 0 1 803 365
/**
 * Generates a new name for the given node when its existing name clashes with
 * some other node.  This function will be called repeatedly, if necessary,
 * until it returns a name that actually is unique.
 *
 * The category is the string returned by get_category(), and index is a
 * uniquely-generated number that may be useful for synthesizing the name.
 */
108
virtual std::string EggNameUniquifier::generate_name(EggNode *node, std::string const &category, int index);

1801 14 get_class_type 0 4 2104 33 EggNameUniquifier::get_class_type 0 1 804 0
58
static TypeHandle EggNameUniquifier::get_class_type(void);

1802 18 EggGroupUniquifier 0 260 2105 38 EggGroupUniquifier::EggGroupUniquifier 0 1 805 254
/**
 * If filter_names is true, then the group names will be coerced into a fairly
 * safe, standard convention that uses no characters other than a-z, A-Z, 0-9,
 * and underscore.  If filter_names is false, the group names will be left
 * unchanged.
 */
74
explicit EggGroupUniquifier::EggGroupUniquifier(bool filter_names = true);

1803 14 get_class_type 0 4 2105 34 EggGroupUniquifier::get_class_type 0 1 806 0
59
static TypeHandle EggGroupUniquifier::get_class_type(void);

1804 19 ~EggGroupUniquifier 0 516 2105 39 EggGroupUniquifier::~EggGroupUniquifier 0 0 0
46
EggGroupUniquifier::~EggGroupUniquifier(void);

1805 7 EggLine 0 260 2106 16 EggLine::EggLine 0 2 807 808 22
/**
 *
 */

/**
 *
 */
109
inline explicit EggLine::EggLine(std::string const &name = "");
inline EggLine::EggLine(EggLine const &copy);

1806 10 operator = 0 4 2106 19 EggLine::operator = 0 1 809 10
/**
 *
 */
53
inline void EggLine::operator =(EggLine const &copy);

1807 9 has_thick 0 4 2106 18 EggLine::has_thick 0 1 810 10
/**
 *
 */
43
inline bool EggLine::has_thick(void) const;

1808 9 get_thick 0 4 2106 18 EggLine::get_thick 0 1 811 108
/**
 * Returns the thickness set on this particular line.  If there is no
 * thickness set, returns 1.0.
 */
45
inline double EggLine::get_thick(void) const;

1809 9 set_thick 0 4 2106 18 EggLine::set_thick 0 1 812 10
/**
 *
 */
45
inline void EggLine::set_thick(double thick);

1810 11 clear_thick 0 4 2106 20 EggLine::clear_thick 0 1 813 10
/**
 *
 */
39
inline void EggLine::clear_thick(void);

1811 14 get_class_type 0 4 2106 23 EggLine::get_class_type 0 1 814 0
48
static TypeHandle EggLine::get_class_type(void);

1812 21 EggMaterialCollection 0 260 2107 44 EggMaterialCollection::EggMaterialCollection 0 2 815 816 22
/**
 *
 */

/**
 *
 */
132
EggMaterialCollection::EggMaterialCollection(void);
EggMaterialCollection::EggMaterialCollection(EggMaterialCollection const &copy);

1813 10 operator = 0 4 2107 33 EggMaterialCollection::operator = 0 1 817 10
/**
 *
 */
74
void EggMaterialCollection::operator =(EggMaterialCollection const &copy);

1814 22 ~EggMaterialCollection 0 516 2107 45 EggMaterialCollection::~EggMaterialCollection 0 0 10
/**
 *
 */
52
EggMaterialCollection::~EggMaterialCollection(void);

1815 5 clear 0 4 2107 28 EggMaterialCollection::clear 0 1 818 53
/**
 * Removes all materials from the collection.
 */
40
void EggMaterialCollection::clear(void);

1816 17 extract_materials 0 4 2107 40 EggMaterialCollection::extract_materials 0 1 819 211
/**
 * Walks the egg hierarchy beginning at the indicated node, and removes any
 * EggMaterials encountered in the hierarchy, adding them to the collection.
 * Returns the number of EggMaterials encountered.
 */
65
int EggMaterialCollection::extract_materials(EggGroupNode *node);

1817 19 find_used_materials 0 4 2107 42 EggMaterialCollection::find_used_materials 0 1 820 903
/**
 * Walks the egg hierarchy beginning at the indicated node, looking for
 * materials that are referenced by primitives but are not already members of
 * the collection, adding them to the collection.
 *
 * If this is called following extract_materials(), it can be used to pick up
 * any additional material references that appeared in the egg hierarchy (but
 * whose EggMaterial node was not actually part of the hierarchy).
 *
 * If this is called in lieu of extract_materials(), it will fill up the
 * collection with all of the referenced materials (and only the referenced
 * materials), without destructively removing the EggMaterials from the
 * hierarchy.
 *
 * This also has the side effect of incrementing the internal usage count for
 * a material in the collection each time a material reference is encountered.
 * This side effect is taken advantage of by remove_unused_materials().
 */
62
int EggMaterialCollection::find_used_materials(EggNode *node);

1818 23 remove_unused_materials 0 4 2107 46 EggMaterialCollection::remove_unused_materials 0 1 821 283
/**
 * Removes any materials from the collection that aren't referenced by any
 * primitives in the indicated egg hierarchy.  This also, incidentally, adds
 * materials to the collection that had been referenced by primitives but had
 * not previously appeared in the collection.
 */
67
void EggMaterialCollection::remove_unused_materials(EggNode *node);

1819 29 collapse_equivalent_materials 0 4 2107 52 EggMaterialCollection::collapse_equivalent_materials 0 2 822 823 1050
/**
 * Walks through the collection and collapses together any separate materials
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggMaterial::is_equivalent_to()).  The return value is the number of
 * materials removed.
 *
 * This flavor of collapse_equivalent_materials() automatically adjusts all
 * the primitives in the egg hierarchy to refer to the new material pointers.
 */

/**
 * Walks through the collection and collapses together any separate materials
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggMaterial::is_equivalent_to()).  The return value is the number of
 * materials removed.
 *
 * This flavor of collapse_equivalent_materials() does not adjust any
 * primitives in the egg hierarchy; instead, it fills up the 'removed' map
 * with an entry for each removed material, mapping it back to the equivalent
 * retained material.  It's up to the user to then call replace_materials()
 * with this map, if desired, to apply these changes to the egg hierarchy.
 */
204
int EggMaterialCollection::collapse_equivalent_materials(int eq, EggGroupNode *node);
int EggMaterialCollection::collapse_equivalent_materials(int eq, EggMaterialCollection::MaterialReplacement &removed);

1820 17 replace_materials 0 4 2107 40 EggMaterialCollection::replace_materials 0 1 824 300
/**
 * Walks the egg hierarchy, changing out any reference to a material appearing
 * on the left side of the map with its corresponding material on the right
 * side.  This is most often done following a call to
 * collapse_equivalent_materials().  It does not directly affect the
 * Collection.
 */
132
static void EggMaterialCollection::replace_materials(EggGroupNode *node, EggMaterialCollection::MaterialReplacement const &replace);

1821 14 uniquify_mrefs 0 4 2107 37 EggMaterialCollection::uniquify_mrefs 0 1 825 131
/**
 * Guarantees that each material in the collection has a unique MRef name.
 * This is essential before writing an egg file.
 */
49
void EggMaterialCollection::uniquify_mrefs(void);

1822 12 sort_by_mref 0 4 2107 35 EggMaterialCollection::sort_by_mref 0 1 826 154
/**
 * Sorts all the materials into alphabetical order by MRef name.  Subsequent
 * operations using begin()/end() will traverse in this sorted order.
 */
47
void EggMaterialCollection::sort_by_mref(void);

1823 12 add_material 0 4 2107 35 EggMaterialCollection::add_material 0 1 827 165
/**
 * Explicitly adds a new material to the collection.  Returns true if the
 * material was added, false if it was already there or if there was some
 * error.
 */
64
bool EggMaterialCollection::add_material(EggMaterial *material);

1824 15 remove_material 0 4 2107 38 EggMaterialCollection::remove_material 0 1 828 160
/**
 * Explicitly removes a material from the collection.  Returns true if the
 * material was removed, false if it wasn't there or if there was some error.
 */
67
bool EggMaterialCollection::remove_material(EggMaterial *material);

1825 22 create_unique_material 0 4 2107 45 EggMaterialCollection::create_unique_material 0 1 829 421
// create_unique_material() creates a new material if there is not already
// one equivalent (according to eq, see EggMaterial::is_equivalent_to()) to
// the indicated material, or returns the existing one if there is.

/**
 * Creates a new material if there is not already one equivalent (according to
 * eq, see EggMaterial::is_equivalent_to()) to the indicated material, or
 * returns the existing one if there is.
 */
92
EggMaterial *EggMaterialCollection::create_unique_material(EggMaterial const &copy, int eq);

1826 9 find_mref 0 4 2107 32 EggMaterialCollection::find_mref 0 1 830 145
// Find a material with a particular MRef name.

/**
 * Returns the material with the indicated MRef name, or NULL if no material
 * matches.
 */
82
EggMaterial *EggMaterialCollection::find_mref(std::string const &mref_name) const;

1827 10 EggPolygon 0 260 2108 22 EggPolygon::EggPolygon 0 2 831 832 22
/**
 *
 */

/**
 *
 */
124
inline explicit EggPolygon::EggPolygon(std::string const &name = "");
inline EggPolygon::EggPolygon(EggPolygon const &copy);

1828 10 operator = 0 4 2108 22 EggPolygon::operator = 0 1 833 10
/**
 *
 */
59
inline void EggPolygon::operator =(EggPolygon const &copy);

1829 16 calculate_normal 0 4 2108 28 EggPolygon::calculate_normal 0 1 834 374
/**
 * Calculates the true polygon normal--the vector pointing out of the front of
 * the polygon--based on the vertices.  This does not return or change the
 * polygon's normal as set via set_normal().
 *
 * The return value is true if the normal is computed correctly, or false if
 * the polygon is degenerate and does not have at least three noncollinear
 * vertices.
 */
94
bool EggPolygon::calculate_normal(LNormald &result, CoordinateSystem cs = ::CS_default) const;

1830 9 is_planar 0 4 2108 21 EggPolygon::is_planar 0 1 835 103
/**
 * Returns true if all of the polygon's vertices lie within the same plane,
 * false otherwise.
 */
39
bool EggPolygon::is_planar(void) const;

1831 24 recompute_polygon_normal 0 4 2108 36 EggPolygon::recompute_polygon_normal 0 1 836 210
/**
 * Recalculates the normal according to the order of the vertices, and sets
 * it.  Returns true if the normal is computed correctly, or false if the
 * polygon is degenerate and does not have a normal.
 */
85
inline bool EggPolygon::recompute_polygon_normal(CoordinateSystem cs = ::CS_default);

1832 16 triangulate_into 0 4 2108 28 EggPolygon::triangulate_into 0 1 837 656
/**
 * Subdivides the polygon into triangles and adds each one to the indicated
 * container.  If the polygon is already a triangle, adds an exact copy of the
 * polygon to the container.  Does not remove the polygon from its existing
 * parent or modify it in any way.
 *
 * Returns true if the triangulation is successful, or false if there was some
 * error (in which case the container may contain some partial triangulation).
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */
90
inline bool EggPolygon::triangulate_into(EggGroupNode *container, bool convex_also) const;

1833 20 triangulate_in_place 0 4 2108 32 EggPolygon::triangulate_in_place 0 1 838 444
/**
 * Subdivides the polygon into triangles and adds those triangles to the
 * parent group node in place of the original polygon.  Returns a pointer to
 * the original polygon, which is likely about to be destructed.
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */
75
PointerTo< EggPolygon > EggPolygon::triangulate_in_place(bool convex_also);

1834 14 get_class_type 0 4 2108 26 EggPolygon::get_class_type 0 1 839 0
51
static TypeHandle EggPolygon::get_class_type(void);

1835 11 ~EggPolygon 0 516 2108 23 EggPolygon::~EggPolygon 0 0 0
30
EggPolygon::~EggPolygon(void);

1836 14 parse_egg_data 0 1 0 14 parse_egg_data 0 1 1004 53
/**
 * Parses an EggData from the raw egg syntax.
 */
67
PointerTo< EggData > parse_egg_data(std::string const &egg_syntax);

1837 14 parse_egg_node 0 1 0 14 parse_egg_node 0 1 1005 60
/**
 * Parses a single egg node from the raw egg syntax.
 */
67
PointerTo< EggNode > parse_egg_node(std::string const &egg_syntax);

1838 13 EggNurbsCurve 0 260 2109 28 EggNurbsCurve::EggNurbsCurve 0 2 840 841 22
/**
 *
 */

/**
 *
 */
139
inline explicit EggNurbsCurve::EggNurbsCurve(std::string const &name = "");
inline EggNurbsCurve::EggNurbsCurve(EggNurbsCurve const &copy);

1839 10 operator = 0 4 2109 25 EggNurbsCurve::operator = 0 1 842 10
/**
 *
 */
65
inline void EggNurbsCurve::operator =(EggNurbsCurve const &copy);

1840 5 setup 0 4 2109 20 EggNurbsCurve::setup 0 1 843 306
/**
 * Prepares a new curve definition with the indicated order and number of
 * knots.  This also implies a particular number of vertices as well (the
 * number of knots minus the order), but it is up to the user to add the
 * correct number of vertices to the curve by repeatedly calling push_back().
 */
52
void EggNurbsCurve::setup(int order, int num_knots);

1841 9 set_order 0 4 2109 24 EggNurbsCurve::set_order 0 1 844 273
/**
 * Directly changes the order to the indicated value (which must be an integer
 * in the range 1 <= order <= 4).  If possible, it is preferable to use the
 * setup() method instead of this method, since changing the order directly
 * may result in an invalid curve.
 */
48
inline void EggNurbsCurve::set_order(int order);

1842 13 set_num_knots 0 4 2109 28 EggNurbsCurve::set_num_knots 0 1 845 361
/**
 * Directly changes the number of knots.  This will either add zero-valued
 * knots onto the end, or truncate knot values from the end, depending on
 * whether the list is being increased or decreased.  If possible, it is
 * preferable to use the setup() method instead of directly setting the number
 * of knots, as this may result in an invalid curve.
 */
43
void EggNurbsCurve::set_num_knots(int num);

1843 8 set_knot 0 4 2109 23 EggNurbsCurve::set_knot 0 1 846 199
/**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_knots(), and the value must be in the range
 * get_knot(k - 1) <= value <= get_knot(k + 1).
 */
57
inline void EggNurbsCurve::set_knot(int k, double value);

1844 8 is_valid 0 4 2109 23 EggNurbsCurve::is_valid 0 1 847 204
/**
 * Returns true if the NURBS parameters are all internally consistent (e.g.
 * it has the right number of vertices to match its number of knots and order
 * in each dimension), or false otherwise.
 */
41
bool EggNurbsCurve::is_valid(void) const;

1845 9 get_order 0 4 2109 24 EggNurbsCurve::get_order 0 1 848 215
/**
 * Returns the order of the curve.  The order is the degree of the NURBS
 * equation plus 1; for a typical NURBS, the order is 4.  With this
 * implementation of NURBS, the order must be in the range [1, 4].
 */
48
inline int EggNurbsCurve::get_order(void) const;

1846 10 get_degree 0 4 2109 25 EggNurbsCurve::get_degree 0 1 849 82
/**
 * Returns the degree of the curve.  For a typical NURBS, the degree is 3.
 */
49
inline int EggNurbsCurve::get_degree(void) const;

1847 13 get_num_knots 0 4 2109 28 EggNurbsCurve::get_num_knots 0 1 850 39
/**
 * Returns the number of knots.
 */
52
inline int EggNurbsCurve::get_num_knots(void) const;

1848 11 get_num_cvs 0 4 2109 26 EggNurbsCurve::get_num_cvs 0 1 851 367
/**
 * Returns the total number of control vertices that *should* be defined for
 * the curve.  This is determined by the number of knots and the order, in
 * each direction; it does not necessarily reflect the number of vertices that
 * have actually been added to the curve.  (However, if the number of vertices
 * in the curve are wrong, the curve is invalid.)
 */
50
inline int EggNurbsCurve::get_num_cvs(void) const;

1849 9 is_closed 0 4 2109 24 EggNurbsCurve::is_closed 0 1 852 204
/**
 * Returns true if the curve appears to be closed.  Since the Egg syntax does
 * not provide a means for explicit indication of closure, this has to be
 * guessed at by examining the curve itself.
 */
42
bool EggNurbsCurve::is_closed(void) const;

1850 8 get_knot 0 4 2109 23 EggNurbsCurve::get_knot 0 1 853 46
/**
 * Returns the nth knot value defined.
 */
51
inline double EggNurbsCurve::get_knot(int k) const;

1851 14 get_class_type 0 4 2109 29 EggNurbsCurve::get_class_type 0 1 854 0
54
static TypeHandle EggNurbsCurve::get_class_type(void);

1852 14 ~EggNurbsCurve 0 516 2109 29 EggNurbsCurve::~EggNurbsCurve 0 0 0
36
EggNurbsCurve::~EggNurbsCurve(void);

1853 10 operator = 0 4 2110 22 EggSurface::operator = 0 1 855 10
/**
 *
 */
59
inline void EggSurface::operator =(EggSurface const &copy);

1854 12 set_u_subdiv 0 4 2110 24 EggSurface::set_u_subdiv 0 1 856 300
/**
 * Sets the number of subdivisions in the U direction that will be requested
 * across the surface.  (This doesn't necessary guarantee that this number of
 * subdivisions will be made; it's just a hint to any surface renderer or
 * quick tesselator.)  Set the number to 0 to disable the hint.
 */
49
inline void EggSurface::set_u_subdiv(int subdiv);

1855 12 get_u_subdiv 0 4 2110 24 EggSurface::get_u_subdiv 0 1 857 134
/**
 * Returns the requested number of subdivisions in the U direction, or 0 if no
 * particular subdivisions have been requested.
 */
48
inline int EggSurface::get_u_subdiv(void) const;

1856 12 set_v_subdiv 0 4 2110 24 EggSurface::set_v_subdiv 0 1 858 300
/**
 * Sets the number of subdivisions in the U direction that will be requested
 * across the surface.  (This doesn't necessary guarantee that this number of
 * subdivisions will be made; it's just a hint to any surface renderer or
 * quick tesselator.)  Set the number to 0 to disable the hint.
 */
49
inline void EggSurface::set_v_subdiv(int subdiv);

1857 12 get_v_subdiv 0 4 2110 24 EggSurface::get_v_subdiv 0 1 859 134
/**
 * Returns the requested number of subdivisions in the U direction, or 0 if no
 * particular subdivisions have been requested.
 */
48
inline int EggSurface::get_v_subdiv(void) const;

1858 14 get_class_type 0 4 2110 26 EggSurface::get_class_type 0 1 860 0
51
static TypeHandle EggSurface::get_class_type(void);

1859 11 ~EggSurface 0 516 2110 23 EggSurface::~EggSurface 0 0 0
30
EggSurface::~EggSurface(void);

1860 15 EggNurbsSurface 0 260 2111 32 EggNurbsSurface::EggNurbsSurface 0 2 861 862 22
/**
 *
 */

/**
 *
 */
149
inline explicit EggNurbsSurface::EggNurbsSurface(std::string const &name = "");
inline EggNurbsSurface::EggNurbsSurface(EggNurbsSurface const &copy);

1861 10 operator = 0 4 2111 27 EggNurbsSurface::operator = 0 1 863 10
/**
 *
 */
69
inline void EggNurbsSurface::operator =(EggNurbsSurface const &copy);

1862 5 setup 0 4 2111 22 EggNurbsSurface::setup 0 1 864 349
/**
 * Prepares a new surface definition with the indicated order and number of
 * knots in each dimension.  This also implies a particular number of vertices
 * in each dimension as well (the number of knots minus the order), but it is
 * up to the user to add the correct number of vertices to the surface by
 * repeatedly calling push_back().
 */
88
void EggNurbsSurface::setup(int u_order, int v_order, int num_u_knots, int num_v_knots);

1863 11 set_u_order 0 4 2111 28 EggNurbsSurface::set_u_order 0 1 865 296
/**
 * Directly changes the order in the U direction to the indicated value (which
 * must be an integer in the range 1 <= u_order <= 4).  If possible, it is
 * preferable to use the setup() method instead of this method, since changing
 * the order directly may result in an invalid surface.
 */
54
inline void EggNurbsSurface::set_u_order(int u_order);

1864 11 set_v_order 0 4 2111 28 EggNurbsSurface::set_v_order 0 1 866 296
/**
 * Directly changes the order in the V direction to the indicated value (which
 * must be an integer in the range 1 <= v_order <= 4).  If possible, it is
 * preferable to use the setup() method instead of this method, since changing
 * the order directly may result in an invalid surface.
 */
54
inline void EggNurbsSurface::set_v_order(int v_order);

1865 15 set_num_u_knots 0 4 2111 32 EggNurbsSurface::set_num_u_knots 0 1 867 382
/**
 * Directly changes the number of knots in the U direction.  This will either
 * add zero-valued knots onto the end, or truncate knot values from the end,
 * depending on whether the list is being increased or decreased.  If
 * possible, it is preferable to use the setup() method instead of directly
 * setting the number of knots, as this may result in an invalid surface.
 */
47
void EggNurbsSurface::set_num_u_knots(int num);

1866 15 set_num_v_knots 0 4 2111 32 EggNurbsSurface::set_num_v_knots 0 1 868 382
/**
 * Directly changes the number of knots in the V direction.  This will either
 * add zero-valued knots onto the end, or truncate knot values from the end,
 * depending on whether the list is being increased or decreased.  If
 * possible, it is preferable to use the setup() method instead of directly
 * setting the number of knots, as this may result in an invalid surface.
 */
47
void EggNurbsSurface::set_num_v_knots(int num);

1867 10 set_u_knot 0 4 2111 27 EggNurbsSurface::set_u_knot 0 1 869 205
/**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_u_knots(), and the value must be in the range
 * get_u_knot(k - 1) <= value <= get_u_knot(k + 1).
 */
61
inline void EggNurbsSurface::set_u_knot(int k, double value);

1868 10 set_v_knot 0 4 2111 27 EggNurbsSurface::set_v_knot 0 1 870 205
/**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_v_knots(), and the value must be in the range
 * get_v_knot(k - 1) <= value <= get_v_knot(k + 1).
 */
61
inline void EggNurbsSurface::set_v_knot(int k, double value);

1869 6 set_cv 0 4 2111 23 EggNurbsSurface::set_cv 0 1 871 202
/**
 * Redefines the control vertex associated with a particular u, v coordinate
 * pair.  This is just a shorthand to access the EggPrimitive's normal vertex
 * assignment for a 2-d control vertex.
 */
71
inline void EggNurbsSurface::set_cv(int ui, int vi, EggVertex *vertex);

1870 8 is_valid 0 4 2111 25 EggNurbsSurface::is_valid 0 1 872 204
/**
 * Returns true if the NURBS parameters are all internally consistent (e.g.
 * it has the right number of vertices to match its number of knots and order
 * in each dimension), or false otherwise.
 */
43
bool EggNurbsSurface::is_valid(void) const;

1871 11 get_u_order 0 4 2111 28 EggNurbsSurface::get_u_order 0 1 873 235
/**
 * Returns the order of the surface in the U direction.  The order is the
 * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.
 * With this implementation of NURBS, the order must be in the range [1, 4].
 */
52
inline int EggNurbsSurface::get_u_order(void) const;

1872 11 get_v_order 0 4 2111 28 EggNurbsSurface::get_v_order 0 1 874 235
/**
 * Returns the order of the surface in the V direction.  The order is the
 * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.
 * With this implementation of NURBS, the order must be in the range [1, 4].
 */
52
inline int EggNurbsSurface::get_v_order(void) const;

1873 12 get_u_degree 0 4 2111 29 EggNurbsSurface::get_u_degree 0 1 875 106
/**
 * Returns the degree of the surface in the U direction.  For a typical NURBS,
 * the degree is 3.
 */
53
inline int EggNurbsSurface::get_u_degree(void) const;

1874 12 get_v_degree 0 4 2111 29 EggNurbsSurface::get_v_degree 0 1 876 106
/**
 * Returns the degree of the surface in the V direction.  for a typical NURBS,
 * the degree is 3.
 */
53
inline int EggNurbsSurface::get_v_degree(void) const;

1875 15 get_num_u_knots 0 4 2111 32 EggNurbsSurface::get_num_u_knots 0 1 877 58
/**
 * Returns the number of knots in the U direction.
 */
56
inline int EggNurbsSurface::get_num_u_knots(void) const;

1876 15 get_num_v_knots 0 4 2111 32 EggNurbsSurface::get_num_v_knots 0 1 878 58
/**
 * Returns the number of knots in the V direction.
 */
56
inline int EggNurbsSurface::get_num_v_knots(void) const;

1877 13 get_num_u_cvs 0 4 2111 30 EggNurbsSurface::get_num_u_cvs 0 1 879 351
/**
 * Returns the number of control vertices that should be present in the U
 * direction.  This is determined by the number of knots and the order; it
 * does not necessarily reflect the number of vertices that have actually been
 * added to the surface.  (However, if the number of vertices in the surface
 * are wrong, the surface is invalid.)
 */
54
inline int EggNurbsSurface::get_num_u_cvs(void) const;

1878 13 get_num_v_cvs 0 4 2111 30 EggNurbsSurface::get_num_v_cvs 0 1 880 351
/**
 * Returns the number of control vertices that should be present in the V
 * direction.  This is determined by the number of knots and the order; it
 * does not necessarily reflect the number of vertices that have actually been
 * added to the surface.  (However, if the number of vertices in the surface
 * are wrong, the surface is invalid.)
 */
54
inline int EggNurbsSurface::get_num_v_cvs(void) const;

1879 11 get_num_cvs 0 4 2111 28 EggNurbsSurface::get_num_cvs 0 1 881 375
/**
 * Returns the total number of control vertices that *should* be defined for
 * the surface.  This is determined by the number of knots and the order, in
 * each direction; it does not necessarily reflect the number of vertices that
 * have actually been added to the surface.  (However, if the number of
 * vertices in the surface are wrong, the surface is invalid.)
 */
52
inline int EggNurbsSurface::get_num_cvs(void) const;

1880 11 get_u_index 0 4 2111 28 EggNurbsSurface::get_u_index 0 1 882 265
/**
 * Returns the U index number of the given vertex within the EggPrimitive's
 * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices
 * to its 2-d mesh; this returns the U index number that corresponds to the
 * nth vertex in the list.
 */
64
inline int EggNurbsSurface::get_u_index(int vertex_index) const;

1881 11 get_v_index 0 4 2111 28 EggNurbsSurface::get_v_index 0 1 883 265
/**
 * Returns the V index number of the given vertex within the EggPrimitive's
 * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices
 * to its 2-d mesh; this returns the V index number that corresponds to the
 * nth vertex in the list.
 */
64
inline int EggNurbsSurface::get_v_index(int vertex_index) const;

1882 16 get_vertex_index 0 4 2111 33 EggNurbsSurface::get_vertex_index 0 1 884 111
/**
 * Returns the index number within the EggPrimitive's list of the control
 * vertex at position ui, vi.
 */
67
inline int EggNurbsSurface::get_vertex_index(int ui, int vi) const;

1883 11 is_closed_u 0 4 2111 28 EggNurbsSurface::is_closed_u 0 1 885 227
/**
 * Returns true if the surface appears to be closed in the U direction.  Since
 * the Egg syntax does not provide a means for explicit indication of closure,
 * this has to be guessed at by examining the surface itself.
 */
46
bool EggNurbsSurface::is_closed_u(void) const;

1884 11 is_closed_v 0 4 2111 28 EggNurbsSurface::is_closed_v 0 1 886 227
/**
 * Returns true if the surface appears to be closed in the V direction.  Since
 * the Egg syntax does not provide a means for explicit indication of closure,
 * this has to be guessed at by examining the surface itself.
 */
46
bool EggNurbsSurface::is_closed_v(void) const;

1885 10 get_u_knot 0 4 2111 27 EggNurbsSurface::get_u_knot 0 1 887 65
/**
 * Returns the nth knot value defined in the U direction.
 */
55
inline double EggNurbsSurface::get_u_knot(int k) const;

1886 10 get_v_knot 0 4 2111 27 EggNurbsSurface::get_v_knot 0 1 888 65
/**
 * Returns the nth knot value defined in the V direction.
 */
55
inline double EggNurbsSurface::get_v_knot(int k) const;

1887 6 get_cv 0 4 2111 23 EggNurbsSurface::get_cv 0 1 889 68
/**
 * Returns the control vertex at the indicate U, V position.
 */
64
inline EggVertex *EggNurbsSurface::get_cv(int ui, int vi) const;

1888 14 get_class_type 0 4 2111 31 EggNurbsSurface::get_class_type 0 1 890 0
56
static TypeHandle EggNurbsSurface::get_class_type(void);

1889 16 ~EggNurbsSurface 0 516 2111 33 EggNurbsSurface::~EggNurbsSurface 0 0 0
40
EggNurbsSurface::~EggNurbsSurface(void);

1890 8 EggPatch 0 260 2120 18 EggPatch::EggPatch 0 2 891 892 22
/**
 *
 */

/**
 *
 */
114
inline explicit EggPatch::EggPatch(std::string const &name = "");
inline EggPatch::EggPatch(EggPatch const &copy);

1891 10 operator = 0 4 2120 20 EggPatch::operator = 0 1 893 10
/**
 *
 */
55
inline void EggPatch::operator =(EggPatch const &copy);

1892 14 get_class_type 0 4 2120 24 EggPatch::get_class_type 0 1 894 0
49
static TypeHandle EggPatch::get_class_type(void);

1893 9 ~EggPatch 0 516 2120 19 EggPatch::~EggPatch 0 0 0
26
EggPatch::~EggPatch(void);

1894 8 EggPoint 0 260 2121 18 EggPoint::EggPoint 0 2 895 896 22
/**
 *
 */

/**
 *
 */
114
inline explicit EggPoint::EggPoint(std::string const &name = "");
inline EggPoint::EggPoint(EggPoint const &copy);

1895 10 operator = 0 4 2121 20 EggPoint::operator = 0 1 897 10
/**
 *
 */
55
inline void EggPoint::operator =(EggPoint const &copy);

1896 9 has_thick 0 4 2121 19 EggPoint::has_thick 0 1 898 10
/**
 *
 */
44
inline bool EggPoint::has_thick(void) const;

1897 9 get_thick 0 4 2121 19 EggPoint::get_thick 0 1 899 109
/**
 * Returns the thickness set on this particular point.  If there is no
 * thickness set, returns 1.0.
 */
46
inline double EggPoint::get_thick(void) const;

1898 9 set_thick 0 4 2121 19 EggPoint::set_thick 0 1 900 10
/**
 *
 */
46
inline void EggPoint::set_thick(double thick);

1899 11 clear_thick 0 4 2121 21 EggPoint::clear_thick 0 1 901 10
/**
 *
 */
40
inline void EggPoint::clear_thick(void);

1900 15 has_perspective 0 4 2121 25 EggPoint::has_perspective 0 1 902 10
/**
 *
 */
50
inline bool EggPoint::has_perspective(void) const;

1901 15 get_perspective 0 4 2121 25 EggPoint::get_perspective 0 1 903 125
/**
 * Returns the perspective flag set on this particular point.  If there is no
 * perspective flag set, returns false.
 */
50
inline bool EggPoint::get_perspective(void) const;

1902 15 set_perspective 0 4 2121 25 EggPoint::set_perspective 0 1 904 10
/**
 *
 */
56
inline void EggPoint::set_perspective(bool perspective);

1903 17 clear_perspective 0 4 2121 27 EggPoint::clear_perspective 0 1 905 10
/**
 *
 */
46
inline void EggPoint::clear_perspective(void);

1904 14 get_class_type 0 4 2121 24 EggPoint::get_class_type 0 1 906 0
49
static TypeHandle EggPoint::get_class_type(void);

1905 9 ~EggPoint 0 516 2121 19 EggPoint::~EggPoint 0 0 0
26
EggPoint::~EggPoint(void);

1906 15 EggPolysetMaker 0 260 2122 32 EggPolysetMaker::EggPolysetMaker 0 1 907 10
/**
 *
 */
39
EggPolysetMaker::EggPolysetMaker(void);

1907 14 set_properties 0 4 2122 31 EggPolysetMaker::set_properties 0 1 908 316
/**
 * Sets the set of properties that determines which polygons are allowed to be
 * grouped together into a single polyset.  This is the bitwise 'or' of all
 * the properties that matter.  If this is 0, all polygons (within a given
 * group) will be lumped into a common polyset regardless of their properties.
 */
53
void EggPolysetMaker::set_properties(int properties);

1908 14 get_class_type 0 4 2122 31 EggPolysetMaker::get_class_type 0 1 909 0
56
static TypeHandle EggPolysetMaker::get_class_type(void);

1909 16 ~EggPolysetMaker 0 516 2122 33 EggPolysetMaker::~EggPolysetMaker 0 0 0
40
EggPolysetMaker::~EggPolysetMaker(void);

1910 17 EggPoolUniquifier 0 260 2125 36 EggPoolUniquifier::EggPoolUniquifier 0 1 910 10
/**
 *
 */
43
EggPoolUniquifier::EggPoolUniquifier(void);

1911 14 get_class_type 0 4 2125 33 EggPoolUniquifier::get_class_type 0 1 911 0
58
static TypeHandle EggPoolUniquifier::get_class_type(void);

1912 18 ~EggPoolUniquifier 0 516 2125 37 EggPoolUniquifier::~EggPoolUniquifier 0 0 0
44
EggPoolUniquifier::~EggPoolUniquifier(void);

1913 12 EggSAnimData 0 260 2126 26 EggSAnimData::EggSAnimData 0 2 912 913 22
/**
 *
 */

/**
 *
 */
134
inline explicit EggSAnimData::EggSAnimData(std::string const &name = "");
inline EggSAnimData::EggSAnimData(EggSAnimData const &copy);

1914 10 operator = 0 4 2126 24 EggSAnimData::operator = 0 1 914 10
/**
 *
 */
63
inline void EggSAnimData::operator =(EggSAnimData const &copy);

1915 12 get_num_rows 0 4 2126 26 EggSAnimData::get_num_rows 0 1 915 100
/**
 * Returns the number of rows in the table.  For an SAnim table, each row has
 * one column.
 */
50
inline int EggSAnimData::get_num_rows(void) const;

1916 9 get_value 0 4 2126 23 EggSAnimData::get_value 0 1 916 106
/**
 * Returns the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows().
 */
53
inline double EggSAnimData::get_value(int row) const;

1917 9 set_value 0 4 2126 23 EggSAnimData::set_value 0 1 917 106
/**
 * Changes the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows().
 */
59
inline void EggSAnimData::set_value(int row, double value);

1918 8 optimize 0 4 2126 22 EggSAnimData::optimize 0 1 918 100
/**
 * Optimizes the data by collapsing a long table of duplicate values into a
 * single value.
 */
34
void EggSAnimData::optimize(void);

1919 14 get_class_type 0 4 2126 28 EggSAnimData::get_class_type 0 1 919 0
53
static TypeHandle EggSAnimData::get_class_type(void);

1920 13 ~EggSAnimData 0 516 2126 27 EggSAnimData::~EggSAnimData 0 0 0
34
EggSAnimData::~EggSAnimData(void);

1921 8 EggTable 0 260 2127 18 EggTable::EggTable 0 2 920 921 22
/**
 *
 */

/**
 *
 */
114
inline explicit EggTable::EggTable(std::string const &name = "");
inline EggTable::EggTable(EggTable const &copy);

1922 10 operator = 0 4 2127 20 EggTable::operator = 0 1 922 10
/**
 *
 */
55
inline void EggTable::operator =(EggTable const &copy);

1923 14 set_table_type 0 4 2127 24 EggTable::set_table_type 0 1 923 10
/**
 *
 */
63
inline void EggTable::set_table_type(EggTable::TableType type);

1924 14 get_table_type 0 4 2127 24 EggTable::get_table_type 0 1 924 10
/**
 *
 */
64
inline EggTable::TableType EggTable::get_table_type(void) const;

1925 13 has_transform 0 4 2127 23 EggTable::has_transform 0 1 925 90
/**
 * Returns true if the table contains a transform description, false
 * otherwise.
 */
41
bool EggTable::has_transform(void) const;

1926 17 string_table_type 0 4 2127 27 EggTable::string_table_type 0 1 926 163
/**
 * Returns the TableType value associated with the given string
 * representation, or TT_invalid if the string does not match any known
 * TableType value.
 */
82
static EggTable::TableType EggTable::string_table_type(std::string const &string);

1927 14 get_class_type 0 4 2127 24 EggTable::get_class_type 0 1 927 0
49
static TypeHandle EggTable::get_class_type(void);

1928 9 ~EggTable 0 516 2127 19 EggTable::~EggTable 0 0 0
26
EggTable::~EggTable(void);

1929 20 EggTextureCollection 0 260 2129 42 EggTextureCollection::EggTextureCollection 0 2 928 929 22
/**
 *
 */

/**
 *
 */
127
EggTextureCollection::EggTextureCollection(void);
EggTextureCollection::EggTextureCollection(EggTextureCollection const &copy);

1930 10 operator = 0 4 2129 32 EggTextureCollection::operator = 0 1 930 10
/**
 *
 */
72
void EggTextureCollection::operator =(EggTextureCollection const &copy);

1931 21 ~EggTextureCollection 0 516 2129 43 EggTextureCollection::~EggTextureCollection 0 0 10
/**
 *
 */
50
EggTextureCollection::~EggTextureCollection(void);

1932 5 clear 0 4 2129 27 EggTextureCollection::clear 0 1 931 52
/**
 * Removes all textures from the collection.
 */
39
void EggTextureCollection::clear(void);

1933 16 extract_textures 0 4 2129 38 EggTextureCollection::extract_textures 0 1 932 209
/**
 * Walks the egg hierarchy beginning at the indicated node, and removes any
 * EggTextures encountered in the hierarchy, adding them to the collection.
 * Returns the number of EggTextures encountered.
 */
63
int EggTextureCollection::extract_textures(EggGroupNode *node);

1934 8 is_empty 0 4 2129 30 EggTextureCollection::is_empty 0 1 933 86
/**
 * Returns true if there are no EggTexures in the collection, false otherwise.
 */
48
bool EggTextureCollection::is_empty(void) const;

1935 16 get_num_textures 0 4 2129 38 EggTextureCollection::get_num_textures 0 1 934 63
/**
 * Returns the number of EggTextures in the collection.
 */
55
int EggTextureCollection::get_num_textures(void) const;

1936 11 get_texture 0 4 2129 33 EggTextureCollection::get_texture 0 1 935 56
/**
 * Returns the nth EggTexture in the collection.
 */
63
EggTexture *EggTextureCollection::get_texture(int index) const;

1937 18 find_used_textures 0 4 2129 40 EggTextureCollection::find_used_textures 0 1 936 1178
/**
 * Walks the egg hierarchy beginning at the indicated node, looking for
 * textures that are referenced by primitives but are not already members of
 * the collection, adding them to the collection.
 *
 * If this is called following extract_textures(), it can be used to pick up
 * any additional texture references that appeared in the egg hierarchy (but
 * whose EggTexture node was not actually part of the hierarchy).
 *
 * If this is called in lieu of extract_textures(), it will fill up the
 * collection with all of the referenced textures (and only the referenced
 * textures), without destructively removing the EggTextures from the
 * hierarchy.
 *
 * This also has the side effect of incrementing the internal usage count for
 * a texture in the collection each time a texture reference is encountered.
 * This side effect is taken advantage of by remove_unused_textures().
 *
 * And one more side effect: this function identifies the presence of
 * multitexturing in the egg file, and calls multitexture_over() on each
 * texture appropriately so that, after this call, you may expect
 * get_multitexture_sort() to return a reasonable value for each texture.
 */
60
int EggTextureCollection::find_used_textures(EggNode *node);

1938 22 remove_unused_textures 0 4 2129 44 EggTextureCollection::remove_unused_textures 0 1 937 281
/**
 * Removes any textures from the collection that aren't referenced by any
 * primitives in the indicated egg hierarchy.  This also, incidentally, adds
 * textures to the collection that had been referenced by primitives but had
 * not previously appeared in the collection.
 */
65
void EggTextureCollection::remove_unused_textures(EggNode *node);

1939 28 collapse_equivalent_textures 0 4 2129 50 EggTextureCollection::collapse_equivalent_textures 0 2 938 939 1038
/**
 * Walks through the collection and collapses together any separate textures
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggTexture::is_equivalent_to()).  The return value is the number of
 * textures removed.
 *
 * This flavor of collapse_equivalent_textures() automatically adjusts all the
 * primitives in the egg hierarchy to refer to the new texture pointers.
 */

/**
 * Walks through the collection and collapses together any separate textures
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggTexture::is_equivalent_to()).  The return value is the number of
 * textures removed.
 *
 * This flavor of collapse_equivalent_textures() does not adjust any
 * primitives in the egg hierarchy; instead, it fills up the 'removed' map
 * with an entry for each removed texture, mapping it back to the equivalent
 * retained texture.  It's up to the user to then call replace_textures() with
 * this map, if desired, to apply these changes to the egg hierarchy.
 */
198
int EggTextureCollection::collapse_equivalent_textures(int eq, EggGroupNode *node);
int EggTextureCollection::collapse_equivalent_textures(int eq, EggTextureCollection::TextureReplacement &removed);

1940 16 replace_textures 0 4 2129 38 EggTextureCollection::replace_textures 0 1 940 297
/**
 * Walks the egg hierarchy, changing out any reference to a texture appearing
 * on the left side of the map with its corresponding texture on the right
 * side.  This is most often done following a call to
 * collapse_equivalent_textures().  It does not directly affect the
 * Collection.
 */
128
static void EggTextureCollection::replace_textures(EggGroupNode *node, EggTextureCollection::TextureReplacement const &replace);

1941 14 uniquify_trefs 0 4 2129 36 EggTextureCollection::uniquify_trefs 0 1 941 130
/**
 * Guarantees that each texture in the collection has a unique TRef name.
 * This is essential before writing an egg file.
 */
48
void EggTextureCollection::uniquify_trefs(void);

1942 12 sort_by_tref 0 4 2129 34 EggTextureCollection::sort_by_tref 0 1 942 153
/**
 * Sorts all the textures into alphabetical order by TRef name.  Subsequent
 * operations using begin()/end() will traverse in this sorted order.
 */
46
void EggTextureCollection::sort_by_tref(void);

1943 16 sort_by_basename 0 4 2129 38 EggTextureCollection::sort_by_basename 0 1 943 202
/**
 * Sorts all the textures into alphabetical order by the basename part
 * (including extension) of the filename.  Subsequent operations using
 * begin()/end() will traverse in this sorted order.
 */
50
void EggTextureCollection::sort_by_basename(void);

1944 11 operator [] 0 4 2129 33 EggTextureCollection::operator [] 0 1 944 56
/**
 * Returns the nth EggTexture in the collection.
 */
94
inline EggTexture *EggTextureCollection::operator [](EggTextureCollection::size_type n) const;

1945 4 size 0 4 2129 26 EggTextureCollection::size 0 1 945 63
/**
 * Returns the number of EggTextures in the collection.
 */
78
inline EggTextureCollection::size_type EggTextureCollection::size(void) const;

1946 11 add_texture 0 4 2129 33 EggTextureCollection::add_texture 0 1 946 163
/**
 * Explicitly adds a new texture to the collection.  Returns true if the
 * texture was added, false if it was already there or if there was some
 * error.
 */
60
bool EggTextureCollection::add_texture(EggTexture *texture);

1947 14 remove_texture 0 4 2129 36 EggTextureCollection::remove_texture 0 1 947 158
/**
 * Explicitly removes a texture from the collection.  Returns true if the
 * texture was removed, false if it wasn't there or if there was some error.
 */
63
bool EggTextureCollection::remove_texture(EggTexture *texture);

1948 21 create_unique_texture 0 4 2129 43 EggTextureCollection::create_unique_texture 0 1 948 414
// create_unique_texture() creates a new texture if there is not already one
// equivalent (according to eq, see EggTexture::is_equivalent_to()) to the
// indicated texture, or returns the existing one if there is.

/**
 * Creates a new texture if there is not already one equivalent (according to
 * eq, see EggTexture::is_equivalent_to()) to the indicated texture, or
 * returns the existing one if there is.
 */
88
EggTexture *EggTextureCollection::create_unique_texture(EggTexture const &copy, int eq);

1949 9 find_tref 0 4 2129 31 EggTextureCollection::find_tref 0 1 949 142
// Find a texture with a particular TRef name.

/**
 * Returns the texture with the indicated TRef name, or NULL if no texture
 * matches.
 */
80
EggTexture *EggTextureCollection::find_tref(std::string const &tref_name) const;

1950 13 find_filename 0 4 2129 35 EggTextureCollection::find_filename 0 1 950 140
// Find a texture with a particular filename.

/**
 * Returns the texture with the indicated filename, or NULL if no texture
 * matches.
 */
80
EggTexture *EggTextureCollection::find_filename(Filename const &filename) const;

1951 14 EggTriangleFan 0 260 2130 30 EggTriangleFan::EggTriangleFan 0 2 951 952 22
/**
 *
 */

/**
 *
 */
144
inline explicit EggTriangleFan::EggTriangleFan(std::string const &name = "");
inline EggTriangleFan::EggTriangleFan(EggTriangleFan const &copy);

1952 10 operator = 0 4 2130 26 EggTriangleFan::operator = 0 1 953 10
/**
 *
 */
67
inline void EggTriangleFan::operator =(EggTriangleFan const &copy);

1953 14 get_class_type 0 4 2130 30 EggTriangleFan::get_class_type 0 1 954 0
55
static TypeHandle EggTriangleFan::get_class_type(void);

1954 16 EggTriangleStrip 0 260 2131 34 EggTriangleStrip::EggTriangleStrip 0 2 955 956 22
/**
 *
 */

/**
 *
 */
154
inline explicit EggTriangleStrip::EggTriangleStrip(std::string const &name = "");
inline EggTriangleStrip::EggTriangleStrip(EggTriangleStrip const &copy);

1955 10 operator = 0 4 2131 28 EggTriangleStrip::operator = 0 1 957 10
/**
 *
 */
71
inline void EggTriangleStrip::operator =(EggTriangleStrip const &copy);

1956 14 get_class_type 0 4 2131 32 EggTriangleStrip::get_class_type 0 1 958 0
57
static TypeHandle EggTriangleStrip::get_class_type(void);

1957 11 EggXfmSAnim 0 260 2132 24 EggXfmSAnim::EggXfmSAnim 0 3 959 960 961 108
/**
 *
 */

/**
 *
 */

/**
 * Converts the older-style XfmAnim table to the newer-style XfmSAnim table.
 */
227
inline explicit EggXfmSAnim::EggXfmSAnim(std::string const &name = "", CoordinateSystem cs = ::CS_default);
EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from);
inline EggXfmSAnim::EggXfmSAnim(EggXfmSAnim const &copy);

1958 10 operator = 0 4 2132 23 EggXfmSAnim::operator = 0 1 962 10
/**
 *
 */
61
inline void EggXfmSAnim::operator =(EggXfmSAnim const &copy);

1959 7 set_fps 0 4 2132 20 EggXfmSAnim::set_fps 0 1 963 10
/**
 *
 */
45
inline void EggXfmSAnim::set_fps(double fps);

1960 9 clear_fps 0 4 2132 22 EggXfmSAnim::clear_fps 0 1 964 10
/**
 *
 */
41
inline void EggXfmSAnim::clear_fps(void);

1961 7 has_fps 0 4 2132 20 EggXfmSAnim::has_fps 0 1 965 10
/**
 *
 */
45
inline bool EggXfmSAnim::has_fps(void) const;

1962 7 get_fps 0 4 2132 20 EggXfmSAnim::get_fps 0 1 966 56
/**
 * This is only valid if has_fps() returns true.
 */
47
inline double EggXfmSAnim::get_fps(void) const;

1963 9 set_order 0 4 2132 22 EggXfmSAnim::set_order 0 1 967 10
/**
 *
 */
61
inline void EggXfmSAnim::set_order(std::string const &order);

1964 11 clear_order 0 4 2132 24 EggXfmSAnim::clear_order 0 1 968 10
/**
 *
 */
43
inline void EggXfmSAnim::clear_order(void);

1965 9 has_order 0 4 2132 22 EggXfmSAnim::has_order 0 1 969 10
/**
 *
 */
47
inline bool EggXfmSAnim::has_order(void) const;

1966 9 get_order 0 4 2132 22 EggXfmSAnim::get_order 0 1 970 10
/**
 *
 */
61
inline std::string const &EggXfmSAnim::get_order(void) const;

1967 18 get_standard_order 0 4 2132 31 EggXfmSAnim::get_standard_order 0 1 971 178
/**
 * Returns the standard order of matrix component composition.  This is what
 * the order string must be set to in order to use set_value() or add_data()
 * successfully.
 */
71
static inline std::string const &EggXfmSAnim::get_standard_order(void);

1968 21 get_coordinate_system 0 4 2132 34 EggXfmSAnim::get_coordinate_system 0 1 972 292
/**
 * Returns the coordinate system this table believes it is defined within.
 * This should always match the coordinate system of the EggData structure
 * that owns it.  It is necessary to store it here because the meaning of the
 * h, p, and r columns depends on the coordinate system.
 */
71
inline CoordinateSystem EggXfmSAnim::get_coordinate_system(void) const;

1969 8 optimize 0 4 2132 21 EggXfmSAnim::optimize 0 1 973 66
/**
 * Optimizes the table by collapsing redundant sub-tables.
 */
33
void EggXfmSAnim::optimize(void);

1970 26 optimize_to_standard_order 0 4 2132 39 EggXfmSAnim::optimize_to_standard_order 0 1 974 225
/**
 * Optimizes the table by collapsing redundant sub-tables, and simultaneously
 * ensures that the order string is the standard order (which is the same as
 * that supported by compose_matrix() and decompose_matrix()).
 */
51
void EggXfmSAnim::optimize_to_standard_order(void);

1971 9 normalize 0 4 2132 22 EggXfmSAnim::normalize 0 1 975 241
/**
 * The inverse operation of optimize(), this ensures that all the sub-tables
 * have the same length by duplicating rows as necessary.  This is needed
 * before doing operations like add_data() or set_value() on an existing
 * table.
 */
34
void EggXfmSAnim::normalize(void);

1972 12 get_num_rows 0 4 2132 25 EggXfmSAnim::get_num_rows 0 1 976 259
/**
 * Returns the effective number of rows in the table.  This is actually the
 * number of rows of the smallest subtable larger than one row.  This is a
 * convenience function that treats the table of tables as if it were a single
 * table of matrices.
 */
42
int EggXfmSAnim::get_num_rows(void) const;

1973 9 get_value 0 4 2132 22 EggXfmSAnim::get_value 0 1 977 342
/**
 * Returns the value of the aggregate row of the table as a matrix.  This is a
 * convenience function that treats the table of tables as if it were a single
 * table of matrices.  It is an error to call this if any SAnimData children
 * of this node have an improper name (e.g.  not a single letter, or not one
 * of "ijkabchprxyz").
 */
59
void EggXfmSAnim::get_value(int row, LMatrix4d &mat) const;

1974 9 set_value 0 4 2132 22 EggXfmSAnim::set_value 0 1 978 387
/**
 * Replaces the indicated row of the table with the given matrix.
 *
 * This function can only be called if all the constraints of add_data(),
 * below, are met.  Call normalize() first if you are not sure.
 *
 * The return value is true if the matrix can be decomposed and stored as
 * scale, shear, rotate, and translate, or false otherwise.  The data is set
 * in either case.
 */
59
bool EggXfmSAnim::set_value(int row, LMatrix4d const &mat);

1975 10 clear_data 0 4 2132 23 EggXfmSAnim::clear_data 0 1 979 93
/**
 * Removes all data from the table.  It does this by removing all of its
 * children.
 */
42
inline void EggXfmSAnim::clear_data(void);

1976 8 add_data 0 4 2132 21 EggXfmSAnim::add_data 0 1 980 1136
/**
 * Adds a new matrix to the table, by adding a new row to each of the
 * subtables.
 *
 * This is a convenience function that treats the table of tables as if it
 * were a single table of matrices.  It is an error to call this if any
 * SAnimData children of this node have an improper name (e.g.  not a single
 * letter, or not one of "ijkabchprxyz").
 *
 * This function has the further requirement that all nine of the subtables
 * must exist and be of the same length.  Furthermore, the order string must
 * be the standard order string, which matches the system compose_matrix() and
 * decompose_matrix() functions.
 *
 * Thus, you probably cannot take an existing EggXfmSAnim object and start
 * adding matrices to the end; you must clear out the original data first.
 * (As a special exception, if no tables exist, they will be created.)  The
 * method normalize() will do this for you on an existing EggXfmSAnim.
 *
 * This function may fail silently if the matrix cannot be decomposed into
 * scale, shear, rotate, and translate.  In this case, the closest
 * approximation is added to the table, and false is returned.
 */
49
bool EggXfmSAnim::add_data(LMatrix4d const &mat);

1977 18 add_component_data 0 4 2132 31 EggXfmSAnim::add_component_data 0 2 981 982 174
/**
 * Adds a new row to the named component (one of matrix_component_letters) of
 * the table.
 */

/**
 * Adds a new row to the indicated component (0-12) of the table.
 */
153
void EggXfmSAnim::add_component_data(std::string const &component_name, double value);
void EggXfmSAnim::add_component_data(int component, double value);

1978 18 compose_with_order 0 4 2132 31 EggXfmSAnim::compose_with_order 0 1 983 172
/**
 * Composes a matrix out of the nine individual components, respecting the
 * order string.  The components will be applied in the order indicated by the
 * string.
 */
205
static void EggXfmSAnim::compose_with_order(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &trans, std::string const &order, CoordinateSystem cs);

1979 14 get_class_type 0 4 2132 27 EggXfmSAnim::get_class_type 0 1 984 0
52
static TypeHandle EggXfmSAnim::get_class_type(void);

1980 12 ~EggXfmSAnim 0 516 2132 25 EggXfmSAnim::~EggXfmSAnim 0 0 0
32
EggXfmSAnim::~EggXfmSAnim(void);

1981 14 EggXfmAnimData 0 260 2133 30 EggXfmAnimData::EggXfmAnimData 0 3 985 986 987 108
/**
 *
 */

/**
 *
 */

/**
 * Converts the newer-style XfmSAnim table to the older-style XfmAnim table.
 */
245
inline explicit EggXfmAnimData::EggXfmAnimData(std::string const &name = "", CoordinateSystem cs = ::CS_default);
EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from);
inline EggXfmAnimData::EggXfmAnimData(EggXfmAnimData const &copy);

1982 10 operator = 0 4 2133 26 EggXfmAnimData::operator = 0 1 988 10
/**
 *
 */
67
inline void EggXfmAnimData::operator =(EggXfmAnimData const &copy);

1983 9 set_order 0 4 2133 25 EggXfmAnimData::set_order 0 1 989 10
/**
 *
 */
64
inline void EggXfmAnimData::set_order(std::string const &order);

1984 11 clear_order 0 4 2133 27 EggXfmAnimData::clear_order 0 1 990 10
/**
 *
 */
46
inline void EggXfmAnimData::clear_order(void);

1985 9 has_order 0 4 2133 25 EggXfmAnimData::has_order 0 1 991 10
/**
 *
 */
50
inline bool EggXfmAnimData::has_order(void) const;

1986 9 get_order 0 4 2133 25 EggXfmAnimData::get_order 0 1 992 10
/**
 *
 */
64
inline std::string const &EggXfmAnimData::get_order(void) const;

1987 18 get_standard_order 0 4 2133 34 EggXfmAnimData::get_standard_order 0 1 993 178
/**
 * Returns the standard order of matrix component composition.  This is what
 * the order string must be set to in order to use set_value() or add_data()
 * successfully.
 */
74
static inline std::string const &EggXfmAnimData::get_standard_order(void);

1988 12 set_contents 0 4 2133 28 EggXfmAnimData::set_contents 0 1 994 10
/**
 *
 */
70
inline void EggXfmAnimData::set_contents(std::string const &contents);

1989 14 clear_contents 0 4 2133 30 EggXfmAnimData::clear_contents 0 1 995 10
/**
 *
 */
49
inline void EggXfmAnimData::clear_contents(void);

1990 12 has_contents 0 4 2133 28 EggXfmAnimData::has_contents 0 1 996 10
/**
 *
 */
53
inline bool EggXfmAnimData::has_contents(void) const;

1991 12 get_contents 0 4 2133 28 EggXfmAnimData::get_contents 0 1 997 10
/**
 *
 */
67
inline std::string const &EggXfmAnimData::get_contents(void) const;

1992 21 get_coordinate_system 0 4 2133 37 EggXfmAnimData::get_coordinate_system 0 1 998 292
/**
 * Returns the coordinate system this table believes it is defined within.
 * This should always match the coordinate system of the EggData structure
 * that owns it.  It is necessary to store it here because the meaning of the
 * h, p, and r columns depends on the coordinate system.
 */
74
inline CoordinateSystem EggXfmAnimData::get_coordinate_system(void) const;

1993 12 get_num_rows 0 4 2133 28 EggXfmAnimData::get_num_rows 0 1 999 51
/**
 * Returns the number of rows in the table.
 */
52
inline int EggXfmAnimData::get_num_rows(void) const;

1994 12 get_num_cols 0 4 2133 28 EggXfmAnimData::get_num_cols 0 1 1000 148
/**
 * Returns the number of columns in the table.  This is set according to the
 * "contents" string, which defines the meaning of each column.
 */
52
inline int EggXfmAnimData::get_num_cols(void) const;

1995 9 get_value 0 4 2133 25 EggXfmAnimData::get_value 0 2 1001 1002 341
/**
 * Returns the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows(); col must be in the range 0 <= col < get_num_cols().
 */

/**
 * Returns the value of the aggregate row of the table as a matrix.  This is a
 * convenience function that treats the 2-d table as if it were a single table
 * of matrices.
 */
127
inline double EggXfmAnimData::get_value(int row, int col) const;
void EggXfmAnimData::get_value(int row, LMatrix4d &mat) const;

1996 14 get_class_type 0 4 2133 30 EggXfmAnimData::get_class_type 0 1 1003 0
55
static TypeHandle EggXfmAnimData::get_class_type(void);

1997 15 ~EggXfmAnimData 0 516 2133 31 EggXfmAnimData::~EggXfmAnimData 0 0 0
38
EggXfmAnimData::~EggXfmAnimData(void);

1005
1 0 0 7 3 2134 0 0 10 /**
 *
 */ 0 
2 0 0 15 3 2134 0 0 10 /**
 *
 */ 1 4 copy 1 2135  
3 0 0 7 4 2134 0 0 10 /**
 *
 */ 2 4 this 3 2134  4 copy 1 2135  
4 0 0 7 5 2138 0 0 0 0 
5 0 0 7 7 2139 0 0 10 /**
 *
 */ 0 
6 0 0 15 7 2139 0 0 10 /**
 *
 */ 1 4 copy 1 2140  
7 0 0 7 8 2139 0 0 10 /**
 *
 */ 2 4 this 3 2139  4 copy 1 2140  
8 0 0 4 9 2142 0 0 766 /**
 * Sets the user data associated with this object.  This may be any
 * EggUserData-derived object.  The egg library will do nothing with this
 * pointer, except to hold its reference count and return the pointer on
 * request.
 *
 * The EggObject maintains multiple different EggUserData pointers, one for
 * each unique type (as reported by get_type()).  If you know that only one
 * type of EggUserData object will be added in your application, you may use
 * the query functions that accept no parameters, but it is recommended that
 * in general you pass in the type of your particular user data, to allow
 * multiple applications to coexist in the same egg data.
 *
 * This pointer is also copied by the copy assignment operator and copy
 * constructor.
 */ 2 4 this 3 2139  9 user_data 1 2134  
9 0 0 7 10 2134 0 0 122 /**
 * Returns the user data pointer most recently stored on this object, or NULL
 * if nothing was previously stored.
 */ 1 4 this 3 2140  
10 0 0 7 10 2134 0 0 104 /**
 * Returns the user data pointer of the indicated type, if it exists, or NULL
 * if it does not.
 */ 2 4 this 3 2140  4 type 1 2138  
11 0 0 6 11 2055 0 0 117 /**
 * Returns true if a generic user data pointer has recently been set and not
 * yet cleared, false otherwise.
 */ 1 4 this 3 2140  
12 0 0 6 11 2055 0 0 104 /**
 * Returns true if the user data pointer of the indicated type has been set,
 * false otherwise.
 */ 2 4 this 3 2140  4 type 1 2138  
13 0 0 4 12 2142 0 0 58 /**
 * Removes *all* user data pointers from the node.
 */ 1 4 this 3 2139  
14 0 0 4 12 2142 0 0 63 /**
 * Removes the user data pointer of the indicated type.
 */ 2 4 this 3 2139  4 type 1 2138  
15 0 0 7 13 2138 0 0 0 0 
16 0 0 15 20 2145 1024 0 10 /**
 *
 */ 1 4 copy 1 2143  
17 0 0 7 20 2145 1024 0 10 /**
 *
 */ 1 4 name 5 2146  
18 0 0 7 21 2145 1024 0 10 /**
 *
 */ 2 4 this 3 2145  4 copy 1 2143  
19 0 0 4 22 2142 0 0 10 /**
 *
 */ 2 4 this 3 2143  3 out 1 2147  
20 0 0 7 23 2138 0 0 0 0 
21 0 0 7 15 2139 0 0 0 1 4 this 3 2145  
22 0 0 6 18 2149 0 0 0 1 4 this 3 2145  
23 0 0 7 26 2150 1102 0 10 /**
 *
 */ 2 4 this 3 2150  4 copy 1 2151  
24 0 0 7 27 2004 0 0 10 /**
 *
 */ 1 4 this 3 2151  
25 0 0 6 28 2010 0 0 76 /**
 * Returns the number of nodes above this node in the egg hierarchy.
 */ 1 4 this 3 2151  
26 0 0 6 29 2055 0 0 123 /**
 * Returns true if there is an <Instance> node somewhere in the egg tree at or
 * above this node, false otherwise.
 */ 1 4 this 3 2151  
27 0 0 6 30 2055 0 0 124 /**
 * Returns true if there is a <Transform> entry somewhere in the egg tree at
 * or above this node, false otherwise.
 */ 1 4 this 3 2151  
28 0 0 6 31 2055 0 0 189 /**
 * Returns true if this node's vertices are not in the global coordinate
 * space.  This will be the case if there was an <Instance> node under a
 * transform at or above this node.
 */ 1 4 this 3 2151  
29 0 0 6 80 2153 0 0 711 /**
 * Returns the coordinate frame of the vertices referenced by primitives at or
 * under this node.  This is not the same as get_node_frame().
 *
 * Generally, vertices in an egg file are stored in the global coordinate
 * space, regardless of the transforms defined at each node.  Thus,
 * get_vertex_frame() will usually return the identity transform (global
 * coordinate space).  However, primitives under an <Instance> entry reference
 * their vertices in the coordinate system under effect at the time of the
 * <Instance>.  Thus, nodes under an <Instance> entry may return this non-
 * identity matrix.
 *
 * Specifically, this may return a non-identity matrix only if
 * is_local_coord() is true.
 */ 1 4 this 3 2151  
30 0 0 6 81 2153 0 0 133 /**
 * Returns the coordinate frame of the node itself.  This is simply the net
 * product of all transformations up to the root.
 */ 1 4 this 3 2151  
31 0 0 6 82 2153 0 0 104 /**
 * Returns the inverse of the matrix returned by get_vertex_frame().  See
 * get_vertex_frame().
 */ 1 4 this 3 2151  
32 0 0 6 83 2153 0 0 100 /**
 * Returns the inverse of the matrix returned by get_node_frame().  See
 * get_node_frame().
 */ 1 4 this 3 2151  
33 0 0 6 84 2153 0 0 231 /**
 * Returns the transformation matrix suitable for converting the vertices as
 * read from the egg file into the coordinate space of the node.  This is the
 * same thing as:
 *
 * get_vertex_frame() * get_node_frame_inv()
 *
 */ 1 4 this 3 2151  
34 0 0 6 85 2153 0 0 263 /**
 * Returns the transformation matrix suitable for converting vertices in the
 * coordinate space of the node to the appropriate coordinate space for
 * storing in the egg file.  This is the same thing as:
 *
 * get_node_frame() * get_vertex_frame_inv()
 *
 */ 1 4 this 3 2151  
35 0 0 6 86 2153 0 0 120 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_frame() matrix.
 */ 1 4 this 3 2151  
36 0 0 6 87 2153 0 0 118 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_frame() matrix.
 */ 1 4 this 3 2151  
37 0 0 6 88 2153 0 0 124 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_frame_inv() matrix.
 */ 1 4 this 3 2151  
38 0 0 6 89 2153 0 0 122 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_frame_inv() matrix.
 */ 1 4 this 3 2151  
39 0 0 6 90 2153 0 0 122 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_vertex_to_node() matrix.
 */ 1 4 this 3 2151  
40 0 0 6 91 2153 0 0 122 /**
 * Returns either a NULL pointer or a unique pointer shared by nodes with the
 * same get_node_to_vertex() matrix.
 */ 1 4 this 3 2151  
41 0 0 4 92 2142 0 0 90 /**
 * Applies the indicated transformation to the node and all of its
 * descendants.
 */ 2 4 this 3 2150  3 mat 1 2153  
42 0 0 4 93 2142 0 0 213 /**
 * Applies the indicated transformation only to vertices that appear in global
 * space within vertex pools at this node and below.  Joints and other
 * transforms are not affected, nor are local vertices.
 */ 2 4 this 3 2150  3 mat 1 2153  
43 0 0 4 94 2142 0 0 382 /**
 * Removes any transform and instance records from this node in the scene
 * graph and below.  If an instance node is encountered, removes the instance
 * and applies the transform to its vertices, duplicating vertices if
 * necessary.
 *
 * Since this function may result in duplicated vertices, it may be a good
 * idea to call remove_unused_vertices() after calling this.
 */ 1 4 this 3 2150  
44 0 0 4 95 2142 0 0 159 /**
 * Applies the texture matrices to the UV's of the vertices that reference
 * them, and then removes the texture matrices from the textures themselves.
 */ 1 4 this 3 2150  
45 0 0 6 96 2010 0 0 45 /**
 * Rename by stripping out the prefix
 */ 2 4 this 3 2150  12 strip_prefix 1 2156  
46 0 0 6 97 2055 0 0 229 /**
 * Returns true if this particular node represents a <Joint> entry or not.
 * This is a handy thing to know since Joints are sorted to the end of their
 * sibling list when writing an egg file.  See EggGroupNode::write().
 */ 1 4 this 3 2151  
47 0 0 6 98 2055 0 0 109 /**
 * Returns true if this node represents a table of animation transformation
 * data, false otherwise.
 */ 1 4 this 3 2151  
48 0 0 6 99 2159 0 0 266 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has an alpha_mode
 * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */ 1 4 this 3 2150  
49 0 0 6 100 2159 0 0 272 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2150  
50 0 0 6 101 2159 0 0 271 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2150  
51 0 0 6 102 2159 0 0 270 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2150  
52 0 0 6 103 2159 0 0 251 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a depth_offset
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2150  
53 0 0 6 104 2159 0 0 249 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a draw_order
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2150  
54 0 0 6 105 2159 0 0 238 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a bin specified.
 * Returns a valid EggRenderMode pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2150  
55 0 0 6 106 2055 0 0 321 /**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "indexed" scalar set.  Returns the value of the indexed scalar
 * if it is found, or false if it is not.
 *
 * In other words, returns true if the "indexed" flag is in effect for the
 * indicated node, false otherwise.
 */ 1 4 this 3 2150  
56 0 0 6 107 2055 0 0 311 /**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "decal" flag set.  Returns the value of the decal flag if it
 * is found, or false if it is not.
 *
 * In other words, returns true if the "decal" flag is in effect for the
 * indicated node, false otherwise.
 */ 1 4 this 3 2150  
57 0 0 4 108 2142 0 0 0 3 4 this 3 2151  3 out 1 2147  12 indent_level 1 2010  
58 0 0 6 109 2055 0 0 296 /**
 * Parses the egg syntax given in the indicate string as if it had been read
 * from the egg file within this object's definition.  Updates the object
 * accordingly.  Returns true if successful, false if there was some parse
 * error or if the object does not support this functionality.
 */ 2 4 this 3 2150  10 egg_syntax 1 2146  
59 0 0 4 110 2142 0 0 0 1 4 this 3 2151  
60 0 0 38 111 2006 0 0 0 1 4 this 3 2151  
61 0 0 7 112 2138 0 0 0 0 
62 0 0 15 35 2004 0 0 10 /**
 *
 */ 1 4 copy 1 2160  
63 0 0 7 35 2004 0 0 0 1 4 name 5 2146  
64 0 0 7 36 2004 0 0 10 /**
 *
 */ 2 4 this 3 2004  4 copy 1 2160  
65 0 0 6 37 2055 0 0 10 /**
 *
 */ 1 4 this 3 2160  
66 0 0 6 38 2162 0 0 10 /**
 *
 */ 1 4 this 3 2160  
67 0 0 4 39 2142 0 0 10 /**
 *
 */ 1 4 this 3 2004  
68 0 0 7 40 2150 1102 0 358 /**
 * Returns the first child in the group's list of children, or NULL if the
 * list of children is empty.  Can be used with get_next_child() to return the
 * complete list of children without using the iterator class; however, this
 * is non-thread-safe, and so is not recommended except for languages other
 * than C++ which cannot use the iterators.
 */ 1 4 this 3 2004  
69 0 0 7 41 2150 1102 0 506 /**
 * Returns the next child in the group's list of children since the last call
 * to get_first_child() or get_next_child(), or NULL if the last child has
 * been returned.  Can be used with get_first_child() to return the complete
 * list of children without using the iterator class; however, this is non-
 * thread-safe, and so is not recommended except for languages other than C++
 * which cannot use the iterators.
 *
 * It is an error to call this without previously calling get_first_child().
 */ 1 4 this 3 2004  
70 0 0 38 42 2006 0 0 0 1 4 this 3 2160  
71 0 0 7 47 2150 1102 0 143 /**
 * Adds the indicated child to the group and returns it.  If the child node is
 * already a child of some other node, removes it first.
 */ 2 4 this 3 2004  4 node 1 2150  
72 0 0 7 48 2150 1102 0 152 /**
 * Removes the indicated child node from the group and returns it.  If the
 * child was not already in the group, does nothing and returns NULL.
 */ 2 4 this 3 2004  4 node 1 2150  
73 0 0 4 49 2142 0 0 171 /**
 * Moves all the children from the other node to this one.  This is especially
 * useful because the group node copy assignment operator does not copy
 * children.
 */ 2 4 this 3 2004  5 other 1 2004  
74 0 0 7 50 2150 1102 0 169 /**
 * Returns the child of this node whose name is the indicated string, or NULL
 * if there is no child of this node by that name.  Does not search
 * recursively.
 */ 2 4 this 3 2160  4 name 1 2146  
75 0 0 6 51 2055 0 0 160 /**
 * Returns true if any nodes at this level and below include a reference to a
 * file via an absolute pathname, or false if all references are relative.
 */ 1 4 this 3 2160  
76 0 0 4 52 2142 0 0 207 /**
 * Walks the tree and attempts to resolve any filenames encountered.  This
 * looks up filenames along the specified search path; it does not
 * automatically search the model_path for missing files.
 */ 2 4 this 3 2004  10 searchpath 1 2164  
77 0 0 4 53 2142 0 0 190 /**
 * Similar to resolve_filenames, but each non-absolute filename encountered is
 * arbitrarily taken to be in the indicated directory, whether or not the so-
 * named filename exists.
 */ 2 4 this 3 2004  9 directory 1 2167  
78 0 0 4 54 2142 0 0 136 /**
 * Reverses the vertex ordering of all polygons defined at this node and
 * below.  Does not change the surface normals, if any.
 */ 1 4 this 3 2004  
79 0 0 4 55 2142 0 0 711 /**
 * Recomputes all the vertex normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  A shared
 * edge between two polygons (even in different groups) is considered smooth
 * if the angle between the two edges is less than threshold degrees.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the correct normals.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */ 3 4 this 3 2004  9 threshold 1 2013  2 cs 5 2097  
80 0 0 4 56 2142 0 0 672 /**
 * Recomputes all the polygon normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  Normals
 * are removed from the vertices and defined only on polygons, giving the
 * geometry a faceted appearance.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normals removed.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */ 2 4 this 3 2004  2 cs 5 2097  
81 0 0 4 57 2142 0 0 317 /**
 * Removes all normals from primitives, and the vertices they reference, at
 * this node and below.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normal removed.  Thus, it is a good idea to
 * call remove_unused_vertices() after calling this.
 */ 1 4 this 3 2004  
82 0 0 6 58 2055 0 0 767 /**
 * This function recomputes the tangent and binormal for the named texture
 * coordinate set for all vertices at this level and below.  Use the empty
 * string for the default texture coordinate set.
 *
 * It is necessary for each vertex to already have a normal (or at least a
 * polygon normal), as well as a texture coordinate in the named texture
 * coordinate set, before calling this function.  You might precede this with
 * recompute_vertex_normals() to ensure that the normals exist.
 *
 * Like recompute_vertex_normals(), this function does not remove or adjust
 * vertices in the vertex pool; it only adds new vertices with the new
 * tangents and binormals computed.  Thus, it is a good idea to call
 * remove_unused_vertices() after calling this.
 */ 2 4 this 3 2004  7 uv_name 1 2168  
83 0 0 6 58 2055 0 0 138 /**
 * This function recomputes the tangent and binormal for the named texture
 * coordinate sets.  Returns true if anything was done.
 */ 2 4 this 3 2004  5 names 1 2171  
84 0 0 6 59 2055 0 0 160 /**
 * This function recomputes the tangent and binormal for any texture
 * coordinate set that affects a normal map.  Returns true if anything was
 * done.
 */ 1 4 this 3 2004  
85 0 0 6 61 2010 0 0 428 /**
 * Replace all higher-order polygons at this point in the scene graph and
 * below with triangles.  Returns the total number of new triangles produced,
 * less degenerate polygons removed.
 *
 * If flags contains T_polygon and T_convex, both concave and convex polygons
 * will be subdivided into triangles; with only T_polygon, only concave
 * polygons will be subdivided, and convex polygons will be largely unchanged.
 */ 2 4 this 3 2004  5 flags 1 2010  
86 0 0 4 62 2142 0 0 84 /**
 * Combine triangles together into triangle strips, at this group and below.
 */ 2 4 this 3 2004  5 flags 1 2010  
87 0 0 4 63 2142 0 0 127 /**
 * Creates PointLight primitives to reference any otherwise unreferences
 * vertices discovered in this group or below.
 */ 1 4 this 3 2004  
88 0 0 6 64 2010 0 0 45 /**
 * Rename by stripping out the prefix
 */ 3 4 this 3 2004  12 strip_prefix 1 2156  7 recurse 1 2055  
89 0 0 6 65 2010 0 0 692 /**
 * Removes all vertices from VertexPools within this group or below that are
 * not referenced by at least one primitive.  Also collapses together
 * equivalent vertices, and renumbers all vertices after the operation so
 * their indices are consecutive, beginning at zero.  Returns the total number
 * of vertices removed.
 *
 * Note that this operates on the VertexPools within this group level, without
 * respect to primitives that reference these vertices (unlike other functions
 * like strip_normals()).  It is therefore most useful to call this on the
 * EggData root, rather than on a subgroup within the hierarchy, since a
 * VertexPool may appear anywhere in the hierarchy.
 */ 2 4 this 3 2004  7 recurse 1 2055  
90 0 0 6 66 2010 0 0 181 /**
 * Removes primitives at this level and below which appear to be degenerate;
 * e.g.  polygons with fewer than 3 vertices, etc.  Returns the number of
 * primitives removed.
 */ 2 4 this 3 2004  7 recurse 1 2055  
91 0 0 4 67 2142 0 0 319 /**
 * Resets the connected_shading information on all primitives at this node and
 * below, so that it may be accurately rederived by the next call to
 * get_connected_shading().
 *
 * It may be a good idea to call remove_unused_vertices() as well, to
 * establish the correct connectivity between common vertices.
 */ 1 4 this 3 2004  
92 0 0 4 68 2142 0 0 194 /**
 * Queries the connected_shading information on all primitives at this node
 * and below, to ensure that it has been completely filled in before we start
 * mucking around with vertices.
 */ 1 4 this 3 2004  
93 0 0 4 69 2142 0 0 1065 /**
 * Applies per-vertex normal and color to all vertices, if they are in fact
 * per-vertex (and different for each vertex), or moves them to the primitive
 * if they are all the same.
 *
 * After this call, either the primitive will have normals or its vertices
 * will, but not both.  Ditto for colors.
 *
 * If use_connected_shading is true, each polygon is considered in conjunction
 * with all connected polygons; otherwise, each polygon is considered
 * individually.
 *
 * If allow_per_primitive is false, S_per_face or S_overall will treated like
 * S_per_vertex: normals and colors will always be assigned to the vertices.
 * In this case, there will never be per-primitive colors or normals after
 * this call returns.  On the other hand, if allow_per_primitive is true, then
 * S_per_face means that normals and colors should be assigned to the
 * primitives, and removed from the vertices, as described above.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */ 4 4 this 3 2004  21 use_connected_shading 1 2055  19 allow_per_primitive 1 2055  7 recurse 1 2055  
94 0 0 4 70 2142 0 0 424 /**
 * Sets the last vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * OpenGL convention of storing flat-shaded properties on the last vertex,
 * although it is not usually a convention in Egg.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */ 2 4 this 3 2004  7 recurse 1 2055  
95 0 0 4 71 2142 0 0 427 /**
 * Sets the first vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * DirectX convention of storing flat-shaded properties on the first vertex,
 * although it is not usually a convention in Egg.
 *
 * This may create redundant vertices in the vertex pool, so it may be a good
 * idea to follow this up with remove_unused_vertices().
 */ 2 4 this 3 2004  7 recurse 1 2055  
96 0 0 4 72 2142 0 0 217 /**
 * Intended as a followup to apply_last_attribute(), this also sets an
 * attribute on the first vertices of the primitive, if they don't already
 * have an attribute set, just so they end up with *something*.
 */ 2 4 this 3 2004  7 recurse 1 2055  
97 0 0 6 73 2055 0 0 124 /**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, false otherwise.
 */ 1 4 this 3 2160  
98 0 0 6 74 2055 0 0 154 /**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, but the search does not include nested joints.
 */ 1 4 this 3 2160  
99 0 0 6 75 2055 0 0 164 /**
 * Returns true if any of the primitives (e.g.  polygons) defined within this
 * group or below have either face or vertex normals defined, false otherwise.
 */ 1 4 this 3 2160  
100 0 0 6 76 2055 0 0 60 /**
 * Returns true if the 2-d v1 is to the right of v2.
 */ 2 2 v1 1 2173  2 v2 1 2173  
101 0 0 7 77 2138 0 0 0 0 
102 0 0 7 115 2176 1113 0 10 /**
 *
 */ 2 4 this 3 2176  4 copy 1 2177  
103 0 0 4 116 2142 0 0 10 /**
 *
 */ 2 4 this 3 2176  4 type 1 2013  
104 0 0 4 117 2142 0 0 10 /**
 *
 */ 1 4 this 3 2176  
105 0 0 6 118 2055 0 0 10 /**
 *
 */ 1 4 this 3 2177  
106 0 0 6 119 2013 0 0 56 /**
 * This is only valid if has_fps() returns true.
 */ 1 4 this 3 2177  
107 0 0 4 120 2142 0 0 50 /**
 * Removes all data and empties the table.
 */ 1 4 this 3 2176  
108 0 0 4 121 2142 0 0 46 /**
 * Adds a single element to the table.
 */ 2 4 this 3 2176  5 value 1 2013  
109 0 0 6 122 2010 0 0 55 /**
 * Returns the number of elements in the table.
 */ 1 4 this 3 2177  
110 0 0 4 123 2142 0 0 79 /**
 * Rounds each element of the table to the nearest multiple of quantum.
 */ 2 4 this 3 2176  7 quantum 1 2013  
111 0 0 7 124 2138 0 0 0 0 
112 0 0 15 127 2181 1125 0 10 /**
 *
 */ 1 4 copy 1 2179  
113 0 0 7 127 2181 1125 0 10 /**
 *
 */ 1 4 name 5 2146  
114 0 0 7 128 2181 1125 0 10 /**
 *
 */ 2 4 this 3 2181  4 copy 1 2179  
115 0 0 4 129 2142 0 0 10 /**
 *
 */ 2 4 this 3 2181  3 fps 1 2013  
116 0 0 4 130 2142 0 0 10 /**
 *
 */ 1 4 this 3 2181  
117 0 0 6 131 2055 0 0 10 /**
 *
 */ 1 4 this 3 2179  
118 0 0 6 132 2013 0 0 56 /**
 * This is only valid if has_fps() returns true.
 */ 1 4 this 3 2179  
119 0 0 4 133 2142 0 0 10 /**
 *
 */ 2 4 this 3 2181  10 num_frames 1 2010  
120 0 0 4 134 2142 0 0 10 /**
 *
 */ 1 4 this 3 2181  
121 0 0 6 135 2055 0 0 10 /**
 *
 */ 1 4 this 3 2179  
122 0 0 6 136 2010 0 0 63 /**
 * This is only valid if has_num_frames() returns true.
 */ 1 4 this 3 2179  
123 0 0 7 140 2138 0 0 0 0 
124 0 0 7 146 2095 1130 0 10 /**
 *
 */ 0 
125 0 0 15 146 2095 1130 0 10 /**
 *
 */ 1 4 copy 1 2182  
126 0 0 6 147 2095 0 0 10 /**
 *
 */ 2 4 this 3 2095  4 copy 1 2182  
127 0 0 6 149 2055 0 0 10 /**
 *
 */ 1 4 this 3 2182  
128 0 0 6 150 2184 0 0 10 /**
 *
 */ 1 4 this 3 2182  
129 0 0 4 151 2142 0 0 10 /**
 *
 */ 2 4 this 3 2095  6 normal 1 2184  
130 0 0 4 152 2142 0 0 10 /**
 *
 */ 1 4 this 3 2095  
131 0 0 6 153 2055 0 0 113 /**
 * Returns true if this normal matches that of the other EggAttributes object,
 * include the morph list.
 */ 2 4 this 3 2182  5 other 1 2182  
132 0 0 4 154 2142 0 0 130 /**
 * Sets this normal to be the same as the other's, include morphs.  If the
 * other has no normal, this clears the normal.
 */ 2 4 this 3 2095  5 other 1 2182  
133 0 0 6 155 2055 0 0 10 /**
 *
 */ 1 4 this 3 2182  
134 0 0 7 156 2188 0 0 107 /**
 * Returns the color set on this particular attribute.  If there is no color
 * set, returns white.
 */ 1 4 this 3 2182  
135 0 0 4 157 2142 0 0 10 /**
 *
 */ 2 4 this 3 2095  5 Color 1 2189  
136 0 0 4 158 2142 0 0 10 /**
 *
 */ 1 4 this 3 2095  
137 0 0 6 159 2055 0 0 112 /**
 * Returns true if this color matches that of the other EggAttributes object,
 * include the morph list.
 */ 2 4 this 3 2182  5 other 1 2182  
138 0 0 4 160 2142 0 0 127 /**
 * Sets this color to be the same as the other's, include morphs.  If the
 * other has no color, this clears the color.
 */ 2 4 this 3 2095  5 other 1 2182  
139 0 0 4 161 2142 0 0 78 /**
 * Writes the attributes to the indicated output stream in Egg format.
 */ 3 4 this 3 2182  3 out 1 2147  12 indent_level 1 2010  
140 0 0 6 162 2055 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2182  5 other 1 2182  
141 0 0 6 163 2010 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2182  5 other 1 2182  
142 0 0 4 164 2142 0 0 73 /**
 * Applies the indicated transformation matrix to the attributes.
 */ 2 4 this 3 2095  3 mat 1 2153  
143 0 0 7 173 2138 0 0 0 0 
144 0 0 6 144 2190 0 0 0 1 4 this 3 2095  
145 0 0 15 175 2193 1024 0 10 /**
 *
 */ 1 4 copy 1 2191  
146 0 0 7 175 2193 1024 0 10 /**
 *
 */ 2 4 name 1 2146  3 uvw 1 2194  
147 0 0 7 175 2193 1024 0 10 /**
 *
 */ 2 4 name 1 2146  2 uv 1 2197  
148 0 0 7 176 2193 1024 0 10 /**
 *
 */ 2 4 this 3 2193  4 copy 1 2191  
149 0 0 6 177 2146 0 0 227 /**
 * Returns the actual name that should be set for a given name string.
 * Usually this is the same string that is input, but for historical reasons
 * the texture coordinate name "default" is mapped to the empty string.
 */ 1 4 name 1 2146  
150 0 0 4 178 2142 0 0 10 /**
 *
 */ 2 4 this 3 2193  4 name 1 2146  
151 0 0 6 179 2010 0 0 150 /**
 * Returns the number of components of the texture coordinate set.  This is
 * either 2 (the normal case) or 3 (for a 3-d texture coordinate).
 */ 1 4 this 3 2191  
152 0 0 6 180 2055 0 0 131 /**
 * Returns true if the texture coordinate has a third, w component, false if
 * it is just a normal 2-d texture coordinate.
 */ 1 4 this 3 2191  
153 0 0 7 181 2201 0 0 77 /**
 * Returns the texture coordinate pair, if get_num_dimensions() is 2.
 */ 1 4 this 3 2191  
154 0 0 6 182 2194 0 0 181 /**
 * Returns the texture coordinate triple, if get_num_dimensions() is 3.  This
 * is also legal to call if get_num_dimensions() is 2 (but the last dimension
 * will be zero).
 */ 1 4 this 3 2191  
155 0 0 4 183 2142 0 0 133 /**
 * Sets the texture coordinate pair.  This makes the texture coordinate a 2-d
 * texture coordinate, which is the usual case.
 */ 2 4 this 3 2193  8 texCoord 1 2197  
156 0 0 4 184 2142 0 0 110 /**
 * Sets the texture coordinate triple.  This makes the texture coordinate a
 * 3-d texture coordinate.
 */ 2 4 this 3 2193  8 texCoord 1 2194  
157 0 0 6 185 2055 0 0 10 /**
 *
 */ 1 4 this 3 2191  
158 0 0 6 186 2055 0 0 10 /**
 *
 */ 1 4 this 3 2191  
159 0 0 6 187 2184 0 0 10 /**
 *
 */ 1 4 this 3 2191  
160 0 0 7 188 2203 0 0 10 /**
 *
 */ 1 4 this 3 2191  
161 0 0 4 189 2142 0 0 10 /**
 *
 */ 2 4 this 3 2193  7 tangent 1 2184  
162 0 0 4 190 2142 0 0 158 /**
 * Sets the tangent vector, along with a fourth parameter that is multiplied
 * with the result of cross(normal, tangent) when computing the binormal.
 */ 2 4 this 3 2193  7 tangent 1 2204  
163 0 0 4 191 2142 0 0 10 /**
 *
 */ 1 4 this 3 2193  
164 0 0 6 192 2055 0 0 10 /**
 *
 */ 1 4 this 3 2191  
165 0 0 6 193 2184 0 0 10 /**
 *
 */ 1 4 this 3 2191  
166 0 0 4 194 2142 0 0 10 /**
 *
 */ 2 4 this 3 2193  8 binormal 1 2184  
167 0 0 4 195 2142 0 0 10 /**
 *
 */ 1 4 this 3 2193  
168 0 0 7 196 2193 1024 0 149 /**
 * Creates a new EggVertexUV that contains the averaged values of the two
 * given objects.  It is an error if they don't have the same name.
 */ 2 5 first 1 2191  6 second 1 2191  
169 0 0 4 197 2142 0 0 149 /**
 * Applies the indicated transformation matrix to the UV's tangent and/or
 * binormal.  This does nothing if there is no tangent or binormal.
 */ 2 4 this 3 2193  3 mat 1 2153  
170 0 0 4 198 2142 0 0 10 /**
 *
 */ 3 4 this 3 2191  3 out 1 2147  12 indent_level 1 2010  
171 0 0 6 199 2010 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2191  5 other 1 2191  
172 0 0 7 204 2138 0 0 0 0 
173 0 0 15 206 2208 1024 0 10 /**
 *
 */ 1 4 copy 1 2206  
174 0 0 7 206 2208 1024 0 10 /**
 *
 */ 2 4 name 1 2146  3 aux 1 2204  
175 0 0 7 207 2208 1024 0 10 /**
 *
 */ 2 4 this 3 2208  4 copy 1 2206  
176 0 0 4 208 2142 0 0 10 /**
 *
 */ 2 4 this 3 2208  4 name 1 2146  
177 0 0 6 209 2204 0 0 48 /**
 * Returns the auxiliary data quadruple.
 */ 1 4 this 3 2206  
178 0 0 4 210 2142 0 0 45 /**
 * Sets the auxiliary data quadruple.
 */ 2 4 this 3 2208  3 aux 1 2204  
179 0 0 7 211 2208 1024 0 150 /**
 * Creates a new EggVertexAux that contains the averaged values of the two
 * given objects.  It is an error if they don't have the same name.
 */ 2 5 first 1 2206  6 second 1 2206  
180 0 0 4 212 2142 0 0 10 /**
 *
 */ 3 4 this 3 2206  3 out 1 2147  12 indent_level 1 2010  
181 0 0 6 213 2010 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2206  5 other 1 2206  
182 0 0 7 214 2138 0 0 0 0 
183 0 0 7 220 2092 1192 0 10 /**
 *
 */ 0 
184 0 0 15 220 2092 1192 0 109 /**
 * Copies all properties of the vertex except its vertex pool, index number,
 * and group membership.
 */ 1 4 copy 1 2209  
185 0 0 7 221 2092 1192 0 109 /**
 * Copies all properties of the vertex except its vertex pool, index number,
 * and group membership.
 */ 2 4 this 3 2092  4 copy 1 2209  
186 0 0 7 223 2093 1102 0 123 /**
 * Returns the vertex pool this vertex belongs in.  This may be NULL if the
 * vertex has not been added to a pool.
 */ 1 4 this 3 2209  
187 0 0 6 224 2055 0 0 386 /**
 * Returns true if the vertex is a forward reference to some vertex that
 * hasn't been defined yet.  In this case, the vertex may not have any
 * properties filled in yet.
 *
 * This can only happen if you implicitly create a vertex via
 * EggVertexPool::get_forward_vertex(). Presumably, when the vertex pool is
 * later filled in, this vertex will be replaced with real data.
 */ 1 4 this 3 2209  
188 0 0 4 225 2142 0 0 98 /**
 * Sets the vertex position.  This variant sets the vertex to a two-
 * dimensional value.
 */ 2 4 this 3 2092  3 pos 1 2211  
189 0 0 4 225 2142 0 0 100 /**
 * Sets the vertex position.  This variant sets the vertex to a three-
 * dimensional value.
 */ 2 4 this 3 2092  3 pos 1 2213  
190 0 0 4 225 2142 0 0 99 /**
 * Sets the vertex position.  This variant sets the vertex to a four-
 * dimensional value.
 */ 2 4 this 3 2092  3 pos 1 2214  
191 0 0 4 225 2142 0 0 98 /**
 * Sets the vertex position.  This variant sets the vertex to a one-
 * dimensional value.
 */ 2 4 this 3 2092  3 pos 1 2013  
192 0 0 4 226 2142 0 0 319 /**
 * This special flavor of set_pos() sets the vertex as a four-component value,
 * but does not change the set number of dimensions.  It's handy for
 * retrieving the vertex position via get_pos4, manipulating it, then storing
 * it back again, without worrying about the number of dimensions it actually
 * had.
 */ 2 4 this 3 2092  3 pos 1 2214  
193 0 0 6 227 2010 0 0 368 // get_pos[123] return the pos as the corresponding type.  It is an error to
// call any of these without first verifying that get_num_dimensions()
// matches the desired type.  However, get_pos4() may always be called; it
// returns the pos as a four-component point in homogeneous space (with a
// 1.0 in the last position if the pos has fewer than four components). 1 4 this 3 2209  
194 0 0 6 228 2013 0 0 108 /**
 * Only valid if get_num_dimensions() returns 1. Returns the position as a
 * one-dimensional value.
 */ 1 4 this 3 2209  
195 0 0 7 229 2217 0 0 108 /**
 * Only valid if get_num_dimensions() returns 2. Returns the position as a
 * two-dimensional value.
 */ 1 4 this 3 2209  
196 0 0 7 230 2219 0 0 110 /**
 * Valid if get_num_dimensions() returns 3 or 4. Returns the position as a
 * three-dimensional value.
 */ 1 4 this 3 2209  
197 0 0 7 231 2220 0 0 309 /**
 * This is always valid, regardless of the value of get_num_dimensions.  It
 * returns the position as a four-dimensional value.  If the pos has fewer
 * than four dimensions, this value represents the pos extended into four-
 * dimensional homogenous space, e.g.  by adding 1 as the fourth component.
 */ 1 4 this 3 2209  
198 0 0 6 232 2055 0 0 272 /**
 * Returns true if the vertex has an unnamed UV coordinate pair, false
 * otherwise.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see has_uv(name) for the interface that supports
 * multitexturing.
 */ 1 4 this 3 2209  
199 0 0 6 232 2055 0 0 132 /**
 * Returns true if the vertex has the named UV coordinate pair, and the named
 * UV coordinate pair is 2-d, false otherwise.
 */ 2 4 this 3 2209  4 name 1 2146  
200 0 0 7 233 2201 0 0 308 /**
 * Returns the unnamed UV coordinate pair on the vertex.  It is an error to
 * call this if has_uv() has returned false.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see get_uv(name) for the interface that supports
 * multitexturing.
 */ 1 4 this 3 2209  
201 0 0 7 233 2201 0 0 126 /**
 * Returns the named UV coordinate pair on the vertex.  It is an error to call
 * this if has_uv(name) returned false.
 */ 2 4 this 3 2209  4 name 1 2146  
202 0 0 4 234 2142 0 0 277 /**
 * Replaces the unnamed UV coordinate pair on the vertex with the indicated
 * value.
 *
 * This is the more restrictive interface, and is generally useful only in the
 * absence of multitexturing; see set_uv(name, uv) for the interface that
 * supports multitexturing.
 */ 2 4 this 3 2092  8 texCoord 1 2197  
203 0 0 4 234 2142 0 0 174 /**
 * Sets the indicated UV coordinate pair on the vertex.  This replaces any UV
 * coordinate pair with the same name already on the vertex, but preserves UV
 * morphs.
 */ 3 4 this 3 2092  4 name 1 2146  8 texCoord 1 2197  
204 0 0 4 235 2142 0 0 59 /**
 * Removes all UV coordinate pairs from the vertex.
 */ 1 4 this 3 2092  
205 0 0 4 235 2142 0 0 93 /**
 * Removes the named UV coordinate pair from the vertex, along with any UV
 * morphs.
 */ 2 4 this 3 2092  4 name 1 2146  
206 0 0 6 236 2055 0 0 136 /**
 * Returns true if the vertex has the named UV coordinate triple, and the
 * named UV coordinate triple is 3-d, false otherwise.
 */ 2 4 this 3 2209  4 name 1 2146  
207 0 0 6 237 2194 0 0 129 /**
 * Returns the named UV coordinate triple on the vertex.  It is an error to
 * call this if has_uvw(name) returned false.
 */ 2 4 this 3 2209  4 name 1 2146  
208 0 0 4 238 2142 0 0 186 /**
 * Sets the indicated UV coordinate triple on the vertex.  This replaces any
 * UV coordinate pair or triple with the same name already on the vertex, but
 * preserves UV morphs.
 */ 3 4 this 3 2092  4 name 1 2146  8 texCoord 1 2194  
209 0 0 7 239 2191 0 0 298 /**
 * Returns the named EggVertexUV object, which defines both the UV coordinate
 * pair for this name and the UV morphs.  This object might be shared between
 * multiple vertices.  You should not attempt to modify this object; instead,
 * call modify_uv_object to return a modifiable pointer.
 */ 2 4 this 3 2209  4 name 1 2146  
210 0 0 7 240 2193 1024 0 204 /**
 * Returns a modifiable pointer to the named EggVertexUV object, which defines
 * both the UV coordinate pair for this name and the UV morphs.  Returns NULL
 * if there is no such named UV object.
 */ 2 4 this 3 2092  4 name 1 2146  
211 0 0 4 241 2142 0 0 163 /**
 * Sets the indicated EggVertexUV on the vertex.  This replaces any UV
 * coordinate pair with the same name already on the vertex, including UV
 * morphs.
 */ 2 4 this 3 2092  9 vertex_uv 1 2193  
212 0 0 6 242 2055 0 0 78 /**
 * Returns true if the vertex has any auxiliary data, false otherwise.
 */ 1 4 this 3 2209  
213 0 0 6 242 2055 0 0 77 /**
 * Returns true if the vertex has the named auxiliary data quadruple.
 */ 2 4 this 3 2209  4 name 1 2146  
214 0 0 4 243 2142 0 0 54 /**
 * Removes all auxiliary data from the vertex.
 */ 1 4 this 3 2092  
215 0 0 4 243 2142 0 0 60 /**
 * Removes the named auxiliary data from the vertex.
 */ 2 4 this 3 2092  4 name 1 2146  
216 0 0 6 244 2204 0 0 133 /**
 * Returns the named auxiliary data quadruple on the vertex.  It is an error
 * to call this if has_aux(name) returned false.
 */ 2 4 this 3 2209  4 name 1 2146  
217 0 0 4 245 2142 0 0 148 /**
 * Sets the indicated auxiliary data quadruple on the vertex.  This replaces
 * any auxiliary data with the same name already on the vertex.
 */ 3 4 this 3 2092  4 name 1 2146  3 aux 1 2204  
218 0 0 7 246 2206 0 0 273 /**
 * Returns the named EggVertexAux object, which defines the auxiliary data for
 * this name.  This object might be shared between multiple vertices.  You
 * should not attempt to modify this object; instead, call modify_aux_object
 * to return a modifiable pointer.
 */ 2 4 this 3 2209  4 name 1 2146  
219 0 0 7 247 2208 1024 0 178 /**
 * Returns a modifiable pointer to the named EggVertexAux object, which
 * defines the auxiliary data for this name.  Returns NULL if there is no such
 * named UV object.
 */ 2 4 this 3 2092  4 name 1 2146  
220 0 0 4 248 2142 0 0 136 /**
 * Sets the indicated EggVertexAux on the vertex.  This replaces any auxiliary
 * data with the same name already on the vertex.
 */ 2 4 this 3 2092  10 vertex_aux 1 2208  
221 0 0 7 249 2092 1192 0 284 /**
 * Creates a new vertex that lies in between the two given vertices.  The
 * attributes for the UV sets they have in common are averaged.
 *
 * Both vertices need to be either in no pool, or in the same pool.  In the
 * latter case, the new vertex will be placed in that pool.
 */ 2 5 first 1 2209  6 second 1 2209  
222 0 0 6 250 2010 0 0 66 /**
 * Returns the index number of the vertex within its pool.
 */ 1 4 this 3 2209  
223 0 0 4 251 2142 0 0 486 /**
 * Sets a special index number that is associated with the EggVertex (but is
 * not written to the egg file). This number is not interpreted by any egg
 * code; it is simply maintained along with the vertex.  It *is* used to
 * differentiate otherwise identical vertices in
 * EggVertexPool::create_unique_vertex(), however.
 *
 * The intention of this number is as an aid for file converters, to associate
 * an EggVertex back to the index number of the original source vertex.
 */ 2 4 this 3 2092  14 external_index 1 2010  
224 0 0 6 252 2010 0 0 85 /**
 * Returns the number set by set_external_index().  See set_external_index().
 */ 1 4 this 3 2209  
225 0 0 4 253 2142 0 0 225 /**
 * Similar to set_external_index(), but this is a different number which may
 * be used for a different purpose by the calling code.  The egg library does
 * not assign any meaning to this number or use it in any way.
 */ 2 4 this 3 2092  15 external_index2 1 2010  
226 0 0 6 254 2010 0 0 90 /**
 * Returns the number set by set_external_index2().  See
 * set_external_index2().
 */ 1 4 this 3 2209  
227 0 0 4 255 2142 0 0 74 /**
 * Writes the vertex to the indicated output stream in Egg format.
 */ 3 4 this 3 2209  3 out 1 2147  12 indent_level 1 2010  
228 0 0 6 256 2055 0 0 149 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 */ 2 4 this 3 2209  5 other 1 2209  
229 0 0 6 257 2010 0 0 746 /**
 * An ordering operator to compare two vertices for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique vertices.
 *
 * Group membership is not considered in this comparison.  This is somewhat
 * problematic, but cannot easily be helped, because considering group
 * membership would make it difficult to add and remove groups from vertices.
 * It also makes it impossible to meaningfully compare with a concrete
 * EggVertex object (which cannot have group memberships).
 *
 * However, this is not altogether bad, because two vertices that are
 * identical in all other properties should generally also be identical in
 * group memberships, else the vertices will tend to fly apart when the joints
 * animate.
 */ 2 4 this 3 2209  5 other 1 2209  
230 0 0 6 258 2010 0 0 134 /**
 * Returns the number of primitives that own this vertex whose vertices are
 * interpreted to be in a local coordinate system.
 */ 1 4 this 3 2209  
231 0 0 6 259 2010 0 0 131 /**
 * Returns the number of primitives that own this vertex whose vertices are
 * interpreted in the global coordinate system.
 */ 1 4 this 3 2209  
232 0 0 4 260 2142 0 0 69 /**
 * Applies the indicated transformation matrix to the vertex.
 */ 2 4 this 3 2092  3 mat 1 2153  
233 0 0 6 261 2055 0 0 90 /**
 * Returns true if the indicated group references this vertex, false
 * otherwise.
 */ 2 4 this 3 2209  5 group 1 2221  
234 0 0 4 262 2142 0 0 406 /**
 * Copies all the group references from the other vertex onto this one.  This
 * assigns the current vertex to exactly the same groups, with exactly the
 * same memberships, as the given one.
 *
 * Warning: only an EggVertex allocated from the free store may have groups
 * assigned to it.  Do not attempt to call this on a temporary concrete
 * EggVertex object; a core dump will certainly result.
 */ 2 4 this 3 2092  5 other 1 2209  
235 0 0 4 263 2142 0 0 100 /**
 * Removes all group references from the vertex, so that it is not assigned to
 * any group.
 */ 1 4 this 3 2092  
236 0 0 6 264 2010 0 0 116 /**
 * Returns the number of times the vertex appears in the indicated primitive,
 * or 0 if it does not appear.
 */ 2 4 this 3 2209  4 prim 1 2223  
237 0 0 4 265 2142 0 0 0 1 4 this 3 2209  
238 0 0 4 266 2142 0 0 0 1 4 this 3 2209  
239 0 0 4 267 2142 0 0 10 /**
 *
 */ 2 4 this 3 2209  3 out 1 2147  
240 0 0 7 272 2138 0 0 0 0 
241 0 0 7 216 2139 0 0 0 1 4 this 3 2092  
242 0 0 6 218 2095 0 0 0 1 4 this 3 2092  
243 0 0 15 274 2093 1102 0 198 /**
 * Copying a vertex pool is of questionable value, since it will copy all of
 * the vertices and assign new pointers to them all.  There will be no
 * polygons referring to the new vertices.
 */ 1 4 copy 1 2225  
244 0 0 7 274 2093 1102 0 10 /**
 *
 */ 1 4 name 1 2146  
245 0 0 6 275 2055 0 0 147 /**
 * Returns true if the indicated vertex has been defined in the vertex pool,
 * false otherwise.  This does not include forward references.
 */ 2 4 this 3 2225  5 index 1 2010  
246 0 0 6 276 2055 0 0 131 /**
 * Returns true if any vertices in the pool are undefined forward-reference
 * vertices, false if all vertices are defined.
 */ 1 4 this 3 2225  
247 0 0 6 277 2055 0 0 128 /**
 * Returns true if any vertices in the pool are fully defined vertices, false
 * if all vertices are forward references.
 */ 1 4 this 3 2225  
248 0 0 7 278 2092 1192 0 124 /**
 * Returns the vertex in the pool with the indicated index number, or NULL if
 * no vertices have that index number.
 */ 2 4 this 3 2225  5 index 1 2010  
249 0 0 7 279 2092 1192 0 124 /**
 * Returns the vertex in the pool with the indicated index number, or NULL if
 * no vertices have that index number.
 */ 2 4 this 3 2225  5 index 1 2010  
250 0 0 7 280 2092 1192 0 327 /**
 * Returns the vertex in the pool with the indicated index number.  If there
 * is not a vertex in the pool with the indicated index number, creates a
 * special forward-reference EggVertex that has no data, on the assumption
 * that the vertex pool has not yet been fully read and more data will be
 * available later.
 */ 2 4 this 3 2093  5 index 1 2010  
251 0 0 6 281 2010 0 0 140 /**
 * Returns the highest index number used by any vertex in the pool (except
 * forward references).  Returns -1 if the pool is empty.
 */ 1 4 this 3 2225  
252 0 0 4 282 2142 0 0 276 /**
 * Artificially changes the "highest index number", so that a newly created
 * vertex will begin at this number plus 1.  This can be used to default a
 * vertex pool to start counting at 1 (or any other index number), instead of
 * the default of 0.  Use with caution.
 */ 2 4 this 3 2093  13 highest_index 1 2010  
253 0 0 6 283 2010 0 0 83 /**
 * Returns the maximum number of dimensions used by any vertex in the pool.
 */ 1 4 this 3 2225  
254 0 0 6 284 2055 0 0 100 /**
 * Returns true if any vertex in the pool has a normal defined, false if none
 * of them do.
 */ 1 4 this 3 2225  
255 0 0 6 285 2055 0 0 99 /**
 * Returns true if any vertex in the pool has a color defined, false if none
 * of them do.
 */ 1 4 this 3 2225  
256 0 0 6 286 2055 0 0 152 /**
 * Returns true if any vertex in the pool has a color defined other than
 * white, false if no vertices have colors, or if all colors are white.
 */ 1 4 this 3 2225  
257 0 0 6 288 2055 0 0 96 /**
 * Returns true if any vertex in the pool has a uv defined, false if none of
 * them do.
 */ 1 4 this 3 2225  
258 0 0 6 289 2055 0 0 106 /**
 * Returns true if any vertex in the pool has auxiliary data defined, false if
 * none of them do.
 */ 1 4 this 3 2225  
259 0 0 4 290 2142 0 0 351 /**
 * Returns the list of UV names that are defined by any vertices in the pool,
 * as well as the subset of UV names that actually define 3-d texture
 * coordinates ("uvw_names").  Also returns the subset of UV/UVW names that
 * define a tangent and binormal.  It is the user's responsibility to clear
 * both vectors before calling this method.
 */ 4 4 this 3 2225  8 uv_names 1 2156  9 uvw_names 1 2156  9 tbn_names 1 2156  
260 0 0 4 291 2142 0 0 100 /**
 * Returns the list of auxiliary data names that are defined by any vertices
 * in the pool.
 */ 2 4 this 3 2225  9 aux_names 1 2156  
261 0 0 6 292 2227 0 0 54 /**
 * Returns the number of vertices in the pool.
 */ 1 4 this 3 2225  
262 0 0 7 293 2092 1192 0 809 /**
 * Adds the indicated vertex to the pool.  It is an error if the vertex is
 * already a member of this or any other pool.  The vertex must have been
 * allocated from the free store; its pointer will now be owned by the vertex
 * pool.  If the index number is supplied, tries to assign that index number;
 * it is an error if the index number is already in use.
 *
 * It is possible that a forward reference to this vertex was requested in the
 * past; if so, the data from the supplied vertex is copied onto the forward
 * reference, which becomes the actual vertex.  In this case, a different
 * pointer is saved (and returned) than the one actually passed in.  In the
 * usual case, however, the vertex pointer passed in is the one that is saved
 * in the vertex pool and returned from this method.
 */ 3 4 this 3 2093  6 vertex 1 2092  5 index 5 2010  
263 0 0 7 294 2092 1192 0 128 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 */ 1 4 this 3 2093  
264 0 0 7 294 2092 1192 0 266 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */ 2 4 this 3 2093  3 pos 1 2211  
265 0 0 7 294 2092 1192 0 266 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */ 2 4 this 3 2093  3 pos 1 2213  
266 0 0 7 294 2092 1192 0 266 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */ 2 4 this 3 2093  3 pos 1 2214  
267 0 0 7 294 2092 1192 0 266 /**
 * Allocates and returns a new vertex from the pool.  This is one of three
 * ways to add new vertices to a vertex pool.
 *
 * This flavor of make_new_vertex() explicitly sets the vertex position as it
 * is allocated.  It does not attempt to share vertices.
 */ 2 4 this 3 2093  3 pos 1 2013  
268 0 0 7 295 2092 1192 0 192 /**
 * Creates a new vertex in the pool that is a copy of the indicated one and
 * returns it.  If there is already a vertex in the pool like the indicated
 * one, simply returns that one.
 */ 2 4 this 3 2093  4 copy 1 2209  
269 0 0 7 296 2092 1192 0 212 /**
 * If the EggVertexPool already has a vertex matching the indicated vertex,
 * returns it; otherwise, returns NULL.  This is similar to
 * create_unique_vertex() except that a new vertex is never created.
 */ 2 4 this 3 2093  4 copy 1 2209  
270 0 0 4 297 2142 0 0 114 /**
 * Removes the vertex from the pool.  It is an error if the vertex is not
 * already a member of the pool.
 */ 2 4 this 3 2093  6 vertex 1 2092  
271 0 0 6 298 2010 0 0 292 /**
 * Removes all vertices from the pool that are not referenced by at least one
 * primitive.  Also collapses together equivalent vertices, and renumbers all
 * vertices after the operation so their indices are consecutive, beginning at
 * zero.  Returns the number of vertices removed.
 */ 1 4 this 3 2093  
272 0 0 4 299 2142 0 0 113 /**
 * Adds all of the unused vertices in this vertex pool to the indicated
 * primitive, in ascending order.
 */ 2 4 this 3 2093  4 prim 1 2228  
273 0 0 4 300 2142 0 0 419 /**
 * Applies the indicated transformation matrix to all the vertices.  However,
 * vertices that are attached to primitives that believe their vertices are in
 * a local coordinate system are transformed only by the scale and rotation
 * component.  If a vertex happens to be attached both to a local and a global
 * primitive, and the transformation includes a translation component, the
 * vertex will be split.
 */ 2 4 this 3 2093  3 mat 1 2153  
274 0 0 4 301 2142 0 0 186 /**
 * Re-orders (and re-numbers) the vertices in this vertex pool so that they
 * appear in increasing order by the optional external_index that has been
 * assigned to each vertex.
 */ 1 4 this 3 2093  
275 0 0 7 302 2138 0 0 0 0 
276 0 0 7 304 2159 1300 0 10 /**
 *
 */ 0 
277 0 0 15 304 2159 1300 0 10 /**
 *
 */ 1 4 copy 1 2229  
278 0 0 6 305 2159 0 0 10 /**
 *
 */ 2 4 this 3 2159  4 copy 1 2229  
279 0 0 4 306 2142 0 0 78 /**
 * Writes the attributes to the indicated output stream in Egg format.
 */ 3 4 this 3 2229  3 out 1 2147  12 indent_level 1 2010  
280 0 0 4 311 2142 0 0 500 /**
 * Specifies precisely how the transparency for this geometry should be
 * achieved, or if it should be used.  The default, AM_unspecified, is to use
 * transparency if the geometry has a color whose alpha value is non-1, or if
 * it has a four-channel texture applied; otherwise, AM_on forces transparency
 * on, and AM_off forces it off.  The other flavors of transparency are
 * specific ways to turn on transparency, which may or may not be supported by
 * a particular rendering backend.
 */ 2 4 this 3 2159  4 mode 1 2029  
281 0 0 6 312 2029 0 0 110 /**
 * Returns the alpha mode that was set, or AM_unspecified if nothing was set.
 * See set_alpha_mode().
 */ 1 4 this 3 2229  
282 0 0 4 313 2142 0 0 160 /**
 * Specifies whether writes should be made to the depth buffer (assuming the
 * rendering backend provides a depth buffer) when rendering this geometry.
 */ 2 4 this 3 2159  4 mode 1 2030  
283 0 0 6 314 2030 0 0 124 /**
 * Returns the depth_write mode that was set, or DWM_unspecified if nothing
 * was set.  See set_depth_write_mode().
 */ 1 4 this 3 2229  
284 0 0 4 315 2142 0 0 238 /**
 * Specifies whether this geometry should be tested against the depth buffer
 * when it is drawn (assuming the rendering backend provides a depth buffer).
 * Note that this is different, and independent from, the depth_write mode.
 */ 2 4 this 3 2159  4 mode 1 2031  
285 0 0 6 316 2031 0 0 122 /**
 * Returns the depth_test mode that was set, or DTM_unspecified if nothing was
 * set.  See set_depth_test_mode().
 */ 1 4 this 3 2229  
286 0 0 4 317 2142 0 0 252 /**
 * Specifies whether this geometry is to be considered normally visible, or
 * hidden.  If it is hidden, it is either not loaded into the scene graph at
 * all, or loaded as a "stashed" node, according to the setting of egg-
 * suppress-hidden.
 */ 2 4 this 3 2159  4 mode 1 2032  
287 0 0 6 318 2032 0 0 121 /**
 * Returns the visibility mode that was set, or VM_unspecified if nothing was
 * set.  See set_visibility_mode().
 */ 1 4 this 3 2229  
288 0 0 4 319 2142 0 0 198 /**
 * Sets the "depth-offset" flag associated with this object.  This adds or
 * subtracts an offset bias into the depth buffer.  See also DepthOffsetAttrib
 * and NodePath::set_depth_offset().
 */ 2 4 this 3 2159  4 bias 1 2010  
289 0 0 6 320 2010 0 0 105 /**
 * Returns the "depth-offset" flag as set for this particular object.  See
 * set_depth_offset().
 */ 1 4 this 3 2229  
290 0 0 6 321 2055 0 0 117 /**
 * Returns true if the depth-offset flag has been set for this particular
 * object.  See set_depth_offset().
 */ 1 4 this 3 2229  
291 0 0 4 322 2142 0 0 97 /**
 * Removes the depth-offset flag from this particular object.  See
 * set_depth_offset().
 */ 1 4 this 3 2159  
292 0 0 4 323 2142 0 0 260 /**
 * Sets the "draw-order" flag associated with this object.  This specifies a
 * particular order in which objects of this type should be drawn, within the
 * specified bin.  If a bin is not explicitly specified, "fixed" is used.  See
 * also set_bin().
 */ 2 4 this 3 2159  5 order 1 2010  
293 0 0 6 324 2010 0 0 101 /**
 * Returns the "draw-order" flag as set for this particular object.  See
 * set_draw_order().
 */ 1 4 this 3 2229  
294 0 0 6 325 2055 0 0 113 /**
 * Returns true if the draw-order flag has been set for this particular
 * object.  See set_draw_order().
 */ 1 4 this 3 2229  
295 0 0 4 326 2142 0 0 93 /**
 * Removes the draw-order flag from this particular object.  See
 * set_draw_order().
 */ 1 4 this 3 2159  
296 0 0 4 327 2142 0 0 378 /**
 * Sets the "bin" string for this particular object.  This names a particular
 * bin in which the object should be rendered.  The exact meaning of a bin is
 * implementation defined, but generally a GeomBin matching each bin name must
 * also be specifically added to the rendering engine (e.g.  the
 * CullTraverser) in use for this to work.  See also set_draw_order().
 */ 2 4 this 3 2159  3 bin 1 2146  
297 0 0 6 328 2146 0 0 103 /**
 * Returns the bin name that has been set for this particular object, if any.
 * See set_bin().
 */ 1 4 this 3 2229  
298 0 0 6 329 2055 0 0 97 /**
 * Returns true if a bin name has been set for this particular object.  See
 * set_bin().
 */ 1 4 this 3 2229  
299 0 0 4 330 2142 0 0 91 /**
 * Removes the bin name that was set for this particular object.  See
 * set_bin().
 */ 1 4 this 3 2159  
300 0 0 6 331 2055 0 0 34 // Comparison operators are handy. 2 4 this 3 2229  5 other 1 2229  
301 0 0 6 332 2055 0 0 0 2 4 this 3 2229  5 other 1 2229  
302 0 0 6 333 2055 0 0 0 2 4 this 3 2229  5 other 1 2229  
303 0 0 6 334 2029 0 0 167 /**
 * Returns the AlphaMode value associated with the given string
 * representation, or AM_unspecified if the string does not match any known
 * AlphaMode value.
 */ 1 6 string 1 2146  
304 0 0 6 335 2030 0 0 178 /**
 * Returns the DepthWriteMode value associated with the given string
 * representation, or DWM_unspecified if the string does not match any known
 * DepthWriteMode value.
 */ 1 6 string 1 2146  
305 0 0 6 336 2031 0 0 176 /**
 * Returns the DepthTestMode value associated with the given string
 * representation, or DTM_unspecified if the string does not match any known
 * DepthTestMode value.
 */ 1 6 string 1 2146  
306 0 0 6 337 2032 0 0 169 /**
 * Returns the HiddenMode value associated with the given string
 * representation, or VM_unspecified if the string does not match any known
 * HiddenMode value.
 */ 1 6 string 1 2146  
307 0 0 7 338 2138 0 0 0 0 
308 0 0 7 343 2231 1305 0 10 /**
 *
 */ 0 
309 0 0 15 343 2231 1305 0 10 /**
 *
 */ 1 4 copy 1 2232  
310 0 0 6 344 2231 0 0 10 /**
 *
 */ 2 4 this 3 2231  4 copy 1 2232  
311 0 0 4 346 2142 0 0 51 /**
 * Resets the transform to empty, identity.
 */ 1 4 this 3 2231  
312 0 0 4 347 2142 0 0 72 /**
 * Appends a 2-d translation operation to the current transform.
 */ 2 4 this 3 2231  9 translate 1 2173  
313 0 0 4 348 2142 0 0 72 /**
 * Appends a 3-d translation operation to the current transform.
 */ 2 4 this 3 2231  9 translate 1 2233  
314 0 0 4 349 2142 0 0 141 /**
 * Appends a 2-d rotation to the current transform.  The rotation angle is
 * specified in degrees counterclockwise about the origin.
 */ 2 4 this 3 2231  5 angle 1 2013  
315 0 0 4 350 2142 0 0 152 /**
 * Appends a rotation about the X axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */ 2 4 this 3 2231  5 angle 1 2013  
316 0 0 4 351 2142 0 0 152 /**
 * Appends a rotation about the Y axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */ 2 4 this 3 2231  5 angle 1 2013  
317 0 0 4 352 2142 0 0 152 /**
 * Appends a rotation about the Z axis to the current transform.  The rotation
 * angle is specified in degrees counterclockwise about the axis.
 */ 2 4 this 3 2231  5 angle 1 2013  
318 0 0 4 353 2142 0 0 160 /**
 * Appends an arbitrary 3-d rotation to the current transform, expressed as a
 * quaternion.  This is converted to axis-angle notation for the egg file.
 */ 2 4 this 3 2231  4 quat 1 2235  
319 0 0 4 353 2142 0 0 162 /**
 * Appends a 3-d rotation about an arbitrary axis to the current transform.
 * The rotation angle is specified in degrees counterclockwise about the axis.
 */ 3 4 this 3 2231  5 angle 1 2013  4 axis 1 2233  
320 0 0 4 354 2142 0 0 73 /**
 * Appends a possibly non-uniform scale to the current transform.
 */ 2 4 this 3 2231  5 scale 1 2238  
321 0 0 4 355 2142 0 0 73 /**
 * Appends a possibly non-uniform scale to the current transform.
 */ 2 4 this 3 2231  5 scale 1 2241  
322 0 0 4 356 2142 0 0 60 /**
 * Appends a uniform scale to the current transform.
 */ 2 4 this 3 2231  5 scale 1 2013  
323 0 0 4 357 2142 0 0 68 /**
 * Appends an arbitrary 3x3 matrix to the current transform.
 */ 2 4 this 3 2231  3 mat 1 2244  
324 0 0 4 358 2142 0 0 68 /**
 * Appends an arbitrary 4x4 matrix to the current transform.
 */ 2 4 this 3 2231  3 mat 1 2153  
325 0 0 6 359 2055 0 0 174 /**
 * Returns true if the transform is nonempty, false if it is empty (no
 * transform components have been added).  This is true for either a 2-d or a
 * 3-d transform.
 */ 1 4 this 3 2232  
326 0 0 6 360 2055 0 0 328 /**
 * Returns true if the transform is specified as a 2-d transform, e.g.  with a
 * 3x3 matrix, or false if it is specified as a 3-d transform (with a 4x4
 * matrix), or not specified at all.
 *
 * Normally, EggTextures have a 2-d matrix (but occasionally they use a 3-d
 * matrix), and EggGroups always have a 3-d matrix.
 */ 1 4 this 3 2232  
327 0 0 4 361 2142 0 0 139 /**
 * Sets the overall transform as a 3x3 matrix.  This completely replaces
 * whatever componentwise transform may have been defined.
 */ 2 4 this 3 2231  3 mat 1 2244  
328 0 0 6 362 2055 0 0 328 /**
 * Returns true if the transform is specified as a 3-d transform, e.g.  with a
 * 4x4 matrix, or false if it is specified as a 2-d transform (with a 2x2
 * matrix), or not specified at all.
 *
 * Normally, EggTextures have a 3-d matrix (but occasionally they use a 3-d
 * matrix), and EggGroups always have a 3-d matrix.
 */ 1 4 this 3 2232  
329 0 0 4 363 2142 0 0 139 /**
 * Sets the overall transform as a 4x4 matrix.  This completely replaces
 * whatever componentwise transform may have been defined.
 */ 2 4 this 3 2231  3 mat 1 2153  
330 0 0 7 364 2247 0 0 119 /**
 * Returns the overall transform as a 3x3 matrix.  It is an error to call this
 * if has_transform3d() is true.
 */ 1 4 this 3 2232  
331 0 0 6 365 2153 0 0 190 /**
 * Returns the overall transform as a 4x4 matrix.  It is valid to call this
 * even if has_transform2d() is true; in this case, the 3x3 transform will be
 * expanded to a 4x4 matrix.
 */ 1 4 this 3 2232  
332 0 0 6 366 2055 0 0 80 /**
 * Returns true if the described transform is identity, false otherwise.
 */ 1 4 this 3 2232  
333 0 0 6 368 2010 0 0 71 /**
 * Returns the number of components that make up the transform.
 */ 1 4 this 3 2232  
334 0 0 6 369 2034 0 0 49 /**
 * Returns the type of the nth component.
 */ 2 4 this 3 2232  1 n 1 2010  
335 0 0 6 370 2013 0 0 252 /**
 * Returns the solitary number associated with the nth component.  In the case
 * of a rotation, this is the angle in degrees to rotate; in the case of
 * uniform scale, this is the amount of the scale.  Other types do not use
 * this property.
 */ 2 4 this 3 2232  1 n 1 2010  
336 0 0 6 371 2238 0 0 239 /**
 * Returns the 2-component vector associated with the nth component.  This may
 * be the translate vector, rotate axis, or non-uniform scale.  It is an error
 * to call this if the component type does not use a 2-d vector property.
 */ 2 4 this 3 2232  1 n 1 2010  
337 0 0 6 372 2241 0 0 239 /**
 * Returns the 3-component vector associated with the nth component.  This may
 * be the translate vector, rotate axis, or non-uniform scale.  It is an error
 * to call this if the component type does not use a 3-d vector property.
 */ 2 4 this 3 2232  1 n 1 2010  
338 0 0 6 373 2244 0 0 141 /**
 * Returns the 3x3 matrix associated with the nth component.  It is an error
 * to call this if the component type is not CT_matrix3.
 */ 2 4 this 3 2232  1 n 1 2010  
339 0 0 6 374 2153 0 0 141 /**
 * Returns the 4x4 matrix associated with the nth component.  It is an error
 * to call this if the component type is not CT_matrix4.
 */ 2 4 this 3 2232  1 n 1 2010  
340 0 0 4 375 2142 0 0 70 /**
 * Writes the transform to the indicated stream in Egg format.
 */ 4 4 this 3 2232  3 out 1 2147  12 indent_level 1 2010  5 label 1 2146  
341 0 0 6 341 2190 0 0 0 1 4 this 3 2231  
342 0 0 7 377 2249 1339 0 0 1 4 this 3 2248  
343 0 0 4 378 2142 0 0 0 3 4 this 3 2248  3 out 1 2147  12 indent_level 1 2010  
344 0 0 4 379 2142 0 0 0 2 4 this 3 2249  3 mat 1 2153  
345 0 0 7 380 2138 0 0 0 0 
346 0 0 7 383 2250 1342 0 10 /**
 *
 */ 4 9 switch_in 1 2013  10 switch_out 1 2013  6 center 1 2213  4 fade 5 2013  
347 0 0 7 384 2138 0 0 0 0 
348 0 0 15 405 2251 1351 0 10 /**
 *
 */ 1 4 copy 1 2221  
349 0 0 7 405 2251 1351 0 10 /**
 *
 */ 1 4 name 5 2146  
350 0 0 7 406 2251 1351 0 10 /**
 *
 */ 2 4 this 3 2251  4 copy 1 2221  
351 0 0 4 408 2142 0 0 100 /**
 * Writes the group and all of its children to the indicated output stream in
 * Egg format.
 */ 3 4 this 3 2221  3 out 1 2147  12 indent_level 1 2010  
352 0 0 4 409 2142 0 0 92 /**
 * Writes just the <Billboard> entry and related fields to the indicated
 * ostream.
 */ 3 4 this 3 2221  3 out 1 2147  12 indent_level 1 2010  
353 0 0 4 410 2142 0 0 90 /**
 * Writes just the <Collide> entry and related fields to the indicated
 * ostream.
 */ 3 4 this 3 2221  3 out 1 2147  12 indent_level 1 2010  
354 0 0 4 411 2142 0 0 78 /**
 * Writes the <Model> flag and related flags to the indicated ostream.
 */ 3 4 this 3 2221  3 out 1 2147  12 indent_level 1 2010  
355 0 0 4 412 2142 0 0 79 /**
 * Writes the <Switch> flag and related flags to the indicated ostream.
 */ 3 4 this 3 2221  3 out 1 2147  12 indent_level 1 2010  
356 0 0 4 413 2142 0 0 83 /**
 * Writes just the <ObjectTypes> entries, if any, to the indicated ostream.
 */ 3 4 this 3 2221  3 out 1 2147  12 indent_level 1 2010  
357 0 0 4 414 2142 0 0 56 /**
 * Writes the flags related to decaling, if any.
 */ 3 4 this 3 2221  3 out 1 2147  12 indent_level 1 2010  
358 0 0 4 415 2142 0 0 75 /**
 * Writes just the <Tag> entries, if any, to the indicated ostream.
 */ 3 4 this 3 2221  3 out 1 2147  12 indent_level 1 2010  
359 0 0 4 416 2142 0 0 114 /**
 * Writes the flags inherited from EggRenderMode and similar flags that
 * control obscure render effects.
 */ 3 4 this 3 2221  3 out 1 2147  12 indent_level 1 2010  
360 0 0 6 417 2055 0 0 229 /**
 * Returns true if this particular node represents a <Joint> entry or not.
 * This is a handy thing to know since Joints are sorted to the end of their
 * sibling list when writing an egg file.  See EggGroupNode::write().
 */ 1 4 this 3 2221  
361 0 0 6 418 2159 0 0 267 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has an alpha_mode
 * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */ 1 4 this 3 2251  
362 0 0 6 419 2159 0 0 273 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2251  
363 0 0 6 420 2159 0 0 272 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2251  
364 0 0 6 421 2159 0 0 271 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2251  
365 0 0 6 422 2159 0 0 252 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a depth_offset
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2251  
366 0 0 6 423 2159 0 0 250 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a draw_order
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2251  
367 0 0 6 424 2159 0 0 243 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this group that has a bin
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2251  
368 0 0 6 425 2055 0 0 321 /**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "indexed" scalar set.  Returns the value of the indexed scalar
 * if it is found, or false if it is not.
 *
 * In other words, returns true if the "indexed" flag is in effect for the
 * indicated node, false otherwise.
 */ 1 4 this 3 2251  
369 0 0 6 426 2055 0 0 311 /**
 * Walks back up the hierarchy, looking for an EggGroup at this level or above
 * that has the "decal" flag set.  Returns the value of the decal flag if it
 * is found, or false if it is not.
 *
 * In other words, returns true if the "decal" flag is in effect for the
 * indicated node, false otherwise.
 */ 1 4 this 3 2251  
370 0 0 4 427 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 type 1 2042  
371 0 0 6 428 2042 0 0 10 /**
 *
 */ 1 4 this 3 2221  
372 0 0 6 429 2055 0 0 368 /**
 * Returns true if this group is an instance type node; i.e.  it begins the
 * root of a local coordinate space.  This is not related to instancing
 * (multiple copies of a node in a scene graph).
 *
 * This also includes the case of the node including a billboard flag without
 * an explicit center, which implicitly makes the node behave like an
 * instance.
 */ 1 4 this 3 2221  
373 0 0 4 430 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 type 1 2044  
374 0 0 6 431 2044 0 0 10 /**
 *
 */ 1 4 this 3 2221  
375 0 0 4 432 2142 0 0 694 /**
 * Sets the point around which the billboard will rotate, if this node
 * contains a billboard specification.
 *
 * If a billboard type is given but no billboard_center is specified, then the
 * group node is treated as an <Instance>, and the billboard rotates around
 * the origin.  If, however, a billboard_center is specified, then the group
 * node is *not* treated as an <Instance>, and the billboard rotates around
 * the specified point.
 *
 * The point is in the same coordinate system as the vertices of this node:
 * usually global, but possibly local if there is an <Instance> somewhere
 * above.  Specifically, this is the coordinate system defined by
 * get_vertex_frame().
 */ 2 4 this 3 2251  16 billboard_center 1 2213  
376 0 0 4 433 2142 0 0 10 /**
 *
 */ 1 4 this 3 2251  
377 0 0 6 434 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
378 0 0 6 435 2213 0 0 10 /**
 *
 */ 1 4 this 3 2221  
379 0 0 4 436 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 type 1 2045  
380 0 0 6 437 2045 0 0 10 /**
 *
 */ 1 4 this 3 2221  
381 0 0 4 438 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  5 flags 1 2010  
382 0 0 6 439 2046 0 0 10 /**
 *
 */ 1 4 this 3 2221  
383 0 0 4 440 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  14 collision_name 1 2146  
384 0 0 4 441 2142 0 0 10 /**
 *
 */ 1 4 this 3 2251  
385 0 0 6 442 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
386 0 0 6 443 2146 0 0 10 /**
 *
 */ 1 4 this 3 2221  
387 0 0 4 444 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 type 1 2043  
388 0 0 6 445 2043 0 0 10 /**
 *
 */ 1 4 this 3 2221  
389 0 0 6 446 2055 0 0 91 /**
 * Returns true if the specified DCS type is not DC_none and not
 * DC_unspecified.
 */ 1 4 this 3 2221  
390 0 0 4 447 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 type 1 2047  
391 0 0 6 448 2047 0 0 10 /**
 *
 */ 1 4 this 3 2221  
392 0 0 4 449 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 flag 1 2055  
393 0 0 6 450 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
394 0 0 4 451 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  3 fps 1 2013  
395 0 0 6 452 2013 0 0 10 /**
 *
 */ 1 4 this 3 2221  
396 0 0 4 453 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  11 object_type 1 2146  
397 0 0 4 454 2142 0 0 10 /**
 *
 */ 1 4 this 3 2251  
398 0 0 6 455 2010 0 0 10 /**
 *
 */ 1 4 this 3 2221  
399 0 0 6 456 2146 0 0 10 /**
 *
 */ 2 4 this 3 2221  5 index 1 2010  
400 0 0 6 458 2055 0 0 104 /**
 * Returns true if the indicated object type has been added to the group, or
 * false otherwise.
 */ 2 4 this 3 2221  11 object_type 1 2146  
401 0 0 6 459 2055 0 0 178 /**
 * Removes the first instance of the indicated object type from the group if
 * it is present.  Returns true if the object type was found and removed,
 * false otherwise.
 */ 2 4 this 3 2251  11 object_type 1 2146  
402 0 0 4 460 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 flag 1 2055  
403 0 0 6 461 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
404 0 0 4 462 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 flag 1 2055  
405 0 0 6 463 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
406 0 0 4 464 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 flag 1 2055  
407 0 0 6 465 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
408 0 0 4 466 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 flag 1 2055  
409 0 0 6 467 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
410 0 0 4 468 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 flag 1 2055  
411 0 0 6 469 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
412 0 0 4 470 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 flag 1 2055  
413 0 0 6 471 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
414 0 0 4 472 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 flag 1 2055  
415 0 0 6 473 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
416 0 0 4 474 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 flag 1 2055  
417 0 0 6 475 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
418 0 0 4 476 2142 0 0 106 /**
 * If this flag is true, geometry at this node and below will be generated as
 * indexed geometry.
 */ 2 4 this 3 2251  4 flag 1 2055  
419 0 0 4 477 2142 0 0 10 /**
 *
 */ 1 4 this 3 2251  
420 0 0 6 478 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
421 0 0 6 479 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
422 0 0 4 480 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 mask 1 2252  
423 0 0 4 481 2142 0 0 10 /**
 *
 */ 1 4 this 3 2251  
424 0 0 6 482 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
425 0 0 7 483 2252 0 0 10 /**
 *
 */ 1 4 this 3 2221  
426 0 0 4 484 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 mask 1 2252  
427 0 0 4 485 2142 0 0 10 /**
 *
 */ 1 4 this 3 2251  
428 0 0 6 486 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
429 0 0 7 487 2252 0 0 10 /**
 *
 */ 1 4 this 3 2221  
430 0 0 4 488 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  4 mask 1 2252  
431 0 0 4 489 2142 0 0 10 /**
 *
 */ 1 4 this 3 2251  
432 0 0 6 490 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
433 0 0 7 491 2252 0 0 10 /**
 *
 */ 1 4 this 3 2221  
434 0 0 4 492 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  10 blend_mode 1 2048  
435 0 0 6 493 2048 0 0 10 /**
 *
 */ 1 4 this 3 2221  
436 0 0 4 494 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  15 blend_operand_a 1 2049  
437 0 0 6 495 2049 0 0 10 /**
 *
 */ 1 4 this 3 2221  
438 0 0 4 496 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  15 blend_operand_b 1 2049  
439 0 0 6 497 2049 0 0 10 /**
 *
 */ 1 4 this 3 2221  
440 0 0 4 498 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  11 blend_color 1 2189  
441 0 0 4 499 2142 0 0 49 /**
 * Removes the blend color specification.
 */ 1 4 this 3 2251  
442 0 0 6 500 2055 0 0 79 /**
 * Returns true if the blend color has been specified, false otherwise.
 */ 1 4 this 3 2221  
443 0 0 6 501 2189 0 0 96 /**
 * Returns the blend color if one has been specified, or (0, 0, 0, 0) if one
 * has not.
 */ 1 4 this 3 2221  
444 0 0 4 502 2142 0 0 10 /**
 *
 */ 2 4 this 3 2251  3 lod 1 2248  
445 0 0 4 503 2142 0 0 10 /**
 *
 */ 1 4 this 3 2251  
446 0 0 6 504 2055 0 0 10 /**
 *
 */ 1 4 this 3 2221  
447 0 0 7 505 2248 0 0 10 /**
 *
 */ 1 4 this 3 2221  
448 0 0 4 506 2142 0 0 524 /**
 * Associates a user-defined value with a user-defined key which is stored on
 * the node.  This value has no meaning to Panda; but it is stored
 * indefinitely on the node until it is requested again.  This value will be
 * copied to the PandaNode that is created for this particular EggGroup if the
 * egg file is loaded as a scene.
 *
 * Each unique key stores a different string value.  There is no effective
 * limit on the number of different keys that may be stored or on the length
 * of any one key's value.
 */ 3 4 this 3 2251  3 key 1 2146  5 value 1 2146  
449 0 0 6 507 2146 0 0 182 /**
 * Retrieves the user-defined value that was previously set on this node for
 * the particular key, if any.  If no value has been previously set, returns
 * the empty string.
 */ 2 4 this 3 2221  3 key 1 2146  
450 0 0 6 508 2055 0 0 170 /**
 * Returns true if a value has been defined on this node for the particular
 * key (even if that value is the empty string), or false if no value has been
 * set.
 */ 2 4 this 3 2221  3 key 1 2146  
451 0 0 4 509 2142 0 0 158 /**
 * Removes the value defined for this key on this particular node.  After a
 * call to clear_tag(), has_tag() will return false for the indicated key.
 */ 2 4 this 3 2251  3 key 1 2146  
452 0 0 6 510 2232 0 0 315 /**
 * Returns a read-only accessor to the initial pose transform.  This is the
 * <DefaultPose> entry for a Joint, and defines only the initial transform
 * pose for the unanimated joint; it has nothing to do with the group's
 * <Transform> entry, which defines the (eventual) space of the group's
 * vertices.
 */ 1 4 this 3 2221  
453 0 0 6 511 2231 0 0 314 /**
 * Returns a writable accessor to the initial pose transform.  This is the
 * <DefaultPose> entry for a Joint, and defines only the initial transform
 * pose for the unanimated joint; it has nothing to do with the group's
 * <Transform> entry, which defines the (eventual) space of the group's
 * vertices.
 */ 1 4 this 3 2251  
454 0 0 4 512 2142 0 0 289 /**
 * Replaces the initial pose transform.  This is the <DefaultPose> entry for a
 * Joint, and defines only the initial transform pose for the unanimated
 * joint; it has nothing to do with the group's <Transform> entry, which
 * defines the (eventual) space of the group's vertices.
 */ 2 4 this 3 2251  9 transform 1 2232  
455 0 0 4 513 2142 0 0 71 /**
 * Removes the initial pose transform.  See set_default_pose().
 */ 1 4 this 3 2251  
456 0 0 4 514 2142 0 0 0 2 4 this 3 2251  7 u_speed 1 2253  
457 0 0 4 515 2142 0 0 0 2 4 this 3 2251  7 v_speed 1 2253  
458 0 0 4 516 2142 0 0 0 2 4 this 3 2251  7 w_speed 1 2253  
459 0 0 4 517 2142 0 0 0 2 4 this 3 2251  7 r_speed 1 2253  
460 0 0 6 518 2013 0 0 0 1 4 this 3 2221  
461 0 0 6 519 2013 0 0 0 1 4 this 3 2221  
462 0 0 6 520 2013 0 0 0 1 4 this 3 2221  
463 0 0 6 521 2013 0 0 0 1 4 this 3 2221  
464 0 0 6 522 2055 0 0 0 1 4 this 3 2251  
465 0 0 4 570 2142 0 0 213 /**
 * Adds the vertex to the set of those referenced by the group, at the
 * indicated membership level.  If the vertex is already being referenced,
 * increases the membership amount by the indicated amount.
 */ 3 4 this 3 2251  4 vert 1 2092  10 membership 5 2013  
466 0 0 4 571 2142 0 0 130 /**
 * Removes the vertex from the set of those referenced by the group.  Does
 * nothing if the vertex is not already reffed.
 */ 2 4 this 3 2251  4 vert 1 2092  
467 0 0 4 572 2142 0 0 56 /**
 * Removes all vertices from the reference list.
 */ 1 4 this 3 2251  
468 0 0 6 573 2013 0 0 139 /**
 * Returns the amount of membership of the indicated vertex in this group.  If
 * the vertex is not reffed by the group, returns 0.
 */ 2 4 this 3 2221  4 vert 1 2209  
469 0 0 4 574 2142 0 0 106 /**
 * Explicitly sets the net membership of the indicated vertex in this group to
 * the given value.
 */ 3 4 this 3 2251  4 vert 1 2092  10 membership 1 2013  
470 0 0 4 575 2142 0 0 195 /**
 * Moves all of the vertex references from the indicated other group into this
 * one.  If a given vertex was previously shared by both groups, the relative
 * memberships will be summed.
 */ 2 4 this 3 2251  5 other 1 2251  
471 0 0 4 576 2142 0 0 0 1 4 this 3 2221  
472 0 0 4 577 2142 0 0 207 /**
 * Adds a new <Ref> entry to the group.  This declares an internal reference
 * to another node, and is used to implement scene-graph instancing; it is
 * only valid if the group_type is GT_instance.
 */ 2 4 this 3 2251  5 group 1 2251  
473 0 0 6 578 2010 0 0 90 /**
 * Returns the number of <Ref> entries within this group.  See
 * add_group_ref().
 */ 1 4 this 3 2221  
474 0 0 7 579 2251 1351 0 79 /**
 * Returns the nth <Ref> entry within this group.  See add_group_ref().
 */ 2 4 this 3 2221  1 n 1 2010  
475 0 0 4 581 2142 0 0 79 /**
 * Removes the nth <Ref> entry within this group.  See add_group_ref().
 */ 2 4 this 3 2251  1 n 1 2010  
476 0 0 4 582 2142 0 0 84 /**
 * Removes all of the <Ref> entries within this group.  See add_group_ref().
 */ 1 4 this 3 2251  
477 0 0 6 583 2042 0 0 163 /**
 * Returns the GroupType value associated with the given string
 * representation, or GT_invalid if the string does not match any known
 * GroupType value.
 */ 1 6 strval 1 2146  
478 0 0 6 584 2047 0 0 155 /**
 * Returns the DartType value associated with the given string representation,
 * or DT_none if the string does not match any known DartType value.
 */ 1 6 strval 1 2146  
479 0 0 6 585 2043 0 0 160 /**
 * Returns the DCSType value associated with the given string representation,
 * or DC_unspecified if the string does not match any known DCSType value.
 */ 1 6 strval 1 2146  
480 0 0 6 586 2044 0 0 168 /**
 * Returns the BillboardType value associated with the given string
 * representation, or BT_none if the string does not match any known
 * BillboardType value.
 */ 1 6 strval 1 2146  
481 0 0 6 587 2045 0 0 179 /**
 * Returns the CollisionSolidType value associated with the given string
 * representation, or CST_none if the string does not match any known
 * CollisionSolidType value.
 */ 1 6 strval 1 2146  
482 0 0 6 588 2046 0 0 260 /**
 * Returns the CollideFlags value associated with the given string
 * representation, or CF_none if the string does not match any known
 * CollideFlags value.  This only recognizes a single keyword; it does not
 * attempt to parse a string of keywords.
 */ 1 6 strval 1 2146  
483 0 0 6 589 2048 0 0 154 /**
 * Returns the BlendMode value associated with the given string
 * representation, or BM_none if the string does not match any known
 * BlendMode.
 */ 1 6 strval 1 2146  
484 0 0 6 590 2049 0 0 160 /**
 * Returns the BlendOperand value associated with the given string
 * representation, or BO_none if the string does not match any known
 * BlendOperand.
 */ 1 6 strval 1 2146  
485 0 0 7 591 2138 0 0 0 0 
486 0 0 7 387 2004 0 0 0 1 4 this 3 2251  
487 0 0 6 389 2159 0 0 0 1 4 this 3 2251  
488 0 0 6 391 2231 0 0 0 1 4 this 3 2251  
489 0 0 15 593 2256 1491 0 10 /**
 *
 */ 1 4 copy 1 2254  
490 0 0 23 593 2256 1491 0 10 /**
 *
 */ 1 4 copy 1 2221  
491 0 0 7 593 2256 1491 0 10 /**
 *
 */ 1 4 name 5 2146  
492 0 0 4 594 2142 0 0 10 /**
 *
 */ 2 4 this 3 2256  10 bin_number 1 2010  
493 0 0 6 595 2010 0 0 10 /**
 *
 */ 1 4 this 3 2254  
494 0 0 7 596 2138 0 0 0 0 
495 0 0 6 599 2010 0 0 208 /**
 * The main entry point to EggBinMaker.  Walks the egg scene graph beginning
 * at the indicated root node, and moves all binnable nodes into EggBin
 * objects.  Returns the number of EggBins created.
 */ 2 4 this 3 2257  10 root_group 1 2004  
496 0 0 4 600 2142 0 0 171 /**
 * May be overridden in derived classes to perform some setup work as each
 * node is encountered.  This will be called once for each node in the egg
 * hierarchy.
 */ 2 4 this 3 2257  4 node 1 2150  
497 0 0 6 601 2010 0 0 0 2 4 this 3 2257  4 node 1 2151  
498 0 0 6 602 2055 0 0 361 /**
 * May be overridden in derived classes to create additional bins within a
 * particular bin number, based on some arbitrary property of nodes.  This
 * function establishes an arbitrary but fixed ordering between nodes; if two
 * nodes do not sort to the same position, different bins are created for each
 * one (with the same bin number on each bin).
 */ 4 4 this 3 2257  10 bin_number 1 2010  1 a 1 2151  1 b 1 2151  
499 0 0 6 603 2055 0 0 145 /**
 * May be overridden in derived classes to specify whether a particular group
 * node, apparently redundant, may be safely collapsed out.
 */ 3 4 this 3 2257  5 group 1 2221  10 bin_number 1 2010  
500 0 0 6 604 2146 0 0 130 /**
 * May be overridden in derived classes to define a name for each new bin,
 * based on its bin number, and a sample child.
 */ 3 4 this 3 2257  10 bin_number 1 2010  5 child 1 2151  
501 0 0 7 605 2256 1491 0 352 /**
 * May be overridden in derived classes to construct a new EggBin object (or
 * some derived class, if needed), and preload some initial data into as
 * required.
 *
 * child is an arbitrary child of the bin, and collapse_from is the group the
 * bin is being collapsed with, if any (implying collapse_group() returned
 * true), or NULL if not.
 */ 4 4 this 3 2257  10 bin_number 1 2010  5 child 1 2151  13 collapse_from 1 2251  
502 0 0 7 606 2138 0 0 0 0 
503 0 0 15 608 2260 1507 0 10 /**
 *
 */ 1 4 copy 1 2258  
504 0 0 7 608 2260 1507 0 10 /**
 *
 */ 2 9 node_name 1 2146  7 comment 1 2146  
505 0 0 7 609 2260 1507 0 10 /**
 *
 */ 2 4 this 3 2260  4 copy 1 2258  
506 0 0 7 609 2260 1507 0 10 /**
 *
 */ 2 4 this 3 2260  7 comment 1 2146  
507 0 0 4 611 2142 0 0 10 /**
 *
 */ 2 4 this 3 2260  7 comment 1 2146  
508 0 0 6 612 2146 0 0 10 /**
 *
 */ 1 4 this 3 2258  
509 0 0 38 613 2006 0 0 0 1 4 this 3 2258  
510 0 0 7 614 2138 0 0 0 0 
511 0 0 6 610 2146 0 0 0 1 4 this 3 2258  
512 0 0 7 617 2261 1515 0 10 /**
 *
 */ 2 4 this 3 2261  4 copy 1 2262  
513 0 0 6 618 2146 0 0 64 /**
 * Returns the default extension for this filename type.
 */ 1 4 this 3 2262  
514 0 0 6 619 2167 0 0 61 /**
 * Returns a nonmodifiable reference to the filename.
 */ 1 4 this 3 2262  
515 0 0 4 620 2142 0 0 10 /**
 *
 */ 2 4 this 3 2261  8 filename 1 2167  
516 0 0 6 621 2167 0 0 472 /**
 * Returns the full pathname to the file, if it is known; otherwise, returns
 * the same thing as get_filename().
 *
 * This function simply returns whatever was set by the last call to
 * set_fullpath().  This string is not written to the egg file; its main
 * purpose is to record the full path to a filename (for instance, a texture
 * filename) if it is known, for egg structures that are generated in-memory
 * and then immediately converted to a scene graph.
 */ 1 4 this 3 2262  
517 0 0 4 622 2142 0 0 84 /**
 * Records the full pathname to the file, for the benefit of get_fullpath().
 */ 2 4 this 3 2261  8 fullpath 1 2167  
518 0 0 7 623 2138 0 0 0 0 
519 0 0 15 632 2090 1524 0 10 /**
 *
 */ 1 4 copy 1 2264  
520 0 0 7 632 2090 1524 0 10 /**
 *
 */ 2 9 tref_name 1 2146  8 filename 1 2167  
521 0 0 7 633 2090 1524 0 10 /**
 *
 */ 2 4 this 3 2090  4 copy 1 2264  
522 0 0 4 635 2142 0 0 86 /**
 * Writes the texture definition to the indicated output stream in Egg format.
 */ 3 4 this 3 2264  3 out 1 2147  12 indent_level 1 2010  
523 0 0 6 637 2055 0 0 899 /**
 * Returns true if the two textures are equivalent in all relevant properties
 * (according to eq), false otherwise.
 *
 * The Equivalence parameter, eq, should be set to the bitwise OR of the
 * following properties, according to what you consider relevant:
 *
 * EggTexture::E_basename: The basename part of the texture filename, without
 * the directory prefix *or* the filename extension.
 *
 * EggTexture::E_extension: The extension part of the texture filename.
 *
 * EggTexture::E_dirname: The directory prefix of the texture filename.
 *
 * EggTexture::E_complete_filename: The union of the above three; that is, the
 * complete filename, with directory, basename, and extension.
 *
 * EggTexture::E_transform: The texture matrix.
 *
 * EggTexture::E_attributes: All remaining texture attributes (mode, mipmap,
 * etc.) except TRef name.
 *
 * EggTexture::E_tref_name: The TRef name.
 */ 3 4 this 3 2264  5 other 1 2264  2 eq 1 2010  
524 0 0 6 638 2055 0 0 224 /**
 * An ordering operator to compare two textures for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique textures, according
 * to the indicated Equivalence factor.  See is_equivalent_to().
 */ 3 4 this 3 2264  5 other 1 2264  2 eq 1 2010  
525 0 0 6 639 2055 0 0 260 /**
 * Given the number of color components (channels) in the image file as
 * actually read from the disk, return true if this texture seems to have an
 * alpha channel or not.  This depends on the EggTexture's format as well as
 * the number of channels.
 */ 2 4 this 3 2264  14 num_components 1 2010  
526 0 0 4 653 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  12 texture_type 1 2071  
527 0 0 6 654 2071 0 0 10 /**
 *
 */ 1 4 this 3 2264  
528 0 0 4 655 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  6 format 1 2072  
529 0 0 6 656 2072 0 0 10 /**
 *
 */ 1 4 this 3 2264  
530 0 0 4 657 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  4 mode 1 2073  
531 0 0 6 658 2073 0 0 10 /**
 *
 */ 1 4 this 3 2264  
532 0 0 4 659 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  4 mode 1 2074  
533 0 0 6 660 2074 0 0 10 /**
 *
 */ 1 4 this 3 2264  
534 0 0 4 661 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  4 mode 1 2074  
535 0 0 6 662 2074 0 0 120 /**
 * Returns the amount specified for U wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */ 1 4 this 3 2264  
536 0 0 6 663 2074 0 0 178 /**
 * Determines the appropriate wrap in the U direction.  This is different from
 * get_wrap_u() in that if the U wrap is unspecified, it returns the overall
 * wrap value.
 */ 1 4 this 3 2264  
537 0 0 4 664 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  4 mode 1 2074  
538 0 0 6 665 2074 0 0 120 /**
 * Returns the amount specified for V wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */ 1 4 this 3 2264  
539 0 0 6 666 2074 0 0 178 /**
 * Determines the appropriate wrap in the V direction.  This is different from
 * get_wrap_v() in that if the V wrap is unspecified, it returns the overall
 * wrap value.
 */ 1 4 this 3 2264  
540 0 0 4 667 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  4 mode 1 2074  
541 0 0 6 668 2074 0 0 120 /**
 * Returns the amount specified for W wrap.  This may be unspecified, even if
 * there is an overall wrap value.
 */ 1 4 this 3 2264  
542 0 0 6 669 2074 0 0 178 /**
 * Determines the appropriate wrap in the W direction.  This is different from
 * get_wrap_w() in that if the W wrap is unspecified, it returns the overall
 * wrap value.
 */ 1 4 this 3 2264  
543 0 0 4 670 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  4 type 1 2075  
544 0 0 6 671 2075 0 0 10 /**
 *
 */ 1 4 this 3 2264  
545 0 0 4 672 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  4 type 1 2075  
546 0 0 6 673 2075 0 0 10 /**
 *
 */ 1 4 this 3 2264  
547 0 0 4 674 2142 0 0 127 /**
 * Sets the degree of anisotropic filtering for this texture.  1 is off;
 * higher levels indicate filtering in effect.
 */ 2 4 this 3 2090  18 anisotropic_degree 1 2010  
548 0 0 4 675 2142 0 0 79 /**
 * Removes the specification of anisotropic filtering from the texture.
 */ 1 4 this 3 2090  
549 0 0 6 676 2055 0 0 128 /**
 * Returns true if a value for the anisotropic filtering degree has been
 * specified for this texture, false otherwise.
 */ 1 4 this 3 2264  
550 0 0 6 677 2010 0 0 132 /**
 * Returns the anisotropic filtering degree that has been specified for this
 * texture, or 0 if nothing has been specified.
 */ 1 4 this 3 2264  
551 0 0 4 678 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  4 type 1 2076  
552 0 0 6 679 2076 0 0 10 /**
 *
 */ 1 4 this 3 2264  
553 0 0 6 680 2055 0 0 162 /**
 * Returns true if this texture's environment type or combine mode allows the
 * texture to have an effect on the polygon's alpha values, false otherwise.
 */ 1 4 this 3 2264  
554 0 0 4 681 2142 0 0 10 /**
 *
 */ 3 4 this 3 2090  7 channel 1 2078  2 cm 1 2077  
555 0 0 6 682 2077 0 0 10 /**
 *
 */ 2 4 this 3 2264  7 channel 1 2078  
556 0 0 4 683 2142 0 0 10 /**
 *
 */ 4 4 this 3 2090  7 channel 1 2078  1 n 1 2010  2 cs 1 2080  
557 0 0 6 684 2080 0 0 10 /**
 *
 */ 3 4 this 3 2264  7 channel 1 2078  1 n 1 2010  
558 0 0 4 685 2142 0 0 10 /**
 *
 */ 4 4 this 3 2090  7 channel 1 2078  1 n 1 2010  2 co 1 2081  
559 0 0 6 686 2081 0 0 10 /**
 *
 */ 3 4 this 3 2264  7 channel 1 2078  1 n 1 2010  
560 0 0 4 687 2142 0 0 614 /**
 * Sets the saved_result flag.  When this is true, the output of this stage is
 * not part of the normal pipeline--that is, it will not be supplied as the
 * "previous" source for the next texture stage--but it will instead be
 * supplied as the "last_saved_result" source for any future stages, until the
 * next TextureStage with a saved_result set true is encountered.
 *
 * This can be used to reuse the results of this texture stage as input to
 * more than one stage later in the pipeline.
 *
 * The last texture in the pipeline (the one with the highest sort value)
 * should not have this flag set.
 */ 2 4 this 3 2090  12 saved_result 1 2055  
561 0 0 6 688 2055 0 0 92 /**
 * Returns the current setting of the saved_result flag.  See
 * set_saved_result().
 */ 1 4 this 3 2264  
562 0 0 4 689 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  7 tex_gen 1 2082  
563 0 0 6 690 2082 0 0 10 /**
 *
 */ 1 4 this 3 2264  
564 0 0 4 691 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  13 quality_level 1 2083  
565 0 0 6 692 2083 0 0 10 /**
 *
 */ 1 4 this 3 2264  
566 0 0 4 693 2142 0 0 442 /**
 * Specifies the particular TextureStage this texture will be rendered on by
 * name.  If this is omitted, the texture will be rendered on the default
 * TextureStage, unless some other stage-specific property is specificied, in
 * which case the texture will be rendered on a TextureStage with the same
 * name as the tref.  This is in support of multitexturing.
 *
 * Each different TextureStage in the world must be uniquely named.
 */ 2 4 this 3 2090  10 stage_name 1 2146  
567 0 0 4 694 2142 0 0 56 /**
 * Removes the named TextureStage specification.
 */ 1 4 this 3 2090  
568 0 0 6 695 2055 0 0 107 /**
 * Returns true if a stage name has been explicitly specified for this
 * texture, false otherwise.
 */ 1 4 this 3 2264  
569 0 0 6 696 2146 0 0 146 /**
 * Returns the stage name that has been specified for this texture, or the
 * tref name if no texture stage has explicitly been specified.
 */ 1 4 this 3 2264  
570 0 0 4 697 2142 0 0 178 /**
 * Sets the importance of this texture with respect to other textures also
 * applied on the same geometry.  This is only meaningful in the presence of
 * multitexturing.
 */ 2 4 this 3 2090  8 priority 1 2010  
571 0 0 4 698 2142 0 0 116 /**
 * Removes the specification of multitexture priority from the texture.  The
 * default priority value is 0.
 */ 1 4 this 3 2090  
572 0 0 6 699 2055 0 0 127 /**
 * Returns true if a priority value for multitexture importance has been
 * specified for the texture, false otherwise.
 */ 1 4 this 3 2264  
573 0 0 6 700 2010 0 0 142 /**
 * Returns the multitexture importance value that has been specified for the
 * texture, or 0 if no priority value has been specified.
 */ 1 4 this 3 2264  
574 0 0 4 701 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  5 color 1 2189  
575 0 0 4 702 2142 0 0 10 /**
 *
 */ 1 4 this 3 2090  
576 0 0 6 703 2055 0 0 76 /**
 * Returns true if a blend color has been specified for the texture.
 */ 1 4 this 3 2264  
577 0 0 6 704 2189 0 0 91 /**
 * Returns the blend color if one has been specified, or (0, 0, 0, 1)
 * otherwise.
 */ 1 4 this 3 2264  
578 0 0 4 705 2142 0 0 10 /**
 *
 */ 2 4 this 3 2090  12 border_color 1 2189  
579 0 0 4 706 2142 0 0 10 /**
 *
 */ 1 4 this 3 2090  
580 0 0 6 707 2055 0 0 77 /**
 * Returns true if a border color has been specified for the texture.
 */ 1 4 this 3 2264  
581 0 0 6 708 2189 0 0 92 /**
 * Returns the border color if one has been specified, or (0, 0, 0, 1)
 * otherwise.
 */ 1 4 this 3 2264  
582 0 0 4 709 2142 0 0 309 /**
 * Specifies the named set of texture coordinates that this texture will use
 * when it is applied to geometry.  Geometry may have multiple sets of texture
 * coordinates defined, by name.
 *
 * If this is not specified for a particular texture, the default set of
 * texture coordinates will be used.
 */ 2 4 this 3 2090  7 uv_name 1 2146  
583 0 0 4 710 2142 0 0 153 /**
 * Removes the restriction to a particular named set of texture coordinates
 * and restores the texture to using the default texture coordinates.
 */ 1 4 this 3 2090  
584 0 0 6 711 2055 0 0 110 /**
 * Returns true if a texcoord name has been explicitly specified for this
 * texture, false otherwise.
 */ 1 4 this 3 2264  
585 0 0 6 712 2146 0 0 152 /**
 * Returns the texcoord name that has been specified for this texture, or the
 * empty string if no texcoord name has explicitly been specified.
 */ 1 4 this 3 2264  
586 0 0 4 713 2142 0 0 220 /**
 * Sets an additional factor that will scale all three r, g, b components
 * after the texture has been applied.  This is used only when a combine mode
 * is in effect.
 *
 * The only legal values are 1, 2, or 4.
 */ 2 4 this 3 2090  9 rgb_scale 1 2010  
587 0 0 4 714 2142 0 0 95 /**
 * Removes the rgb_scale from the texture and restores it to the default value
 * of 1.
 */ 1 4 this 3 2090  
588 0 0 6 715 2055 0 0 95 /**
 * Returns true if an rgb_scale has been specified for the texture, false
 * otherwise.
 */ 1 4 this 3 2264  
589 0 0 6 716 2010 0 0 129 /**
 * Returns the rgb_scale value that has been specified for the texture, or 1
 * if no rgb_scale value has been specified.
 */ 1 4 this 3 2264  
590 0 0 4 717 2142 0 0 211 /**
 * Sets an additional factor that will scale the alpha component after the
 * texture has been applied.  This is used only when a combine mode is in
 * effect.
 *
 * The only legal values are 1, 2, or 4.
 */ 2 4 this 3 2090  11 alpha_scale 1 2010  
591 0 0 4 718 2142 0 0 97 /**
 * Removes the alpha_scale from the texture and restores it to the default
 * value of 1.
 */ 1 4 this 3 2090  
592 0 0 6 719 2055 0 0 97 /**
 * Returns true if an alpha_scale has been specified for the texture, false
 * otherwise.
 */ 1 4 this 3 2264  
593 0 0 6 720 2010 0 0 133 /**
 * Returns the alpha_scale value that has been specified for the texture, or 1
 * if no alpha_scale value has been specified.
 */ 1 4 this 3 2264  
594 0 0 4 721 2142 0 0 235 /**
 * Specifies a separate file that will be loaded in with the 1- or 3-component
 * texture and applied as the alpha channel.  This is useful when loading
 * textures from file formats that do not support alpha, for instance jpg.
 */ 2 4 this 3 2090  8 filename 1 2167  
595 0 0 4 722 2142 0 0 10 /**
 *
 */ 1 4 this 3 2090  
596 0 0 6 723 2055 0 0 131 /**
 * Returns true if a separate file for the alpha component has been applied,
 * false otherwise.  See set_alpha_filename().
 */ 1 4 this 3 2264  
597 0 0 6 724 2167 0 0 172 /**
 * Returns the separate file assigned for the alpha channel.  It is an error
 * to call this unless has_alpha_filename() returns true.  See
 * set_alpha_filename().
 */ 1 4 this 3 2264  
598 0 0 4 725 2142 0 0 93 /**
 * Records the full pathname to the file, for the benefit of
 * get_alpha_fullpath().
 */ 2 4 this 3 2090  8 fullpath 1 2167  
599 0 0 6 726 2167 0 0 463 /**
 * Returns the full pathname to the alpha file, if it is known; otherwise,
 * returns the same thing as get_alpha_filename().
 *
 * This function simply returns whatever was set by the last call to
 * set_alpha_fullpath().  This string is not written to the egg file; its main
 * purpose is to record the full path to the alpha filename if it is known,
 * for egg structures that are generated in-memory and then immediately
 * converted to a scene graph.
 */ 1 4 this 3 2264  
600 0 0 4 727 2142 0 0 416 /**
 * If a separate alpha-file is specified, this indicates which channel number
 * should be extracted from this file to derive the alpha channel for the
 * final image.  The default is 0, which means the grayscale combination of r,
 * g, b.  Otherwise, this should be the 1-based channel number, for instance
 * 1, 2, or 3 for r, g, or b, respectively, or 4 for the alpha channel of a
 * four-component image.
 */ 2 4 this 3 2090  18 alpha_file_channel 1 2010  
601 0 0 4 728 2142 0 0 98 /**
 * Removes the specification of a particular channel to use from the alpha-
 * file image.
 */ 1 4 this 3 2090  
602 0 0 6 729 2055 0 0 112 /**
 * Returns true if a particular channel has been specified for the alpha-file
 * image, false otherwise.
 */ 1 4 this 3 2264  
603 0 0 6 730 2010 0 0 167 /**
 * Returns the particular channel that has been specified for the alpha-file
 * image, or 0 if no channel has been specified.  See
 * set_alpha_file_channel().
 */ 1 4 this 3 2264  
604 0 0 4 731 2142 0 0 380 /**
 * Sets the multiview flag.
 *
 * If multiview is true, the filename should contain a hash mark ('#'), which
 * will be filled in with the view number; and a multiview texture will be
 * defined with a series of images, one for each view.
 *
 * A multiview texture is most often used for stereo textures, but other uses
 * are also possible, such as for texture animation.
 */ 2 4 this 3 2090  9 multiview 1 2055  
605 0 0 6 732 2055 0 0 83 /**
 * Returns the current setting of the multiview flag.  See set_multiview().
 */ 1 4 this 3 2264  
606 0 0 4 733 2142 0 0 197 /**
 * When loading a 3-D multiview texture, this parameter is necessary to
 * specify how many views will be expected.  The z size is determined
 * implicitly from the number of images loaded.
 */ 2 4 this 3 2090  9 num_views 1 2010  
607 0 0 4 734 2142 0 0 91 /**
 * Removes the specification of the number of views for a 3-D multiview
 * texture.
 */ 1 4 this 3 2090  
608 0 0 6 735 2055 0 0 116 /**
 * Returns true if the number of views has been specified for the 3-D
 * multiview texture, false otherwise.
 */ 1 4 this 3 2264  
609 0 0 6 736 2010 0 0 114 /**
 * Returns the specified number of views specified for the 3-D multiview
 * texture.  See set_num_views().
 */ 1 4 this 3 2264  
610 0 0 4 737 2142 0 0 546 /**
 * Sets the read_mipmaps flag.
 *
 * If read_mipmaps is true, the filename should contain a hash mark ('#'),
 * which will be filled in with the mipmap level number; and the texture will
 * be defined with a series of images, one for each mipmap level.
 *
 * If the filename is of a type that already requires a hash mark, such as a
 * cube map or a 3-d texture, then the filename should now require two hash
 * marks, and the first one indicates the mipmap level number, while the
 * second indicates the face number or 3-d level number.
 */ 2 4 this 3 2090  12 read_mipmaps 1 2055  
611 0 0 6 738 2055 0 0 92 /**
 * Returns the current setting of the read_mipmaps flag.  See
 * set_read_mipmaps().
 */ 1 4 this 3 2264  
612 0 0 4 739 2142 0 0 61 /**
 * Sets the minimum mipmap level that may be sampled.
 */ 2 4 this 3 2090  7 min_lod 1 2013  
613 0 0 4 740 2142 0 0 80 /**
 * Removes the specification of a minimum mipmap level from the texture.
 */ 1 4 this 3 2090  
614 0 0 6 741 2055 0 0 120 /**
 * Returns true if a value for the minimum mipmap level has been specified for
 * this texture, false otherwise.
 */ 1 4 this 3 2264  
615 0 0 6 742 2013 0 0 85 /**
 * Returns the minimum mipmap level that has been specified for this texture.
 */ 1 4 this 3 2264  
616 0 0 4 743 2142 0 0 61 /**
 * Sets the maximum mipmap level that may be sampled.
 */ 2 4 this 3 2090  7 max_lod 1 2013  
617 0 0 4 744 2142 0 0 80 /**
 * Removes the specification of a maximum mipmap level from the texture.
 */ 1 4 this 3 2090  
618 0 0 6 745 2055 0 0 120 /**
 * Returns true if a value for the maximum mipmap level has been specified for
 * this texture, false otherwise.
 */ 1 4 this 3 2264  
619 0 0 6 746 2013 0 0 85 /**
 * Returns the maximum mipmap level that has been specified for this texture.
 */ 1 4 this 3 2264  
620 0 0 4 747 2142 0 0 86 /**
 * Sets the mipmap level bias that is added to the mipmap level to be sampled.
 */ 2 4 this 3 2090  8 lod_bias 1 2013  
621 0 0 4 748 2142 0 0 80 /**
 * Removes the specification of a maximum mipmap level from the texture.
 */ 1 4 this 3 2090  
622 0 0 6 749 2055 0 0 120 /**
 * Returns true if a value for the maximum mipmap level has been specified for
 * this texture, false otherwise.
 */ 1 4 this 3 2264  
623 0 0 6 750 2013 0 0 85 /**
 * Returns the maximum mipmap level that has been specified for this texture.
 */ 1 4 this 3 2264  
624 0 0 4 751 2142 0 0 173 /**
 * Resets the multitexture flags set by multitexture_over().  After this call,
 * get_multitexture() will return false, and get_multitexture_sort() will
 * return 0.
 */ 1 4 this 3 2090  
625 0 0 6 752 2055 0 0 434 /**
 * Indicates that this texture should be layered on top of the other texture.
 * This will guarantee that this->get_multitexture_sort() >
 * other->get_multitexture_sort(), at least until clear_multitexture() is
 * called on either one.
 *
 * The return value is true if successful, or false if there is a failure
 * because the other texture was already layered on top of this one (or there
 * is a three- or more-way cycle).
 */ 2 4 this 3 2090  5 other 1 2090  
626 0 0 6 753 2010 0 0 333 /**
 * Returns an integer that represents the depth to which this texture is
 * layered on all other textures in the egg file.  In general, if texture A is
 * layered over texture B, then sort(A) > sort(B).  If texture A is never
 * layered over any other texture, then sort(A) == 0.  More than that is
 * difficult to guarantee.
 */ 1 4 this 3 2264  
627 0 0 6 754 2071 0 0 171 /**
 * Returns the Texture_ype value associated with the given string
 * representation, or TT_unspecified if the string does not match any known
 * TextureType value.
 */ 1 6 string 1 2146  
628 0 0 6 755 2072 0 0 157 /**
 * Returns the Format value associated with the given string representation,
 * or F_unspecified if the string does not match any known Format value.
 */ 1 6 string 1 2146  
629 0 0 6 756 2073 0 0 175 /**
 * Returns the CompressionMode value associated with the given string
 * representation, or CM_default if the string does not match any known
 * CompressionMode value.
 */ 1 6 string 1 2146  
630 0 0 6 757 2074 0 0 162 /**
 * Returns the WrapMode value associated with the given string representation,
 * or WM_unspecified if the string does not match any known WrapMode value.
 */ 1 6 string 1 2146  
631 0 0 6 758 2075 0 0 169 /**
 * Returns the FilterType value associated with the given string
 * representation, or FT_unspecified if the string does not match any known
 * FilterType value.
 */ 1 6 string 1 2146  
632 0 0 6 759 2076 0 0 160 /**
 * Returns the EnvType value associated with the given string representation,
 * or ET_unspecified if the string does not match any known EnvType value.
 */ 1 6 string 1 2146  
633 0 0 6 760 2077 0 0 171 /**
 * Returns the CombineMode value associated with the given string
 * representation, or CM_unspecified if the string does not match any known
 * CombineMode value.
 */ 1 6 string 1 2146  
634 0 0 6 761 2080 0 0 175 /**
 * Returns the CombineSource value associated with the given string
 * representation, or CS_unspecified if the string does not match any known
 * CombineSource value.
 */ 1 6 string 1 2146  
635 0 0 6 762 2081 0 0 177 /**
 * Returns the CombineOperand value associated with the given string
 * representation, or CO_unspecified if the string does not match any known
 * CombineOperand value.
 */ 1 6 string 1 2146  
636 0 0 6 763 2082 0 0 158 /**
 * Returns the TexGen value associated with the given string representation,
 * or ET_unspecified if the string does not match any known TexGen value.
 */ 1 6 string 1 2146  
637 0 0 6 764 2083 0 0 158 /**
 * Returns the TexGen value associated with the given string representation,
 * or ET_unspecified if the string does not match any known TexGen value.
 */ 1 6 string 1 2146  
638 0 0 7 798 2138 0 0 0 0 
639 0 0 7 626 2261 1515 0 0 1 4 this 3 2090  
640 0 0 6 628 2159 0 0 0 1 4 this 3 2090  
641 0 0 6 630 2231 0 0 0 1 4 this 3 2090  
642 0 0 15 800 2091 1686 0 10 /**
 *
 */ 1 4 copy 1 2266  
643 0 0 7 800 2091 1686 0 10 /**
 *
 */ 1 9 mref_name 1 2146  
644 0 0 6 802 2055 0 0 411 /**
 * Returns true if the two materials are equivalent in all relevant properties
 * (according to eq), false otherwise.
 *
 * The Equivalence parameter, eq, should be set to the bitwise OR of the
 * following properties, according to what you consider relevant:
 *
 * EggMaterial::E_attributes: All material attributes (diff, spec, etc.)
 * except MRef name.
 *
 * EggMaterial::E_mref_name: The MRef name.
 */ 3 4 this 3 2266  5 other 1 2266  2 eq 1 2010  
645 0 0 6 803 2055 0 0 226 /**
 * An ordering operator to compare two materials for sorting order.  This
 * imposes an arbitrary ordering useful to identify unique materials,
 * according to the indicated Equivalence factor.  See is_equivalent_to().
 */ 3 4 this 3 2266  5 other 1 2266  2 eq 1 2010  
646 0 0 4 804 2142 0 0 24 /**
 * @since 1.10.0
 */ 2 4 this 3 2091  4 base 1 2189  
647 0 0 4 805 2142 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2091  
648 0 0 6 806 2055 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2266  
649 0 0 7 807 2188 0 0 142 /**
 * It is legal to call this even if has_base() returns false.  If so, it
 * simply returns the default base color.
 *
 * @since 1.10.0
 */ 1 4 this 3 2266  
650 0 0 4 808 2142 0 0 10 /**
 *
 */ 2 4 this 3 2091  4 diff 1 2189  
651 0 0 4 809 2142 0 0 10 /**
 *
 */ 1 4 this 3 2091  
652 0 0 6 810 2055 0 0 10 /**
 *
 */ 1 4 this 3 2266  
653 0 0 7 811 2188 0 0 122 /**
 * It is legal to call this even if has_diff() returns false.  If so, it
 * simply returns the default diff color.
 */ 1 4 this 3 2266  
654 0 0 4 812 2142 0 0 10 /**
 *
 */ 2 4 this 3 2091  3 amb 1 2189  
655 0 0 4 813 2142 0 0 10 /**
 *
 */ 1 4 this 3 2091  
656 0 0 6 814 2055 0 0 10 /**
 *
 */ 1 4 this 3 2266  
657 0 0 7 815 2188 0 0 120 /**
 * It is legal to call this even if has_amb() returns false.  If so, it simply
 * returns the default amb color.
 */ 1 4 this 3 2266  
658 0 0 4 816 2142 0 0 10 /**
 *
 */ 2 4 this 3 2091  4 emit 1 2189  
659 0 0 4 817 2142 0 0 10 /**
 *
 */ 1 4 this 3 2091  
660 0 0 6 818 2055 0 0 10 /**
 *
 */ 1 4 this 3 2266  
661 0 0 7 819 2188 0 0 122 /**
 * It is legal to call this even if has_emit() returns false.  If so, it
 * simply returns the default emit color.
 */ 1 4 this 3 2266  
662 0 0 4 820 2142 0 0 10 /**
 *
 */ 2 4 this 3 2091  4 spec 1 2189  
663 0 0 4 821 2142 0 0 10 /**
 *
 */ 1 4 this 3 2091  
664 0 0 6 822 2055 0 0 10 /**
 *
 */ 1 4 this 3 2266  
665 0 0 7 823 2188 0 0 122 /**
 * It is legal to call this even if has_spec() returns false.  If so, it
 * simply returns the default spec color.
 */ 1 4 this 3 2266  
666 0 0 4 824 2142 0 0 10 /**
 *
 */ 2 4 this 3 2091  9 shininess 1 2013  
667 0 0 4 825 2142 0 0 10 /**
 *
 */ 1 4 this 3 2091  
668 0 0 6 826 2055 0 0 10 /**
 *
 */ 1 4 this 3 2266  
669 0 0 6 827 2013 0 0 10 /**
 *
 */ 1 4 this 3 2266  
670 0 0 4 828 2142 0 0 24 /**
 * @since 1.10.0
 */ 2 4 this 3 2091  9 roughness 1 2013  
671 0 0 4 829 2142 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2091  
672 0 0 6 830 2055 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2266  
673 0 0 6 831 2013 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2266  
674 0 0 4 832 2142 0 0 24 /**
 * @since 1.10.0
 */ 2 4 this 3 2091  8 metallic 1 2013  
675 0 0 4 833 2142 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2091  
676 0 0 6 834 2055 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2266  
677 0 0 6 835 2013 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2266  
678 0 0 4 836 2142 0 0 24 /**
 * @since 1.10.0
 */ 2 4 this 3 2091  3 ior 1 2013  
679 0 0 4 837 2142 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2091  
680 0 0 6 838 2055 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2266  
681 0 0 6 839 2013 0 0 24 /**
 * @since 1.10.0
 */ 1 4 this 3 2266  
682 0 0 4 840 2142 0 0 10 /**
 *
 */ 2 4 this 3 2091  5 local 1 2055  
683 0 0 4 841 2142 0 0 10 /**
 *
 */ 1 4 this 3 2091  
684 0 0 6 842 2055 0 0 10 /**
 *
 */ 1 4 this 3 2266  
685 0 0 6 843 2055 0 0 10 /**
 *
 */ 1 4 this 3 2266  
686 0 0 7 854 2138 0 0 0 0 
687 0 0 7 864 2228 1694 0 10 /**
 *
 */ 2 4 this 3 2228  4 copy 1 2223  
688 0 0 7 866 2228 1694 0 0 1 4 this 3 2223  
689 0 0 6 867 2159 0 0 271 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has an
 * alpha_mode other than AM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2228  
690 0 0 6 868 2159 0 0 272 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2228  
691 0 0 6 869 2159 0 0 271 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2228  
692 0 0 6 870 2159 0 0 270 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this node that has a
 * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode
 * pointer if one is found, or NULL otherwise.
 */ 1 4 this 3 2228  
693 0 0 6 871 2159 0 0 256 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a
 * depth_offset specified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */ 1 4 this 3 2228  
694 0 0 6 872 2159 0 0 254 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a
 * draw_order specified.  Returns a valid EggRenderMode pointer if one is
 * found, or NULL otherwise.
 */ 1 4 this 3 2228  
695 0 0 6 873 2159 0 0 247 /**
 * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or
 * some such object at this level or above this primitive that has a bin
 * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL
 * otherwise.
 */ 1 4 this 3 2228  
696 0 0 6 874 2146 0 0 223 /**
 * Returns the name of the primitive for the purposes of sorting primitives
 * into different groups, if there is one.
 *
 * Presently, this is defined as the primitive name itself, unless it begins
 * with a digit.
 */ 1 4 this 3 2223  
697 0 0 6 875 2089 0 0 696 /**
 * Returns the shading properties apparent on this particular primitive.  This
 * returns S_per_vertex if the vertices have colors or normals (and they are
 * not all the same values), or for a simple primitive, S_overall otherwise.
 * A composite primitive may also return S_per_face if the individual
 * component primitives have colors or normals that are not all the same
 * values.
 *
 * To get the most accurate results, you should call clear_shading() on all
 * connected primitives (or on all primitives in the egg file), followed by
 * get_shading() on each primitive.  You may find it easiest to call these
 * methods on the EggData root node (they are defined on EggGroupNode).
 */ 1 4 this 3 2223  
698 0 0 4 876 2142 0 0 128 /**
 * Resets the connected_shading member in this primitive, so that
 * get_connected_shading() will recompute a new value.
 */ 1 4 this 3 2228  
699 0 0 6 877 2089 0 0 479 /**
 * Determines what sort of shading properties this primitive's connected
 * neighbors have.
 *
 * To get the most accurate results, you should first call
 * clear_connected_shading() on all connected primitives (or on all primitives
 * in the egg file). It might also be a good idea to call
 * remove_unused_vertices() to ensure proper connectivity.
 *
 * You may find it easiest to call these other methods on the EggData root
 * node (they are defined on EggGroupNode).
 */ 1 4 this 3 2223  
700 0 0 4 878 2142 0 0 211 /**
 * Replaces the current list of textures with the indicated texture.
 *
 * @deprecated This method is used in support of single-texturing only.
 * Please use the multitexture variant add_texture instead.
 */ 2 4 this 3 2228  7 texture 1 2090  
701 0 0 6 879 2055 0 0 232 /**
 * Returns true if the primitive has any textures specified, false otherwise.
 *
 * @deprecated This method is used in support of single-texturing only.
 * New code should be written to use the multitexture variants instead.
 */ 1 4 this 3 2223  
702 0 0 6 879 2055 0 0 98 /**
 * Returns true if the primitive has the particular indicated texture, false
 * otherwise.
 */ 2 4 this 3 2223  7 texture 1 2090  
703 0 0 7 880 2090 1524 0 263 /**
 * Returns the first texture on the primitive, if any, or NULL if there are no
 * textures on the primitive.
 *
 * @deprecated This method is used in support of single-texturing only.
 * New code should be written to use the multitexture variants instead.
 */ 1 4 this 3 2223  
704 0 0 7 880 2090 1524 0 74 /**
 * Returns the nth texture that has been applied to the primitive.
 */ 2 4 this 3 2223  1 n 1 2010  
705 0 0 4 881 2142 0 0 276 /**
 * Applies the indicated texture to the primitive.
 *
 * Note that, in the case of multiple textures being applied to a single
 * primitive, the order in which the textures are applied does not affect the
 * rendering order; use EggTexture::set_sort() to specify that.
 */ 2 4 this 3 2228  7 texture 1 2090  
706 0 0 4 882 2142 0 0 52 /**
 * Removes any texturing from the primitive.
 */ 1 4 this 3 2228  
707 0 0 6 883 2010 0 0 67 /**
 * Returns the number of textures applied to the primitive.
 */ 1 4 this 3 2223  
708 0 0 4 885 2142 0 0 59 /**
 * Applies the indicated material to the primitive.
 */ 2 4 this 3 2228  8 material 1 2091  
709 0 0 4 886 2142 0 0 51 /**
 * Removes any material from the primitive.
 */ 1 4 this 3 2228  
710 0 0 7 887 2091 1686 0 97 /**
 * Returns a pointer to the applied material, or NULL if there is no material
 * applied.
 */ 1 4 this 3 2223  
711 0 0 6 888 2055 0 0 160 /**
 * Returns true if the primitive is materiald (and get_material() will return
 * a real pointer), false otherwise (and get_material() will return NULL).
 */ 1 4 this 3 2223  
712 0 0 4 889 2142 0 0 204 /**
 * Sets the backfacing flag of the polygon.  If this is true, the polygon will
 * be rendered so that both faces are visible; if it is false, only the front
 * face of the polygon will be visible.
 */ 2 4 this 3 2228  4 flag 1 2055  
713 0 0 6 890 2055 0 0 79 /**
 * Retrieves the backfacing flag of the polygon.  See set_bface_flag().
 */ 1 4 this 3 2223  
714 0 0 4 899 2142 0 0 72 /**
 * Copies the rendering attributes from the indicated primitive.
 */ 2 4 this 3 2228  5 other 1 2182  
715 0 0 4 899 2142 0 0 72 /**
 * Copies the rendering attributes from the indicated primitive.
 */ 2 4 this 3 2228  5 other 1 2223  
716 0 0 6 900 2055 0 0 295 /**
 * Returns true if any vertex on the primitive has a specific normal set,
 * false otherwise.
 *
 * If you call unify_attributes() first, this will also return false even if
 * all the vertices were set to the same value (since unify_attributes()
 * removes redundant vertex properties).
 */ 1 4 this 3 2223  
717 0 0 6 901 2055 0 0 294 /**
 * Returns true if any vertex on the primitive has a specific color set, false
 * otherwise.
 *
 * If you call unify_attributes() first, this will also return false even if
 * all the vertices were set to the same value (since unify_attributes()
 * removes redundant vertex properties).
 */ 1 4 this 3 2223  
718 0 0 4 902 2142 0 0 766 /**
 * If the shading property is S_per_vertex, ensures that all vertices have a
 * normal and a color, and the overall primitive does not.
 *
 * If the shading property is S_per_face, and this is a composite primitive,
 * ensures that all components have a normal and a color, and the vertices and
 * overall primitive do not.  (If this is a simple primitive, S_per_face works
 * the same as S_overall, below).
 *
 * If the shading property is S_overall, ensures that no vertices or
 * components have a normal or a color, and the overall primitive does (if any
 * exists at all).
 *
 * After this call, either the primitive will have normals or its vertices
 * will, but not both.  Ditto for colors.
 *
 * This may create redundant vertices in the vertex pool.
 */ 2 4 this 3 2228  7 shading 1 2089  
719 0 0 4 903 2142 0 0 350 /**
 * Sets the last vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * OpenGL convention of storing flat-shaded properties on the last vertex,
 * although it is not usually a convention in Egg.
 *
 * This may introduce redundant vertices to the vertex pool.
 */ 1 4 this 3 2228  
720 0 0 4 904 2142 0 0 353 /**
 * Sets the first vertex of the triangle (or each component) to the primitive
 * normal and/or color, if the primitive is flat-shaded.  This reflects the
 * DirectX convention of storing flat-shaded properties on the first vertex,
 * although it is not usually a convention in Egg.
 *
 * This may introduce redundant vertices to the vertex pool.
 */ 1 4 this 3 2228  
721 0 0 4 905 2142 0 0 217 /**
 * Intended as a followup to apply_last_attribute(), this also sets an
 * attribute on the first vertices of the primitive, if they don't already
 * have an attribute set, just so they end up with *something*.
 */ 1 4 this 3 2228  
722 0 0 4 906 2142 0 0 201 /**
 * Reverses the ordering of the vertices in this primitive, if appropriate, in
 * order to change the direction the polygon appears to be facing.  Does not
 * adjust the surface normal, if any.
 */ 1 4 this 3 2228  
723 0 0 6 907 2055 0 0 272 /**
 * Cleans up modeling errors in whatever context this makes sense.  For
 * instance, for a polygon, this calls remove_doubled_verts(true).  For a
 * point, it calls remove_nonunique_verts().  Returns true if the primitive is
 * valid, or false if it is degenerate.
 */ 1 4 this 3 2228  
724 0 0 4 908 2142 0 0 559 /**
 * Certain kinds of primitives, particularly polygons, don't like to have the
 * same vertex repeated consecutively.  Unfortunately, some modeling programs
 * (like MultiGen) make this an easy mistake to make.
 *
 * It's handy to have a function to remove these redundant vertices.  If
 * closed is true, it also checks that the first and last vertices are not the
 * same.
 *
 * This function identifies repeated vertices by position only; it does not
 * consider any other properties, such as color or UV, significant in
 * differentiating vertices.
 */ 2 4 this 3 2228  6 closed 1 2055  
725 0 0 4 909 2142 0 0 256 /**
 * Removes any multiple appearances of the same vertex from the primitive.
 * This primarily makes sense for a point primitive, which is really a
 * collection of points and which doesn't make sense to include the same point
 * twice, in any order.
 */ 1 4 this 3 2228  
726 0 0 6 910 2055 0 0 124 /**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, false otherwise.
 */ 1 4 this 3 2223  
727 0 0 6 911 2055 0 0 154 /**
 * Returns true if there are any primitives (e.g.  polygons) defined within
 * this group or below, but the search does not include nested joints.
 */ 1 4 this 3 2223  
728 0 0 6 912 2055 0 0 164 /**
 * Returns true if any of the primitives (e.g.  polygons) defined within this
 * group or below have either face or vertex normals defined, false otherwise.
 */ 1 4 this 3 2223  
729 0 0 4 913 2142 0 0 58 /**
 * Removes all of the vertices from the primitive.
 */ 1 4 this 3 2228  
730 0 0 7 914 2092 1192 0 103 /**
 * Adds the indicated vertex to the end of the primitive's list of vertices,
 * and returns it.
 */ 2 4 this 3 2228  6 vertex 1 2092  
731 0 0 7 915 2092 1192 0 157 /**
 * Removes the indicated vertex from the primitive and returns it.  If the
 * vertex was not already in the primitive, does nothing and returns NULL.
 */ 2 4 this 3 2228  6 vertex 1 2092  
732 0 0 4 915 2142 0 0 59 /**
 * Removes the indicated vertex from the primitive.
 */ 2 4 this 3 2228  5 index 1 2268  
733 0 0 4 916 2142 0 0 123 /**
 * Replaces the current primitive's list of vertices with a copy of the list
 * of vertices on the other primitive.
 */ 2 4 this 3 2228  5 other 1 2223  
734 0 0 6 917 2268 0 0 63 // These are shorthands if you don't want to use the iterators. 1 4 this 3 2223  
735 0 0 7 918 2092 1192 0 64 /**
 * Returns a particular index based on its index number.
 */ 2 4 this 3 2223  5 index 1 2268  
736 0 0 4 919 2142 0 0 187 /**
 * Replaces a particular vertex based on its index number in the list of
 * vertices.  This is just a convenience function for people who don't want to
 * mess with the iterators.
 */ 3 4 this 3 2228  5 index 1 2268  6 vertex 1 2092  
737 0 0 4 920 2142 0 0 50 /**
 * Inserts a vertex at the given position.
 */ 3 4 this 3 2228  5 index 1 2268  6 vertex 1 2092  
738 0 0 7 922 2093 1102 0 126 /**
 * Returns the vertex pool associated with the vertices of the primitive, or
 * NULL if the primitive has no vertices.
 */ 1 4 this 3 2223  
739 0 0 4 927 2142 0 0 0 3 4 this 3 2223  3 out 1 2147  12 indent_level 1 2010  
740 0 0 4 928 2142 0 0 0 1 4 this 3 2223  
741 0 0 7 929 2138 0 0 0 0 
742 0 0 7 857 2150 1102 0 0 1 4 this 3 2228  
743 0 0 6 859 2095 0 0 0 1 4 this 3 2228  
744 0 0 6 861 2159 0 0 0 1 4 this 3 2228  
745 0 0 7 931 2269 1694 0 10 /**
 *
 */ 2 4 this 3 2269  4 copy 1 2270  
746 0 0 6 932 2268 0 0 148 /**
 * Returns the number of individual component triangles within the composite.
 * Each one of these might have a different set of attributes.
 */ 1 4 this 3 2270  
747 0 0 6 933 2095 0 0 65 /**
 * Returns the attributes for the nth component triangle.
 */ 2 4 this 3 2269  1 i 1 2268  
748 0 0 6 933 2182 0 0 65 /**
 * Returns the attributes for the nth component triangle.
 */ 2 4 this 3 2270  1 i 1 2268  
749 0 0 4 935 2142 0 0 65 /**
 * Changes the attributes for the nth component triangle.
 */ 3 4 this 3 2269  1 i 1 2268  6 attrib 1 2182  
750 0 0 6 938 2055 0 0 361 /**
 * Subdivides the composite primitive into triangles and adds those triangles
 * to the indicated container.  Does not remove the primitive from its
 * existing parent or modify it in any way.
 *
 * Returns true if the triangulation is successful, or false if there was some
 * error (in which case the container may contain some partial triangulation).
 */ 2 4 this 3 2270  9 container 1 2004  
751 0 0 7 939 2269 1694 0 460 /**
 * Subdivides the composite primitive into triangles and adds those triangles
 * to the parent group node in place of the original primitive.  Returns a
 * pointer to the original primitive, which is likely about to be destructed.
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */ 1 4 this 3 2269  
752 0 0 7 940 2138 0 0 0 0 
753 0 0 7 942 2272 1774 0 10 /**
 *
 */ 0 
754 0 0 15 942 2272 1774 0 10 /**
 *
 */ 1 4 copy 1 2273  
755 0 0 7 943 2272 1774 0 10 /**
 *
 */ 2 4 this 3 2272  4 copy 1 2273  
756 0 0 6 944 2055 0 0 212 /**
 * Looks for the indicated filename, first along the indicated searchpath, and
 * then along the model_path.  If found, updates the filename to the full path
 * and returns true; otherwise, returns false.
 */ 2 12 egg_filename 1 2275  10 searchpath 5 2164  
757 0 0 6 945 2055 0 0 291 /**
 * Opens the indicated filename and reads the egg data contents from it.
 * Returns true if the file was successfully opened and read, false if there
 * were some errors, in which case the data may be partially read.
 *
 * error is the output stream to which to write error messages.
 */ 3 4 this 3 2272  8 filename 1 2275  12 display_name 5 2146  
758 0 0 6 945 2055 0 0 442 /**
 * Parses the egg syntax contained in the indicated input stream.  Returns
 * true if the stream was a completely valid egg file, false if there were
 * some errors, in which case the data may be partially read.
 *
 * Before you call this routine, you should probably call set_egg_filename()
 * to set the name of the egg file we're processing, if at all possible.  If
 * there is no such filename, you may set it to the empty string.
 */ 2 4 this 3 2272  2 in 1 2276  
759 0 0 4 946 2142 0 0 110 /**
 * Appends the other egg structure to the end of this one.  The other egg
 * structure is invalidated.
 */ 2 4 this 3 2272  5 other 1 2272  
760 0 0 6 947 2055 0 0 356 /**
 * Loads up all the egg files referenced by <File> entries within the egg
 * structure, and inserts their contents in place of the <File> entries.
 * Searches for files in the searchpath, if not found directly, and writes
 * error messages to the indicated output stream.  Returns true if all
 * externals were loaded successfully, false otherwise.
 */ 2 4 this 3 2272  10 searchpath 5 2164  
761 0 0 6 947 2055 0 0 356 /**
 * Loads up all the egg files referenced by <File> entries within the egg
 * structure, and inserts their contents in place of the <File> entries.
 * Searches for files in the searchpath, if not found directly, and writes
 * error messages to the indicated output stream.  Returns true if all
 * externals were loaded successfully, false otherwise.
 */ 3 4 this 3 2272  10 searchpath 1 2164  6 record 1 2278  
762 0 0 6 948 2010 0 0 310 /**
 * Removes duplicate references to the same texture image with the same
 * properties.  Considers two texture references with identical properties,
 * but different tref names, to be equivalent, and collapses them, choosing
 * one tref name to keep arbitrarily.  Returns the number of textures removed.
 */ 1 4 this 3 2272  
763 0 0 6 949 2010 0 0 306 /**
 * Removes duplicate references to the same material with the same properties.
 * Considers two material references with identical properties, but different
 * mref names, to be equivalent, and collapses them, choosing one mref name to
 * keep arbitrarily.  Returns the number of materials removed.
 */ 1 4 this 3 2272  
764 0 0 6 950 2055 0 0 61 /**
 * The main interface for writing complete egg files.
 */ 2 4 this 3 2272  8 filename 1 2275  
765 0 0 6 950 2055 0 0 61 /**
 * The main interface for writing complete egg files.
 */ 2 4 this 3 2272  3 out 1 2147  
766 0 0 4 951 2142 0 0 147 /**
 * Indicates whether the EggData object will automatically resolve any
 * external references when read() is called.  The default is false.
 */ 2 4 this 3 2272  7 resolve 1 2055  
767 0 0 6 952 2055 0 0 147 /**
 * Indicates whether the EggData object will automatically resolve any
 * external references when read() is called.  The default is false.
 */ 1 4 this 3 2273  
768 0 0 6 953 2055 0 0 411 /**
 * Returns true if the data processed in the last call to read() contained
 * absolute pathnames, or false if those pathnames were all relative.
 *
 * This method is necessary because if auto_resolve_externals() is in effect,
 * it may modify the pathnames to be absolute whether or not they were as
 * loaded from disk.  This method can be used to query the state of the
 * original egg file from disk.
 */ 1 4 this 3 2273  
769 0 0 4 954 2142 0 0 156 /**
 * Changes the coordinate system of the EggData.  If the coordinate system was
 * previously different, this may result in a conversion of the data.
 */ 2 4 this 3 2272  8 coordsys 1 2097  
770 0 0 6 955 2097 0 0 74 /**
 * Returns the coordinate system in which the egg file is defined.
 */ 1 4 this 3 2273  
771 0 0 4 956 2142 0 0 150 /**
 * Sets the filename--especially the directory part--in which the egg file is
 * considered to reside.  This is also implicitly set by read().
 */ 2 4 this 3 2272  12 egg_filename 1 2167  
772 0 0 6 957 2167 0 0 79 /**
 * Returns the directory in which the egg file is considered to reside.
 */ 1 4 this 3 2273  
773 0 0 4 958 2142 0 0 136 /**
 * Sets the timestamp of the egg file on disk, at the time it was opened for
 * reading.  This is also implicitly set by read().
 */ 2 4 this 3 2272  13 egg_timestamp 1 2098  
774 0 0 6 959 2098 0 0 142 /**
 * Returns the timestamp of the egg file on disk, at the time it was opened
 * for reading, or 0 if this information is not available.
 */ 1 4 this 3 2273  
775 0 0 4 967 2142 0 0 711 /**
 * Recomputes all the vertex normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  A shared
 * edge between two polygons (even in different groups) is considered smooth
 * if the angle between the two edges is less than threshold degrees.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the correct normals.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */ 2 4 this 3 2272  9 threshold 1 2013  
776 0 0 4 968 2142 0 0 672 /**
 * Recomputes all the polygon normals for polygon geometry at this group node
 * and below so that they accurately reflect the vertex positions.  Normals
 * are removed from the vertices and defined only on polygons, giving the
 * geometry a faceted appearance.
 *
 * This function also removes degenerate polygons that do not have enough
 * vertices to define a normal.  It does not affect normals for other kinds of
 * primitives like Nurbs or Points.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normals removed.  Thus, it is a good idea
 * to call remove_unused_vertices() after calling this.
 */ 1 4 this 3 2272  
777 0 0 4 969 2142 0 0 317 /**
 * Removes all normals from primitives, and the vertices they reference, at
 * this node and below.
 *
 * This function does not remove or adjust vertices in the vertex pool; it
 * only adds new vertices with the normal removed.  Thus, it is a good idea to
 * call remove_unused_vertices() after calling this.
 */ 1 4 this 3 2272  
778 0 0 7 970 2138 0 0 0 0 
779 0 0 23 973 2280 1780 0 10 /**
 *
 */ 1 5 value 5 2097  
780 0 0 15 973 2280 1780 0 10 /**
 *
 */ 1 4 copy 1 2281  
781 0 0 4 974 2142 0 0 10 /**
 *
 */ 2 4 this 3 2280  5 value 1 2097  
782 0 0 6 975 2097 0 0 10 /**
 *
 */ 1 4 this 3 2281  
783 0 0 38 976 2006 0 0 0 1 4 this 3 2281  
784 0 0 7 977 2138 0 0 0 0 
785 0 0 7 980 2283 1788 0 10 /**
 *
 */ 2 4 this 3 2283  4 copy 1 2284  
786 0 0 4 982 2142 0 0 276 /**
 * Sets the number of subdivisions that will be requested across the curve.
 * (This doesn't necessary guarantee that this number of subdivisions will be
 * made; it's just a hint to any curve renderer or quick tesselator.)  Set the
 * number to 0 to disable the hint.
 */ 2 4 this 3 2283  6 subdiv 1 2010  
787 0 0 6 983 2010 0 0 115 /**
 * Returns the requested number of subdivisions, or 0 if no particular
 * subdivisions have been requested.
 */ 1 4 this 3 2284  
788 0 0 4 984 2142 0 0 126 /**
 * Sets the type of the curve.  This is primarily used as a hint to any code
 * that may need to deal with this curve.
 */ 2 4 this 3 2283  4 type 1 2102  
789 0 0 6 985 2102 0 0 51 /**
 * Returns the indicated type of the curve.
 */ 1 4 this 3 2284  
790 0 0 6 986 2102 0 0 163 /**
 * Returns the CurveType value associated with the given string
 * representation, or CT_invalid if the string does not match any known
 * CurveType value.
 */ 1 6 string 1 2146  
791 0 0 7 987 2138 0 0 0 0 
792 0 0 15 990 2288 1792 0 10 /**
 *
 */ 1 4 copy 1 2286  
793 0 0 7 990 2288 1792 0 10 /**
 *
 */ 2 9 node_name 1 2146  8 filename 1 2146  
794 0 0 7 991 2288 1792 0 10 /**
 *
 */ 2 4 this 3 2288  4 copy 1 2286  
795 0 0 7 992 2138 0 0 0 0 
796 0 0 4 995 2142 0 0 86 /**
 * Empties the table of used named and prepares the Uniquifier for a new tree.
 */ 1 4 this 3 2289  
797 0 0 4 996 2142 0 0 56 /**
 * Begins the traversal from the indicated node.
 */ 2 4 this 3 2289  4 node 1 2150  
798 0 0 7 997 2150 1102 0 114 /**
 * Returns the node associated with the given category and name, or NULL if
 * the name has not been used.
 */ 3 4 this 3 2290  8 category 1 2146  4 name 1 2146  
799 0 0 6 998 2055 0 0 105 /**
 * Returns true if the name has been used for the indicated category already,
 * false otherwise.
 */ 3 4 this 3 2290  8 category 1 2146  4 name 1 2146  
800 0 0 6 999 2055 0 0 219 /**
 * Adds the name to the indicated category.  This name will not be used for
 * any other egg node within this category.  Returns true if the name was
 * added, or false if it was already in use for the category.
 */ 4 4 this 3 2289  8 category 1 2146  4 name 1 2146  4 node 5 2150  
801 0 0 6 1000 2146 0 0 0 2 4 this 3 2289  4 node 1 2150  
802 0 0 6 1001 2146 0 0 216 /**
 * Returns the name of the given node, or at least the name it should be.
 * This provides a hook to adjust the name before attempting to uniquify it,
 * if desired, for instance to remove invalid characters.
 */ 2 4 this 3 2289  4 node 1 2150  
803 0 0 6 1002 2146 0 0 365 /**
 * Generates a new name for the given node when its existing name clashes with
 * some other node.  This function will be called repeatedly, if necessary,
 * until it returns a name that actually is unique.
 *
 * The category is the string returned by get_category(), and index is a
 * uniquely-generated number that may be useful for synthesizing the name.
 */ 4 4 this 3 2289  4 node 1 2150  8 category 1 2146  5 index 1 2010  
804 0 0 7 1003 2138 0 0 0 0 
805 0 0 7 1005 2292 1804 0 254 /**
 * If filter_names is true, then the group names will be coerced into a fairly
 * safe, standard convention that uses no characters other than a-z, A-Z, 0-9,
 * and underscore.  If filter_names is false, the group names will be left
 * unchanged.
 */ 1 12 filter_names 5 2055  
806 0 0 7 1006 2138 0 0 0 0 
807 0 0 15 1009 2295 1694 0 10 /**
 *
 */ 1 4 copy 1 2293  
808 0 0 7 1009 2295 1694 0 10 /**
 *
 */ 1 4 name 5 2146  
809 0 0 7 1010 2295 1694 0 10 /**
 *
 */ 2 4 this 3 2295  4 copy 1 2293  
810 0 0 6 1011 2055 0 0 10 /**
 *
 */ 1 4 this 3 2293  
811 0 0 6 1012 2013 0 0 108 /**
 * Returns the thickness set on this particular line.  If there is no
 * thickness set, returns 1.0.
 */ 1 4 this 3 2293  
812 0 0 4 1013 2142 0 0 10 /**
 *
 */ 2 4 this 3 2295  5 thick 1 2013  
813 0 0 4 1014 2142 0 0 10 /**
 *
 */ 1 4 this 3 2295  
814 0 0 7 1015 2138 0 0 0 0 
815 0 0 7 1017 2296 1814 0 10 /**
 *
 */ 0 
816 0 0 15 1017 2296 1814 0 10 /**
 *
 */ 1 4 copy 1 2297  
817 0 0 6 1018 2296 0 0 10 /**
 *
 */ 2 4 this 3 2296  4 copy 1 2297  
818 0 0 4 1020 2142 0 0 53 /**
 * Removes all materials from the collection.
 */ 1 4 this 3 2296  
819 0 0 6 1021 2010 0 0 211 /**
 * Walks the egg hierarchy beginning at the indicated node, and removes any
 * EggMaterials encountered in the hierarchy, adding them to the collection.
 * Returns the number of EggMaterials encountered.
 */ 2 4 this 3 2296  4 node 1 2004  
820 0 0 6 1022 2010 0 0 903 /**
 * Walks the egg hierarchy beginning at the indicated node, looking for
 * materials that are referenced by primitives but are not already members of
 * the collection, adding them to the collection.
 *
 * If this is called following extract_materials(), it can be used to pick up
 * any additional material references that appeared in the egg hierarchy (but
 * whose EggMaterial node was not actually part of the hierarchy).
 *
 * If this is called in lieu of extract_materials(), it will fill up the
 * collection with all of the referenced materials (and only the referenced
 * materials), without destructively removing the EggMaterials from the
 * hierarchy.
 *
 * This also has the side effect of incrementing the internal usage count for
 * a material in the collection each time a material reference is encountered.
 * This side effect is taken advantage of by remove_unused_materials().
 */ 2 4 this 3 2296  4 node 1 2150  
821 0 0 4 1023 2142 0 0 283 /**
 * Removes any materials from the collection that aren't referenced by any
 * primitives in the indicated egg hierarchy.  This also, incidentally, adds
 * materials to the collection that had been referenced by primitives but had
 * not previously appeared in the collection.
 */ 2 4 this 3 2296  4 node 1 2150  
822 0 0 6 1024 2010 0 0 414 /**
 * Walks through the collection and collapses together any separate materials
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggMaterial::is_equivalent_to()).  The return value is the number of
 * materials removed.
 *
 * This flavor of collapse_equivalent_materials() automatically adjusts all
 * the primitives in the egg hierarchy to refer to the new material pointers.
 */ 3 4 this 3 2296  2 eq 1 2010  4 node 1 2004  
823 0 0 6 1024 2010 0 0 634 /**
 * Walks through the collection and collapses together any separate materials
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggMaterial::is_equivalent_to()).  The return value is the number of
 * materials removed.
 *
 * This flavor of collapse_equivalent_materials() does not adjust any
 * primitives in the egg hierarchy; instead, it fills up the 'removed' map
 * with an entry for each removed material, mapping it back to the equivalent
 * retained material.  It's up to the user to then call replace_materials()
 * with this map, if desired, to apply these changes to the egg hierarchy.
 */ 3 4 this 3 2296  2 eq 1 2010  7 removed 1 2299  
824 0 0 4 1025 2142 0 0 300 /**
 * Walks the egg hierarchy, changing out any reference to a material appearing
 * on the left side of the map with its corresponding material on the right
 * side.  This is most often done following a call to
 * collapse_equivalent_materials().  It does not directly affect the
 * Collection.
 */ 2 4 node 1 2004  7 replace 1 2302  
825 0 0 4 1026 2142 0 0 131 /**
 * Guarantees that each material in the collection has a unique MRef name.
 * This is essential before writing an egg file.
 */ 1 4 this 3 2296  
826 0 0 4 1027 2142 0 0 154 /**
 * Sorts all the materials into alphabetical order by MRef name.  Subsequent
 * operations using begin()/end() will traverse in this sorted order.
 */ 1 4 this 3 2296  
827 0 0 6 1028 2055 0 0 165 /**
 * Explicitly adds a new material to the collection.  Returns true if the
 * material was added, false if it was already there or if there was some
 * error.
 */ 2 4 this 3 2296  8 material 1 2091  
828 0 0 6 1029 2055 0 0 160 /**
 * Explicitly removes a material from the collection.  Returns true if the
 * material was removed, false if it wasn't there or if there was some error.
 */ 2 4 this 3 2296  8 material 1 2091  
829 0 0 7 1030 2091 1686 0 218 // create_unique_material() creates a new material if there is not already
// one equivalent (according to eq, see EggMaterial::is_equivalent_to()) to
// the indicated material, or returns the existing one if there is. 3 4 this 3 2296  4 copy 1 2266  2 eq 1 2010  
830 0 0 7 1031 2091 1686 0 96 /**
 * Returns the material with the indicated MRef name, or NULL if no material
 * matches.
 */ 2 4 this 3 2297  9 mref_name 1 2146  
831 0 0 15 1033 2306 1835 0 10 /**
 *
 */ 1 4 copy 1 2304  
832 0 0 7 1033 2306 1835 0 10 /**
 *
 */ 1 4 name 5 2146  
833 0 0 7 1034 2306 1835 0 10 /**
 *
 */ 2 4 this 3 2306  4 copy 1 2304  
834 0 0 6 1035 2055 0 0 374 /**
 * Calculates the true polygon normal--the vector pointing out of the front of
 * the polygon--based on the vertices.  This does not return or change the
 * polygon's normal as set via set_normal().
 *
 * The return value is true if the normal is computed correctly, or false if
 * the polygon is degenerate and does not have at least three noncollinear
 * vertices.
 */ 3 4 this 3 2304  6 result 1 2307  2 cs 5 2097  
835 0 0 6 1036 2055 0 0 103 /**
 * Returns true if all of the polygon's vertices lie within the same plane,
 * false otherwise.
 */ 1 4 this 3 2304  
836 0 0 6 1037 2055 0 0 210 /**
 * Recalculates the normal according to the order of the vertices, and sets
 * it.  Returns true if the normal is computed correctly, or false if the
 * polygon is degenerate and does not have a normal.
 */ 2 4 this 3 2306  2 cs 5 2097  
837 0 0 6 1038 2055 0 0 656 /**
 * Subdivides the polygon into triangles and adds each one to the indicated
 * container.  If the polygon is already a triangle, adds an exact copy of the
 * polygon to the container.  Does not remove the polygon from its existing
 * parent or modify it in any way.
 *
 * Returns true if the triangulation is successful, or false if there was some
 * error (in which case the container may contain some partial triangulation).
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */ 3 4 this 3 2304  9 container 1 2004  11 convex_also 1 2055  
838 0 0 7 1039 2306 1835 0 444 /**
 * Subdivides the polygon into triangles and adds those triangles to the
 * parent group node in place of the original polygon.  Returns a pointer to
 * the original polygon, which is likely about to be destructed.
 *
 * If convex_also is true, both concave and convex polygons will be subdivided
 * into triangles; otherwise, only concave polygons will be subdivided, and
 * convex polygons will be copied unchanged into the container.
 */ 2 4 this 3 2306  11 convex_also 1 2055  
839 0 0 7 1040 2138 0 0 0 0 
840 0 0 15 1045 2310 1852 0 10 /**
 *
 */ 1 4 copy 1 2308  
841 0 0 7 1045 2310 1852 0 10 /**
 *
 */ 1 4 name 5 2146  
842 0 0 7 1046 2310 1852 0 10 /**
 *
 */ 2 4 this 3 2310  4 copy 1 2308  
843 0 0 4 1047 2142 0 0 306 /**
 * Prepares a new curve definition with the indicated order and number of
 * knots.  This also implies a particular number of vertices as well (the
 * number of knots minus the order), but it is up to the user to add the
 * correct number of vertices to the curve by repeatedly calling push_back().
 */ 3 4 this 3 2310  5 order 1 2010  9 num_knots 1 2010  
844 0 0 4 1048 2142 0 0 273 /**
 * Directly changes the order to the indicated value (which must be an integer
 * in the range 1 <= order <= 4).  If possible, it is preferable to use the
 * setup() method instead of this method, since changing the order directly
 * may result in an invalid curve.
 */ 2 4 this 3 2310  5 order 1 2010  
845 0 0 4 1049 2142 0 0 361 /**
 * Directly changes the number of knots.  This will either add zero-valued
 * knots onto the end, or truncate knot values from the end, depending on
 * whether the list is being increased or decreased.  If possible, it is
 * preferable to use the setup() method instead of directly setting the number
 * of knots, as this may result in an invalid curve.
 */ 2 4 this 3 2310  3 num 1 2010  
846 0 0 4 1050 2142 0 0 199 /**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_knots(), and the value must be in the range
 * get_knot(k - 1) <= value <= get_knot(k + 1).
 */ 3 4 this 3 2310  1 k 1 2010  5 value 1 2013  
847 0 0 6 1051 2055 0 0 204 /**
 * Returns true if the NURBS parameters are all internally consistent (e.g.
 * it has the right number of vertices to match its number of knots and order
 * in each dimension), or false otherwise.
 */ 1 4 this 3 2308  
848 0 0 6 1052 2010 0 0 215 /**
 * Returns the order of the curve.  The order is the degree of the NURBS
 * equation plus 1; for a typical NURBS, the order is 4.  With this
 * implementation of NURBS, the order must be in the range [1, 4].
 */ 1 4 this 3 2308  
849 0 0 6 1053 2010 0 0 82 /**
 * Returns the degree of the curve.  For a typical NURBS, the degree is 3.
 */ 1 4 this 3 2308  
850 0 0 6 1054 2010 0 0 39 /**
 * Returns the number of knots.
 */ 1 4 this 3 2308  
851 0 0 6 1055 2010 0 0 367 /**
 * Returns the total number of control vertices that *should* be defined for
 * the curve.  This is determined by the number of knots and the order, in
 * each direction; it does not necessarily reflect the number of vertices that
 * have actually been added to the curve.  (However, if the number of vertices
 * in the curve are wrong, the curve is invalid.)
 */ 1 4 this 3 2308  
852 0 0 6 1056 2055 0 0 204 /**
 * Returns true if the curve appears to be closed.  Since the Egg syntax does
 * not provide a means for explicit indication of closure, this has to be
 * guessed at by examining the curve itself.
 */ 1 4 this 3 2308  
853 0 0 6 1057 2013 0 0 46 /**
 * Returns the nth knot value defined.
 */ 2 4 this 3 2308  1 k 1 2010  
854 0 0 7 1063 2138 0 0 0 0 
855 0 0 7 1066 2311 1859 0 10 /**
 *
 */ 2 4 this 3 2311  4 copy 1 2312  
856 0 0 4 1067 2142 0 0 300 /**
 * Sets the number of subdivisions in the U direction that will be requested
 * across the surface.  (This doesn't necessary guarantee that this number of
 * subdivisions will be made; it's just a hint to any surface renderer or
 * quick tesselator.)  Set the number to 0 to disable the hint.
 */ 2 4 this 3 2311  6 subdiv 1 2010  
857 0 0 6 1068 2010 0 0 134 /**
 * Returns the requested number of subdivisions in the U direction, or 0 if no
 * particular subdivisions have been requested.
 */ 1 4 this 3 2312  
858 0 0 4 1069 2142 0 0 300 /**
 * Sets the number of subdivisions in the U direction that will be requested
 * across the surface.  (This doesn't necessary guarantee that this number of
 * subdivisions will be made; it's just a hint to any surface renderer or
 * quick tesselator.)  Set the number to 0 to disable the hint.
 */ 2 4 this 3 2311  6 subdiv 1 2010  
859 0 0 6 1070 2010 0 0 134 /**
 * Returns the requested number of subdivisions in the U direction, or 0 if no
 * particular subdivisions have been requested.
 */ 1 4 this 3 2312  
860 0 0 7 1071 2138 0 0 0 0 
861 0 0 15 1082 2316 1889 0 10 /**
 *
 */ 1 4 copy 1 2314  
862 0 0 7 1082 2316 1889 0 10 /**
 *
 */ 1 4 name 5 2146  
863 0 0 7 1083 2316 1889 0 10 /**
 *
 */ 2 4 this 3 2316  4 copy 1 2314  
864 0 0 4 1084 2142 0 0 349 /**
 * Prepares a new surface definition with the indicated order and number of
 * knots in each dimension.  This also implies a particular number of vertices
 * in each dimension as well (the number of knots minus the order), but it is
 * up to the user to add the correct number of vertices to the surface by
 * repeatedly calling push_back().
 */ 5 4 this 3 2316  7 u_order 1 2010  7 v_order 1 2010  11 num_u_knots 1 2010  11 num_v_knots 1 2010  
865 0 0 4 1085 2142 0 0 296 /**
 * Directly changes the order in the U direction to the indicated value (which
 * must be an integer in the range 1 <= u_order <= 4).  If possible, it is
 * preferable to use the setup() method instead of this method, since changing
 * the order directly may result in an invalid surface.
 */ 2 4 this 3 2316  7 u_order 1 2010  
866 0 0 4 1086 2142 0 0 296 /**
 * Directly changes the order in the V direction to the indicated value (which
 * must be an integer in the range 1 <= v_order <= 4).  If possible, it is
 * preferable to use the setup() method instead of this method, since changing
 * the order directly may result in an invalid surface.
 */ 2 4 this 3 2316  7 v_order 1 2010  
867 0 0 4 1087 2142 0 0 382 /**
 * Directly changes the number of knots in the U direction.  This will either
 * add zero-valued knots onto the end, or truncate knot values from the end,
 * depending on whether the list is being increased or decreased.  If
 * possible, it is preferable to use the setup() method instead of directly
 * setting the number of knots, as this may result in an invalid surface.
 */ 2 4 this 3 2316  3 num 1 2010  
868 0 0 4 1088 2142 0 0 382 /**
 * Directly changes the number of knots in the V direction.  This will either
 * add zero-valued knots onto the end, or truncate knot values from the end,
 * depending on whether the list is being increased or decreased.  If
 * possible, it is preferable to use the setup() method instead of directly
 * setting the number of knots, as this may result in an invalid surface.
 */ 2 4 this 3 2316  3 num 1 2010  
869 0 0 4 1089 2142 0 0 205 /**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_u_knots(), and the value must be in the range
 * get_u_knot(k - 1) <= value <= get_u_knot(k + 1).
 */ 3 4 this 3 2316  1 k 1 2010  5 value 1 2013  
870 0 0 4 1090 2142 0 0 205 /**
 * Resets the value of the indicated knot as indicated.  k must be in the
 * range 0 <= k < get_num_v_knots(), and the value must be in the range
 * get_v_knot(k - 1) <= value <= get_v_knot(k + 1).
 */ 3 4 this 3 2316  1 k 1 2010  5 value 1 2013  
871 0 0 4 1091 2142 0 0 202 /**
 * Redefines the control vertex associated with a particular u, v coordinate
 * pair.  This is just a shorthand to access the EggPrimitive's normal vertex
 * assignment for a 2-d control vertex.
 */ 4 4 this 3 2316  2 ui 1 2010  2 vi 1 2010  6 vertex 1 2092  
872 0 0 6 1092 2055 0 0 204 /**
 * Returns true if the NURBS parameters are all internally consistent (e.g.
 * it has the right number of vertices to match its number of knots and order
 * in each dimension), or false otherwise.
 */ 1 4 this 3 2314  
873 0 0 6 1093 2010 0 0 235 /**
 * Returns the order of the surface in the U direction.  The order is the
 * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.
 * With this implementation of NURBS, the order must be in the range [1, 4].
 */ 1 4 this 3 2314  
874 0 0 6 1094 2010 0 0 235 /**
 * Returns the order of the surface in the V direction.  The order is the
 * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.
 * With this implementation of NURBS, the order must be in the range [1, 4].
 */ 1 4 this 3 2314  
875 0 0 6 1095 2010 0 0 106 /**
 * Returns the degree of the surface in the U direction.  For a typical NURBS,
 * the degree is 3.
 */ 1 4 this 3 2314  
876 0 0 6 1096 2010 0 0 106 /**
 * Returns the degree of the surface in the V direction.  for a typical NURBS,
 * the degree is 3.
 */ 1 4 this 3 2314  
877 0 0 6 1097 2010 0 0 58 /**
 * Returns the number of knots in the U direction.
 */ 1 4 this 3 2314  
878 0 0 6 1098 2010 0 0 58 /**
 * Returns the number of knots in the V direction.
 */ 1 4 this 3 2314  
879 0 0 6 1099 2010 0 0 351 /**
 * Returns the number of control vertices that should be present in the U
 * direction.  This is determined by the number of knots and the order; it
 * does not necessarily reflect the number of vertices that have actually been
 * added to the surface.  (However, if the number of vertices in the surface
 * are wrong, the surface is invalid.)
 */ 1 4 this 3 2314  
880 0 0 6 1100 2010 0 0 351 /**
 * Returns the number of control vertices that should be present in the V
 * direction.  This is determined by the number of knots and the order; it
 * does not necessarily reflect the number of vertices that have actually been
 * added to the surface.  (However, if the number of vertices in the surface
 * are wrong, the surface is invalid.)
 */ 1 4 this 3 2314  
881 0 0 6 1101 2010 0 0 375 /**
 * Returns the total number of control vertices that *should* be defined for
 * the surface.  This is determined by the number of knots and the order, in
 * each direction; it does not necessarily reflect the number of vertices that
 * have actually been added to the surface.  (However, if the number of
 * vertices in the surface are wrong, the surface is invalid.)
 */ 1 4 this 3 2314  
882 0 0 6 1102 2010 0 0 265 /**
 * Returns the U index number of the given vertex within the EggPrimitive's
 * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices
 * to its 2-d mesh; this returns the U index number that corresponds to the
 * nth vertex in the list.
 */ 2 4 this 3 2314  12 vertex_index 1 2010  
883 0 0 6 1103 2010 0 0 265 /**
 * Returns the V index number of the given vertex within the EggPrimitive's
 * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices
 * to its 2-d mesh; this returns the V index number that corresponds to the
 * nth vertex in the list.
 */ 2 4 this 3 2314  12 vertex_index 1 2010  
884 0 0 6 1104 2010 0 0 111 /**
 * Returns the index number within the EggPrimitive's list of the control
 * vertex at position ui, vi.
 */ 3 4 this 3 2314  2 ui 1 2010  2 vi 1 2010  
885 0 0 6 1105 2055 0 0 227 /**
 * Returns true if the surface appears to be closed in the U direction.  Since
 * the Egg syntax does not provide a means for explicit indication of closure,
 * this has to be guessed at by examining the surface itself.
 */ 1 4 this 3 2314  
886 0 0 6 1106 2055 0 0 227 /**
 * Returns true if the surface appears to be closed in the V direction.  Since
 * the Egg syntax does not provide a means for explicit indication of closure,
 * this has to be guessed at by examining the surface itself.
 */ 1 4 this 3 2314  
887 0 0 6 1107 2013 0 0 65 /**
 * Returns the nth knot value defined in the U direction.
 */ 2 4 this 3 2314  1 k 1 2010  
888 0 0 6 1109 2013 0 0 65 /**
 * Returns the nth knot value defined in the V direction.
 */ 2 4 this 3 2314  1 k 1 2010  
889 0 0 7 1111 2092 1192 0 68 /**
 * Returns the control vertex at the indicate U, V position.
 */ 3 4 this 3 2314  2 ui 1 2010  2 vi 1 2010  
890 0 0 7 1112 2138 0 0 0 0 
891 0 0 15 1115 2319 1893 0 10 /**
 *
 */ 1 4 copy 1 2317  
892 0 0 7 1115 2319 1893 0 10 /**
 *
 */ 1 4 name 5 2146  
893 0 0 7 1116 2319 1893 0 10 /**
 *
 */ 2 4 this 3 2319  4 copy 1 2317  
894 0 0 7 1117 2138 0 0 0 0 
895 0 0 15 1120 2322 1905 0 10 /**
 *
 */ 1 4 copy 1 2320  
896 0 0 7 1120 2322 1905 0 10 /**
 *
 */ 1 4 name 5 2146  
897 0 0 7 1121 2322 1905 0 10 /**
 *
 */ 2 4 this 3 2322  4 copy 1 2320  
898 0 0 6 1122 2055 0 0 10 /**
 *
 */ 1 4 this 3 2320  
899 0 0 6 1123 2013 0 0 109 /**
 * Returns the thickness set on this particular point.  If there is no
 * thickness set, returns 1.0.
 */ 1 4 this 3 2320  
900 0 0 4 1124 2142 0 0 10 /**
 *
 */ 2 4 this 3 2322  5 thick 1 2013  
901 0 0 4 1125 2142 0 0 10 /**
 *
 */ 1 4 this 3 2322  
902 0 0 6 1126 2055 0 0 10 /**
 *
 */ 1 4 this 3 2320  
903 0 0 6 1127 2055 0 0 125 /**
 * Returns the perspective flag set on this particular point.  If there is no
 * perspective flag set, returns false.
 */ 1 4 this 3 2320  
904 0 0 4 1128 2142 0 0 10 /**
 *
 */ 2 4 this 3 2322  11 perspective 1 2055  
905 0 0 4 1129 2142 0 0 10 /**
 *
 */ 1 4 this 3 2322  
906 0 0 7 1130 2138 0 0 0 0 
907 0 0 7 1135 2323 1909 0 10 /**
 *
 */ 0 
908 0 0 4 1136 2142 0 0 316 /**
 * Sets the set of properties that determines which polygons are allowed to be
 * grouped together into a single polyset.  This is the bitwise 'or' of all
 * the properties that matter.  If this is 0, all polygons (within a given
 * group) will be lumped into a common polyset regardless of their properties.
 */ 2 4 this 3 2323  10 properties 1 2010  
909 0 0 7 1137 2138 0 0 0 0 
910 0 0 7 1140 2324 1912 0 10 /**
 *
 */ 0 
911 0 0 7 1141 2138 0 0 0 0 
912 0 0 15 1144 2327 1920 0 10 /**
 *
 */ 1 4 copy 1 2325  
913 0 0 7 1144 2327 1920 0 10 /**
 *
 */ 1 4 name 5 2146  
914 0 0 7 1145 2327 1920 0 10 /**
 *
 */ 2 4 this 3 2327  4 copy 1 2325  
915 0 0 6 1146 2010 0 0 100 /**
 * Returns the number of rows in the table.  For an SAnim table, each row has
 * one column.
 */ 1 4 this 3 2325  
916 0 0 6 1147 2013 0 0 106 /**
 * Returns the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows().
 */ 2 4 this 3 2325  3 row 1 2010  
917 0 0 4 1148 2142 0 0 106 /**
 * Changes the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows().
 */ 3 4 this 3 2327  3 row 1 2010  5 value 1 2013  
918 0 0 4 1149 2142 0 0 100 /**
 * Optimizes the data by collapsing a long table of duplicate values into a
 * single value.
 */ 1 4 this 3 2327  
919 0 0 7 1150 2138 0 0 0 0 
920 0 0 15 1154 2330 1928 0 10 /**
 *
 */ 1 4 copy 1 2328  
921 0 0 7 1154 2330 1928 0 10 /**
 *
 */ 1 4 name 5 2146  
922 0 0 7 1155 2330 1928 0 10 /**
 *
 */ 2 4 this 3 2330  4 copy 1 2328  
923 0 0 4 1156 2142 0 0 10 /**
 *
 */ 2 4 this 3 2330  4 type 1 2128  
924 0 0 6 1157 2128 0 0 10 /**
 *
 */ 1 4 this 3 2328  
925 0 0 6 1158 2055 0 0 90 /**
 * Returns true if the table contains a transform description, false
 * otherwise.
 */ 1 4 this 3 2328  
926 0 0 6 1159 2128 0 0 163 /**
 * Returns the TableType value associated with the given string
 * representation, or TT_invalid if the string does not match any known
 * TableType value.
 */ 1 6 string 1 2146  
927 0 0 7 1160 2138 0 0 0 0 
928 0 0 7 1163 2331 1931 0 10 /**
 *
 */ 0 
929 0 0 15 1163 2331 1931 0 10 /**
 *
 */ 1 4 copy 1 2332  
930 0 0 6 1164 2331 0 0 10 /**
 *
 */ 2 4 this 3 2331  4 copy 1 2332  
931 0 0 4 1166 2142 0 0 52 /**
 * Removes all textures from the collection.
 */ 1 4 this 3 2331  
932 0 0 6 1167 2010 0 0 209 /**
 * Walks the egg hierarchy beginning at the indicated node, and removes any
 * EggTextures encountered in the hierarchy, adding them to the collection.
 * Returns the number of EggTextures encountered.
 */ 2 4 this 3 2331  4 node 1 2004  
933 0 0 6 1168 2055 0 0 86 /**
 * Returns true if there are no EggTexures in the collection, false otherwise.
 */ 1 4 this 3 2332  
934 0 0 6 1169 2010 0 0 63 /**
 * Returns the number of EggTextures in the collection.
 */ 1 4 this 3 2332  
935 0 0 7 1170 2090 1524 0 56 /**
 * Returns the nth EggTexture in the collection.
 */ 2 4 this 3 2332  5 index 1 2010  
936 0 0 6 1172 2010 0 0 1178 /**
 * Walks the egg hierarchy beginning at the indicated node, looking for
 * textures that are referenced by primitives but are not already members of
 * the collection, adding them to the collection.
 *
 * If this is called following extract_textures(), it can be used to pick up
 * any additional texture references that appeared in the egg hierarchy (but
 * whose EggTexture node was not actually part of the hierarchy).
 *
 * If this is called in lieu of extract_textures(), it will fill up the
 * collection with all of the referenced textures (and only the referenced
 * textures), without destructively removing the EggTextures from the
 * hierarchy.
 *
 * This also has the side effect of incrementing the internal usage count for
 * a texture in the collection each time a texture reference is encountered.
 * This side effect is taken advantage of by remove_unused_textures().
 *
 * And one more side effect: this function identifies the presence of
 * multitexturing in the egg file, and calls multitexture_over() on each
 * texture appropriately so that, after this call, you may expect
 * get_multitexture_sort() to return a reasonable value for each texture.
 */ 2 4 this 3 2331  4 node 1 2150  
937 0 0 4 1173 2142 0 0 281 /**
 * Removes any textures from the collection that aren't referenced by any
 * primitives in the indicated egg hierarchy.  This also, incidentally, adds
 * textures to the collection that had been referenced by primitives but had
 * not previously appeared in the collection.
 */ 2 4 this 3 2331  4 node 1 2150  
938 0 0 6 1174 2010 0 0 409 /**
 * Walks through the collection and collapses together any separate textures
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggTexture::is_equivalent_to()).  The return value is the number of
 * textures removed.
 *
 * This flavor of collapse_equivalent_textures() automatically adjusts all the
 * primitives in the egg hierarchy to refer to the new texture pointers.
 */ 3 4 this 3 2331  2 eq 1 2010  4 node 1 2004  
939 0 0 6 1174 2010 0 0 627 /**
 * Walks through the collection and collapses together any separate textures
 * that are equivalent according to the indicated equivalence factor, eq (see
 * EggTexture::is_equivalent_to()).  The return value is the number of
 * textures removed.
 *
 * This flavor of collapse_equivalent_textures() does not adjust any
 * primitives in the egg hierarchy; instead, it fills up the 'removed' map
 * with an entry for each removed texture, mapping it back to the equivalent
 * retained texture.  It's up to the user to then call replace_textures() with
 * this map, if desired, to apply these changes to the egg hierarchy.
 */ 3 4 this 3 2331  2 eq 1 2010  7 removed 1 2334  
940 0 0 4 1175 2142 0 0 297 /**
 * Walks the egg hierarchy, changing out any reference to a texture appearing
 * on the left side of the map with its corresponding texture on the right
 * side.  This is most often done following a call to
 * collapse_equivalent_textures().  It does not directly affect the
 * Collection.
 */ 2 4 node 1 2004  7 replace 1 2337  
941 0 0 4 1176 2142 0 0 130 /**
 * Guarantees that each texture in the collection has a unique TRef name.
 * This is essential before writing an egg file.
 */ 1 4 this 3 2331  
942 0 0 4 1177 2142 0 0 153 /**
 * Sorts all the textures into alphabetical order by TRef name.  Subsequent
 * operations using begin()/end() will traverse in this sorted order.
 */ 1 4 this 3 2331  
943 0 0 4 1178 2142 0 0 202 /**
 * Sorts all the textures into alphabetical order by the basename part
 * (including extension) of the filename.  Subsequent operations using
 * begin()/end() will traverse in this sorted order.
 */ 1 4 this 3 2331  
944 0 0 7 1179 2090 1524 0 56 /**
 * Returns the nth EggTexture in the collection.
 */ 2 4 this 3 2332  1 n 1 2339  
945 0 0 6 1180 2339 0 0 63 /**
 * Returns the number of EggTextures in the collection.
 */ 1 4 this 3 2332  
946 0 0 6 1181 2055 0 0 163 /**
 * Explicitly adds a new texture to the collection.  Returns true if the
 * texture was added, false if it was already there or if there was some
 * error.
 */ 2 4 this 3 2331  7 texture 1 2090  
947 0 0 6 1182 2055 0 0 158 /**
 * Explicitly removes a texture from the collection.  Returns true if the
 * texture was removed, false if it wasn't there or if there was some error.
 */ 2 4 this 3 2331  7 texture 1 2090  
948 0 0 7 1183 2090 1524 0 214 // create_unique_texture() creates a new texture if there is not already one
// equivalent (according to eq, see EggTexture::is_equivalent_to()) to the
// indicated texture, or returns the existing one if there is. 3 4 this 3 2331  4 copy 1 2264  2 eq 1 2010  
949 0 0 7 1184 2090 1524 0 94 /**
 * Returns the texture with the indicated TRef name, or NULL if no texture
 * matches.
 */ 2 4 this 3 2332  9 tref_name 1 2146  
950 0 0 7 1185 2090 1524 0 93 /**
 * Returns the texture with the indicated filename, or NULL if no texture
 * matches.
 */ 2 4 this 3 2332  8 filename 1 2167  
951 0 0 15 1187 2342 1694 0 10 /**
 *
 */ 1 4 copy 1 2340  
952 0 0 7 1187 2342 1694 0 10 /**
 *
 */ 1 4 name 5 2146  
953 0 0 7 1188 2342 1694 0 10 /**
 *
 */ 2 4 this 3 2342  4 copy 1 2340  
954 0 0 7 1189 2138 0 0 0 0 
955 0 0 15 1191 2345 1694 0 10 /**
 *
 */ 1 4 copy 1 2343  
956 0 0 7 1191 2345 1694 0 10 /**
 *
 */ 1 4 name 5 2146  
957 0 0 7 1192 2345 1694 0 10 /**
 *
 */ 2 4 this 3 2345  4 copy 1 2343  
958 0 0 7 1193 2138 0 0 0 0 
959 0 0 23 1195 2348 1980 0 84 /**
 * Converts the older-style XfmAnim table to the newer-style XfmSAnim table.
 */ 1 12 convert_from 1 2346  
960 0 0 15 1195 2348 1980 0 10 /**
 *
 */ 1 4 copy 1 2349  
961 0 0 7 1195 2348 1980 0 10 /**
 *
 */ 2 4 name 5 2146  2 cs 5 2097  
962 0 0 7 1196 2348 1980 0 10 /**
 *
 */ 2 4 this 3 2348  4 copy 1 2349  
963 0 0 4 1197 2142 0 0 10 /**
 *
 */ 2 4 this 3 2348  3 fps 1 2013  
964 0 0 4 1198 2142 0 0 10 /**
 *
 */ 1 4 this 3 2348  
965 0 0 6 1199 2055 0 0 10 /**
 *
 */ 1 4 this 3 2349  
966 0 0 6 1200 2013 0 0 56 /**
 * This is only valid if has_fps() returns true.
 */ 1 4 this 3 2349  
967 0 0 4 1201 2142 0 0 10 /**
 *
 */ 2 4 this 3 2348  5 order 1 2146  
968 0 0 4 1202 2142 0 0 10 /**
 *
 */ 1 4 this 3 2348  
969 0 0 6 1203 2055 0 0 10 /**
 *
 */ 1 4 this 3 2349  
970 0 0 6 1204 2146 0 0 10 /**
 *
 */ 1 4 this 3 2349  
971 0 0 6 1205 2146 0 0 178 /**
 * Returns the standard order of matrix component composition.  This is what
 * the order string must be set to in order to use set_value() or add_data()
 * successfully.
 */ 0 
972 0 0 6 1206 2097 0 0 292 /**
 * Returns the coordinate system this table believes it is defined within.
 * This should always match the coordinate system of the EggData structure
 * that owns it.  It is necessary to store it here because the meaning of the
 * h, p, and r columns depends on the coordinate system.
 */ 1 4 this 3 2349  
973 0 0 4 1207 2142 0 0 66 /**
 * Optimizes the table by collapsing redundant sub-tables.
 */ 1 4 this 3 2348  
974 0 0 4 1208 2142 0 0 225 /**
 * Optimizes the table by collapsing redundant sub-tables, and simultaneously
 * ensures that the order string is the standard order (which is the same as
 * that supported by compose_matrix() and decompose_matrix()).
 */ 1 4 this 3 2348  
975 0 0 4 1209 2142 0 0 241 /**
 * The inverse operation of optimize(), this ensures that all the sub-tables
 * have the same length by duplicating rows as necessary.  This is needed
 * before doing operations like add_data() or set_value() on an existing
 * table.
 */ 1 4 this 3 2348  
976 0 0 6 1210 2010 0 0 259 /**
 * Returns the effective number of rows in the table.  This is actually the
 * number of rows of the smallest subtable larger than one row.  This is a
 * convenience function that treats the table of tables as if it were a single
 * table of matrices.
 */ 1 4 this 3 2349  
977 0 0 4 1211 2142 0 0 342 /**
 * Returns the value of the aggregate row of the table as a matrix.  This is a
 * convenience function that treats the table of tables as if it were a single
 * table of matrices.  It is an error to call this if any SAnimData children
 * of this node have an improper name (e.g.  not a single letter, or not one
 * of "ijkabchprxyz").
 */ 3 4 this 3 2349  3 row 1 2010  3 mat 1 2351  
978 0 0 6 1212 2055 0 0 387 /**
 * Replaces the indicated row of the table with the given matrix.
 *
 * This function can only be called if all the constraints of add_data(),
 * below, are met.  Call normalize() first if you are not sure.
 *
 * The return value is true if the matrix can be decomposed and stored as
 * scale, shear, rotate, and translate, or false otherwise.  The data is set
 * in either case.
 */ 3 4 this 3 2348  3 row 1 2010  3 mat 1 2153  
979 0 0 4 1213 2142 0 0 93 /**
 * Removes all data from the table.  It does this by removing all of its
 * children.
 */ 1 4 this 3 2348  
980 0 0 6 1214 2055 0 0 1136 /**
 * Adds a new matrix to the table, by adding a new row to each of the
 * subtables.
 *
 * This is a convenience function that treats the table of tables as if it
 * were a single table of matrices.  It is an error to call this if any
 * SAnimData children of this node have an improper name (e.g.  not a single
 * letter, or not one of "ijkabchprxyz").
 *
 * This function has the further requirement that all nine of the subtables
 * must exist and be of the same length.  Furthermore, the order string must
 * be the standard order string, which matches the system compose_matrix() and
 * decompose_matrix() functions.
 *
 * Thus, you probably cannot take an existing EggXfmSAnim object and start
 * adding matrices to the end; you must clear out the original data first.
 * (As a special exception, if no tables exist, they will be created.)  The
 * method normalize() will do this for you on an existing EggXfmSAnim.
 *
 * This function may fail silently if the matrix cannot be decomposed into
 * scale, shear, rotate, and translate.  In this case, the closest
 * approximation is added to the table, and false is returned.
 */ 2 4 this 3 2348  3 mat 1 2153  
981 0 0 4 1215 2142 0 0 73 /**
 * Adds a new row to the indicated component (0-12) of the table.
 */ 3 4 this 3 2348  9 component 1 2010  5 value 1 2013  
982 0 0 4 1215 2142 0 0 99 /**
 * Adds a new row to the named component (one of matrix_component_letters) of
 * the table.
 */ 3 4 this 3 2348  14 component_name 1 2146  5 value 1 2013  
983 0 0 4 1216 2142 0 0 172 /**
 * Composes a matrix out of the nine individual components, respecting the
 * order string.  The components will be applied in the order indicated by the
 * string.
 */ 7 3 mat 1 2351  5 scale 1 2241  5 shear 1 2241  3 hpr 1 2241  5 trans 1 2241  5 order 1 2146  2 cs 1 2097  
984 0 0 7 1217 2138 0 0 0 0 
985 0 0 15 1220 2352 1997 0 10 /**
 *
 */ 1 4 copy 1 2346  
986 0 0 23 1220 2352 1997 0 84 /**
 * Converts the newer-style XfmSAnim table to the older-style XfmAnim table.
 */ 1 12 convert_from 1 2349  
987 0 0 7 1220 2352 1997 0 10 /**
 *
 */ 2 4 name 5 2146  2 cs 5 2097  
988 0 0 7 1221 2352 1997 0 10 /**
 *
 */ 2 4 this 3 2352  4 copy 1 2346  
989 0 0 4 1222 2142 0 0 10 /**
 *
 */ 2 4 this 3 2352  5 order 1 2146  
990 0 0 4 1223 2142 0 0 10 /**
 *
 */ 1 4 this 3 2352  
991 0 0 6 1224 2055 0 0 10 /**
 *
 */ 1 4 this 3 2346  
992 0 0 6 1225 2146 0 0 10 /**
 *
 */ 1 4 this 3 2346  
993 0 0 6 1226 2146 0 0 178 /**
 * Returns the standard order of matrix component composition.  This is what
 * the order string must be set to in order to use set_value() or add_data()
 * successfully.
 */ 0 
994 0 0 4 1227 2142 0 0 10 /**
 *
 */ 2 4 this 3 2352  8 contents 1 2146  
995 0 0 4 1228 2142 0 0 10 /**
 *
 */ 1 4 this 3 2352  
996 0 0 6 1229 2055 0 0 10 /**
 *
 */ 1 4 this 3 2346  
997 0 0 6 1230 2146 0 0 10 /**
 *
 */ 1 4 this 3 2346  
998 0 0 6 1231 2097 0 0 292 /**
 * Returns the coordinate system this table believes it is defined within.
 * This should always match the coordinate system of the EggData structure
 * that owns it.  It is necessary to store it here because the meaning of the
 * h, p, and r columns depends on the coordinate system.
 */ 1 4 this 3 2346  
999 0 0 6 1232 2010 0 0 51 /**
 * Returns the number of rows in the table.
 */ 1 4 this 3 2346  
1000 0 0 6 1233 2010 0 0 148 /**
 * Returns the number of columns in the table.  This is set according to the
 * "contents" string, which defines the meaning of each column.
 */ 1 4 this 3 2346  
1001 0 0 4 1234 2142 0 0 181 /**
 * Returns the value of the aggregate row of the table as a matrix.  This is a
 * convenience function that treats the 2-d table as if it were a single table
 * of matrices.
 */ 3 4 this 3 2346  3 row 1 2010  3 mat 1 2351  
1002 0 0 6 1234 2013 0 0 158 /**
 * Returns the value at the indicated row.  Row must be in the range 0 <= row
 * < get_num_rows(); col must be in the range 0 <= col < get_num_cols().
 */ 3 4 this 3 2346  3 row 1 2010  3 col 1 2010  
1003 0 0 7 1235 2138 0 0 0 0 
1004 0 0 7 1042 2272 1774 0 53 /**
 * Parses an EggData from the raw egg syntax.
 */ 1 10 egg_syntax 1 2146  
1005 0 0 7 1043 2150 1102 0 60 /**
 * Parses a single egg node from the raw egg syntax.
 */ 1 10 egg_syntax 1 2146  
355
1998 11 EggUserData 0 75777 11 EggUserData 11 EggUserData 0 0 0 1 1006 0 0 2 1007 1008 0 0 1 0 1999 0 0 0 0 352
/**
 * This is a base class for a user-defined data type to extend egg structures
 * in processing code.  The user of the egg library may derive from
 * EggUserData to associate any arbitrary data with various egg objects.
 *
 * However, this data will not be written out to the disk when the egg file is
 * written; it is an in-memory object only.
 */

1999 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

2000 9 EggObject 0 75777 9 EggObject 9 EggObject 0 0 0 1 1009 0 0 6 1010 1011 1012 1013 1014 1015 0 0 1 0 1999 0 0 0 0 108
/**
 * The highest-level base class in the egg directory.  (Almost) all things egg
 * inherit from this.
 */

2001 14 EggNamedObject 0 141313 14 EggNamedObject 14 EggNamedObject 0 0 0 1 1020 1024 0 3 1021 1022 1023 0 0 2 3 2000 1016 1017 3 2002 1018 1019 0 0 81
/**
 * This is a fairly low-level base class--any egg object that has a name.
 */

2002 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

2003 7 EggNode 0 141313 7 EggNode 7 EggNode 0 0 0 0 1102 2 2353 2355 39 1025 1026 1027 1028 1029 1030 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 0 0 1 0 2001 0 0 0 0 194
/**
 * A base class for things that may be directly added into the egg hierarchy.
 * This includes groups, joints, polygons, vertex pools, etc., but does not
 * include things like vertices.
 */

2004 14 EggGroupNode * 0 8576 14 EggGroupNode * 14 EggGroupNode * 0 0 2005 0 0 0 0 0 0 0 0 0 0

2005 12 EggGroupNode 0 75777 12 EggGroupNode 12 EggGroupNode 0 0 0 1 1031 0 1 2354 37 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 0 0 1 0 2003 0 0 0 1 2009 417
/**
 * A base class for nodes in the hierarchy that are not leaf nodes.  (See also
 * EggGroup, which is specifically the "<Group>" node in egg.)
 *
 * An EggGroupNode is an STL-style container of pointers to EggNodes, like a
 * vector.  Functions push_back()/pop_back() and insert()/erase() are provided
 * to manipulate the list.  The list may also be operated on (read-only) via
 * iterators and begin()/end().
 */

2006 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 2007 0 0 0 0 0 0 0 0 0 0

2007 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 2008 0 0 0 0 0 0 0 0 0 0

2008 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

2009 16 TriangulateFlags 0 794624 30 EggGroupNode::TriangulateFlags 30 EggGroupNode::TriangulateFlags 2005 0 0 0 0 0 0 0 0 0 5 9 T_polygon 23 EggGroupNode::T_polygon 0
1 8 T_convex 22 EggGroupNode::T_convex 0
2 11 T_composite 25 EggGroupNode::T_composite 0
4 9 T_recurse 23 EggGroupNode::T_recurse 0
8 13 T_flat_shaded 27 EggGroupNode::T_flat_shaded 0
16 0 0

2010 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

2011 11 EggAnimData 0 141313 11 EggAnimData 11 EggAnimData 0 0 0 0 1113 0 10 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 0 0 1 0 2003 0 0 0 0 106
/**
 * A base class for EggSAnimData and EggXfmAnimData, which contain rows and
 * columns of numbers.
 */

2012 14 EggAnimPreload 0 141313 14 EggAnimPreload 14 EggAnimPreload 0 0 0 1 1114 1125 2 2356 2357 10 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 0 0 1 0 2003 0 0 0 0 54
/**
 * This corresponds to an <AnimPreload> entry.
 */

2013 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

2014 13 EggAttributes 0 26625 13 EggAttributes 13 EggAttributes 0 0 0 1 1128 1130 2 2358 2359 18 1129 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1149 0 0 1 3 2015 1126 1127 0 0 340
/**
 * The set of attributes that may be applied to vertices as well as polygons,
 * such as surface normal and color.
 *
 * This class cannot inherit from EggObject, because it causes problems at the
 * EggPolygon level with multiple appearances of the EggObject base class.
 * And making EggObject a virtual base class is just no fun.
 */

2015 10 MemoryBase 0 2048 10 MemoryBase 10 MemoryBase 0 0 0 0 0 0 0 0 0 0 0 0 428
/**
 * This class is intended to be the base class of all objects in Panda that
 * might be allocated and deleted via the new and delete operators.  It
 * redefines these operators to provide some memory tracking support.
 *
 * We used to try to override the global operator new and delete methods, but
 * that seems to cause problems when including header files for C++-based
 * system libraries (such as are found on OSX).
 */

2016 18 EggMorphNormalList 0 2105344 18 EggMorphNormalList 18 EggMorphNormalList 0 0 2017 0 0 0 0 0 0 0 0 0 0

2017 30 EggMorphList< EggMorphNormal > 0 1050624 30 EggMorphList< EggMorphNormal > 30 EggMorphList< EggMorphNormal > 0 0 0 0 0 0 0 0 0 0 0 0 0

2018 17 EggMorphColorList 0 2105344 17 EggMorphColorList 17 EggMorphColorList 0 0 2019 0 0 0 0 0 0 0 0 0 0

2019 29 EggMorphList< EggMorphColor > 0 1050624 29 EggMorphList< EggMorphColor > 29 EggMorphList< EggMorphColor > 0 0 0 0 0 0 0 0 0 0 0 0 0

2020 11 EggVertexUV 0 75777 11 EggVertexUV 11 EggVertexUV 0 0 0 1 1150 1024 1 2360 25 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1176 0 0 1 0 2001 0 0 0 0 188
/**
 * The set of UV's that may or may not be assigned to a vertex.  To support
 * multitexturing, there may be multiple sets of UV's on a particular vertex,
 * each with its own name.
 */

2021 20 EggMorphTexCoordList 0 2105344 20 EggMorphTexCoordList 20 EggMorphTexCoordList 0 0 2022 0 0 0 0 0 0 0 0 0 0

2022 32 EggMorphList< EggMorphTexCoord > 0 1050624 32 EggMorphList< EggMorphTexCoord > 32 EggMorphList< EggMorphTexCoord > 0 0 0 0 0 0 0 0 0 0 0 0 0

2023 12 EggVertexAux 0 75777 12 EggVertexAux 12 EggVertexAux 0 0 0 1 1177 1024 0 8 1178 1179 1180 1181 1182 1183 1184 1185 0 0 1 0 2001 0 0 0 0 267
/**
 * The set of named auxiliary data that may or may not be assigned to a
 * vertex.  Panda will import this data and create a custom column for it in
 * the vertex data, but will not otherwise interpret it.  Presumably, a shader
 * will process the data later.
 */

2024 9 EggVertex 0 26625 9 EggVertex 9 EggVertex 0 0 0 1 1190 1192 1 2361 47 1191 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1239 0 0 2 3 2000 1186 1187 3 2014 1188 1189 0 0 106
/**
 * Any one-, two-, three-, or four-component vertex, possibly with attributes
 * such as a normal.
 */

2025 18 EggMorphVertexList 0 2105344 18 EggMorphVertexList 18 EggMorphVertexList 0 0 2026 0 0 0 0 0 0 0 0 0 0

2026 30 EggMorphList< EggMorphVertex > 0 1050624 30 EggMorphList< EggMorphVertex > 30 EggMorphList< EggMorphVertex > 0 0 0 0 0 0 0 0 0 0 0 0 0

2027 13 EggVertexPool 0 75777 13 EggVertexPool 13 EggVertexPool 0 0 0 1 1240 1102 0 28 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 0 0 1 0 2003 0 0 0 0 553
/**
 * A collection of vertices.  There may be any number of vertex pools in a
 * single egg structure.  The vertices in a single pool need not necessarily
 * have any connection to each other, but it is necessary that any one
 * primitive (e.g.  a polygon) must pull all its vertices from the same pool.
 *
 * An EggVertexPool is an STL-style container of pointers to EggVertex's.
 * Functions add_vertex() and remove_vertex() are provided to manipulate the
 * list.  The list may also be operated on (read-only) via iterators and
 * begin()/end().
 */

2028 13 EggRenderMode 0 141313 13 EggRenderMode 13 EggRenderMode 0 0 0 1 1269 1300 0 30 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 0 0 0 0 4 2029 2030 2031 2032 516
/**
 * This class stores miscellaneous rendering properties that is associated
 * with geometry, and which may be set on the geometry primitive level, on the
 * group above it, or indirectly via a texture.  It's intended to be a base
 * class for egg objects that can have these properties set.
 *
 * This class cannot inherit from EggObject, because it causes problems at the
 * EggPolygon level with multiple appearances of the EggObject base class.
 * And making EggObject a virtual base class is just no fun.
 */

2029 9 AlphaMode 0 794624 24 EggRenderMode::AlphaMode 24 EggRenderMode::AlphaMode 2028 0 0 0 0 0 0 0 0 0 10 14 AM_unspecified 29 EggRenderMode::AM_unspecified 0
0 6 AM_off 21 EggRenderMode::AM_off 19
// No transparency.
1 5 AM_on 20 EggRenderMode::AM_on 37
// Use whatever the default model is.
2 8 AM_blend 23 EggRenderMode::AM_blend 59
// Normal alpha blending, e.g. TransparencyAttrib::M_alpha.
3 19 AM_blend_no_occlude 34 EggRenderMode::AM_blend_no_occlude 34
// Alpha blending w/o depth write.
4 5 AM_ms 20 EggRenderMode::AM_ms 36
// TransparencyAttrib::M_multisample
5 10 AM_ms_mask 25 EggRenderMode::AM_ms_mask 41
// TransparencyAttrib::M_multisample_mask
6 9 AM_binary 24 EggRenderMode::AM_binary 31
// TransparencyAttrib::M_binary
7 7 AM_dual 22 EggRenderMode::AM_dual 29
// TransparencyAttrib::M_dual
8 16 AM_premultiplied 31 EggRenderMode::AM_premultiplied 44
// TransparencyAttrib::M_premultiplied_alpha
9 0 44
// Specifies implementation of transparency.

2030 14 DepthWriteMode 0 794624 29 EggRenderMode::DepthWriteMode 29 EggRenderMode::DepthWriteMode 2028 0 0 0 0 0 0 0 0 0 3 15 DWM_unspecified 30 EggRenderMode::DWM_unspecified 0
0 7 DWM_off 22 EggRenderMode::DWM_off 0
1 6 DWM_on 21 EggRenderMode::DWM_on 0
2 0 0

2031 13 DepthTestMode 0 794624 28 EggRenderMode::DepthTestMode 28 EggRenderMode::DepthTestMode 2028 0 0 0 0 0 0 0 0 0 3 15 DTM_unspecified 30 EggRenderMode::DTM_unspecified 0
0 7 DTM_off 22 EggRenderMode::DTM_off 0
1 6 DTM_on 21 EggRenderMode::DTM_on 0
2 0 0

2032 14 VisibilityMode 0 794624 29 EggRenderMode::VisibilityMode 29 EggRenderMode::VisibilityMode 2028 0 0 0 0 0 0 0 0 0 3 14 VM_unspecified 29 EggRenderMode::VM_unspecified 0
0 9 VM_hidden 24 EggRenderMode::VM_hidden 0
1 9 VM_normal 24 EggRenderMode::VM_normal 0
2 0 0

2033 12 EggTransform 0 26625 12 EggTransform 12 EggTransform 0 0 0 1 1303 1305 0 30 1304 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 0 0 1 3 2015 1301 1302 0 1 2034 313
/**
 * This represents the <Transform> entry of a group or texture node: a list of
 * component transform operations, applied in order, that describe a net
 * transform matrix.
 *
 * This may be either a 3-d transform, and therefore described by a 4x4
 * matrix, or a 2-d transform, described by a 3x3 matrix.
 */

2034 13 ComponentType 0 794624 27 EggTransform::ComponentType 27 EggTransform::ComponentType 2033 0 0 0 0 0 0 0 0 0 13 10 CT_invalid 24 EggTransform::CT_invalid 0
0 14 CT_translate2d 28 EggTransform::CT_translate2d 0
1 14 CT_translate3d 28 EggTransform::CT_translate3d 0
2 11 CT_rotate2d 25 EggTransform::CT_rotate2d 0
3 7 CT_rotx 21 EggTransform::CT_rotx 0
4 7 CT_roty 21 EggTransform::CT_roty 0
5 7 CT_rotz 21 EggTransform::CT_rotz 0
6 11 CT_rotate3d 25 EggTransform::CT_rotate3d 0
7 10 CT_scale2d 24 EggTransform::CT_scale2d 0
8 10 CT_scale3d 24 EggTransform::CT_scale3d 0
9 16 CT_uniform_scale 30 EggTransform::CT_uniform_scale 0
10 10 CT_matrix3 24 EggTransform::CT_matrix3 0
11 10 CT_matrix4 24 EggTransform::CT_matrix4 0
12 0 0

2035 18 EggSwitchCondition 0 141313 18 EggSwitchCondition 18 EggSwitchCondition 0 0 0 0 1339 0 4 1335 1336 1337 1338 0 0 1 0 2000 0 0 0 0 340
/**
 * This corresponds to a <SwitchCondition> entry within a group.  It indicates
 * the condition at which a level-of-detail is switched in or out.  This is
 * actually an abstract base class for potentially any number of specific
 * different kinds of switching conditions; presently, only a <Distance> type
 * is actually supported.
 */

2036 26 EggSwitchConditionDistance 0 141313 26 EggSwitchConditionDistance 26 EggSwitchConditionDistance 0 0 0 1 1340 1342 0 1 1341 0 0 1 0 2035 0 0 0 0 112
/**
 * A SwitchCondition that switches the levels-of-detail based on distance from
 * the camera's eyepoint.
 */

2037 8 EggGroup 0 26625 8 EggGroup 8 EggGroup 0 0 0 1 1349 1351 32 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 136 1350 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 2 2452 2453 0 3 3 2005 1343 1344 3 2028 1345 1346 3 2033 1347 1348 0 10 2038 2040 2042 2043 2044 2045 2046 2047 2048 2049 118
/**
 * The main glue of the egg hierarchy, this corresponds to the <Group>,
 * <Instance>, and <Joint> type nodes.
 */

2038 9 VertexRef 0 2367488 19 EggGroup::VertexRef 19 EggGroup::VertexRef 2037 0 2039 0 0 0 0 0 0 0 0 0 0

2039 27 map< PT_EggVertex, double > 0 2048 27 map< PT_EggVertex, double > 27 map< PT_EggVertex, double > 0 0 0 0 0 0 0 0 0 0 0 0 0

2040 7 TagData 0 2367488 17 EggGroup::TagData 17 EggGroup::TagData 2037 0 2041 0 0 0 0 0 0 0 0 0 0

2041 21 map< string, string > 0 2048 31 map< std::string, std::string > 31 map< std::string, std::string > 0 0 0 0 0 0 0 0 0 0 0 0 0

2042 9 GroupType 0 794624 19 EggGroup::GroupType 19 EggGroup::GroupType 2037 0 0 0 0 0 0 0 0 0 4 10 GT_invalid 20 EggGroup::GT_invalid 58
// The bits here must correspond to those in Flags, below.
-1 8 GT_group 18 EggGroup::GT_group 0
0 11 GT_instance 21 EggGroup::GT_instance 0
1 8 GT_joint 18 EggGroup::GT_joint 0
2 0 49
// These bits are all stored somewhere in _flags.

2043 7 DCSType 0 794624 17 EggGroup::DCSType 17 EggGroup::DCSType 2037 0 0 0 0 0 0 0 0 0 6 14 DC_unspecified 24 EggGroup::DC_unspecified 59
// The bits here must correspond to those in Flags2, below.
0 7 DC_none 17 EggGroup::DC_none 0
16 8 DC_local 18 EggGroup::DC_local 0
32 6 DC_net 16 EggGroup::DC_net 0
48 11 DC_no_touch 21 EggGroup::DC_no_touch 0
64 10 DC_default 20 EggGroup::DC_default 0
80 0 0

2044 13 BillboardType 0 794624 23 EggGroup::BillboardType 23 EggGroup::BillboardType 2037 0 0 0 0 0 0 0 0 0 4 7 BT_none 17 EggGroup::BT_none 58
// The bits here must correspond to those in Flags, below.
0 7 BT_axis 17 EggGroup::BT_axis 0
32 24 BT_point_camera_relative 34 EggGroup::BT_point_camera_relative 0
64 23 BT_point_world_relative 33 EggGroup::BT_point_world_relative 0
128 0 0

2045 18 CollisionSolidType 0 794624 28 EggGroup::CollisionSolidType 28 EggGroup::CollisionSolidType 2037 0 0 0 0 0 0 0 0 0 9 8 CST_none 18 EggGroup::CST_none 97
// The bits here must correspond to those in Flags, below, and they must
// fit within F_cs_type.
0 9 CST_plane 19 EggGroup::CST_plane 0
65536 11 CST_polygon 21 EggGroup::CST_polygon 0
131072 11 CST_polyset 21 EggGroup::CST_polyset 0
196608 10 CST_sphere 20 EggGroup::CST_sphere 0
262144 8 CST_tube 18 EggGroup::CST_tube 0
327680 14 CST_inv_sphere 24 EggGroup::CST_inv_sphere 0
393216 7 CST_box 17 EggGroup::CST_box 0
458752 14 CST_floor_mesh 24 EggGroup::CST_floor_mesh 0
524288 0 0

2046 12 CollideFlags 0 794624 22 EggGroup::CollideFlags 22 EggGroup::CollideFlags 2037 0 0 0 0 0 0 0 0 0 9 7 CF_none 17 EggGroup::CF_none 103
// The bits here must correspond to those in Flags, below, and they must
// fit within F_collide_flags.
0 10 CF_descend 20 EggGroup::CF_descend 0
1048576 8 CF_event 18 EggGroup::CF_event 0
2097152 7 CF_keep 17 EggGroup::CF_keep 0
4194304 8 CF_solid 18 EggGroup::CF_solid 0
8388608 9 CF_center 19 EggGroup::CF_center 0
16777216 12 CF_turnstile 22 EggGroup::CF_turnstile 0
33554432 8 CF_level 18 EggGroup::CF_level 0
67108864 13 CF_intangible 23 EggGroup::CF_intangible 0
134217728 0 0

2047 8 DartType 0 794624 18 EggGroup::DartType 18 EggGroup::DartType 2037 0 0 0 0 0 0 0 0 0 5 7 DT_none 17 EggGroup::DT_none 58
// The bits here must correspond to those in Flags, below.
0 13 DT_structured 23 EggGroup::DT_structured 0
268435456 7 DT_sync 17 EggGroup::DT_sync 0
536870912 9 DT_nosync 19 EggGroup::DT_nosync 0
805306368 10 DT_default 20 EggGroup::DT_default 0
1073741824 0 0

2048 9 BlendMode 0 794624 19 EggGroup::BlendMode 19 EggGroup::BlendMode 2037 0 0 0 0 0 0 0 0 0 7 14 BM_unspecified 24 EggGroup::BM_unspecified 0
0 7 BM_none 17 EggGroup::BM_none 0
1 6 BM_add 16 EggGroup::BM_add 0
2 11 BM_subtract 21 EggGroup::BM_subtract 0
3 15 BM_inv_subtract 25 EggGroup::BM_inv_subtract 0
4 6 BM_min 16 EggGroup::BM_min 0
5 6 BM_max 16 EggGroup::BM_max 0
6 0 68
// These correspond to ColorBlendAttrib::Mode (but not numerically).

2049 12 BlendOperand 0 794624 22 EggGroup::BlendOperand 22 EggGroup::BlendOperand 2037 0 0 0 0 0 0 0 0 0 20 14 BO_unspecified 24 EggGroup::BO_unspecified 0
0 7 BO_zero 17 EggGroup::BO_zero 0
1 6 BO_one 16 EggGroup::BO_one 0
2 17 BO_incoming_color 27 EggGroup::BO_incoming_color 0
3 27 BO_one_minus_incoming_color 37 EggGroup::BO_one_minus_incoming_color 0
4 16 BO_fbuffer_color 26 EggGroup::BO_fbuffer_color 0
5 26 BO_one_minus_fbuffer_color 36 EggGroup::BO_one_minus_fbuffer_color 0
6 17 BO_incoming_alpha 27 EggGroup::BO_incoming_alpha 0
7 27 BO_one_minus_incoming_alpha 37 EggGroup::BO_one_minus_incoming_alpha 0
8 16 BO_fbuffer_alpha 26 EggGroup::BO_fbuffer_alpha 0
9 26 BO_one_minus_fbuffer_alpha 36 EggGroup::BO_one_minus_fbuffer_alpha 0
10 17 BO_constant_color 27 EggGroup::BO_constant_color 0
11 27 BO_one_minus_constant_color 37 EggGroup::BO_one_minus_constant_color 0
12 17 BO_constant_alpha 27 EggGroup::BO_constant_alpha 0
13 27 BO_one_minus_constant_alpha 37 EggGroup::BO_one_minus_constant_alpha 0
14 26 BO_incoming_color_saturate 36 EggGroup::BO_incoming_color_saturate 0
15 14 BO_color_scale 24 EggGroup::BO_color_scale 0
16 24 BO_one_minus_color_scale 34 EggGroup::BO_one_minus_color_scale 0
17 14 BO_alpha_scale 24 EggGroup::BO_alpha_scale 0
18 24 BO_one_minus_alpha_scale 34 EggGroup::BO_one_minus_alpha_scale 0
19 0 71
// These correspond to ColorBlendAttrib::Operand (but not numerically).

2050 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 2051 0 0 0 0 0 0 0 0 0 0

2051 8 LPoint3d 0 2048 8 LPoint3d 8 LPoint3d 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

2052 12 string const 0 8832 17 std::string const 17 std::string const 0 0 2053 0 0 0 0 0 0 0 0 0 0

2053 6 string 0 2105344 11 std::string 11 std::string 0 0 2054 0 0 0 0 0 0 0 0 0 0

2054 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

2055 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

2056 11 CollideMask 0 2105344 11 CollideMask 11 CollideMask 0 0 2057 0 0 0 0 0 0 0 0 0 0

2057 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 2058 0 0 0 0 0 0 0 0 0 0

2058 23 BitMask< uint32_t, 32 > 0 2048 23 BitMask< uint32_t, 32 > 23 BitMask< uint32_t, 32 > 0 0 0 0 0 0 0 0 0 0 0 0 0

2059 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 2060 0 0 0 0 0 0 0 0 0 0

2060 6 LColor 0 2105344 6 LColor 6 LColor 0 0 2061 0 0 0 0 0 0 0 0 0 0

2061 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 2062 0 0 0 0 0 0 0 0 0 0

2062 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2063 24 EggSwitchCondition const 0 8832 24 EggSwitchCondition const 24 EggSwitchCondition const 0 0 2035 0 0 0 0 0 0 0 0 0 0

2064 18 EggTransform const 0 8832 18 EggTransform const 18 EggTransform const 0 0 2033 0 0 0 0 0 0 0 0 0 0

2065 6 EggBin 0 141313 6 EggBin 6 EggBin 0 0 0 1 1487 1491 0 3 1488 1489 1490 0 0 1 0 2037 0 0 0 0 233
/**
 * A type of group node that holds related subnodes.  This is a special kind
 * of node that will never be read in from an egg file, but can only exist in
 * the egg scene graph if it is created via the use of an EggBinMaker.
 */

2066 11 EggBinMaker 0 75777 11 EggBinMaker 11 EggBinMaker 0 0 0 0 0 0 8 1492 1493 1494 1495 1496 1497 1498 1499 0 0 1 0 2000 0 0 0 0 183
/**
 * This is a handy class for collecting related nodes together.  It is an
 * abstract class; to use it you must subclass off of it.  See the somewhat
 * lengthy comment above.
 */

2067 10 EggComment 0 141313 10 EggComment 10 EggComment 0 0 0 1 1500 1507 0 5 1501 1503 1504 1505 1506 0 1 1502 1 0 2003 0 0 0 0 74
/**
 * A comment that appears in an egg file within a <Comment> entry.
 */

2068 15 EggFilenameNode 0 141313 15 EggFilenameNode 15 EggFilenameNode 0 0 0 0 1515 0 7 1508 1509 1510 1511 1512 1513 1514 0 0 1 0 2003 0 0 0 0 208
/**
 * This is an egg node that contains a filename.  It references a physical
 * file relative to the directory the egg file was loaded in.  It is a base
 * class for EggTexture and EggExternalReference.
 */

2069 10 EggTexture 0 26625 10 EggTexture 10 EggTexture 0 0 0 1 1522 1524 31 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 118 1523 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 0 0 3 3 2068 1516 1517 3 2028 1518 1519 3 2033 1520 1521 0 14 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 65
/**
 * Defines a texture map that may be applied to geometry.
 */

2070 11 Equivalence 0 794624 23 EggTexture::Equivalence 23 EggTexture::Equivalence 2069 0 0 0 0 0 0 0 0 0 7 10 E_basename 22 EggTexture::E_basename 0
1 11 E_extension 23 EggTexture::E_extension 0
2 9 E_dirname 21 EggTexture::E_dirname 0
4 19 E_complete_filename 31 EggTexture::E_complete_filename 0
7 11 E_transform 23 EggTexture::E_transform 0
8 12 E_attributes 24 EggTexture::E_attributes 0
16 11 E_tref_name 23 EggTexture::E_tref_name 0
32 0 0

2071 11 TextureType 0 794624 23 EggTexture::TextureType 23 EggTexture::TextureType 2069 0 0 0 0 0 0 0 0 0 5 14 TT_unspecified 26 EggTexture::TT_unspecified 0
0 13 TT_1d_texture 25 EggTexture::TT_1d_texture 0
1 13 TT_2d_texture 25 EggTexture::TT_2d_texture 0
2 13 TT_3d_texture 25 EggTexture::TT_3d_texture 0
3 11 TT_cube_map 23 EggTexture::TT_cube_map 0
4 0 0

2072 6 Format 0 794624 18 EggTexture::Format 18 EggTexture::Format 2069 0 0 0 0 0 0 0 0 0 23 13 F_unspecified 25 EggTexture::F_unspecified 0
0 6 F_rgba 18 EggTexture::F_rgba 0
1 6 F_rgbm 18 EggTexture::F_rgbm 0
2 8 F_rgba12 20 EggTexture::F_rgba12 0
3 7 F_rgba8 19 EggTexture::F_rgba8 0
4 7 F_rgba4 19 EggTexture::F_rgba4 0
5 7 F_rgba5 19 EggTexture::F_rgba5 0
6 5 F_rgb 17 EggTexture::F_rgb 0
7 7 F_rgb12 19 EggTexture::F_rgb12 0
8 6 F_rgb8 18 EggTexture::F_rgb8 0
9 6 F_rgb5 18 EggTexture::F_rgb5 0
10 8 F_rgb332 20 EggTexture::F_rgb332 0
11 5 F_red 17 EggTexture::F_red 0
12 7 F_green 19 EggTexture::F_green 0
13 6 F_blue 18 EggTexture::F_blue 0
14 7 F_alpha 19 EggTexture::F_alpha 0
15 11 F_luminance 23 EggTexture::F_luminance 0
16 17 F_luminance_alpha 29 EggTexture::F_luminance_alpha 0
17 21 F_luminance_alphamask 33 EggTexture::F_luminance_alphamask 0
18 6 F_srgb 18 EggTexture::F_srgb 56
// Only for compatibility with .bam, use is discouraged!
19 12 F_srgb_alpha 24 EggTexture::F_srgb_alpha 56
// Only for compatibility with .bam, use is discouraged!
20 12 F_sluminance 24 EggTexture::F_sluminance 0
21 18 F_sluminance_alpha 30 EggTexture::F_sluminance_alpha 0
22 0 0

2073 15 CompressionMode 0 794624 27 EggTexture::CompressionMode 27 EggTexture::CompressionMode 2069 0 0 0 0 0 0 0 0 0 9 10 CM_default 22 EggTexture::CM_default 0
0 6 CM_off 18 EggTexture::CM_off 0
1 5 CM_on 17 EggTexture::CM_on 0
2 7 CM_fxt1 19 EggTexture::CM_fxt1 0
3 7 CM_dxt1 19 EggTexture::CM_dxt1 0
4 7 CM_dxt2 19 EggTexture::CM_dxt2 0
5 7 CM_dxt3 19 EggTexture::CM_dxt3 0
6 7 CM_dxt4 19 EggTexture::CM_dxt4 0
7 7 CM_dxt5 19 EggTexture::CM_dxt5 0
8 0 0

2074 8 WrapMode 0 794624 20 EggTexture::WrapMode 20 EggTexture::WrapMode 2069 0 0 0 0 0 0 0 0 0 6 14 WM_unspecified 26 EggTexture::WM_unspecified 0
0 8 WM_clamp 20 EggTexture::WM_clamp 0
1 9 WM_repeat 21 EggTexture::WM_repeat 0
2 9 WM_mirror 21 EggTexture::WM_mirror 0
3 14 WM_mirror_once 26 EggTexture::WM_mirror_once 0
4 15 WM_border_color 27 EggTexture::WM_border_color 0
5 0 0

2075 10 FilterType 0 794624 22 EggTexture::FilterType 22 EggTexture::FilterType 2069 0 0 0 0 0 0 0 0 0 7 14 FT_unspecified 26 EggTexture::FT_unspecified 225
// Note that these type values match up, name-for-name, with a similar
// enumerated type in Panda's Texture object.  However, they do *not*
// match up numerically.  You must convert between them using a switch
// statement.
0 10 FT_nearest 22 EggTexture::FT_nearest 28
// Mag Filter and Min Filter
1 9 FT_linear 21 EggTexture::FT_linear 0
2 25 FT_nearest_mipmap_nearest 37 EggTexture::FT_nearest_mipmap_nearest 17
// "mipmap point"
3 24 FT_linear_mipmap_nearest 36 EggTexture::FT_linear_mipmap_nearest 18
// "mipmap linear"
4 24 FT_nearest_mipmap_linear 36 EggTexture::FT_nearest_mipmap_linear 20
// "mipmap bilinear"
5 23 FT_linear_mipmap_linear 35 EggTexture::FT_linear_mipmap_linear 21
// "mipmap trilinear"
6 0 0

2076 7 EnvType 0 794624 19 EggTexture::EnvType 19 EggTexture::EnvType 2069 0 0 0 0 0 0 0 0 0 17 14 ET_unspecified 26 EggTexture::ET_unspecified 0
0 11 ET_modulate 23 EggTexture::ET_modulate 0
1 8 ET_decal 20 EggTexture::ET_decal 0
2 8 ET_blend 20 EggTexture::ET_blend 0
3 10 ET_replace 22 EggTexture::ET_replace 0
4 6 ET_add 18 EggTexture::ET_add 0
5 20 ET_blend_color_scale 32 EggTexture::ET_blend_color_scale 0
6 16 ET_modulate_glow 28 EggTexture::ET_modulate_glow 0
7 17 ET_modulate_gloss 29 EggTexture::ET_modulate_gloss 0
8 9 ET_normal 21 EggTexture::ET_normal 0
9 16 ET_normal_height 28 EggTexture::ET_normal_height 0
10 7 ET_glow 19 EggTexture::ET_glow 0
11 8 ET_gloss 20 EggTexture::ET_gloss 0
12 9 ET_height 21 EggTexture::ET_height 0
13 11 ET_selector 23 EggTexture::ET_selector 0
14 15 ET_normal_gloss 27 EggTexture::ET_normal_gloss 0
15 11 ET_emission 23 EggTexture::ET_emission 0
16 0 0

2077 11 CombineMode 0 794624 23 EggTexture::CombineMode 23 EggTexture::CombineMode 2069 0 0 0 0 0 0 0 0 0 9 14 CM_unspecified 26 EggTexture::CM_unspecified 0
0 10 CM_replace 22 EggTexture::CM_replace 0
1 11 CM_modulate 23 EggTexture::CM_modulate 0
2 6 CM_add 18 EggTexture::CM_add 0
3 13 CM_add_signed 25 EggTexture::CM_add_signed 0
4 14 CM_interpolate 26 EggTexture::CM_interpolate 0
5 11 CM_subtract 23 EggTexture::CM_subtract 0
6 11 CM_dot3_rgb 23 EggTexture::CM_dot3_rgb 0
7 12 CM_dot3_rgba 24 EggTexture::CM_dot3_rgba 0
8 0 0

2078 14 CombineChannel 0 794624 26 EggTexture::CombineChannel 26 EggTexture::CombineChannel 2069 0 0 0 0 0 0 0 0 0 3 6 CC_rgb 18 EggTexture::CC_rgb 0
0 8 CC_alpha 20 EggTexture::CC_alpha 0
1 15 CC_num_channels 27 EggTexture::CC_num_channels 0
2 0 0

2079 12 CombineIndex 0 794624 24 EggTexture::CombineIndex 24 EggTexture::CombineIndex 2069 0 0 0 0 0 0 0 0 0 1 14 CI_num_indices 26 EggTexture::CI_num_indices 0
3 0 0

2080 13 CombineSource 0 794624 25 EggTexture::CombineSource 25 EggTexture::CombineSource 2069 0 0 0 0 0 0 0 0 0 7 14 CS_unspecified 26 EggTexture::CS_unspecified 0
0 10 CS_texture 22 EggTexture::CS_texture 0
1 11 CS_constant 23 EggTexture::CS_constant 0
2 16 CS_primary_color 28 EggTexture::CS_primary_color 0
3 11 CS_previous 23 EggTexture::CS_previous 0
4 23 CS_constant_color_scale 35 EggTexture::CS_constant_color_scale 0
5 20 CS_last_saved_result 32 EggTexture::CS_last_saved_result 0
6 0 0

2081 14 CombineOperand 0 794624 26 EggTexture::CombineOperand 26 EggTexture::CombineOperand 2069 0 0 0 0 0 0 0 0 0 5 14 CO_unspecified 26 EggTexture::CO_unspecified 0
0 12 CO_src_color 24 EggTexture::CO_src_color 0
1 22 CO_one_minus_src_color 34 EggTexture::CO_one_minus_src_color 0
2 12 CO_src_alpha 24 EggTexture::CO_src_alpha 0
3 22 CO_one_minus_src_alpha 34 EggTexture::CO_one_minus_src_alpha 0
4 0 0

2082 6 TexGen 0 794624 18 EggTexture::TexGen 18 EggTexture::TexGen 2069 0 0 0 0 0 0 0 0 0 9 14 TG_unspecified 26 EggTexture::TG_unspecified 0
0 17 TG_eye_sphere_map 29 EggTexture::TG_eye_sphere_map 0
1 17 TG_world_cube_map 29 EggTexture::TG_world_cube_map 0
2 15 TG_eye_cube_map 27 EggTexture::TG_eye_cube_map 0
3 15 TG_world_normal 27 EggTexture::TG_world_normal 0
4 13 TG_eye_normal 25 EggTexture::TG_eye_normal 0
5 17 TG_world_position 29 EggTexture::TG_world_position 0
6 15 TG_eye_position 27 EggTexture::TG_eye_position 0
7 15 TG_point_sprite 27 EggTexture::TG_point_sprite 0
8 0 0

2083 12 QualityLevel 0 794624 24 EggTexture::QualityLevel 24 EggTexture::QualityLevel 2069 0 0 0 0 0 0 0 0 0 5 14 QL_unspecified 26 EggTexture::QL_unspecified 0
0 10 QL_default 22 EggTexture::QL_default 0
1 10 QL_fastest 22 EggTexture::QL_fastest 0
2 9 QL_normal 21 EggTexture::QL_normal 0
3 7 QL_best 19 EggTexture::QL_best 0
4 0 0

2084 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 2085 0 0 0 0 0 0 0 0 0 0

2085 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 839
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 *
 * Note that the methods of Filename that interact with the filesystem (such
 * as exists(), open_read(), etc.) directly interface with the operating system
 * and are not aware of Panda's virtual file system.  To interact with the VFS,
 * use the methods on VirtualFileSystem instead.
 */

2086 11 EggMaterial 0 141313 11 EggMaterial 11 EggMaterial 0 0 0 1 1642 1686 10 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 43 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 0 0 1 0 2003 0 0 0 1 2087 10
/**
 *
 */

2087 11 Equivalence 0 794624 24 EggMaterial::Equivalence 24 EggMaterial::Equivalence 2086 0 0 0 0 0 0 0 0 0 2 12 E_attributes 25 EggMaterial::E_attributes 0
1 11 E_mref_name 24 EggMaterial::E_mref_name 0
2 0 0

2088 12 EggPrimitive 0 26625 12 EggPrimitive 12 EggPrimitive 0 0 0 0 1694 8 2435 2436 2437 2438 2439 2440 2441 2442 51 1693 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 2 2454 2455 0 3 3 2003 1687 1688 3 2014 1689 1690 3 2028 1691 1692 0 1 2089 463
/**
 * A base class for any of a number of kinds of geometry primitives: polygons,
 * point lights, nurbs patches, parametrics curves, etc.  Things with a set of
 * vertices and some rendering properties like color.
 *
 * An EggPrimitive is an STL-style container of pointers to EggVertex's.  In
 * fact, it IS a vector, and can be manipulated in all the ways that vectors
 * can.  However, it is necessary that all vertices belong to the same vertex
 * pool.
 */

2089 7 Shading 0 794624 21 EggPrimitive::Shading 21 EggPrimitive::Shading 2088 0 0 0 0 0 0 0 0 0 4 9 S_unknown 23 EggPrimitive::S_unknown 94
// The order here is important.  The later choices are more specific than
// the earlier ones.
0 9 S_overall 23 EggPrimitive::S_overall 0
1 10 S_per_face 24 EggPrimitive::S_per_face 0
2 12 S_per_vertex 26 EggPrimitive::S_per_vertex 0
3 0 0

2090 12 EggTexture * 0 8576 12 EggTexture * 12 EggTexture * 0 0 2069 0 0 0 0 0 0 0 0 0 0

2091 13 EggMaterial * 0 8576 13 EggMaterial * 13 EggMaterial * 0 0 2086 0 0 0 0 0 0 0 0 0 0

2092 11 EggVertex * 0 8576 11 EggVertex * 11 EggVertex * 0 0 2024 0 0 0 0 0 0 0 0 0 0

2093 15 EggVertexPool * 0 8576 15 EggVertexPool * 15 EggVertexPool * 0 0 2027 0 0 0 0 0 0 0 0 0 0

2094 21 EggCompositePrimitive 0 75777 21 EggCompositePrimitive 21 EggCompositePrimitive 0 0 0 0 1694 1 2443 7 1745 1746 1747 1748 1749 1750 1751 1 2456 0 1 0 2088 0 0 0 0 186
/**
 * The base class for primitives such as triangle strips and triangle fans,
 * which include several component triangles, each of which might have its own
 * color and/or normal.
 */

2095 15 EggAttributes * 0 8576 15 EggAttributes * 15 EggAttributes * 0 0 2014 0 0 0 0 0 0 0 0 0 0

2096 7 EggData 0 141313 7 EggData 7 EggData 0 0 0 1 1752 1774 4 2444 2445 2446 2447 21 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 0 0 1 0 2005 0 0 0 0 441
/**
 * This is the primary interface into all the egg data, and the root of the
 * egg file structure.  An EggData structure corresponds exactly with an egg
 * file on the disk.
 *
 * The EggData class inherits from EggGroupNode its collection of children,
 * which are accessed by using the EggData itself as an STL container with
 * begin() and end() calls.  The children of the EggData class are the
 * toplevel nodes in the egg file.
 */

2097 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 21
// Z-Up, Right-handed
1 12 CS_yup_right 12 CS_yup_right 21
// Y-Up, Right-handed
2 11 CS_zup_left 11 CS_zup_left 20
// Z-Up, Left-handed
3 11 CS_yup_left 11 CS_yup_left 20
// Y-Up, Left-handed
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

2098 6 time_t 0 2105344 6 time_t 6 time_t 0 0 2099 0 0 0 0 0 0 0 0 0 0

2099 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0

2100 19 EggCoordinateSystem 0 141313 19 EggCoordinateSystem 19 EggCoordinateSystem 0 0 0 1 1775 1780 0 4 1776 1777 1778 1779 0 0 1 0 2003 0 0 0 0 177
/**
 * The <CoordinateSystem> entry at the top of an egg file.  Don't confuse this
 * with the enum EggData::CoordinateSystem, which is the value contained by
 * this entry.
 */

2101 8 EggCurve 0 141313 8 EggCurve 8 EggCurve 0 0 0 0 1788 0 7 1781 1782 1783 1784 1785 1786 1787 0 0 1 0 2088 0 0 0 1 2102 63
/**
 * A parametric curve of some kind.  See EggNurbsCurve.
 */

2102 9 CurveType 0 794624 19 EggCurve::CurveType 19 EggCurve::CurveType 2101 0 0 0 0 0 0 0 0 0 4 7 CT_none 17 EggCurve::CT_none 0
0 6 CT_xyz 16 EggCurve::CT_xyz 0
1 6 CT_hpr 16 EggCurve::CT_hpr 0
2 4 CT_t 14 EggCurve::CT_t 0
3 0 0

2103 20 EggExternalReference 0 141313 20 EggExternalReference 20 EggExternalReference 0 0 0 1 1789 1792 0 2 1790 1791 0 0 1 0 2068 0 0 0 0 93
/**
 * Defines a reference to another egg file which should be inserted at this
 * point.
 */

2104 17 EggNameUniquifier 0 75777 17 EggNameUniquifier 17 EggNameUniquifier 0 0 0 0 0 0 9 1793 1794 1795 1796 1797 1798 1799 1800 1801 0 0 1 0 2000 0 0 0 0 182
/**
 * This is a handy class for guaranteeing unique node names in an egg
 * hierarchy.  It is an abstract class; to use it you must subclass off of it.
 * See the comment above.
 */

2105 18 EggGroupUniquifier 0 141313 18 EggGroupUniquifier 18 EggGroupUniquifier 0 0 0 1 1802 1804 0 1 1803 0 0 1 0 2104 0 0 0 0 183
/**
 * This is a specialization of EggNameUniquifier to generate unique names for
 * EggGroup nodes.  It's not called automatically; you must invoke it yourself
 * if you want it.
 */

2106 7 EggLine 0 75777 7 EggLine 7 EggLine 0 0 0 1 1805 1694 0 6 1806 1807 1808 1809 1810 1811 0 0 1 0 2094 0 0 0 0 96
/**
 * A line segment, or a series of connected line segments, defined by a <Line>
 * entry.
 */

2107 21 EggMaterialCollection 0 26625 21 EggMaterialCollection 21 EggMaterialCollection 0 0 0 1 1812 1814 0 13 1813 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 0 0 0 0 0 232
/**
 * This is a collection of materials by MRef name.  It can extract the
 * materials from an egg file and sort them all together; it can also manage
 * the creation of unique materials and the assignment of unique MRef names.
 */

2108 10 EggPolygon 0 141313 10 EggPolygon 10 EggPolygon 0 0 0 1 1827 1835 0 7 1828 1829 1830 1831 1832 1833 1834 0 0 1 0 2088 0 0 0 0 28
/**
 * A single polygon.
 */

2109 13 EggNurbsCurve 0 141313 13 EggNurbsCurve 13 EggNurbsCurve 0 0 0 1 1838 1852 4 2448 2449 2450 2451 13 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1 2457 0 1 0 2101 0 0 0 0 36
/**
 * A parametric NURBS curve.
 */

2110 10 EggSurface 0 141313 10 EggSurface 10 EggSurface 0 0 0 0 1859 0 6 1853 1854 1855 1856 1857 1858 0 0 1 0 2088 0 0 0 0 67
/**
 * A parametric surface of some kind.  See EggNurbsSurface.
 */

2111 15 EggNurbsSurface 0 141313 15 EggNurbsSurface 15 EggNurbsSurface 0 0 0 1 1860 1889 0 28 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 2 2458 2459 0 1 0 2110 0 0 0 5 2112 2114 2115 2117 2118 38
/**
 * A parametric NURBS surface.
 */

2112 6 Curves 0 2367488 23 EggNurbsSurface::Curves 23 EggNurbsSurface::Curves 2111 0 2113 0 0 0 0 0 0 0 0 0 0

2113 34 list< PointerTo< EggNurbsCurve > > 0 2048 39 std::list< PointerTo< EggNurbsCurve > > 39 std::list< PointerTo< EggNurbsCurve > > 0 0 0 0 0 0 0 0 0 0 0 0 0

2114 4 Loop 0 2367488 21 EggNurbsSurface::Loop 21 EggNurbsSurface::Loop 2111 0 2112 0 0 0 0 0 0 0 0 0 0

2115 5 Loops 0 2367488 22 EggNurbsSurface::Loops 22 EggNurbsSurface::Loops 2111 0 2116 0 0 0 0 0 0 0 0 0 0

2116 12 list< Loop > 0 2048 17 std::list< Loop > 34 std::list< EggNurbsSurface::Loop > 0 0 0 0 0 0 0 0 0 0 0 0 0

2117 4 Trim 0 2367488 21 EggNurbsSurface::Trim 21 EggNurbsSurface::Trim 2111 0 2115 0 0 0 0 0 0 0 0 0 0

2118 5 Trims 0 2367488 22 EggNurbsSurface::Trims 22 EggNurbsSurface::Trims 2111 0 2119 0 0 0 0 0 0 0 0 0 0

2119 12 list< Trim > 0 2048 17 std::list< Trim > 34 std::list< EggNurbsSurface::Trim > 0 0 0 0 0 0 0 0 0 0 0 0 0

2120 8 EggPatch 0 141313 8 EggPatch 8 EggPatch 0 0 0 1 1890 1893 0 2 1891 1892 0 0 1 0 2088 0 0 0 0 99
/**
 * A single "patch", a special primitive to be rendered only with a
 * tessellation shader.
 */

2121 8 EggPoint 0 141313 8 EggPoint 8 EggPoint 0 0 0 1 1894 1905 0 10 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 0 0 1 0 2088 0 0 0 0 98
/**
 * A single point, or a collection of points as defined by a single
 * <PointLight> entry.
 */

2122 15 EggPolysetMaker 0 141313 15 EggPolysetMaker 15 EggPolysetMaker 0 0 0 1 1906 1909 0 2 1907 1908 0 0 1 0 2066 0 0 0 2 2123 2124 400
/**
 * A specialization on EggBinMaker for making polysets that share the same
 * basic rendering characteristic.  This really just defines the example
 * functions described in the leading comment to EggBinMaker.
 *
 * It makes some common assumptions about how polysets should be grouped; if
 * these are not sufficient, you can always rederive your own further
 * specialization of this class.
 */

2123 9 BinNumber 0 794624 26 EggPolysetMaker::BinNumber 26 EggPolysetMaker::BinNumber 2122 0 0 0 0 0 0 0 0 0 2 7 BN_none 24 EggPolysetMaker::BN_none 0
0 10 BN_polyset 27 EggPolysetMaker::BN_polyset 0
1 0 72
// The BinNumber serves to identify why a particular EggBin was created.

2124 10 Properties 0 794624 27 EggPolysetMaker::Properties 27 EggPolysetMaker::Properties 2122 0 0 0 0 0 0 0 0 0 10 13 P_has_texture 30 EggPolysetMaker::P_has_texture 0
1 9 P_texture 26 EggPolysetMaker::P_texture 0
2 14 P_has_material 31 EggPolysetMaker::P_has_material 0
4 10 P_material 27 EggPolysetMaker::P_material 0
8 16 P_has_poly_color 33 EggPolysetMaker::P_has_poly_color 0
16 12 P_poly_color 29 EggPolysetMaker::P_poly_color 0
32 17 P_has_poly_normal 34 EggPolysetMaker::P_has_poly_normal 0
64 19 P_has_vertex_normal 36 EggPolysetMaker::P_has_vertex_normal 0
128 18 P_has_vertex_color 35 EggPolysetMaker::P_has_vertex_color 0
256 7 P_bface 24 EggPolysetMaker::P_bface 0
512 0 0

2125 17 EggPoolUniquifier 0 141313 17 EggPoolUniquifier 17 EggPoolUniquifier 0 0 0 1 1910 1912 0 1 1911 0 0 1 0 2104 0 0 0 0 234
/**
 * This is a specialization of EggNameUniquifier to generate unique names for
 * textures, materials, and vertex pools prior to writing out an egg file.
 * It's automatically called by EggData prior to writing out an egg file.
 */

2126 12 EggSAnimData 0 141313 12 EggSAnimData 12 EggSAnimData 0 0 0 1 1913 1920 0 6 1914 1915 1916 1917 1918 1919 0 0 1 0 2011 0 0 0 0 158
/**
 * Corresponding to an <S$Anim> entry, this stores a single column of numbers,
 * for instance for a morph target, or as one column in an EggXfmSAnim.
 */

2127 8 EggTable 0 141313 8 EggTable 8 EggTable 0 0 0 1 1921 1928 0 6 1922 1923 1924 1925 1926 1927 0 0 1 0 2005 0 0 0 1 2128 295
/**
 * This corresponds to a <Table> or a <Bundle> entry.  As such, it doesn't
 * actually contain a table of numbers, but it may be a parent to an
 * EggSAnimData or an EggXfmAnimData, which do.  It may also be a parent to
 * another <Table> or <Bundle>, establishing a hierarchy of tables.
 */

2128 9 TableType 0 794624 19 EggTable::TableType 19 EggTable::TableType 2127 0 0 0 0 0 0 0 0 0 3 10 TT_invalid 20 EggTable::TT_invalid 0
0 8 TT_table 18 EggTable::TT_table 0
1 9 TT_bundle 19 EggTable::TT_bundle 0
2 0 0

2129 20 EggTextureCollection 0 26625 20 EggTextureCollection 20 EggTextureCollection 0 0 0 1 1929 1931 0 20 1930 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1 2460 0 0 0 0 229
/**
 * This is a collection of textures by TRef name.  It can extract the textures
 * from an egg file and sort them all together; it can also manage the
 * creation of unique textures and the assignment of unique TRef names.
 */

2130 14 EggTriangleFan 0 75777 14 EggTriangleFan 14 EggTriangleFan 0 0 0 1 1951 1694 0 2 1952 1953 0 0 1 0 2094 0 0 0 0 140
/**
 * A connected fan of triangles.  This does not normally appear in an egg
 * file; it is typically generated as a result of meshing.
 */

2131 16 EggTriangleStrip 0 75777 16 EggTriangleStrip 16 EggTriangleStrip 0 0 0 1 1954 1694 0 2 1955 1956 0 0 1 0 2094 0 0 0 0 142
/**
 * A connected strip of triangles.  This does not normally appear in an egg
 * file; it is typically generated as a result of meshing.
 */

2132 11 EggXfmSAnim 0 141313 11 EggXfmSAnim 11 EggXfmSAnim 0 0 0 1 1957 1980 0 22 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 0 0 1 0 2005 0 0 0 0 252
/**
 * This corresponds to an <Xfm$Anim_S$> entry, which is a collection of up to
 * nine <S$Anim> entries that specify the nine components of a transformation.
 * It's implemented as a group that can contain any number of EggSAnimData
 * children.
 */

2133 14 EggXfmAnimData 0 141313 14 EggXfmAnimData 14 EggXfmAnimData 0 0 0 1 1981 1997 0 15 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 0 0 1 0 2011 0 0 0 0 262
/**
 * Corresponding to an <Xfm$Anim> entry, this stores a two-dimensional table
 * with up to nine columns, one for each component of a transformation.  This
 * is an older syntax of egg anim table, not often used currently--it's
 * replaced by EggXfmSAnim.
 */

2134 13 EggUserData * 0 8576 13 EggUserData * 13 EggUserData * 0 0 1998 0 0 0 0 0 0 0 0 0 0

2135 19 EggUserData const * 0 8576 19 EggUserData const * 19 EggUserData const * 0 0 2136 0 0 0 0 0 0 0 0 0 0

2136 17 EggUserData const 0 8832 17 EggUserData const 17 EggUserData const 0 0 1998 0 0 0 0 0 0 0 0 0 0

2137 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

2138 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 2137 0 0 0 0 0 0 0 0 0 0

2139 11 EggObject * 0 8576 11 EggObject * 11 EggObject * 0 0 2000 0 0 0 0 0 0 0 0 0 0

2140 17 EggObject const * 0 8576 17 EggObject const * 17 EggObject const * 0 0 2141 0 0 0 0 0 0 0 0 0 0

2141 15 EggObject const 0 8832 15 EggObject const 15 EggObject const 0 0 2000 0 0 0 0 0 0 0 0 0 0

2142 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

2143 22 EggNamedObject const * 0 8576 22 EggNamedObject const * 22 EggNamedObject const * 0 0 2144 0 0 0 0 0 0 0 0 0 0

2144 20 EggNamedObject const 0 8832 20 EggNamedObject const 20 EggNamedObject const 0 0 2001 0 0 0 0 0 0 0 0 0 0

2145 16 EggNamedObject * 0 8576 16 EggNamedObject * 16 EggNamedObject * 0 0 2001 0 0 0 0 0 0 0 0 0 0

2146 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

2147 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 2148 0 0 0 0 0 0 0 0 0 0

2148 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

2149 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 2002 0 0 0 0 0 0 0 0 0 0

2150 9 EggNode * 0 8576 9 EggNode * 9 EggNode * 0 0 2003 0 0 0 0 0 0 0 0 0 0

2151 15 EggNode const * 0 8576 15 EggNode const * 15 EggNode const * 0 0 2152 0 0 0 0 0 0 0 0 0 0

2152 13 EggNode const 0 8832 13 EggNode const 13 EggNode const 0 0 2003 0 0 0 0 0 0 0 0 0 0

2153 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 2154 0 0 0 0 0 0 0 0 0 0

2154 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 2155 0 0 0 0 0 0 0 0 0 0

2155 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

2156 15 vector_string * 0 8576 15 vector_string * 15 vector_string * 0 0 2157 0 0 0 0 0 0 0 0 0 0

2157 13 vector_string 0 2105344 13 vector_string 13 vector_string 0 0 2158 0 0 0 0 0 0 0 0 0 0

2158 17 pvector< string > 0 2048 22 pvector< std::string > 22 pvector< std::string > 0 0 0 0 0 0 0 0 0 0 0 0 0

2159 15 EggRenderMode * 0 8576 15 EggRenderMode * 15 EggRenderMode * 0 0 2028 0 0 0 0 0 0 0 0 0 0

2160 20 EggGroupNode const * 0 8576 20 EggGroupNode const * 20 EggGroupNode const * 0 0 2161 0 0 0 0 0 0 0 0 0 0

2161 18 EggGroupNode const 0 8832 18 EggGroupNode const 18 EggGroupNode const 0 0 2005 0 0 0 0 0 0 0 0 0 0

2162 9 size_type 0 2367488 23 EggGroupNode::size_type 23 EggGroupNode::size_type 2005 0 2163 0 0 0 0 0 0 0 0 0 0

2163 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

2164 19 DSearchPath const * 0 8576 19 DSearchPath const * 19 DSearchPath const * 0 0 2165 0 0 0 0 0 0 0 0 0 0

2165 17 DSearchPath const 0 8832 17 DSearchPath const 17 DSearchPath const 0 0 2166 0 0 0 0 0 0 0 0 0 0

2166 11 DSearchPath 0 2048 11 DSearchPath 11 DSearchPath 0 0 0 0 0 0 0 0 0 0 0 0 304
/**
 * This class stores a list of directories that can be searched, in order, to
 * locate a particular file.  It is normally constructed by passing it a
 * traditional searchpath-style string, e.g.  a list of directory names
 * delimited by spaces or colons, but it can also be built up explicitly.
 */

2167 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 2084 0 0 0 0 0 0 0 0 0 0

2168 19 GlobPattern const * 0 8576 19 GlobPattern const * 19 GlobPattern const * 0 0 2169 0 0 0 0 0 0 0 0 0 0

2169 17 GlobPattern const 0 8832 17 GlobPattern const 17 GlobPattern const 0 0 2170 0 0 0 0 0 0 0 0 0 0

2170 11 GlobPattern 0 2048 11 GlobPattern 11 GlobPattern 0 0 0 0 0 0 0 0 0 0 0 0 538
/**
 * This class can be used to test for string matches against standard Unix-
 * shell filename globbing conventions.  It serves as a portable standin for
 * the Posix fnmatch() call.
 *
 * A GlobPattern is given a pattern string, which can contain operators like
 * *, ?, and [].  Then it can be tested against any number of candidate
 * strings; for each candidate, it will indicate whether the string matches
 * the pattern or not.  It can be used, for example, to scan a directory for
 * all files matching a particular pattern.
 */

2171 21 vector_string const * 0 8576 21 vector_string const * 21 vector_string const * 0 0 2172 0 0 0 0 0 0 0 0 0 0

2172 19 vector_string const 0 8832 19 vector_string const 19 vector_string const 0 0 2157 0 0 0 0 0 0 0 0 0 0

2173 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 2174 0 0 0 0 0 0 0 0 0 0

2174 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 2175 0 0 0 0 0 0 0 0 0 0

2175 9 LVector2d 0 2048 9 LVector2d 9 LVector2d 0 0 0 0 0 0 0 0 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

2176 13 EggAnimData * 0 8576 13 EggAnimData * 13 EggAnimData * 0 0 2011 0 0 0 0 0 0 0 0 0 0

2177 19 EggAnimData const * 0 8576 19 EggAnimData const * 19 EggAnimData const * 0 0 2178 0 0 0 0 0 0 0 0 0 0

2178 17 EggAnimData const 0 8832 17 EggAnimData const 17 EggAnimData const 0 0 2011 0 0 0 0 0 0 0 0 0 0

2179 22 EggAnimPreload const * 0 8576 22 EggAnimPreload const * 22 EggAnimPreload const * 0 0 2180 0 0 0 0 0 0 0 0 0 0

2180 20 EggAnimPreload const 0 8832 20 EggAnimPreload const 20 EggAnimPreload const 0 0 2012 0 0 0 0 0 0 0 0 0 0

2181 16 EggAnimPreload * 0 8576 16 EggAnimPreload * 16 EggAnimPreload * 0 0 2012 0 0 0 0 0 0 0 0 0 0

2182 21 EggAttributes const * 0 8576 21 EggAttributes const * 21 EggAttributes const * 0 0 2183 0 0 0 0 0 0 0 0 0 0

2183 19 EggAttributes const 0 8832 19 EggAttributes const 19 EggAttributes const 0 0 2014 0 0 0 0 0 0 0 0 0 0

2184 16 LNormald const * 0 8576 16 LNormald const * 16 LNormald const * 0 0 2185 0 0 0 0 0 0 0 0 0 0

2185 14 LNormald const 0 8832 14 LNormald const 14 LNormald const 0 0 2186 0 0 0 0 0 0 0 0 0 0

2186 8 LNormald 0 2105344 8 LNormald 8 LNormald 0 0 2187 0 0 0 0 0 0 0 0 0 0

2187 9 LVector3d 0 2048 9 LVector3d 9 LVector3d 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

2188 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 2060 0 0 0 0 0 0 0 0 0 0

2189 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 2059 0 0 0 0 0 0 0 0 0 0

2190 12 MemoryBase * 0 8576 12 MemoryBase * 12 MemoryBase * 0 0 2015 0 0 0 0 0 0 0 0 0 0

2191 19 EggVertexUV const * 0 8576 19 EggVertexUV const * 19 EggVertexUV const * 0 0 2192 0 0 0 0 0 0 0 0 0 0

2192 17 EggVertexUV const 0 8832 17 EggVertexUV const 17 EggVertexUV const 0 0 2020 0 0 0 0 0 0 0 0 0 0

2193 13 EggVertexUV * 0 8576 13 EggVertexUV * 13 EggVertexUV * 0 0 2020 0 0 0 0 0 0 0 0 0 0

2194 19 LTexCoord3d const * 0 8576 19 LTexCoord3d const * 19 LTexCoord3d const * 0 0 2195 0 0 0 0 0 0 0 0 0 0

2195 17 LTexCoord3d const 0 8832 17 LTexCoord3d const 17 LTexCoord3d const 0 0 2196 0 0 0 0 0 0 0 0 0 0

2196 11 LTexCoord3d 0 2105344 11 LTexCoord3d 11 LTexCoord3d 0 0 2051 0 0 0 0 0 0 0 0 0 0

2197 18 LTexCoordd const * 0 8576 18 LTexCoordd const * 18 LTexCoordd const * 0 0 2198 0 0 0 0 0 0 0 0 0 0

2198 16 LTexCoordd const 0 8832 16 LTexCoordd const 16 LTexCoordd const 0 0 2199 0 0 0 0 0 0 0 0 0 0

2199 10 LTexCoordd 0 2105344 10 LTexCoordd 10 LTexCoordd 0 0 2200 0 0 0 0 0 0 0 0 0 0

2200 8 LPoint2d 0 2048 8 LPoint2d 8 LPoint2d 0 0 0 0 0 0 0 0 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

2201 12 LTexCoordd * 0 8576 12 LTexCoordd * 12 LTexCoordd * 0 0 2199 0 0 0 0 0 0 0 0 0 0

2202 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2203 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 2202 0 0 0 0 0 0 0 0 0 0

2204 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 2205 0 0 0 0 0 0 0 0 0 0

2205 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 2202 0 0 0 0 0 0 0 0 0 0

2206 20 EggVertexAux const * 0 8576 20 EggVertexAux const * 20 EggVertexAux const * 0 0 2207 0 0 0 0 0 0 0 0 0 0

2207 18 EggVertexAux const 0 8832 18 EggVertexAux const 18 EggVertexAux const 0 0 2023 0 0 0 0 0 0 0 0 0 0

2208 14 EggVertexAux * 0 8576 14 EggVertexAux * 14 EggVertexAux * 0 0 2023 0 0 0 0 0 0 0 0 0 0

2209 17 EggVertex const * 0 8576 17 EggVertex const * 17 EggVertex const * 0 0 2210 0 0 0 0 0 0 0 0 0 0

2210 15 EggVertex const 0 8832 15 EggVertex const 15 EggVertex const 0 0 2024 0 0 0 0 0 0 0 0 0 0

2211 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 2212 0 0 0 0 0 0 0 0 0 0

2212 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 2200 0 0 0 0 0 0 0 0 0 0

2213 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 2050 0 0 0 0 0 0 0 0 0 0

2214 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 2215 0 0 0 0 0 0 0 0 0 0

2215 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 2216 0 0 0 0 0 0 0 0 0 0

2216 8 LPoint4d 0 2048 8 LPoint4d 8 LPoint4d 0 0 0 0 0 0 0 0 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

2217 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 2200 0 0 0 0 0 0 0 0 0 0

2218 8 LVertexd 0 2105344 8 LVertexd 8 LVertexd 0 0 2051 0 0 0 0 0 0 0 0 0 0

2219 10 LVertexd * 0 8576 10 LVertexd * 10 LVertexd * 0 0 2218 0 0 0 0 0 0 0 0 0 0

2220 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 2216 0 0 0 0 0 0 0 0 0 0

2221 16 EggGroup const * 0 8576 16 EggGroup const * 16 EggGroup const * 0 0 2222 0 0 0 0 0 0 0 0 0 0

2222 14 EggGroup const 0 8832 14 EggGroup const 14 EggGroup const 0 0 2037 0 0 0 0 0 0 0 0 0 0

2223 20 EggPrimitive const * 0 8576 20 EggPrimitive const * 20 EggPrimitive const * 0 0 2224 0 0 0 0 0 0 0 0 0 0

2224 18 EggPrimitive const 0 8832 18 EggPrimitive const 18 EggPrimitive const 0 0 2088 0 0 0 0 0 0 0 0 0 0

2225 21 EggVertexPool const * 0 8576 21 EggVertexPool const * 21 EggVertexPool const * 0 0 2226 0 0 0 0 0 0 0 0 0 0

2226 19 EggVertexPool const 0 8832 19 EggVertexPool const 19 EggVertexPool const 0 0 2027 0 0 0 0 0 0 0 0 0 0

2227 9 size_type 0 2367488 24 EggVertexPool::size_type 24 EggVertexPool::size_type 2027 0 2163 0 0 0 0 0 0 0 0 0 0

2228 14 EggPrimitive * 0 8576 14 EggPrimitive * 14 EggPrimitive * 0 0 2088 0 0 0 0 0 0 0 0 0 0

2229 21 EggRenderMode const * 0 8576 21 EggRenderMode const * 21 EggRenderMode const * 0 0 2230 0 0 0 0 0 0 0 0 0 0

2230 19 EggRenderMode const 0 8832 19 EggRenderMode const 19 EggRenderMode const 0 0 2028 0 0 0 0 0 0 0 0 0 0

2231 14 EggTransform * 0 8576 14 EggTransform * 14 EggTransform * 0 0 2033 0 0 0 0 0 0 0 0 0 0

2232 20 EggTransform const * 0 8576 20 EggTransform const * 20 EggTransform const * 0 0 2064 0 0 0 0 0 0 0 0 0 0

2233 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 2234 0 0 0 0 0 0 0 0 0 0

2234 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 2187 0 0 0 0 0 0 0 0 0 0

2235 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 2236 0 0 0 0 0 0 0 0 0 0

2236 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 2237 0 0 0 0 0 0 0 0 0 0

2237 12 LQuaterniond 0 2048 12 LQuaterniond 12 LQuaterniond 0 0 0 0 0 0 0 0 0 0 0 0 44
/**
 * This is the base quaternion class
 */

2238 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 2239 0 0 0 0 0 0 0 0 0 0

2239 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 2240 0 0 0 0 0 0 0 0 0 0

2240 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

2241 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 2242 0 0 0 0 0 0 0 0 0 0

2242 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 2243 0 0 0 0 0 0 0 0 0 0

2243 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2244 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 2245 0 0 0 0 0 0 0 0 0 0

2245 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 2246 0 0 0 0 0 0 0 0 0 0

2246 9 LMatrix3d 0 2048 9 LMatrix3d 9 LMatrix3d 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

2247 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 2246 0 0 0 0 0 0 0 0 0 0

2248 26 EggSwitchCondition const * 0 8576 26 EggSwitchCondition const * 26 EggSwitchCondition const * 0 0 2063 0 0 0 0 0 0 0 0 0 0

2249 20 EggSwitchCondition * 0 8576 20 EggSwitchCondition * 20 EggSwitchCondition * 0 0 2035 0 0 0 0 0 0 0 0 0 0

2250 28 EggSwitchConditionDistance * 0 8576 28 EggSwitchConditionDistance * 28 EggSwitchConditionDistance * 0 0 2036 0 0 0 0 0 0 0 0 0 0

2251 10 EggGroup * 0 8576 10 EggGroup * 10 EggGroup * 0 0 2037 0 0 0 0 0 0 0 0 0 0

2252 13 CollideMask * 0 8576 13 CollideMask * 13 CollideMask * 0 0 2056 0 0 0 0 0 0 0 0 0 0

2253 12 double const 0 8832 12 double const 12 double const 0 0 2013 0 0 0 0 0 0 0 0 0 0

2254 14 EggBin const * 0 8576 14 EggBin const * 14 EggBin const * 0 0 2255 0 0 0 0 0 0 0 0 0 0

2255 12 EggBin const 0 8832 12 EggBin const 12 EggBin const 0 0 2065 0 0 0 0 0 0 0 0 0 0

2256 8 EggBin * 0 8576 8 EggBin * 8 EggBin * 0 0 2065 0 0 0 0 0 0 0 0 0 0

2257 13 EggBinMaker * 0 8576 13 EggBinMaker * 13 EggBinMaker * 0 0 2066 0 0 0 0 0 0 0 0 0 0

2258 18 EggComment const * 0 8576 18 EggComment const * 18 EggComment const * 0 0 2259 0 0 0 0 0 0 0 0 0 0

2259 16 EggComment const 0 8832 16 EggComment const 16 EggComment const 0 0 2067 0 0 0 0 0 0 0 0 0 0

2260 12 EggComment * 0 8576 12 EggComment * 12 EggComment * 0 0 2067 0 0 0 0 0 0 0 0 0 0

2261 17 EggFilenameNode * 0 8576 17 EggFilenameNode * 17 EggFilenameNode * 0 0 2068 0 0 0 0 0 0 0 0 0 0

2262 23 EggFilenameNode const * 0 8576 23 EggFilenameNode const * 23 EggFilenameNode const * 0 0 2263 0 0 0 0 0 0 0 0 0 0

2263 21 EggFilenameNode const 0 8832 21 EggFilenameNode const 21 EggFilenameNode const 0 0 2068 0 0 0 0 0 0 0 0 0 0

2264 18 EggTexture const * 0 8576 18 EggTexture const * 18 EggTexture const * 0 0 2265 0 0 0 0 0 0 0 0 0 0

2265 16 EggTexture const 0 8832 16 EggTexture const 16 EggTexture const 0 0 2069 0 0 0 0 0 0 0 0 0 0

2266 19 EggMaterial const * 0 8576 19 EggMaterial const * 19 EggMaterial const * 0 0 2267 0 0 0 0 0 0 0 0 0 0

2267 17 EggMaterial const 0 8832 17 EggMaterial const 17 EggMaterial const 0 0 2086 0 0 0 0 0 0 0 0 0 0

2268 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 2163 0 0 0 0 0 0 0 0 0 0

2269 23 EggCompositePrimitive * 0 8576 23 EggCompositePrimitive * 23 EggCompositePrimitive * 0 0 2094 0 0 0 0 0 0 0 0 0 0

2270 29 EggCompositePrimitive const * 0 8576 29 EggCompositePrimitive const * 29 EggCompositePrimitive const * 0 0 2271 0 0 0 0 0 0 0 0 0 0

2271 27 EggCompositePrimitive const 0 8832 27 EggCompositePrimitive const 27 EggCompositePrimitive const 0 0 2094 0 0 0 0 0 0 0 0 0 0

2272 9 EggData * 0 8576 9 EggData * 9 EggData * 0 0 2096 0 0 0 0 0 0 0 0 0 0

2273 15 EggData const * 0 8576 15 EggData const * 15 EggData const * 0 0 2274 0 0 0 0 0 0 0 0 0 0

2274 13 EggData const 0 8832 13 EggData const 13 EggData const 0 0 2096 0 0 0 0 0 0 0 0 0 0

2275 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 2085 0 0 0 0 0 0 0 0 0 0

2276 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 2277 0 0 0 0 0 0 0 0 0 0

2277 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0

2278 16 BamCacheRecord * 0 8576 16 BamCacheRecord * 16 BamCacheRecord * 0 0 2279 0 0 0 0 0 0 0 0 0 0

2279 14 BamCacheRecord 0 2048 14 BamCacheRecord 14 BamCacheRecord 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * An instance of this class is written to the front of a Bam or Txo file to
 * make the file a cached instance of some other loadable resource.  This
 * record contains information needed to test the validity of the cache.
 */

2280 21 EggCoordinateSystem * 0 8576 21 EggCoordinateSystem * 21 EggCoordinateSystem * 0 0 2100 0 0 0 0 0 0 0 0 0 0

2281 27 EggCoordinateSystem const * 0 8576 27 EggCoordinateSystem const * 27 EggCoordinateSystem const * 0 0 2282 0 0 0 0 0 0 0 0 0 0

2282 25 EggCoordinateSystem const 0 8832 25 EggCoordinateSystem const 25 EggCoordinateSystem const 0 0 2100 0 0 0 0 0 0 0 0 0 0

2283 10 EggCurve * 0 8576 10 EggCurve * 10 EggCurve * 0 0 2101 0 0 0 0 0 0 0 0 0 0

2284 16 EggCurve const * 0 8576 16 EggCurve const * 16 EggCurve const * 0 0 2285 0 0 0 0 0 0 0 0 0 0

2285 14 EggCurve const 0 8832 14 EggCurve const 14 EggCurve const 0 0 2101 0 0 0 0 0 0 0 0 0 0

2286 28 EggExternalReference const * 0 8576 28 EggExternalReference const * 28 EggExternalReference const * 0 0 2287 0 0 0 0 0 0 0 0 0 0

2287 26 EggExternalReference const 0 8832 26 EggExternalReference const 26 EggExternalReference const 0 0 2103 0 0 0 0 0 0 0 0 0 0

2288 22 EggExternalReference * 0 8576 22 EggExternalReference * 22 EggExternalReference * 0 0 2103 0 0 0 0 0 0 0 0 0 0

2289 19 EggNameUniquifier * 0 8576 19 EggNameUniquifier * 19 EggNameUniquifier * 0 0 2104 0 0 0 0 0 0 0 0 0 0

2290 25 EggNameUniquifier const * 0 8576 25 EggNameUniquifier const * 25 EggNameUniquifier const * 0 0 2291 0 0 0 0 0 0 0 0 0 0

2291 23 EggNameUniquifier const 0 8832 23 EggNameUniquifier const 23 EggNameUniquifier const 0 0 2104 0 0 0 0 0 0 0 0 0 0

2292 20 EggGroupUniquifier * 0 8576 20 EggGroupUniquifier * 20 EggGroupUniquifier * 0 0 2105 0 0 0 0 0 0 0 0 0 0

2293 15 EggLine const * 0 8576 15 EggLine const * 15 EggLine const * 0 0 2294 0 0 0 0 0 0 0 0 0 0

2294 13 EggLine const 0 8832 13 EggLine const 13 EggLine const 0 0 2106 0 0 0 0 0 0 0 0 0 0

2295 9 EggLine * 0 8576 9 EggLine * 9 EggLine * 0 0 2106 0 0 0 0 0 0 0 0 0 0

2296 23 EggMaterialCollection * 0 8576 23 EggMaterialCollection * 23 EggMaterialCollection * 0 0 2107 0 0 0 0 0 0 0 0 0 0

2297 29 EggMaterialCollection const * 0 8576 29 EggMaterialCollection const * 29 EggMaterialCollection const * 0 0 2298 0 0 0 0 0 0 0 0 0 0

2298 27 EggMaterialCollection const 0 8832 27 EggMaterialCollection const 27 EggMaterialCollection const 0 0 2107 0 0 0 0 0 0 0 0 0 0

2299 21 MaterialReplacement * 0 8576 44 EggMaterialCollection::MaterialReplacement * 44 EggMaterialCollection::MaterialReplacement * 0 0 2300 0 0 0 0 0 0 0 0 0 0

2300 19 MaterialReplacement 0 2367488 42 EggMaterialCollection::MaterialReplacement 42 EggMaterialCollection::MaterialReplacement 2107 0 2301 0 0 0 0 0 0 0 0 0 0

2301 37 map< PT_EggMaterial, PT_EggMaterial > 0 2048 37 map< PT_EggMaterial, PT_EggMaterial > 37 map< PT_EggMaterial, PT_EggMaterial > 0 0 0 0 0 0 0 0 0 0 0 0 0

2302 27 MaterialReplacement const * 0 8576 50 EggMaterialCollection::MaterialReplacement const * 50 EggMaterialCollection::MaterialReplacement const * 0 0 2303 0 0 0 0 0 0 0 0 0 0

2303 25 MaterialReplacement const 0 8832 48 EggMaterialCollection::MaterialReplacement const 48 EggMaterialCollection::MaterialReplacement const 0 0 2300 0 0 0 0 0 0 0 0 0 0

2304 18 EggPolygon const * 0 8576 18 EggPolygon const * 18 EggPolygon const * 0 0 2305 0 0 0 0 0 0 0 0 0 0

2305 16 EggPolygon const 0 8832 16 EggPolygon const 16 EggPolygon const 0 0 2108 0 0 0 0 0 0 0 0 0 0

2306 12 EggPolygon * 0 8576 12 EggPolygon * 12 EggPolygon * 0 0 2108 0 0 0 0 0 0 0 0 0 0

2307 10 LNormald * 0 8576 10 LNormald * 10 LNormald * 0 0 2186 0 0 0 0 0 0 0 0 0 0

2308 21 EggNurbsCurve const * 0 8576 21 EggNurbsCurve const * 21 EggNurbsCurve const * 0 0 2309 0 0 0 0 0 0 0 0 0 0

2309 19 EggNurbsCurve const 0 8832 19 EggNurbsCurve const 19 EggNurbsCurve const 0 0 2109 0 0 0 0 0 0 0 0 0 0

2310 15 EggNurbsCurve * 0 8576 15 EggNurbsCurve * 15 EggNurbsCurve * 0 0 2109 0 0 0 0 0 0 0 0 0 0

2311 12 EggSurface * 0 8576 12 EggSurface * 12 EggSurface * 0 0 2110 0 0 0 0 0 0 0 0 0 0

2312 18 EggSurface const * 0 8576 18 EggSurface const * 18 EggSurface const * 0 0 2313 0 0 0 0 0 0 0 0 0 0

2313 16 EggSurface const 0 8832 16 EggSurface const 16 EggSurface const 0 0 2110 0 0 0 0 0 0 0 0 0 0

2314 23 EggNurbsSurface const * 0 8576 23 EggNurbsSurface const * 23 EggNurbsSurface const * 0 0 2315 0 0 0 0 0 0 0 0 0 0

2315 21 EggNurbsSurface const 0 8832 21 EggNurbsSurface const 21 EggNurbsSurface const 0 0 2111 0 0 0 0 0 0 0 0 0 0

2316 17 EggNurbsSurface * 0 8576 17 EggNurbsSurface * 17 EggNurbsSurface * 0 0 2111 0 0 0 0 0 0 0 0 0 0

2317 16 EggPatch const * 0 8576 16 EggPatch const * 16 EggPatch const * 0 0 2318 0 0 0 0 0 0 0 0 0 0

2318 14 EggPatch const 0 8832 14 EggPatch const 14 EggPatch const 0 0 2120 0 0 0 0 0 0 0 0 0 0

2319 10 EggPatch * 0 8576 10 EggPatch * 10 EggPatch * 0 0 2120 0 0 0 0 0 0 0 0 0 0

2320 16 EggPoint const * 0 8576 16 EggPoint const * 16 EggPoint const * 0 0 2321 0 0 0 0 0 0 0 0 0 0

2321 14 EggPoint const 0 8832 14 EggPoint const 14 EggPoint const 0 0 2121 0 0 0 0 0 0 0 0 0 0

2322 10 EggPoint * 0 8576 10 EggPoint * 10 EggPoint * 0 0 2121 0 0 0 0 0 0 0 0 0 0

2323 17 EggPolysetMaker * 0 8576 17 EggPolysetMaker * 17 EggPolysetMaker * 0 0 2122 0 0 0 0 0 0 0 0 0 0

2324 19 EggPoolUniquifier * 0 8576 19 EggPoolUniquifier * 19 EggPoolUniquifier * 0 0 2125 0 0 0 0 0 0 0 0 0 0

2325 20 EggSAnimData const * 0 8576 20 EggSAnimData const * 20 EggSAnimData const * 0 0 2326 0 0 0 0 0 0 0 0 0 0

2326 18 EggSAnimData const 0 8832 18 EggSAnimData const 18 EggSAnimData const 0 0 2126 0 0 0 0 0 0 0 0 0 0

2327 14 EggSAnimData * 0 8576 14 EggSAnimData * 14 EggSAnimData * 0 0 2126 0 0 0 0 0 0 0 0 0 0

2328 16 EggTable const * 0 8576 16 EggTable const * 16 EggTable const * 0 0 2329 0 0 0 0 0 0 0 0 0 0

2329 14 EggTable const 0 8832 14 EggTable const 14 EggTable const 0 0 2127 0 0 0 0 0 0 0 0 0 0

2330 10 EggTable * 0 8576 10 EggTable * 10 EggTable * 0 0 2127 0 0 0 0 0 0 0 0 0 0

2331 22 EggTextureCollection * 0 8576 22 EggTextureCollection * 22 EggTextureCollection * 0 0 2129 0 0 0 0 0 0 0 0 0 0

2332 28 EggTextureCollection const * 0 8576 28 EggTextureCollection const * 28 EggTextureCollection const * 0 0 2333 0 0 0 0 0 0 0 0 0 0

2333 26 EggTextureCollection const 0 8832 26 EggTextureCollection const 26 EggTextureCollection const 0 0 2129 0 0 0 0 0 0 0 0 0 0

2334 20 TextureReplacement * 0 8576 42 EggTextureCollection::TextureReplacement * 42 EggTextureCollection::TextureReplacement * 0 0 2335 0 0 0 0 0 0 0 0 0 0

2335 18 TextureReplacement 0 2367488 40 EggTextureCollection::TextureReplacement 40 EggTextureCollection::TextureReplacement 2129 0 2336 0 0 0 0 0 0 0 0 0 0

2336 35 map< PT_EggTexture, PT_EggTexture > 0 2048 35 map< PT_EggTexture, PT_EggTexture > 35 map< PT_EggTexture, PT_EggTexture > 0 0 0 0 0 0 0 0 0 0 0 0 0

2337 26 TextureReplacement const * 0 8576 48 EggTextureCollection::TextureReplacement const * 48 EggTextureCollection::TextureReplacement const * 0 0 2338 0 0 0 0 0 0 0 0 0 0

2338 24 TextureReplacement const 0 8832 46 EggTextureCollection::TextureReplacement const 46 EggTextureCollection::TextureReplacement const 0 0 2335 0 0 0 0 0 0 0 0 0 0

2339 9 size_type 0 2367488 31 EggTextureCollection::size_type 31 EggTextureCollection::size_type 2129 0 2163 0 0 0 0 0 0 0 0 0 0

2340 22 EggTriangleFan const * 0 8576 22 EggTriangleFan const * 22 EggTriangleFan const * 0 0 2341 0 0 0 0 0 0 0 0 0 0

2341 20 EggTriangleFan const 0 8832 20 EggTriangleFan const 20 EggTriangleFan const 0 0 2130 0 0 0 0 0 0 0 0 0 0

2342 16 EggTriangleFan * 0 8576 16 EggTriangleFan * 16 EggTriangleFan * 0 0 2130 0 0 0 0 0 0 0 0 0 0

2343 24 EggTriangleStrip const * 0 8576 24 EggTriangleStrip const * 24 EggTriangleStrip const * 0 0 2344 0 0 0 0 0 0 0 0 0 0

2344 22 EggTriangleStrip const 0 8832 22 EggTriangleStrip const 22 EggTriangleStrip const 0 0 2131 0 0 0 0 0 0 0 0 0 0

2345 18 EggTriangleStrip * 0 8576 18 EggTriangleStrip * 18 EggTriangleStrip * 0 0 2131 0 0 0 0 0 0 0 0 0 0

2346 22 EggXfmAnimData const * 0 8576 22 EggXfmAnimData const * 22 EggXfmAnimData const * 0 0 2347 0 0 0 0 0 0 0 0 0 0

2347 20 EggXfmAnimData const 0 8832 20 EggXfmAnimData const 20 EggXfmAnimData const 0 0 2133 0 0 0 0 0 0 0 0 0 0

2348 13 EggXfmSAnim * 0 8576 13 EggXfmSAnim * 13 EggXfmSAnim * 0 0 2132 0 0 0 0 0 0 0 0 0 0

2349 19 EggXfmSAnim const * 0 8576 19 EggXfmSAnim const * 19 EggXfmSAnim const * 0 0 2350 0 0 0 0 0 0 0 0 0 0

2350 17 EggXfmSAnim const 0 8832 17 EggXfmSAnim const 17 EggXfmSAnim const 0 0 2132 0 0 0 0 0 0 0 0 0 0

2351 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 2155 0 0 0 0 0 0 0 0 0 0

2352 16 EggXfmAnimData * 0 8576 16 EggXfmAnimData * 16 EggXfmAnimData * 0 0 2133 0 0 0 0 0 0 0 0 0 0

0
99
2353 6 parent 0 2 2004 1026 0 0 0 0 0 0 0 15 EggNode::parent 0

2354 8 children 0 2 2006 1038 0 0 0 0 0 0 0 22 EggGroupNode::children 0

2355 5 depth 0 2 2010 1027 0 0 0 0 0 0 0 14 EggNode::depth 0

2356 3 fps 0 30 2013 1119 1116 1118 1117 0 0 0 0 19 EggAnimPreload::fps 0

2357 10 num_frames 0 30 2010 1123 1120 1122 1121 0 0 0 0 26 EggAnimPreload::num_frames 0

2358 9 _dnormals 0 2 2016 1147 0 0 0 0 0 0 0 24 EggAttributes::_dnormals 0

2359 7 _drgbas 0 2 2018 1148 0 0 0 0 0 0 0 22 EggAttributes::_drgbas 0

2360 5 _duvs 0 2 2021 1175 0 0 0 0 0 0 0 18 EggVertexUV::_duvs 0

2361 6 _dxyzs 0 2 2025 1238 0 0 0 0 0 0 0 17 EggVertex::_dxyzs 0

2362 10 group_type 0 6 2042 1372 1371 0 0 0 0 0 0 20 EggGroup::group_type 0

2363 14 billboard_type 0 6 2044 1375 1374 0 0 0 0 0 0 24 EggGroup::billboard_type 0

2364 16 billboard_center 0 30 2050 1379 1376 1378 1377 0 0 0 0 26 EggGroup::billboard_center 0

2365 7 cs_type 0 6 2045 1381 1380 0 0 0 0 0 0 17 EggGroup::cs_type 0

2366 13 collide_flags 0 6 2046 1383 1382 0 0 0 0 0 0 23 EggGroup::collide_flags 0

2367 14 collision_name 0 6 2052 1387 1384 0 0 0 0 0 0 24 EggGroup::collision_name 0

2368 8 dcs_type 0 6 2043 1389 1388 0 0 0 0 0 0 18 EggGroup::dcs_type 0

2369 9 dart_type 0 6 2047 1392 1391 0 0 0 0 0 0 19 EggGroup::dart_type 0

2370 11 switch_flag 0 6 2055 1394 1393 0 0 0 0 0 0 21 EggGroup::switch_flag 0

2371 10 switch_fps 0 6 2013 1396 1395 0 0 0 0 0 0 20 EggGroup::switch_fps 0

2372 12 object_types 0 66 2053 1400 0 0 0 0 1399 0 0 22 EggGroup::object_types 0

2373 10 model_flag 0 6 2055 1404 1403 0 0 0 0 0 0 20 EggGroup::model_flag 0

2374 12 texlist_flag 0 6 2055 1406 1405 0 0 0 0 0 0 22 EggGroup::texlist_flag 0

2375 10 nofog_flag 0 6 2055 1408 1407 0 0 0 0 0 0 20 EggGroup::nofog_flag 0

2376 10 decal_flag 0 6 2055 1410 1409 0 0 0 0 0 0 20 EggGroup::decal_flag 0

2377 11 direct_flag 0 6 2055 1412 1411 0 0 0 0 0 0 21 EggGroup::direct_flag 0

2378 11 portal_flag 0 6 2055 1414 1413 0 0 0 0 0 0 21 EggGroup::portal_flag 0

2379 13 occluder_flag 0 6 2055 1416 1415 0 0 0 0 0 0 23 EggGroup::occluder_flag 0

2380 12 indexed_flag 0 30 2055 1422 1419 1421 1420 0 0 0 0 22 EggGroup::indexed_flag 0

2381 12 collide_mask 0 30 2056 1426 1423 1425 1424 0 0 0 0 22 EggGroup::collide_mask 0

2382 17 from_collide_mask 0 30 2056 1430 1427 1429 1428 0 0 0 0 27 EggGroup::from_collide_mask 0

2383 17 into_collide_mask 0 30 2056 1434 1431 1433 1432 0 0 0 0 27 EggGroup::into_collide_mask 0

2384 10 blend_mode 0 6 2048 1436 1435 0 0 0 0 0 0 20 EggGroup::blend_mode 0

2385 15 blend_operand_a 0 6 2049 1438 1437 0 0 0 0 0 0 25 EggGroup::blend_operand_a 0

2386 15 blend_operand_b 0 6 2049 1440 1439 0 0 0 0 0 0 25 EggGroup::blend_operand_b 0

2387 11 blend_color 0 30 2059 1444 1441 1443 1442 0 0 0 0 21 EggGroup::blend_color 0

2388 3 lod 0 30 2063 1448 1445 1447 1446 0 0 0 0 13 EggGroup::lod 0

2389 12 default_pose 0 6 2064 1453 1455 0 0 0 0 0 0 22 EggGroup::default_pose 0

2390 8 scroll_u 0 6 2013 1461 1457 0 0 0 0 0 0 18 EggGroup::scroll_u 0

2391 8 scroll_v 0 6 2013 1462 1458 0 0 0 0 0 0 18 EggGroup::scroll_v 0

2392 8 scroll_w 0 6 2013 1463 1459 0 0 0 0 0 0 18 EggGroup::scroll_w 0

2393 8 scroll_r 0 6 2013 1464 1460 0 0 0 0 0 0 18 EggGroup::scroll_r 0

2394 12 texture_type 0 6 2071 1530 1529 0 0 0 0 0 0 24 EggTexture::texture_type 0

2395 6 format 0 6 2072 1532 1531 0 0 0 0 0 0 18 EggTexture::format 0

2396 16 compression_mode 0 6 2073 1534 1533 0 0 0 0 0 0 28 EggTexture::compression_mode 0

2397 9 wrap_mode 0 6 2074 1536 1535 0 0 0 0 0 0 21 EggTexture::wrap_mode 0

2398 6 wrap_u 0 6 2074 1538 1537 0 0 0 0 0 0 18 EggTexture::wrap_u 0

2399 6 wrap_v 0 6 2074 1541 1540 0 0 0 0 0 0 18 EggTexture::wrap_v 0

2400 6 wrap_w 0 6 2074 1544 1543 0 0 0 0 0 0 18 EggTexture::wrap_w 0

2401 9 minfilter 0 6 2075 1547 1546 0 0 0 0 0 0 21 EggTexture::minfilter 0

2402 9 magfilter 0 6 2075 1549 1548 0 0 0 0 0 0 21 EggTexture::magfilter 0

2403 18 anisotropic_degree 0 30 2010 1553 1550 1552 1551 0 0 0 0 30 EggTexture::anisotropic_degree 0

2404 8 env_type 0 6 2076 1555 1554 0 0 0 0 0 0 20 EggTexture::env_type 0

2405 12 saved_result 0 6 2055 1564 1563 0 0 0 0 0 0 24 EggTexture::saved_result 0

2406 7 tex_gen 0 6 2082 1566 1565 0 0 0 0 0 0 19 EggTexture::tex_gen 0

2407 13 quality_level 0 6 2083 1568 1567 0 0 0 0 0 0 25 EggTexture::quality_level 0

2408 10 stage_name 0 30 2052 1572 1569 1571 1570 0 0 0 0 22 EggTexture::stage_name 0

2409 8 priority 0 30 2010 1576 1573 1575 1574 0 0 0 0 20 EggTexture::priority 0

2410 5 color 0 30 2059 1580 1577 1579 1578 0 0 0 0 17 EggTexture::color 0

2411 12 border_color 0 30 2059 1584 1581 1583 1582 0 0 0 0 24 EggTexture::border_color 0

2412 7 uv_name 0 30 2052 1588 1585 1587 1586 0 0 0 0 19 EggTexture::uv_name 0

2413 9 rgb_scale 0 30 2010 1592 1589 1591 1590 0 0 0 0 21 EggTexture::rgb_scale 0

2414 11 alpha_scale 0 30 2010 1596 1593 1595 1594 0 0 0 0 23 EggTexture::alpha_scale 0

2415 14 alpha_filename 0 30 2084 1600 1597 1599 1598 0 0 0 0 26 EggTexture::alpha_filename 0

2416 14 alpha_fullpath 0 6 2084 1602 1601 0 0 0 0 0 0 26 EggTexture::alpha_fullpath 0

2417 18 alpha_file_channel 0 30 2010 1606 1603 1605 1604 0 0 0 0 30 EggTexture::alpha_file_channel 0

2418 9 multiview 0 6 2055 1608 1607 0 0 0 0 0 0 21 EggTexture::multiview 0

2419 9 num_views 0 30 2010 1612 1609 1611 1610 0 0 0 0 21 EggTexture::num_views 0

2420 12 read_mipmaps 0 6 2055 1614 1613 0 0 0 0 0 0 24 EggTexture::read_mipmaps 0

2421 7 min_lod 0 30 2013 1618 1615 1617 1616 0 0 0 0 19 EggTexture::min_lod 0

2422 7 max_lod 0 30 2013 1622 1619 1621 1620 0 0 0 0 19 EggTexture::max_lod 0

2423 8 lod_bias 0 30 2013 1626 1623 1625 1624 0 0 0 0 20 EggTexture::lod_bias 0

2424 17 multitexture_sort 0 2 2010 1629 0 0 0 0 0 0 0 29 EggTexture::multitexture_sort 0

2425 4 base 0 30 2060 1648 1645 1647 1646 0 0 0 0 17 EggMaterial::base 0

2426 4 diff 0 30 2060 1652 1649 1651 1650 0 0 0 0 17 EggMaterial::diff 0

2427 3 amb 0 30 2060 1656 1653 1655 1654 0 0 0 0 16 EggMaterial::amb 0

2428 4 emit 0 30 2060 1660 1657 1659 1658 0 0 0 0 17 EggMaterial::emit 0

2429 4 spec 0 30 2060 1664 1661 1663 1662 0 0 0 0 17 EggMaterial::spec 0

2430 9 shininess 0 30 2013 1668 1665 1667 1666 0 0 0 0 22 EggMaterial::shininess 0

2431 9 roughness 0 30 2013 1672 1669 1671 1670 0 0 0 0 22 EggMaterial::roughness 0

2432 8 metallic 0 30 2013 1676 1673 1675 1674 0 0 0 0 21 EggMaterial::metallic 0

2433 3 ior 0 30 2013 1680 1677 1679 1678 0 0 0 0 16 EggMaterial::ior 0

2434 5 local 0 30 2055 1684 1681 1683 1682 0 0 0 0 18 EggMaterial::local 0

2435 9 sort_name 0 2 2053 1703 0 0 0 0 0 0 0 23 EggPrimitive::sort_name 0

2436 7 shading 0 2 2089 1704 0 0 0 0 0 0 0 21 EggPrimitive::shading 0

2437 17 connected_shading 0 2 2089 1706 0 0 0 0 0 0 0 31 EggPrimitive::connected_shading 0

2438 8 textures 0 66 2090 1709 0 0 0 0 1712 0 0 22 EggPrimitive::textures 0

2439 8 material 0 30 2091 1715 1713 1716 1714 0 0 0 0 22 EggPrimitive::material 0

2440 10 bface_flag 0 6 2055 1718 1717 0 0 0 0 0 0 24 EggPrimitive::bface_flag 0

2441 8 vertices 0 358 2092 1738 1739 0 0 1735 1737 1740 0 22 EggPrimitive::vertices 0

2442 4 pool 0 2 2093 1741 0 0 0 0 0 0 0 18 EggPrimitive::pool 0

2443 10 components 0 70 2095 1747 1748 0 0 0 1746 0 0 33 EggCompositePrimitive::components 0

2444 22 auto_resolve_externals 0 6 2055 1762 1761 0 0 0 0 0 0 31 EggData::auto_resolve_externals 0

2445 17 coordinate_system 0 6 2097 1765 1764 0 0 0 0 0 0 26 EggData::coordinate_system 0

2446 12 egg_filename 0 6 2084 1767 1766 0 0 0 0 0 0 21 EggData::egg_filename 0

2447 13 egg_timestamp 0 6 2098 1769 1768 0 0 0 0 0 0 22 EggData::egg_timestamp 0

2448 5 order 0 6 2010 1845 1841 0 0 0 0 0 0 20 EggNurbsCurve::order 0

2449 6 degree 0 2 2010 1846 0 0 0 0 0 0 0 21 EggNurbsCurve::degree 0

2450 6 closed 0 2 2055 1849 0 0 0 0 0 0 0 21 EggNurbsCurve::closed 0

2451 5 knots 0 70 2013 1850 1843 0 0 0 1847 0 0 20 EggNurbsCurve::knots 0

9
2452 16 get_object_types 0 1399 1400 26 EggGroup::get_object_types 0

2453 14 get_group_refs 0 1474 1475 24 EggGroup::get_group_refs 0

2454 12 get_textures 0 1712 1709 26 EggPrimitive::get_textures 0

2455 12 get_vertices 0 1737 1738 26 EggPrimitive::get_vertices 0

2456 14 get_components 0 1746 1747 37 EggCompositePrimitive::get_components 0

2457 9 get_knots 0 1847 1850 24 EggNurbsCurve::get_knots 0

2458 11 get_u_knots 0 1875 1885 28 EggNurbsSurface::get_u_knots 0

2459 11 get_v_knots 0 1876 1886 28 EggNurbsSurface::get_v_knots 0

2460 12 get_textures 0 1935 1936 34 EggTextureCollection::get_textures 0

