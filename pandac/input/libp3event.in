1713074447
3 3
10 libp3event 4 _0BP 12 panda3d.core 
270
250 14 EventParameter 0 260 520 30 EventParameter::EventParameter 0 9 1 2 3 4 5 6 7 8 9 1162
/**
 * Defines an EventParameter that stores a pointer to any kind of
 * TypedWritableReferenceCount object.  This is the most general constructor.
 *
 * This accepts a const pointer, even though it stores (and eventually
 * returns) a non-const pointer.  This is just the simplest way to allow both
 * const and non-const pointers to be stored, but it does lose the constness.
 * Be careful.
 */

/**
 * Defines an EventParameter that stores a pointer to a TypedReferenceCount
 * object.  Note that a TypedReferenceCount is not the same kind of pointer as
 * a TypedWritableReferenceCount, hence we require both constructors.
 *
 * This accepts a const pointer, even though it stores (and eventually
 * returns) a non-const pointer.  This is just the simplest way to allow both
 * const and non-const pointers to be stored, but it does lose the constness.
 * Be careful.
 */

/**
 * Defines an EventParameter that stores an integer value.
 */

/**
 * Defines an EventParameter that stores a floating-point value.
 */

/**
 * Defines an EventParameter that stores a string value.
 */

/**
 * Defines an EventParameter that stores a wstring value.
 */

/**
 *
 */
561
inline EventParameter::EventParameter(void) = default;
inline EventParameter::EventParameter(std::nullptr_t );
inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr);
inline EventParameter::EventParameter(TypedReferenceCount const *ptr);
inline EventParameter::EventParameter(int value);
inline EventParameter::EventParameter(double value);
inline EventParameter::EventParameter(std::string const &value);
inline EventParameter::EventParameter(std::wstring const &value);
inline EventParameter::EventParameter(EventParameter const &copy);

251 10 operator = 0 4 520 26 EventParameter::operator = 0 1 10 10
/**
 *
 */
67
inline void EventParameter::operator =(EventParameter const &copy);

252 15 ~EventParameter 0 516 520 31 EventParameter::~EventParameter 0 0 10
/**
 *
 */
45
inline EventParameter::~EventParameter(void);

253 8 is_empty 0 4 520 24 EventParameter::is_empty 0 1 11 377
// These functions are conveniences to easily determine if the
// EventParameter is one of the predefined parameter types, and retrieve the
// corresponding value.  Of course, it is possible that the EventParameter
// is some user-defined type, and is none of these.

/**
 * Returns true if the EventParameter is the empty parameter, storing nothing,
 * or false otherwise.
 */
49
inline bool EventParameter::is_empty(void) const;

254 6 is_int 0 4 520 22 EventParameter::is_int 0 1 12 90
/**
 * Returns true if the EventParameter stores an integer value, false
 * otherwise.
 */
47
inline bool EventParameter::is_int(void) const;

255 13 get_int_value 0 4 520 29 EventParameter::get_int_value 0 1 13 133
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_int() has already returned true.
 */
53
inline int EventParameter::get_int_value(void) const;

256 9 is_double 0 4 520 25 EventParameter::is_double 0 1 14 103
/**
 * Returns true if the EventParameter stores a double floating-point value,
 * false otherwise.
 */
50
inline bool EventParameter::is_double(void) const;

257 16 get_double_value 0 4 520 32 EventParameter::get_double_value 0 1 15 136
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_double() has already returned true.
 */
59
inline double EventParameter::get_double_value(void) const;

258 9 is_string 0 4 520 25 EventParameter::is_string 0 1 16 85
/**
 * Returns true if the EventParameter stores a string value, false otherwise.
 */
50
inline bool EventParameter::is_string(void) const;

259 16 get_string_value 0 4 520 32 EventParameter::get_string_value 0 1 17 136
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_string() has already returned true.
 */
64
inline std::string EventParameter::get_string_value(void) const;

260 10 is_wstring 0 4 520 26 EventParameter::is_wstring 0 1 18 86
/**
 * Returns true if the EventParameter stores a wstring value, false otherwise.
 */
51
inline bool EventParameter::is_wstring(void) const;

261 17 get_wstring_value 0 4 520 33 EventParameter::get_wstring_value 0 1 19 137
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_wstring() has already returned true.
 */
66
inline std::wstring EventParameter::get_wstring_value(void) const;

262 18 is_typed_ref_count 0 4 520 34 EventParameter::is_typed_ref_count 0 1 20 255
/**
 * Returns true if the EventParameter stores a TypedReferenceCount pointer,
 * false otherwise.  Note that a TypedReferenceCount is not exactly the same
 * kind of pointer as a TypedWritableReferenceCount, hence the need for this
 * separate call.
 */
59
inline bool EventParameter::is_typed_ref_count(void) const;

263 25 get_typed_ref_count_value 0 4 520 41 EventParameter::get_typed_ref_count_value 0 1 21 145
/**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_typed_ref_count() has already returned true.
 */
82
inline TypedReferenceCount *EventParameter::get_typed_ref_count_value(void) const;

264 7 get_ptr 0 4 520 23 EventParameter::get_ptr 0 1 22 281
/**
 * Retrieves a pointer to the actual value stored in the parameter.  The
 * TypeHandle of this pointer may be examined to determine the actual type of
 * parameter it contains.  This is the only way to retrieve the value when it
 * is not one of the above predefined types.
 */
72
inline TypedWritableReferenceCount *EventParameter::get_ptr(void) const;

265 6 output 0 4 520 22 EventParameter::output 0 1 23 10
/**
 *
 */
53
void EventParameter::output(std::ostream &out) const;

266 11 AsyncFuture 0 260 521 24 AsyncFuture::AsyncFuture 0 1 24 55
/**
 * Initializes the future in the pending state.
 */
38
inline AsyncFuture::AsyncFuture(void);

267 9 __await__ 0 4 521 22 AsyncFuture::__await__ 0 1 25 0
56
static PyObject *AsyncFuture::__await__(PyObject *self);

268 8 __iter__ 0 4 521 21 AsyncFuture::__iter__ 0 1 26 0
55
static PyObject *AsyncFuture::__iter__(PyObject *self);

269 4 done 0 4 521 17 AsyncFuture::done 0 1 27 104
/**
 * Returns true if the future is done or has been cancelled.  It is always
 * safe to call this.
 */
42
inline bool AsyncFuture::done(void) const;

270 9 cancelled 0 4 521 22 AsyncFuture::cancelled 0 1 28 85
/**
 * Returns true if the future was cancelled.  It is always safe to call this.
 */
47
inline bool AsyncFuture::cancelled(void) const;

271 6 result 0 4 521 19 AsyncFuture::result 0 1 29 0
94
PyObject *AsyncFuture::result(PyObject *self, PyObject *timeout = (& ::_Py_NoneStruct)) const;

272 6 cancel 0 6 521 19 AsyncFuture::cancel 0 1 30 531
/**
 * Cancels the future.  Returns true if it was cancelled, or false if the
 * future was already done.  Either way, done() will return true after this
 * call returns.
 *
 * Please note that calling this is not a guarantee that the operation
 * corresponding this future does not run.  It could already be in the process
 * of running, or perhaps not respond to a cancel signal.  All this guarantees
 * is that the future is marked as done when this call returns.
 *
 * In the case of a task, this is equivalent to remove().
 */
39
virtual bool AsyncFuture::cancel(void);

273 14 set_done_event 0 4 521 27 AsyncFuture::set_done_event 0 1 31 212
/**
 * Sets the event name that will be triggered when the future finishes.  Will
 * not be triggered if the future is cancelled, but it will be triggered for
 * a coroutine task that exits with an exception.
 */
71
inline void AsyncFuture::set_done_event(std::string const &done_event);

274 14 get_done_event 0 4 521 27 AsyncFuture::get_done_event 0 1 32 107
/**
 * Returns the event name that will be triggered when the future finishes.
 * See set_done_event().
 */
66
inline std::string const &AsyncFuture::get_done_event(void) const;

275 17 add_done_callback 0 4 521 30 AsyncFuture::add_done_callback 0 1 33 0
71
PyObject *AsyncFuture::add_done_callback(PyObject *self, PyObject *fn);

276 6 gather 0 4 521 19 AsyncFuture::gather 0 1 34 232
/**
 * Creates a new future that returns `done()` when all of the contained
 * futures are done.
 *
 * Calling `cancel()` on the returned future will result in all contained
 * futures that have not yet finished to be cancelled.
 */
53
static PyObject *AsyncFuture::gather(PyObject *args);

277 6 shield 0 4 521 19 AsyncFuture::shield 0 1 35 159
/**
 * Creates a new future that shields the given future from cancellation.
 * Calling `cancel()` on the returned future will not affect the given future.
 */
92
static inline PointerTo< AsyncFuture > AsyncFuture::shield(PointerTo< AsyncFuture > future);

278 6 output 0 6 521 19 AsyncFuture::output 0 1 36 10
/**
 *
 */
58
virtual void AsyncFuture::output(std::ostream &out) const;

279 4 wait 0 4 521 17 AsyncFuture::wait 0 2 37 38 280
/**
 * Waits until the future is done.
 */

/**
 * Waits until the future is done, or until the timeout is reached.  Note that
 * this can be considerably less efficient than wait() without a timeout, so
 * it's generally not a good idea to use this unless you really need to.
 */
69
void AsyncFuture::wait(void);
void AsyncFuture::wait(double timeout);

280 10 set_result 0 4 521 23 AsyncFuture::set_result 0 1 39 503
/**
 * Sets this future's result.  Can only be called if done() returns false.
 */

/**
 * Sets this future's result as a generic TypedObject.
 */

/**
 * Sets this future's result.  Can only be done while the future is not done.
 * Calling this marks the future as done and schedules the done callbacks.
 *
 * This variant takes two pointers; the second one is only set if this object
 * inherits from ReferenceCount, so that a reference can be held.
 *
 * Assumes the manager's lock is *not* held.
 */
41
void AsyncFuture::set_result(PyObject *);

281 14 get_class_type 0 4 521 27 AsyncFuture::get_class_type 0 1 40 0
52
static TypeHandle AsyncFuture::get_class_type(void);

282 21 upcast_to_AsyncFuture 0 12 526 32 AsyncTask::upcast_to_AsyncFuture 0 1 71 36
upcast from AsyncTask to AsyncFuture
52
AsyncFuture *AsyncTask::upcast_to_AsyncFuture(void);

283 21 downcast_to_AsyncTask 0 12 521 34 AsyncFuture::downcast_to_AsyncTask 0 0 38
downcast from AsyncFuture to AsyncTask
52
AsyncTask *AsyncFuture::downcast_to_AsyncTask(void);

284 17 upcast_to_Namable 0 12 526 28 AsyncTask::upcast_to_Namable 0 1 72 32
upcast from AsyncTask to Namable
44
Namable *AsyncTask::upcast_to_Namable(void);

285 21 downcast_to_AsyncTask 0 12 527 30 Namable::downcast_to_AsyncTask 0 0 34
downcast from Namable to AsyncTask
48
AsyncTask *Namable::downcast_to_AsyncTask(void);

286 10 ~AsyncTask 0 518 526 21 AsyncTask::~AsyncTask 0 0 10
/**
 *
 */
36
virtual AsyncTask::~AsyncTask(void);

287 9 get_state 0 4 526 20 AsyncTask::get_state 0 1 41 49
/**
 * Returns the current state of the task.
 */
57
inline AsyncTask::State AsyncTask::get_state(void) const;

288 8 is_alive 0 4 526 19 AsyncTask::is_alive 0 1 42 332
/**
 * Returns true if the task is currently active or sleeping on some task
 * chain, meaning that it will be executed in its turn, or false if it is not
 * active.  If the task has recently been removed while it is in the middle of
 * execution, this will return false, because the task will not run again once
 * it finishes.
 */
44
inline bool AsyncTask::is_alive(void) const;

289 11 get_manager 0 4 526 22 AsyncTask::get_manager 0 1 43 118
/**
 * Returns the AsyncTaskManager that this task is active on.  This will be
 * NULL if the state is S_inactive.
 */
60
inline AsyncTaskManager *AsyncTask::get_manager(void) const;

290 6 remove 0 4 526 17 AsyncTask::remove 0 1 44 297
/**
 * Removes the task from its active manager, if any, and makes the state
 * S_inactive (or possible S_servicing_removed).  This is a no-op if the state
 * is already S_inactive.
 *
 * If the task is a coroutine that is currently awaiting a future, this will
 * fail, but see also cancel().
 */
29
bool AsyncTask::remove(void);

291 9 set_delay 0 4 526 20 AsyncTask::set_delay 0 1 45 686
/**
 * Specifies the amount of time, in seconds, by which this task will be
 * delayed after it has been added to the AsyncTaskManager.  At least the
 * specified amount of time (and possibly more) will elapse before the task
 * begins.
 *
 * You may specify a delay of 0.0 to guarantee that the task will run in the
 * next epoch following the one in which it is added.
 *
 * Setting this value after the task has already been added will not affect
 * the task's wake time; it will only affect the task if it is re-added to the
 * queue in the future, for instance if the task returns DS_again.  However,
 * see recalc_wake_time() if you wish to apply the delay effect immediately.
 */
47
inline void AsyncTask::set_delay(double delay);

292 11 clear_delay 0 4 526 22 AsyncTask::clear_delay 0 1 46 216
/**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */
41
inline void AsyncTask::clear_delay(void);

293 9 has_delay 0 4 526 20 AsyncTask::has_delay 0 1 47 101
/**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */
45
inline bool AsyncTask::has_delay(void) const;

294 9 get_delay 0 4 526 20 AsyncTask::get_delay 0 1 48 75
/**
 * Returns the delay value that has been set via set_delay, if any.
 */
47
inline double AsyncTask::get_delay(void) const;

295 13 get_wake_time 0 4 526 24 AsyncTask::get_wake_time 0 1 49 354
/**
 * If this task has been added to an AsyncTaskManager with a delay in effect,
 * this returns the time at which the task is expected to awaken.  It has no
 * meaning if the task has not yet been added to a queue, or if there was no
 * delay in effect at the time the task was added.
 *
 * If the task's status is not S_sleeping, this returns 0.0.
 */
44
double AsyncTask::get_wake_time(void) const;

296 16 recalc_wake_time 0 4 526 27 AsyncTask::recalc_wake_time 0 1 50 437
/**
 * If the task is currently sleeping on a task chain, this resets its wake
 * time to the current time + get_delay().  It is as if the task had suddenly
 * returned DS_again.  The task will sleep for its current delay seconds
 * before running again.  This method may therefore be used to make the task
 * wake up sooner or later than it would have otherwise.
 *
 * If the task is not already sleeping, this method has no effect.
 */
39
void AsyncTask::recalc_wake_time(void);

297 14 get_start_time 0 4 526 25 AsyncTask::get_start_time 0 1 51 176
/**
 * Returns the time at which the task was started, according to the task
 * manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
52
inline double AsyncTask::get_start_time(void) const;

298 16 get_elapsed_time 0 4 526 27 AsyncTask::get_elapsed_time 0 1 52 200
/**
 * Returns the amount of time that has elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
47
double AsyncTask::get_elapsed_time(void) const;

299 15 get_start_frame 0 4 526 26 AsyncTask::get_start_frame 0 1 53 184
/**
 * Returns the frame number at which the task was started, according to the
 * task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
50
inline int AsyncTask::get_start_frame(void) const;

300 18 get_elapsed_frames 0 4 526 29 AsyncTask::get_elapsed_frames 0 1 54 203
/**
 * Returns the number of frames that have elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
46
int AsyncTask::get_elapsed_frames(void) const;

301 8 set_name 0 4 526 19 AsyncTask::set_name 0 1 55 10
/**
 *
 */
50
void AsyncTask::set_name(std::string const &name);

302 10 clear_name 0 4 526 21 AsyncTask::clear_name 0 1 56 43
/**
 * Resets the task's name to empty.
 */
40
inline void AsyncTask::clear_name(void);

303 15 get_name_prefix 0 4 526 26 AsyncTask::get_name_prefix 0 1 57 129
/**
 * Returns the initial part of the name, up to but not including any trailing
 * digits following a hyphen or underscore.
 */
51
std::string AsyncTask::get_name_prefix(void) const;

304 11 get_task_id 0 4 526 22 AsyncTask::get_task_id 0 1 58 107
/**
 * Returns a number guaranteed to be unique for each different AsyncTask
 * object in the universe.
 */
64
inline AtomicAdjust::Integer AsyncTask::get_task_id(void) const;

305 14 set_task_chain 0 4 526 25 AsyncTask::set_task_chain 0 1 59 135
/**
 * Specifies the AsyncTaskChain on which this task will be running.  Each task
 * chain runs tasks independently of the others.
 */
62
void AsyncTask::set_task_chain(std::string const &chain_name);

306 14 get_task_chain 0 4 526 25 AsyncTask::get_task_chain 0 1 60 133
/**
 * Returns the AsyncTaskChain on which this task will be running.  Each task
 * chain runs tasks independently of the others.
 */
64
inline std::string const &AsyncTask::get_task_chain(void) const;

307 8 set_sort 0 4 526 19 AsyncTask::set_sort 0 1 61 483
/**
 * Specifies a sort value for this task.  Within a given AsyncTaskManager, all
 * of the tasks with a given sort value are guaranteed to be completed before
 * any tasks with a higher sort value are begun.
 *
 * To put it another way, two tasks might execute in parallel with each other
 * only if they both have the same sort value.  Tasks with a lower sort value
 * are executed first.
 *
 * This is different from the priority, which makes no such exclusion
 * guarantees.
 */
35
void AsyncTask::set_sort(int sort);

308 8 get_sort 0 4 526 19 AsyncTask::get_sort 0 1 62 66
/**
 * Returns the task's current sort value.  See set_sort().
 */
43
inline int AsyncTask::get_sort(void) const;

309 12 set_priority 0 4 526 23 AsyncTask::set_priority 0 1 63 874
/**
 * Specifies a priority value for this task.  In general, tasks with a higher
 * priority value are executed before tasks with a lower priority value (but
 * only for tasks with the same sort value).
 *
 * Unlike the sort value, tasks with different priorities may execute at the
 * same time, if the AsyncTaskManager has more than one thread servicing
 * tasks.
 *
 * Also see AsyncTaskChain::set_timeslice_priority(), which changes the
 * meaning of this value.  In the default mode, when the timeslice_priority
 * flag is false, all tasks always run once per epoch, regardless of their
 * priority values (that is, the priority controls the order of the task
 * execution only, not the number of times it runs).  On the other hand, if
 * you set the timeslice_priority flag to true, then changing a task's
 * priority has an effect on the number of times it runs.
 */
43
void AsyncTask::set_priority(int priority);

310 12 get_priority 0 4 526 23 AsyncTask::get_priority 0 1 64 74
/**
 * Returns the task's current priority value.  See set_priority().
 */
47
inline int AsyncTask::get_priority(void) const;

311 14 set_done_event 0 4 526 25 AsyncTask::set_done_event 0 1 65 257
/**
 * Sets the event name that will be triggered when the task finishes.  This
 * should only be called before the task has been started, or after it has
 * finished and before it is about to be restarted (i.e.  when get_state()
 * returns S_inactive).
 */
69
inline void AsyncTask::set_done_event(std::string const &done_event);

312 6 get_dt 0 4 526 17 AsyncTask::get_dt 0 1 66 98
/**
 * Returns the amount of time elapsed during the task's previous run cycle, in
 * seconds.
 */
44
inline double AsyncTask::get_dt(void) const;

313 10 get_max_dt 0 4 526 21 AsyncTask::get_max_dt 0 1 67 118
/**
 * Returns the maximum amount of time elapsed during any one of the task's
 * previous run cycles, in seconds.
 */
48
inline double AsyncTask::get_max_dt(void) const;

314 14 get_average_dt 0 4 526 25 AsyncTask::get_average_dt 0 1 68 115
/**
 * Returns the average amount of time elapsed during each of the task's
 * previous run cycles, in seconds.
 */
52
inline double AsyncTask::get_average_dt(void) const;

315 6 output 0 6 526 17 AsyncTask::output 0 1 69 10
/**
 *
 */
56
virtual void AsyncTask::output(std::ostream &out) const;

316 29 upcast_to_TypedReferenceCount 0 12 532 47 AsyncTaskManager::upcast_to_TypedReferenceCount 0 1 103 51
upcast from AsyncTaskManager to TypedReferenceCount
75
TypedReferenceCount *AsyncTaskManager::upcast_to_TypedReferenceCount(void);

317 28 downcast_to_AsyncTaskManager 0 12 522 49 TypedReferenceCount::downcast_to_AsyncTaskManager 0 0 53
downcast from TypedReferenceCount to AsyncTaskManager
74
AsyncTaskManager *TypedReferenceCount::downcast_to_AsyncTaskManager(void);

318 17 upcast_to_Namable 0 12 532 35 AsyncTaskManager::upcast_to_Namable 0 1 104 39
upcast from AsyncTaskManager to Namable
51
Namable *AsyncTaskManager::upcast_to_Namable(void);

319 28 downcast_to_AsyncTaskManager 0 12 527 37 Namable::downcast_to_AsyncTaskManager 0 0 41
downcast from Namable to AsyncTaskManager
62
AsyncTaskManager *Namable::downcast_to_AsyncTaskManager(void);

320 16 AsyncTaskManager 0 260 532 34 AsyncTaskManager::AsyncTaskManager 0 1 73 10
/**
 *
 */
69
explicit AsyncTaskManager::AsyncTaskManager(std::string const &name);

321 17 ~AsyncTaskManager 0 518 532 35 AsyncTaskManager::~AsyncTaskManager 0 0 10
/**
 *
 */
50
virtual AsyncTaskManager::~AsyncTaskManager(void);

322 7 cleanup 0 4 532 25 AsyncTaskManager::cleanup 0 1 74 118
/**
 * Stops all threads and messily empties the task list.  This is intended to
 * be called on destruction only.
 */
37
void AsyncTaskManager::cleanup(void);

323 9 set_clock 0 4 532 27 AsyncTaskManager::set_clock 0 1 75 286
/**
 * Replaces the clock pointer used within the AsyncTaskManager.  This is used
 * to control when tasks with a set_delay() specified will be scheduled.  It
 * can also be ticked automatically each epoch, if set_tick_clock() is true.
 *
 * The default is the global clock pointer.
 */
60
inline void AsyncTaskManager::set_clock(ClockObject *clock);

324 9 get_clock 0 4 532 27 AsyncTaskManager::get_clock 0 1 76 91
/**
 * Returns the clock pointer used within the AsyncTaskManager.  See
 * set_clock().
 */
54
inline ClockObject *AsyncTaskManager::get_clock(void);

325 19 get_num_task_chains 0 4 532 37 AsyncTaskManager::get_num_task_chains 0 1 77 55
/**
 * Returns the number of different task chains.
 */
54
int AsyncTaskManager::get_num_task_chains(void) const;

326 14 get_task_chain 0 4 532 32 AsyncTaskManager::get_task_chain 0 1 78 38
/**
 * Returns the nth task chain.
 */
62
AsyncTaskChain *AsyncTaskManager::get_task_chain(int n) const;

327 15 make_task_chain 0 4 532 33 AsyncTaskManager::make_task_chain 0 2 79 80 367
/**
 * Creates a new AsyncTaskChain of the indicated name and stores it within the
 * AsyncTaskManager.  If a task chain with this name already exists, returns
 * it instead.
 */

/**
 * Creates a new threaded AsyncTaskChain of the indicated name and stores it
 * within the AsyncTaskManager.  If a task chain with this name already exists,
 * returns it instead.
 */
200
AsyncTaskChain *AsyncTaskManager::make_task_chain(std::string const &name);
AsyncTaskChain *AsyncTaskManager::make_task_chain(std::string const &name, int num_threads, ThreadPriority thread_priority);

328 15 find_task_chain 0 4 532 33 AsyncTaskManager::find_task_chain 0 1 81 113
/**
 * Searches a new AsyncTaskChain of the indicated name and returns it if it
 * exists, or NULL otherwise.
 */
75
AsyncTaskChain *AsyncTaskManager::find_task_chain(std::string const &name);

329 17 remove_task_chain 0 4 532 35 AsyncTaskManager::remove_task_chain 0 1 82 211
/**
 * Removes the AsyncTaskChain of the indicated name.  If the chain still has
 * tasks, this will block until all tasks are finished.
 *
 * Returns true if successful, or false if the chain did not exist.
 */
66
bool AsyncTaskManager::remove_task_chain(std::string const &name);

330 3 add 0 4 532 21 AsyncTaskManager::add 0 1 83 138
/**
 * Adds the indicated task to the active queue.  It is an error if the task is
 * already added to this or any other active queue.
 */
44
void AsyncTaskManager::add(AsyncTask *task);

331 8 has_task 0 4 532 26 AsyncTaskManager::has_task 0 1 84 106
/**
 * Returns true if the indicated task has been added to this AsyncTaskManager,
 * false otherwise.
 */
55
bool AsyncTaskManager::has_task(AsyncTask *task) const;

332 9 find_task 0 4 532 27 AsyncTaskManager::find_task 0 1 85 210
/**
 * Returns the first task found with the indicated name, or NULL if there is
 * no task with the indicated name.
 *
 * If there are multiple tasks with the same name, returns one of them
 * arbitrarily.
 */
70
AsyncTask *AsyncTaskManager::find_task(std::string const &name) const;

333 10 find_tasks 0 4 532 28 AsyncTaskManager::find_tasks 0 1 86 67
/**
 * Returns the list of tasks found with the indicated name.
 */
80
AsyncTaskCollection AsyncTaskManager::find_tasks(std::string const &name) const;

334 19 find_tasks_matching 0 4 532 37 AsyncTaskManager::find_tasks_matching 0 1 87 111
/**
 * Returns the list of tasks found whose name matches the indicated glob
 * pattern, e.g.  "my_task_*".
 */
92
AsyncTaskCollection AsyncTaskManager::find_tasks_matching(GlobPattern const &pattern) const;

335 6 remove 0 4 532 24 AsyncTaskManager::remove 0 2 88 89 249
/**
 * Removes the indicated task from the active queue.  Returns true if the task
 * is successfully removed, or false if it wasn't there.
 */

/**
 * Removes all of the tasks in the AsyncTaskCollection.  Returns the number of
 * tasks removed.
 */
119
bool AsyncTaskManager::remove(AsyncTask *task);
std::size_t AsyncTaskManager::remove(AsyncTaskCollection const &tasks);

336 14 wait_for_tasks 0 4 532 32 AsyncTaskManager::wait_for_tasks 0 1 90 47
/**
 * Blocks until the task list is empty.
 */
44
void AsyncTaskManager::wait_for_tasks(void);

337 12 stop_threads 0 4 532 30 AsyncTaskManager::stop_threads 0 1 91 215
/**
 * Stops any threads that are currently running.  If any tasks are still
 * pending and have not yet been picked up by a thread, they will not be
 * serviced unless poll() or start_threads() is later called.
 */
42
void AsyncTaskManager::stop_threads(void);

338 13 start_threads 0 4 532 31 AsyncTaskManager::start_threads 0 1 92 171
/**
 * Starts any requested threads to service the tasks on the queue.  This is
 * normally not necessary, since adding a task will start the threads
 * automatically.
 */
43
void AsyncTaskManager::start_threads(void);

339 13 get_num_tasks 0 4 532 31 AsyncTaskManager::get_num_tasks 0 1 93 104
/**
 * Returns the number of tasks that are currently active or sleeping within
 * the task manager.
 */
63
inline std::size_t AsyncTaskManager::get_num_tasks(void) const;

340 9 get_tasks 0 4 532 27 AsyncTaskManager::get_tasks 0 1 94 112
/**
 * Returns the set of tasks that are active or sleeping on the task manager,
 * at the time of the call.
 */
60
AsyncTaskCollection AsyncTaskManager::get_tasks(void) const;

341 16 get_active_tasks 0 4 532 34 AsyncTaskManager::get_active_tasks 0 1 95 119
/**
 * Returns the set of tasks that are active (and not sleeping) on the task
 * manager, at the time of the call.
 */
67
AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const;

342 18 get_sleeping_tasks 0 4 532 36 AsyncTaskManager::get_sleeping_tasks 0 1 96 119
/**
 * Returns the set of tasks that are sleeping (and not active) on the task
 * manager, at the time of the call.
 */
69
AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const;

343 19 AsyncTaskCollection 0 260 535 40 AsyncTaskCollection::AsyncTaskCollection 0 2 105 106 22
/**
 *
 */

/**
 *
 */
122
AsyncTaskCollection::AsyncTaskCollection(void);
AsyncTaskCollection::AsyncTaskCollection(AsyncTaskCollection const &copy);

344 10 operator = 0 4 535 31 AsyncTaskCollection::operator = 0 1 107 0
70
void AsyncTaskCollection::operator =(AsyncTaskCollection const &copy);

345 20 ~AsyncTaskCollection 0 516 535 41 AsyncTaskCollection::~AsyncTaskCollection 0 0 10
/**
 *
 */
55
inline AsyncTaskCollection::~AsyncTaskCollection(void);

346 8 add_task 0 4 535 29 AsyncTaskCollection::add_task 0 1 108 50
/**
 * Adds a new AsyncTask to the collection.
 */
52
void AsyncTaskCollection::add_task(AsyncTask *task);

347 11 remove_task 0 4 535 32 AsyncTaskCollection::remove_task 0 2 109 110 212
/**
 * Removes the indicated AsyncTask from the collection.  Returns true if the
 * task was removed, false if it was not a member of the collection.
 */

/**
 * Removes the nth AsyncTask from the collection.
 */
113
bool AsyncTaskCollection::remove_task(AsyncTask *task);
void AsyncTaskCollection::remove_task(std::size_t index);

348 14 add_tasks_from 0 4 535 35 AsyncTaskCollection::add_tasks_from 0 1 111 204
/**
 * Adds all the AsyncTasks indicated in the other collection to this task.
 * The other tasks are simply appended to the end of the tasks in this list;
 * duplicates are not automatically removed.
 */
75
void AsyncTaskCollection::add_tasks_from(AsyncTaskCollection const &other);

349 17 remove_tasks_from 0 4 535 38 AsyncTaskCollection::remove_tasks_from 0 1 112 96
/**
 * Removes from this collection all of the AsyncTasks listed in the other
 * collection.
 */
78
void AsyncTaskCollection::remove_tasks_from(AsyncTaskCollection const &other);

350 22 remove_duplicate_tasks 0 4 535 43 AsyncTaskCollection::remove_duplicate_tasks 0 1 113 198
/**
 * Removes any duplicate entries of the same AsyncTasks on this collection.
 * If a AsyncTask appears multiple times, the first appearance is retained;
 * subsequent appearances are removed.
 */
55
void AsyncTaskCollection::remove_duplicate_tasks(void);

351 8 has_task 0 4 535 29 AsyncTaskCollection::has_task 0 1 114 98
/**
 * Returns true if the indicated AsyncTask appears in this collection, false
 * otherwise.
 */
58
bool AsyncTaskCollection::has_task(AsyncTask *task) const;

352 5 clear 0 4 535 26 AsyncTaskCollection::clear 0 1 115 54
/**
 * Removes all AsyncTasks from the collection.
 */
38
void AsyncTaskCollection::clear(void);

353 9 find_task 0 4 535 30 AsyncTaskCollection::find_task 0 1 116 115
/**
 * Returns the task in the collection with the indicated name, if any, or NULL
 * if no task has that name.
 */
73
AsyncTask *AsyncTaskCollection::find_task(std::string const &name) const;

354 13 get_num_tasks 0 4 535 34 AsyncTaskCollection::get_num_tasks 0 1 117 62
/**
 * Returns the number of AsyncTasks in the collection.
 */
59
std::size_t AsyncTaskCollection::get_num_tasks(void) const;

355 8 get_task 0 4 535 29 AsyncTaskCollection::get_task 0 1 118 55
/**
 * Returns the nth AsyncTask in the collection.
 */
66
AsyncTask *AsyncTaskCollection::get_task(std::size_t index) const;

356 11 operator [] 0 4 535 32 AsyncTaskCollection::operator [] 0 1 119 141
/**
 * Returns the nth AsyncTask in the collection.  This is the same as
 * get_task(), but it may be a more convenient way to access it.
 */
69
AsyncTask *AsyncTaskCollection::operator [](std::size_t index) const;

357 4 size 0 4 535 25 AsyncTaskCollection::size 0 1 120 104
/**
 * Returns the number of tasks in the collection.  This is the same thing as
 * get_num_tasks().
 */
50
std::size_t AsyncTaskCollection::size(void) const;

358 11 operator += 0 4 535 32 AsyncTaskCollection::operator += 0 1 121 0
79
inline void AsyncTaskCollection::operator +=(AsyncTaskCollection const &other);

359 10 operator + 0 4 535 31 AsyncTaskCollection::operator + 0 1 122 0
99
inline AsyncTaskCollection AsyncTaskCollection::operator +(AsyncTaskCollection const &other) const;

360 6 output 0 4 535 27 AsyncTaskCollection::output 0 1 123 108
/**
 * Writes a brief one-line description of the AsyncTaskCollection to the
 * indicated output stream.
 */
58
void AsyncTaskCollection::output(std::ostream &out) const;

361 5 write 0 4 535 26 AsyncTaskCollection::write 0 1 124 113
/**
 * Writes a complete multi-line description of the AsyncTaskCollection to the
 * indicated output stream.
 */
79
void AsyncTaskCollection::write(std::ostream &out, int indent_level = 0) const;

362 4 poll 0 4 532 22 AsyncTaskManager::poll 0 1 97 233
/**
 * Runs through all the tasks in the task list, once, if the task manager is
 * running in single-threaded mode (no threads available).  This method does
 * nothing in threaded mode, so it may safely be called in either case.
 */
34
void AsyncTaskManager::poll(void);

363 18 get_next_wake_time 0 4 532 36 AsyncTaskManager::get_next_wake_time 0 1 98 169
/**
 * Returns the scheduled time (on the manager's clock) of the next sleeping
 * task, on any task chain, to awaken.  Returns -1 if there are no sleeping
 * tasks.
 */
56
double AsyncTaskManager::get_next_wake_time(void) const;

364 6 output 0 6 532 24 AsyncTaskManager::output 0 1 99 10
/**
 *
 */
63
virtual void AsyncTaskManager::output(std::ostream &out) const;

365 5 write 0 6 532 23 AsyncTaskManager::write 0 1 100 10
/**
 *
 */
84
virtual void AsyncTaskManager::write(std::ostream &out, int indent_level = 0) const;

366 14 get_global_ptr 0 4 532 32 AsyncTaskManager::get_global_ptr 0 1 101 152
/**
 * Returns a pointer to the global AsyncTaskManager.  This is the
 * AsyncTaskManager that most code should use for queueing tasks and suchlike.
 */
71
static inline AsyncTaskManager *AsyncTaskManager::get_global_ptr(void);

367 14 get_class_type 0 4 532 32 AsyncTaskManager::get_class_type 0 1 102 0
57
static TypeHandle AsyncTaskManager::get_class_type(void);

368 8 get_name 0 4 526 19 AsyncTask::get_name 0 0 0
58
inline std::string const &AsyncTask::get_name(void) const;

369 14 get_done_event 0 4 526 25 AsyncTask::get_done_event 0 0 107
/**
 * Returns the event name that will be triggered when the future finishes.
 * See set_done_event().
 */
64
inline std::string const &AsyncTask::get_done_event(void) const;

370 14 get_class_type 0 4 526 25 AsyncTask::get_class_type 0 1 70 0
50
static TypeHandle AsyncTask::get_class_type(void);

371 29 upcast_to_TypedReferenceCount 0 12 541 45 AsyncTaskChain::upcast_to_TypedReferenceCount 0 1 153 49
upcast from AsyncTaskChain to TypedReferenceCount
73
TypedReferenceCount *AsyncTaskChain::upcast_to_TypedReferenceCount(void);

372 26 downcast_to_AsyncTaskChain 0 12 522 47 TypedReferenceCount::downcast_to_AsyncTaskChain 0 0 51
downcast from TypedReferenceCount to AsyncTaskChain
70
AsyncTaskChain *TypedReferenceCount::downcast_to_AsyncTaskChain(void);

373 17 upcast_to_Namable 0 12 541 33 AsyncTaskChain::upcast_to_Namable 0 1 154 37
upcast from AsyncTaskChain to Namable
49
Namable *AsyncTaskChain::upcast_to_Namable(void);

374 26 downcast_to_AsyncTaskChain 0 12 527 35 Namable::downcast_to_AsyncTaskChain 0 0 39
downcast from Namable to AsyncTaskChain
58
AsyncTaskChain *Namable::downcast_to_AsyncTaskChain(void);

375 15 ~AsyncTaskChain 0 518 541 31 AsyncTaskChain::~AsyncTaskChain 0 0 10
/**
 *
 */
46
virtual AsyncTaskChain::~AsyncTaskChain(void);

376 14 set_tick_clock 0 4 541 30 AsyncTaskChain::set_tick_clock 0 1 125 155
/**
 * Sets the tick_clock flag.  When this is true, get_clock()->tick() will be
 * called automatically at each task epoch.  This is false by default.
 */
53
void AsyncTaskChain::set_tick_clock(bool tick_clock);

377 14 get_tick_clock 0 4 541 30 AsyncTaskChain::get_tick_clock 0 1 126 62
/**
 * Returns the tick_clock flag.  See set_tick_clock().
 */
48
bool AsyncTaskChain::get_tick_clock(void) const;

378 15 set_num_threads 0 4 541 31 AsyncTaskChain::set_num_threads 0 1 127 132
/**
 * Changes the number of threads for this task chain.  This may require
 * stopping the threads if they are already running.
 */
54
void AsyncTaskChain::set_num_threads(int num_threads);

379 15 get_num_threads 0 4 541 31 AsyncTaskChain::get_num_threads 0 1 128 124
/**
 * Returns the number of threads that will be servicing tasks for this chain.
 * Also see get_num_running_threads().
 */
48
int AsyncTaskChain::get_num_threads(void) const;

380 23 get_num_running_threads 0 4 541 39 AsyncTaskChain::get_num_running_threads 0 1 129 211
/**
 * Returns the number of threads that have been created and are actively
 * running.  This will return 0 before the threads have been started; it will
 * also return 0 if thread support is not available.
 */
56
int AsyncTaskChain::get_num_running_threads(void) const;

381 19 set_thread_priority 0 4 541 35 AsyncTaskChain::set_thread_priority 0 1 130 153
/**
 * Changes the priority associated with threads that serve this task chain.
 * This may require stopping the threads if they are already running.
 */
66
void AsyncTaskChain::set_thread_priority(ThreadPriority priority);

382 19 get_thread_priority 0 4 541 35 AsyncTaskChain::get_thread_priority 0 1 131 83
/**
 * Returns the priority associated with threads that serve this task chain.
 */
63
ThreadPriority AsyncTaskChain::get_thread_priority(void) const;

383 16 set_frame_budget 0 4 541 32 AsyncTaskChain::set_frame_budget 0 1 132 414
/**
 * Sets the maximum amount of time per frame the tasks on this chain are
 * granted for execution.  If this is less than zero, there is no limit; if it
 * is >= 0, it represents a maximum amount of time (in seconds) that will be
 * used to execute tasks.  If this time is exceeded in any one frame, the task
 * chain will stop executing tasks until the next frame, as defined by the
 * TaskManager's clock.
 */
59
void AsyncTaskChain::set_frame_budget(double frame_budget);

384 16 get_frame_budget 0 4 541 32 AsyncTaskChain::get_frame_budget 0 1 133 134
/**
 * Returns the maximum amount of time per frame the tasks on this chain are
 * granted for execution.  See set_frame_budget().
 */
52
double AsyncTaskChain::get_frame_budget(void) const;

385 14 set_frame_sync 0 4 541 30 AsyncTaskChain::set_frame_sync 0 1 134 638
/**
 * Sets the frame_sync flag.  When this flag is true, this task chain will be
 * forced to sync with the TaskManager's clock.  It will run no faster than
 * one epoch per clock frame.
 *
 * When this flag is false, the default, the task chain will finish all of its
 * tasks and then immediately start from the first task again, regardless of
 * the clock frame.  When it is true, the task chain will finish all of its
 * tasks and then wait for the clock to tick to the next frame before resuming
 * the first task.
 *
 * This only makes sense for threaded task chains.  Non-threaded task chains
 * are automatically synchronous.
 */
53
void AsyncTaskChain::set_frame_sync(bool frame_sync);

386 14 get_frame_sync 0 4 541 30 AsyncTaskChain::get_frame_sync 0 1 135 62
/**
 * Returns the frame_sync flag.  See set_frame_sync().
 */
48
bool AsyncTaskChain::get_frame_sync(void) const;

387 22 set_timeslice_priority 0 4 541 38 AsyncTaskChain::set_timeslice_priority 0 1 136 903
/**
 * Sets the timeslice_priority flag.  This changes the interpretation of
 * priority, and the number of times per epoch each task will run.
 *
 * When this flag is true, some tasks might not run in any given epoch.
 * Instead, tasks with priority higher than 1 will be given precedence, in
 * proportion to the amount of time they have already used.  This gives
 * higher-priority tasks more runtime than lower-priority tasks.  Each task
 * gets the amount of time proportional to its priority value, so a task with
 * priority 100 will get five times as much processing time as a task with
 * priority 20.  For these purposes, priority values less than 1 are deemed to
 * be equal to 1.
 *
 * When this flag is false (the default), all tasks are run exactly once each
 * epoch, round-robin style.  Priority is only used to determine which task
 * runs first within tasks of the same sort value.
 */
69
void AsyncTaskChain::set_timeslice_priority(bool timeslice_priority);

388 22 get_timeslice_priority 0 4 541 38 AsyncTaskChain::get_timeslice_priority 0 1 137 184
/**
 * Returns the timeslice_priority flag.  This changes the interpretation of
 * priority, and the number of times per epoch each task will run.  See
 * set_timeslice_priority().
 */
56
bool AsyncTaskChain::get_timeslice_priority(void) const;

389 12 stop_threads 0 4 541 28 AsyncTaskChain::stop_threads 0 1 138 215
/**
 * Stops any threads that are currently running.  If any tasks are still
 * pending and have not yet been picked up by a thread, they will not be
 * serviced unless poll() or start_threads() is later called.
 */
40
void AsyncTaskChain::stop_threads(void);

390 13 start_threads 0 4 541 29 AsyncTaskChain::start_threads 0 1 139 171
/**
 * Starts any requested threads to service the tasks on the queue.  This is
 * normally not necessary, since adding a task will start the threads
 * automatically.
 */
41
void AsyncTaskChain::start_threads(void);

391 10 is_started 0 4 541 26 AsyncTaskChain::is_started 0 1 140 212
/**
 * Returns true if the thread(s) have been started and are ready to service
 * requests, false otherwise.  If this is false, the next call to add() or
 * add_and_do() will automatically start the threads.
 */
51
inline bool AsyncTaskChain::is_started(void) const;

392 3 add 0 4 541 19 AsyncTaskChain::add 0 1 141 156
/**
 * Adds the indicated task to the active queue.  The task must be inactive, and
 * may not have been added to any queue (including the current one).
 */
42
void AsyncTaskChain::add(AsyncTask *task);

393 8 has_task 0 4 541 24 AsyncTaskChain::has_task 0 1 142 104
/**
 * Returns true if the indicated task has been added to this AsyncTaskChain,
 * false otherwise.
 */
53
bool AsyncTaskChain::has_task(AsyncTask *task) const;

394 14 wait_for_tasks 0 4 541 30 AsyncTaskChain::wait_for_tasks 0 1 143 47
/**
 * Blocks until the task list is empty.
 */
42
void AsyncTaskChain::wait_for_tasks(void);

395 13 get_num_tasks 0 4 541 29 AsyncTaskChain::get_num_tasks 0 1 144 102
/**
 * Returns the number of tasks that are currently active or sleeping within
 * the task chain.
 */
46
int AsyncTaskChain::get_num_tasks(void) const;

396 9 get_tasks 0 4 541 25 AsyncTaskChain::get_tasks 0 1 145 110
/**
 * Returns the set of tasks that are active or sleeping on the task chain, at
 * the time of the call.
 */
58
AsyncTaskCollection AsyncTaskChain::get_tasks(void) const;

397 16 get_active_tasks 0 4 541 32 AsyncTaskChain::get_active_tasks 0 1 146 117
/**
 * Returns the set of tasks that are active (and not sleeping) on the task
 * chain, at the time of the call.
 */
65
AsyncTaskCollection AsyncTaskChain::get_active_tasks(void) const;

398 18 get_sleeping_tasks 0 4 541 34 AsyncTaskChain::get_sleeping_tasks 0 1 147 117
/**
 * Returns the set of tasks that are sleeping (and not active) on the task
 * chain, at the time of the call.
 */
67
AsyncTaskCollection AsyncTaskChain::get_sleeping_tasks(void) const;

399 4 poll 0 4 541 20 AsyncTaskChain::poll 0 1 148 381
/**
 * Runs through all the tasks in the task list, once, if the task chain is
 * running in single-threaded mode (no threads available).  This method does
 * nothing in threaded mode, so it may safely be called in either case.
 *
 * Normally, you would not call this function directly; instead, call
 * AsyncTaskManager::poll(), which polls all of the task chains in sequence.
 */
32
void AsyncTaskChain::poll(void);

400 18 get_next_wake_time 0 4 541 34 AsyncTaskChain::get_next_wake_time 0 1 149 169
/**
 * Returns the scheduled time (on the manager's clock) of the next sleeping
 * task, on any task chain, to awaken.  Returns -1 if there are no sleeping
 * tasks.
 */
54
double AsyncTaskChain::get_next_wake_time(void) const;

401 6 output 0 6 541 22 AsyncTaskChain::output 0 1 150 10
/**
 *
 */
61
virtual void AsyncTaskChain::output(std::ostream &out) const;

402 5 write 0 6 541 21 AsyncTaskChain::write 0 1 151 10
/**
 *
 */
82
virtual void AsyncTaskChain::write(std::ostream &out, int indent_level = 0) const;

403 14 get_class_type 0 4 541 30 AsyncTaskChain::get_class_type 0 1 152 0
55
static TypeHandle AsyncTaskChain::get_class_type(void);

404 14 AsyncTaskPause 0 260 542 30 AsyncTaskPause::AsyncTaskPause 0 1 155 10
/**
 *
 */
45
AsyncTaskPause::AsyncTaskPause(double delay);

405 12 operator new 0 4 542 28 AsyncTaskPause::operator new 0 1 156 0
132
inline void *AsyncTaskPause::operator new(std::size_t size);
inline void *AsyncTaskPause::operator new(std::size_t size, void *ptr);

406 15 operator delete 0 4 542 31 AsyncTaskPause::operator delete 0 0 0
116
inline void AsyncTaskPause::operator delete(void *ptr);
inline void AsyncTaskPause::operator delete(void *, void *);

407 12 validate_ptr 0 4 542 28 AsyncTaskPause::validate_ptr 0 0 0
65
static inline bool AsyncTaskPause::validate_ptr(void const *ptr);

408 14 get_class_type 0 4 542 30 AsyncTaskPause::get_class_type 0 1 157 0
55
static TypeHandle AsyncTaskPause::get_class_type(void);

409 15 ~AsyncTaskPause 0 516 542 31 AsyncTaskPause::~AsyncTaskPause 0 0 0
38
AsyncTaskPause::~AsyncTaskPause(void);

410 19 upcast_to_AsyncTask 0 12 543 38 AsyncTaskSequence::upcast_to_AsyncTask 0 1 164 42
upcast from AsyncTaskSequence to AsyncTask
56
AsyncTask *AsyncTaskSequence::upcast_to_AsyncTask(void);

411 29 downcast_to_AsyncTaskSequence 0 12 526 40 AsyncTask::downcast_to_AsyncTaskSequence 0 0 44
downcast from AsyncTask to AsyncTaskSequence
66
AsyncTaskSequence *AsyncTask::downcast_to_AsyncTaskSequence(void);

412 29 upcast_to_AsyncTaskCollection 0 12 543 48 AsyncTaskSequence::upcast_to_AsyncTaskCollection 0 1 165 52
upcast from AsyncTaskSequence to AsyncTaskCollection
76
AsyncTaskCollection *AsyncTaskSequence::upcast_to_AsyncTaskCollection(void);

413 29 downcast_to_AsyncTaskSequence 0 12 535 50 AsyncTaskCollection::downcast_to_AsyncTaskSequence 0 0 54
downcast from AsyncTaskCollection to AsyncTaskSequence
76
AsyncTaskSequence *AsyncTaskCollection::downcast_to_AsyncTaskSequence(void);

414 17 AsyncTaskSequence 0 260 543 36 AsyncTaskSequence::AsyncTaskSequence 0 1 158 10
/**
 *
 */
71
explicit AsyncTaskSequence::AsyncTaskSequence(std::string const &name);

415 18 ~AsyncTaskSequence 0 518 543 37 AsyncTaskSequence::~AsyncTaskSequence 0 0 10
/**
 *
 */
52
virtual AsyncTaskSequence::~AsyncTaskSequence(void);

416 12 operator new 0 4 543 31 AsyncTaskSequence::operator new 0 1 159 0
138
inline void *AsyncTaskSequence::operator new(std::size_t size);
inline void *AsyncTaskSequence::operator new(std::size_t size, void *ptr);

417 15 operator delete 0 4 543 34 AsyncTaskSequence::operator delete 0 0 0
122
inline void AsyncTaskSequence::operator delete(void *ptr);
inline void AsyncTaskSequence::operator delete(void *, void *);

418 12 validate_ptr 0 4 543 31 AsyncTaskSequence::validate_ptr 0 0 0
68
static inline bool AsyncTaskSequence::validate_ptr(void const *ptr);

419 16 set_repeat_count 0 4 543 35 AsyncTaskSequence::set_repeat_count 0 1 160 251
/**
 * Sets the repeat count of the sequence.  If the count is 0 or 1, the
 * sequence will run exactly once.  If it is greater than 0, it will run that
 * number of times.  If it is negative, it will run forever until it is
 * explicitly removed.
 */
66
inline void AsyncTaskSequence::set_repeat_count(int repeat_count);

420 16 get_repeat_count 0 4 543 35 AsyncTaskSequence::get_repeat_count 0 1 161 77
/**
 * Returns the repeat count of the sequence.  See set_repeat_count().
 */
59
inline int AsyncTaskSequence::get_repeat_count(void) const;

421 22 get_current_task_index 0 4 543 41 AsyncTaskSequence::get_current_task_index 0 1 162 142
/**
 * Returns the index of the task within the sequence that is currently being
 * executed (or that will be executed at the next epoch).
 */
73
inline std::size_t AsyncTaskSequence::get_current_task_index(void) const;

422 14 get_class_type 0 4 543 33 AsyncTaskSequence::get_class_type 0 1 163 0
58
static TypeHandle AsyncTaskSequence::get_class_type(void);

423 11 operator == 0 4 544 24 ButtonEvent::operator == 0 1 166 0
69
inline bool ButtonEvent::operator ==(ButtonEvent const &other) const;

424 11 operator != 0 4 544 24 ButtonEvent::operator != 0 1 167 0
69
inline bool ButtonEvent::operator !=(ButtonEvent const &other) const;

425 10 operator < 0 4 544 23 ButtonEvent::operator < 0 1 168 0
68
inline bool ButtonEvent::operator <(ButtonEvent const &other) const;

426 10 get_button 0 4 544 23 ButtonEvent::get_button 0 0 10
/**
 *
 */
56
inline ButtonHandle ButtonEvent::get_button(void) const;

427 11 get_keycode 0 4 544 24 ButtonEvent::get_keycode 0 0 10
/**
 *
 */
48
inline int ButtonEvent::get_keycode(void) const;

428 8 get_type 0 4 544 21 ButtonEvent::get_type 0 0 10
/**
 *
 */
59
inline ButtonEvent::Type ButtonEvent::get_type(void) const;

429 8 get_time 0 4 544 21 ButtonEvent::get_time 0 0 10
/**
 *
 */
48
inline double ButtonEvent::get_time(void) const;

430 12 ~ButtonEvent 0 516 544 25 ButtonEvent::~ButtonEvent 0 0 0
32
ButtonEvent::~ButtonEvent(void);

431 15 ButtonEventList 0 260 547 32 ButtonEventList::ButtonEventList 0 2 169 170 22
/**
 *
 */

/**
 *
 */
116
inline ButtonEventList::ButtonEventList(void);
inline ButtonEventList::ButtonEventList(ButtonEventList const &copy);

432 10 operator = 0 4 547 27 ButtonEventList::operator = 0 1 171 0
69
inline void ButtonEventList::operator =(ButtonEventList const &copy);

433 9 add_event 0 4 547 26 ButtonEventList::add_event 0 1 172 51
/**
 * Adds a new event to the end of the list.
 */
58
inline void ButtonEventList::add_event(ButtonEvent event);

434 14 get_num_events 0 4 547 31 ButtonEventList::get_num_events 0 1 173 52
/**
 * Returns the number of events in the list.
 */
55
inline int ButtonEventList::get_num_events(void) const;

435 9 get_event 0 4 547 26 ButtonEventList::get_event 0 1 174 169
/**
 * Returns the nth event in the list.  This does not remove the event from the
 * list; the only way to remove events is to empty the whole list with
 * clear().
 */
66
inline ButtonEvent const &ButtonEventList::get_event(int n) const;

436 5 clear 0 4 547 22 ButtonEventList::clear 0 1 175 48
/**
 * Empties all the events from the list.
 */
41
inline void ButtonEventList::clear(void);

437 10 add_events 0 4 547 27 ButtonEventList::add_events 0 1 176 75
/**
 * Appends the events from the other list onto the end of this one.
 */
63
void ButtonEventList::add_events(ButtonEventList const &other);

438 11 update_mods 0 4 547 28 ButtonEventList::update_mods 0 1 177 124
/**
 * Updates the indicated ModifierButtons object with all of the button up/down
 * transitions indicated in the list.
 */
63
void ButtonEventList::update_mods(ModifierButtons &mods) const;

439 5 write 0 4 547 22 ButtonEventList::write 0 1 178 10
/**
 *
 */
75
void ButtonEventList::write(std::ostream &out, int indent_level = 0) const;

440 14 get_class_type 0 4 547 31 ButtonEventList::get_class_type 0 1 179 0
56
static TypeHandle ButtonEventList::get_class_type(void);

441 16 ~ButtonEventList 0 516 547 33 ButtonEventList::~ButtonEventList 0 0 0
40
ButtonEventList::~ButtonEventList(void);

442 5 Event 0 260 550 12 Event::Event 0 2 180 181 22
/**
 *
 */

/**
 *
 */
112
Event::Event(std::string const &event_name, EventReceiver *receiver = nullptr);
Event::Event(Event const &copy);

443 10 operator = 0 4 550 17 Event::operator = 0 1 182 0
42
void Event::operator =(Event const &copy);

444 8 set_name 0 4 550 15 Event::set_name 0 1 183 10
/**
 *
 */
53
inline void Event::set_name(std::string const &name);

445 10 clear_name 0 4 550 17 Event::clear_name 0 1 184 44
/**
 * Resets the Event's name to empty.
 */
36
inline void Event::clear_name(void);

446 8 has_name 0 4 550 15 Event::has_name 0 1 185 92
/**
 * Returns true if the Event has a nonempty name set, false if the name is
 * empty.
 */
40
inline bool Event::has_name(void) const;

447 8 get_name 0 4 550 15 Event::get_name 0 1 186 10
/**
 *
 */
54
inline std::string const &Event::get_name(void) const;

448 13 add_parameter 0 4 550 20 Event::add_parameter 0 1 187 10
/**
 *
 */
53
void Event::add_parameter(EventParameter const &obj);

449 18 get_num_parameters 0 4 550 25 Event::get_num_parameters 0 1 188 10
/**
 *
 */
42
int Event::get_num_parameters(void) const;

450 13 get_parameter 0 4 550 20 Event::get_parameter 0 1 189 10
/**
 *
 */
49
EventParameter Event::get_parameter(int n) const;

451 12 has_receiver 0 4 550 19 Event::has_receiver 0 1 190 10
/**
 *
 */
37
bool Event::has_receiver(void) const;

452 12 get_receiver 0 4 550 19 Event::get_receiver 0 1 191 10
/**
 *
 */
47
EventReceiver *Event::get_receiver(void) const;

453 12 set_receiver 0 4 550 19 Event::set_receiver 0 1 192 10
/**
 *
 */
50
void Event::set_receiver(EventReceiver *receiver);

454 14 clear_receiver 0 4 550 21 Event::clear_receiver 0 1 193 10
/**
 *
 */
33
void Event::clear_receiver(void);

455 6 output 0 4 550 13 Event::output 0 1 194 10
/**
 *
 */
44
void Event::output(std::ostream &out) const;

456 14 get_class_type 0 4 550 21 Event::get_class_type 0 1 195 0
46
static TypeHandle Event::get_class_type(void);

457 12 EventHandler 0 260 553 26 EventHandler::EventHandler 0 1 196 10
/**
 *
 */
58
explicit EventHandler::EventHandler(EventQueue *ev_queue);

458 10 get_future 0 4 553 24 EventHandler::get_future 0 1 197 96
/**
 * Returns a pending future that will be marked as done when the event is next
 * fired.
 */
69
AsyncFuture *EventHandler::get_future(std::string const &event_name);

459 14 process_events 0 4 553 28 EventHandler::process_events 0 1 198 188
/**
 * The main processing loop of the EventHandler.  This function must be called
 * periodically to service events.  Walks through each pending event and calls
 * its assigned hooks.
 */
40
void EventHandler::process_events(void);

460 14 dispatch_event 0 6 553 28 EventHandler::dispatch_event 0 1 199 66
/**
 * Calls the hooks assigned to the indicated single event.
 */
62
virtual void EventHandler::dispatch_event(Event const *event);

461 5 write 0 4 553 19 EventHandler::write 0 1 200 10
/**
 *
 */
50
void EventHandler::write(std::ostream &out) const;

462 24 get_global_event_handler 0 4 553 38 EventHandler::get_global_event_handler 0 1 201 139
/**
 * Returns a pointer to the one global EventHandler object.  If the global
 * object has not yet been created, this will create it.
 */
96
static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue = nullptr);

463 14 get_class_type 0 4 553 28 EventHandler::get_class_type 0 1 202 0
53
static TypeHandle EventHandler::get_class_type(void);

464 10 EventQueue 0 260 555 22 EventQueue::EventQueue 0 1 203 10
/**
 *
 */
29
EventQueue::EventQueue(void);

465 11 ~EventQueue 0 516 555 23 EventQueue::~EventQueue 0 0 10
/**
 *
 */
30
EventQueue::~EventQueue(void);

466 11 queue_event 0 4 555 23 EventQueue::queue_event 0 1 204 10
/**
 *
 */
46
void EventQueue::queue_event(CPT_Event event);

467 5 clear 0 4 555 17 EventQueue::clear 0 1 205 71
/**
 * Empties all events on the queue, throwing them on the floor.
 */
29
void EventQueue::clear(void);

468 14 is_queue_empty 0 4 555 26 EventQueue::is_queue_empty 0 1 206 10
/**
 *
 */
44
bool EventQueue::is_queue_empty(void) const;

469 13 is_queue_full 0 4 555 25 EventQueue::is_queue_full 0 1 207 73
/**
 * @deprecated Always returns false; the queue can never be full.
 */
43
bool EventQueue::is_queue_full(void) const;

470 13 dequeue_event 0 4 555 25 EventQueue::dequeue_event 0 1 208 10
/**
 *
 */
42
CPT_Event EventQueue::dequeue_event(void);

471 22 get_global_event_queue 0 4 555 34 EventQueue::get_global_event_queue 0 1 209 137
/**
 * Returns a pointer to the one global EventQueue object.  If the global
 * object has not yet been created, this will create it.
 */
67
static inline EventQueue *EventQueue::get_global_event_queue(void);

472 16 PointerEventList 0 260 556 34 PointerEventList::PointerEventList 0 1 210 22
/**
 *
 */

/**
 *
 */
48
inline PointerEventList::PointerEventList(void);

473 14 get_num_events 0 4 556 32 PointerEventList::get_num_events 0 1 211 52
/**
 * Returns the number of events in the list.
 */
64
inline std::size_t PointerEventList::get_num_events(void) const;

474 13 get_in_window 0 4 556 31 PointerEventList::get_in_window 0 1 212 51
/**
 * Get the in-window flag of the nth event.
 */
65
inline bool PointerEventList::get_in_window(std::size_t n) const;

475 8 get_xpos 0 4 556 26 PointerEventList::get_xpos 0 1 213 49
/**
 * Get the x-coordinate of the nth event.
 */
59
inline int PointerEventList::get_xpos(std::size_t n) const;

476 8 get_ypos 0 4 556 26 PointerEventList::get_ypos 0 1 214 49
/**
 * Get the y-coordinate of the nth event.
 */
59
inline int PointerEventList::get_ypos(std::size_t n) const;

477 6 get_dx 0 4 556 24 PointerEventList::get_dx 0 1 215 44
/**
 * Get the x-delta of the nth event.
 */
60
inline double PointerEventList::get_dx(std::size_t n) const;

478 6 get_dy 0 4 556 24 PointerEventList::get_dy 0 1 216 44
/**
 * Get the y-delta of the nth event.
 */
60
inline double PointerEventList::get_dy(std::size_t n) const;

479 12 get_sequence 0 4 556 30 PointerEventList::get_sequence 0 1 217 52
/**
 * Get the sequence number of the nth event.
 */
63
inline int PointerEventList::get_sequence(std::size_t n) const;

480 10 get_length 0 4 556 28 PointerEventList::get_length 0 1 218 43
/**
 * Get the length of the nth event.
 */
64
inline double PointerEventList::get_length(std::size_t n) const;

481 13 get_direction 0 4 556 31 PointerEventList::get_direction 0 1 219 46
/**
 * Get the direction of the nth event.
 */
67
inline double PointerEventList::get_direction(std::size_t n) const;

482 12 get_rotation 0 4 556 30 PointerEventList::get_rotation 0 1 220 45
/**
 * Get the rotation of the nth event.
 */
66
inline double PointerEventList::get_rotation(std::size_t n) const;

483 8 get_time 0 4 556 26 PointerEventList::get_time 0 1 221 46
/**
 * Get the timestamp of the nth event.
 */
62
inline double PointerEventList::get_time(std::size_t n) const;

484 5 clear 0 4 556 23 PointerEventList::clear 0 1 222 48
/**
 * Empties all the events from the list.
 */
42
inline void PointerEventList::clear(void);

485 9 pop_front 0 4 556 27 PointerEventList::pop_front 0 1 223 48
/**
 * Discards the first event on the list.
 */
46
inline void PointerEventList::pop_front(void);

486 9 add_event 0 4 556 27 PointerEventList::add_event 0 3 224 225 226 304
/**
 * Adds a new event from the given PointerData object.
 */

/**
 * Adds a new event to the end of the list.  Automatically calculates the dx,
 * dy, length, direction, and rotation for all but the first event.
 */

/**
 * Adds a new event to the end of the list based on the given mouse movement.
 */
288
void PointerEventList::add_event(PointerData const &data, int seq, double time);
void PointerEventList::add_event(bool in_win, int xpos, int ypos, int seq, double time);
void PointerEventList::add_event(bool in_win, int xpos, int ypos, double xdelta, double ydelta, int seq, double time);

487 9 encircles 0 4 556 27 PointerEventList::encircles 0 1 227 70
/**
 * Returns true if the trail loops around the specified point.
 */
53
bool PointerEventList::encircles(int x, int y) const;

488 11 total_turns 0 4 556 29 PointerEventList::total_turns 0 1 228 279
/**
 * returns the total angular deviation that the trail has made in the
 * specified time period.  A small number means that the trail is moving in a
 * relatively straight line, a large number means that the trail is zig-
 * zagging or spinning.  The result is in degrees.
 */
55
double PointerEventList::total_turns(double sec) const;

489 13 match_pattern 0 4 556 31 PointerEventList::match_pattern 0 1 229 540
/**
 * This function is not implemented yet.  It is a work in progress.  The
 * intent is as follows:
 *
 * Returns a nonzero value if the mouse movements match the specified pattern.
 * The higher the value, the better the match.  The pattern is a sequence of
 * compass directions (ie, "E", "NE", etc) separated by spaces.  If rot is
 * nonzero, then the pattern is rotated counterclockwise by the specified
 * amount before testing.  Seglen is the minimum length a mouse movement needs
 * to be in order to be considered significant.
 */
94
double PointerEventList::match_pattern(std::string const &pattern, double rot, double seglen);

490 14 get_class_type 0 4 556 32 PointerEventList::get_class_type 0 1 230 0
57
static TypeHandle PointerEventList::get_class_type(void);

491 17 ~PointerEventList 0 516 556 35 PointerEventList::~PointerEventList 0 0 0
42
PointerEventList::~PointerEventList(void);

492 10 PythonTask 0 260 557 22 PythonTask::PythonTask 0 1 231 0
102
PythonTask::PythonTask(PyObject *function = (& ::_Py_NoneStruct), std::string const &name = string());

493 12 operator new 0 4 557 24 PythonTask::operator new 0 1 232 0
124
inline void *PythonTask::operator new(std::size_t size);
inline void *PythonTask::operator new(std::size_t size, void *ptr);

494 15 operator delete 0 4 557 27 PythonTask::operator delete 0 0 0
108
inline void PythonTask::operator delete(void *ptr);
inline void PythonTask::operator delete(void *, void *);

495 12 validate_ptr 0 4 557 24 PythonTask::validate_ptr 0 0 0
61
static inline bool PythonTask::validate_ptr(void const *ptr);

496 12 set_function 0 4 557 24 PythonTask::set_function 0 1 233 0
50
void PythonTask::set_function(PyObject *function);

497 12 get_function 0 4 557 24 PythonTask::get_function 0 1 234 66
/**
 * Returns the function that is called when the task runs.
 */
48
inline PyObject *PythonTask::get_function(void);

498 8 set_args 0 4 557 20 PythonTask::set_args 0 1 235 0
60
void PythonTask::set_args(PyObject *args, bool append_task);

499 8 get_args 0 4 557 20 PythonTask::get_args 0 1 236 0
37
PyObject *PythonTask::get_args(void);

500 14 set_upon_death 0 4 557 26 PythonTask::set_upon_death 0 1 237 0
54
void PythonTask::set_upon_death(PyObject *upon_death);

501 14 get_upon_death 0 4 557 26 PythonTask::get_upon_death 0 1 238 70
/**
 * Returns the function that is called when the task finishes.
 */
50
inline PyObject *PythonTask::get_upon_death(void);

502 9 set_owner 0 4 557 21 PythonTask::set_owner 0 1 239 0
44
void PythonTask::set_owner(PyObject *owner);

503 9 get_owner 0 4 557 21 PythonTask::get_owner 0 1 240 56
/**
 * Returns the "owner" object.  See set_owner().
 */
51
inline PyObject *PythonTask::get_owner(void) const;

504 10 set_result 0 4 557 22 PythonTask::set_result 0 1 241 172
/**
 * Sets the "result" of this task.  This is the value returned from an "await"
 * expression on this task.
 * This can only be called while the task is still alive.
 */
53
inline void PythonTask::set_result(PyObject *result);

505 11 __setattr__ 0 4 557 23 PythonTask::__setattr__ 0 1 242 0
73
int PythonTask::__setattr__(PyObject *self, PyObject *attr, PyObject *v);

506 11 __delattr__ 0 4 557 23 PythonTask::__delattr__ 0 1 243 0
60
int PythonTask::__delattr__(PyObject *self, PyObject *attr);

507 16 __getattribute__ 0 4 557 28 PythonTask::__getattribute__ 0 1 244 0
77
PyObject *PythonTask::__getattribute__(PyObject *self, PyObject *attr) const;

508 12 __traverse__ 0 4 557 24 PythonTask::__traverse__ 0 1 245 0
57
int PythonTask::__traverse__(visitproc visit, void *arg);

509 9 __clear__ 0 4 557 21 PythonTask::__clear__ 0 1 246 0
32
int PythonTask::__clear__(void);

510 16 get_elapsed_time 0 4 557 28 PythonTask::get_elapsed_time 0 0 200
/**
 * Returns the amount of time that has elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
48
double PythonTask::get_elapsed_time(void) const;

511 13 get_wake_time 0 4 557 25 PythonTask::get_wake_time 0 0 710
/**
 * If this task has been added to an AsyncTaskManager with a delay in effect,
 * this returns the time at which the task is expected to awaken.  It has no
 * meaning if the task has not yet been added to a queue, or if there was no
 * delay in effect at the time the task was added.
 *
 * If the task's status is not S_sleeping, this returns 0.0.
 */

/**
 * If this task has been added to an AsyncTaskManager with a delay in effect,
 * this returns the time at which the task is expected to awaken.  It has no
 * meaning if the task has not yet been added to a queue, or if there was no
 * delay in effect at the time the task was added.
 *
 * If the task's status is not S_sleeping, this returns 0.0.
 */
45
double PythonTask::get_wake_time(void) const;

512 9 get_delay 0 4 557 21 PythonTask::get_delay 0 0 152
/**
 * Returns the delay value that has been set via set_delay, if any.
 */

/**
 * Returns the delay value that has been set via set_delay, if any.
 */
48
inline double PythonTask::get_delay(void) const;

513 9 has_delay 0 4 557 21 PythonTask::has_delay 0 1 248 204
/**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */

/**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */
46
inline bool PythonTask::has_delay(void) const;

514 9 set_delay 0 4 557 21 PythonTask::set_delay 0 0 1374
/**
 * Specifies the amount of time, in seconds, by which this task will be
 * delayed after it has been added to the AsyncTaskManager.  At least the
 * specified amount of time (and possibly more) will elapse before the task
 * begins.
 *
 * You may specify a delay of 0.0 to guarantee that the task will run in the
 * next epoch following the one in which it is added.
 *
 * Setting this value after the task has already been added will not affect
 * the task's wake time; it will only affect the task if it is re-added to the
 * queue in the future, for instance if the task returns DS_again.  However,
 * see recalc_wake_time() if you wish to apply the delay effect immediately.
 */

/**
 * Specifies the amount of time, in seconds, by which this task will be
 * delayed after it has been added to the AsyncTaskManager.  At least the
 * specified amount of time (and possibly more) will elapse before the task
 * begins.
 *
 * You may specify a delay of 0.0 to guarantee that the task will run in the
 * next epoch following the one in which it is added.
 *
 * Setting this value after the task has already been added will not affect
 * the task's wake time; it will only affect the task if it is re-added to the
 * queue in the future, for instance if the task returns DS_again.  However,
 * see recalc_wake_time() if you wish to apply the delay effect immediately.
 */
48
inline void PythonTask::set_delay(double delay);

515 11 clear_delay 0 4 557 23 PythonTask::clear_delay 0 1 249 434
/**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */

/**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */
42
inline void PythonTask::clear_delay(void);

516 18 get_elapsed_frames 0 4 557 30 PythonTask::get_elapsed_frames 0 0 203
/**
 * Returns the number of frames that have elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */
47
int PythonTask::get_elapsed_frames(void) const;

517 8 get_dict 0 20 557 20 PythonTask::get_dict 0 0 42
getter for PyObject *PythonTask::__dict__;
43
PyObject *PythonTask::get_dict(void) const;

518 8 set_dict 0 36 557 20 PythonTask::set_dict 0 0 42
setter for PyObject *PythonTask::__dict__;
43
void PythonTask::set_dict(PyObject *value);

519 14 get_class_type 0 4 557 26 PythonTask::get_class_type 0 1 247 0
51
static TypeHandle PythonTask::get_class_type(void);

249
1 0 0 7 2 561 252 0 0 0 
2 0 0 15 2 561 252 0 10 /**
 *
 */ 1 4 copy 1 562  
3 0 0 23 2 561 252 0 477 /**
 * Defines an EventParameter that stores a pointer to a TypedReferenceCount
 * object.  Note that a TypedReferenceCount is not the same kind of pointer as
 * a TypedWritableReferenceCount, hence we require both constructors.
 *
 * This accepts a const pointer, even though it stores (and eventually
 * returns) a non-const pointer.  This is just the simplest way to allow both
 * const and non-const pointers to be stored, but it does lose the constness.
 * Be careful.
 */ 1 3 ptr 1 564  
4 0 0 23 2 561 252 0 396 /**
 * Defines an EventParameter that stores a pointer to any kind of
 * TypedWritableReferenceCount object.  This is the most general constructor.
 *
 * This accepts a const pointer, even though it stores (and eventually
 * returns) a non-const pointer.  This is just the simplest way to allow both
 * const and non-const pointers to be stored, but it does lose the constness.
 * Be careful.
 */ 1 3 ptr 1 566  
5 0 0 23 2 561 252 0 72 /**
 * Defines an EventParameter that stores a floating-point value.
 */ 1 5 value 1 536  
6 0 0 23 2 561 252 0 66 /**
 * Defines an EventParameter that stores an integer value.
 */ 1 5 value 1 540  
7 0 0 23 2 561 252 0 0 1 6 param0 0 569  
8 0 0 23 2 561 252 0 64 /**
 * Defines an EventParameter that stores a string value.
 */ 1 5 value 1 571  
9 0 0 23 2 561 252 0 65 /**
 * Defines an EventParameter that stores a wstring value.
 */ 1 5 value 1 571  
10 0 0 6 3 561 0 0 10 /**
 *
 */ 2 4 this 3 561  4 copy 1 562  
11 0 0 6 5 530 0 0 266 // These functions are conveniences to easily determine if the
// EventParameter is one of the predefined parameter types, and retrieve the
// corresponding value.  Of course, it is possible that the EventParameter
// is some user-defined type, and is none of these. 1 4 this 3 562  
12 0 0 6 6 530 0 0 90 /**
 * Returns true if the EventParameter stores an integer value, false
 * otherwise.
 */ 1 4 this 3 562  
13 0 0 6 7 540 0 0 133 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_int() has already returned true.
 */ 1 4 this 3 562  
14 0 0 6 8 530 0 0 103 /**
 * Returns true if the EventParameter stores a double floating-point value,
 * false otherwise.
 */ 1 4 this 3 562  
15 0 0 6 9 536 0 0 136 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_double() has already returned true.
 */ 1 4 this 3 562  
16 0 0 6 10 530 0 0 85 /**
 * Returns true if the EventParameter stores a string value, false otherwise.
 */ 1 4 this 3 562  
17 0 0 6 11 571 0 0 136 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_string() has already returned true.
 */ 1 4 this 3 562  
18 0 0 6 12 530 0 0 86 /**
 * Returns true if the EventParameter stores a wstring value, false otherwise.
 */ 1 4 this 3 562  
19 0 0 6 13 571 0 0 137 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_wstring() has already returned true.
 */ 1 4 this 3 562  
20 0 0 6 14 530 0 0 255 /**
 * Returns true if the EventParameter stores a TypedReferenceCount pointer,
 * false otherwise.  Note that a TypedReferenceCount is not exactly the same
 * kind of pointer as a TypedWritableReferenceCount, hence the need for this
 * separate call.
 */ 1 4 this 3 562  
21 0 0 7 15 572 0 0 145 /**
 * Retrieves the value stored in the EventParameter.  It is only valid to call
 * this if is_typed_ref_count() has already returned true.
 */ 1 4 this 3 562  
22 0 0 7 16 573 0 0 281 /**
 * Retrieves a pointer to the actual value stored in the parameter.  The
 * TypeHandle of this pointer may be examined to determine the actual type of
 * parameter it contains.  This is the only way to retrieve the value when it
 * is not one of the above predefined types.
 */ 1 4 this 3 562  
23 0 0 4 17 576 0 0 10 /**
 *
 */ 2 4 this 3 562  3 out 1 574  
24 0 0 7 20 577 0 0 55 /**
 * Initializes the future in the pending state.
 */ 0 
25 0 0 38 21 558 0 0 0 0 
26 0 0 38 22 558 0 0 0 0 
27 0 0 6 23 530 0 0 104 /**
 * Returns true if the future is done or has been cancelled.  It is always
 * safe to call this.
 */ 1 4 this 3 578  
28 0 0 6 24 530 0 0 85 /**
 * Returns true if the future was cancelled.  It is always safe to call this.
 */ 1 4 this 3 578  
29 0 0 38 25 558 0 0 0 2 4 this 3 578  7 timeout 5 558  
30 0 0 6 26 530 0 0 531 /**
 * Cancels the future.  Returns true if it was cancelled, or false if the
 * future was already done.  Either way, done() will return true after this
 * call returns.
 *
 * Please note that calling this is not a guarantee that the operation
 * corresponding this future does not run.  It could already be in the process
 * of running, or perhaps not respond to a cancel signal.  All this guarantees
 * is that the future is marked as done when this call returns.
 *
 * In the case of a task, this is equivalent to remove().
 */ 1 4 this 3 577  
31 0 0 4 27 576 0 0 212 /**
 * Sets the event name that will be triggered when the future finishes.  Will
 * not be triggered if the future is cancelled, but it will be triggered for
 * a coroutine task that exits with an exception.
 */ 2 4 this 3 577  10 done_event 1 571  
32 0 0 6 28 571 0 0 107 /**
 * Returns the event name that will be triggered when the future finishes.
 * See set_done_event().
 */ 1 4 this 3 578  
33 0 0 38 33 558 0 0 0 2 4 this 3 577  2 fn 1 558  
34 0 0 38 34 558 0 0 0 1 4 args 1 558  
35 0 0 7 35 577 0 0 159 /**
 * Creates a new future that shields the given future from cancellation.
 * Calling `cancel()` on the returned future will not affect the given future.
 */ 1 6 future 1 577  
36 0 0 4 36 576 0 0 10 /**
 *
 */ 2 4 this 3 578  3 out 1 574  
37 0 0 4 37 576 0 0 42 /**
 * Waits until the future is done.
 */ 1 4 this 3 577  
38 0 0 4 37 576 0 0 236 /**
 * Waits until the future is done, or until the timeout is reached.  Note that
 * this can be considerably less efficient than wait() without a timeout, so
 * it's generally not a good idea to use this unless you really need to.
 */ 2 4 this 3 577  7 timeout 1 536  
39 0 0 36 38 576 0 0 0 2 4 this 3 577  6 param0 0 558  
40 0 0 7 39 581 0 0 0 0 
41 0 0 6 49 529 0 0 49 /**
 * Returns the current state of the task.
 */ 1 4 this 3 582  
42 0 0 6 50 530 0 0 332 /**
 * Returns true if the task is currently active or sleeping on some task
 * chain, meaning that it will be executed in its turn, or false if it is not
 * active.  If the task has recently been removed while it is in the middle of
 * execution, this will return false, because the task will not run again once
 * it finishes.
 */ 1 4 this 3 582  
43 0 0 7 51 531 321 0 118 /**
 * Returns the AsyncTaskManager that this task is active on.  This will be
 * NULL if the state is S_inactive.
 */ 1 4 this 3 582  
44 0 0 6 52 530 0 0 297 /**
 * Removes the task from its active manager, if any, and makes the state
 * S_inactive (or possible S_servicing_removed).  This is a no-op if the state
 * is already S_inactive.
 *
 * If the task is a coroutine that is currently awaiting a future, this will
 * fail, but see also cancel().
 */ 1 4 this 3 584  
45 0 0 4 53 576 0 0 686 /**
 * Specifies the amount of time, in seconds, by which this task will be
 * delayed after it has been added to the AsyncTaskManager.  At least the
 * specified amount of time (and possibly more) will elapse before the task
 * begins.
 *
 * You may specify a delay of 0.0 to guarantee that the task will run in the
 * next epoch following the one in which it is added.
 *
 * Setting this value after the task has already been added will not affect
 * the task's wake time; it will only affect the task if it is re-added to the
 * queue in the future, for instance if the task returns DS_again.  However,
 * see recalc_wake_time() if you wish to apply the delay effect immediately.
 */ 2 4 this 3 584  5 delay 1 536  
46 0 0 4 54 576 0 0 216 /**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */ 1 4 this 3 584  
47 0 0 6 55 530 0 0 101 /**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */ 1 4 this 3 582  
48 0 0 6 56 536 0 0 75 /**
 * Returns the delay value that has been set via set_delay, if any.
 */ 1 4 this 3 582  
49 0 0 6 57 536 0 0 354 /**
 * If this task has been added to an AsyncTaskManager with a delay in effect,
 * this returns the time at which the task is expected to awaken.  It has no
 * meaning if the task has not yet been added to a queue, or if there was no
 * delay in effect at the time the task was added.
 *
 * If the task's status is not S_sleeping, this returns 0.0.
 */ 1 4 this 3 582  
50 0 0 4 58 576 0 0 437 /**
 * If the task is currently sleeping on a task chain, this resets its wake
 * time to the current time + get_delay().  It is as if the task had suddenly
 * returned DS_again.  The task will sleep for its current delay seconds
 * before running again.  This method may therefore be used to make the task
 * wake up sooner or later than it would have otherwise.
 *
 * If the task is not already sleeping, this method has no effect.
 */ 1 4 this 3 584  
51 0 0 6 59 536 0 0 176 /**
 * Returns the time at which the task was started, according to the task
 * manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 582  
52 0 0 6 60 536 0 0 200 /**
 * Returns the amount of time that has elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 582  
53 0 0 6 61 540 0 0 184 /**
 * Returns the frame number at which the task was started, according to the
 * task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 582  
54 0 0 6 62 540 0 0 203 /**
 * Returns the number of frames that have elapsed since the task was started,
 * according to the task manager's clock.
 *
 * It is only valid to call this if the task's status is not S_inactive.
 */ 1 4 this 3 582  
55 0 0 4 63 576 0 0 10 /**
 *
 */ 2 4 this 3 584  4 name 1 571  
56 0 0 4 64 576 0 0 43 /**
 * Resets the task's name to empty.
 */ 1 4 this 3 584  
57 0 0 6 65 571 0 0 129 /**
 * Returns the initial part of the name, up to but not including any trailing
 * digits following a hyphen or underscore.
 */ 1 4 this 3 582  
58 0 0 6 66 537 0 0 107 /**
 * Returns a number guaranteed to be unique for each different AsyncTask
 * object in the universe.
 */ 1 4 this 3 582  
59 0 0 4 67 576 0 0 135 /**
 * Specifies the AsyncTaskChain on which this task will be running.  Each task
 * chain runs tasks independently of the others.
 */ 2 4 this 3 584  10 chain_name 1 571  
60 0 0 6 68 571 0 0 133 /**
 * Returns the AsyncTaskChain on which this task will be running.  Each task
 * chain runs tasks independently of the others.
 */ 1 4 this 3 582  
61 0 0 4 69 576 0 0 483 /**
 * Specifies a sort value for this task.  Within a given AsyncTaskManager, all
 * of the tasks with a given sort value are guaranteed to be completed before
 * any tasks with a higher sort value are begun.
 *
 * To put it another way, two tasks might execute in parallel with each other
 * only if they both have the same sort value.  Tasks with a lower sort value
 * are executed first.
 *
 * This is different from the priority, which makes no such exclusion
 * guarantees.
 */ 2 4 this 3 584  4 sort 1 540  
62 0 0 6 70 540 0 0 66 /**
 * Returns the task's current sort value.  See set_sort().
 */ 1 4 this 3 582  
63 0 0 4 71 576 0 0 874 /**
 * Specifies a priority value for this task.  In general, tasks with a higher
 * priority value are executed before tasks with a lower priority value (but
 * only for tasks with the same sort value).
 *
 * Unlike the sort value, tasks with different priorities may execute at the
 * same time, if the AsyncTaskManager has more than one thread servicing
 * tasks.
 *
 * Also see AsyncTaskChain::set_timeslice_priority(), which changes the
 * meaning of this value.  In the default mode, when the timeslice_priority
 * flag is false, all tasks always run once per epoch, regardless of their
 * priority values (that is, the priority controls the order of the task
 * execution only, not the number of times it runs).  On the other hand, if
 * you set the timeslice_priority flag to true, then changing a task's
 * priority has an effect on the number of times it runs.
 */ 2 4 this 3 584  8 priority 1 540  
64 0 0 6 72 540 0 0 74 /**
 * Returns the task's current priority value.  See set_priority().
 */ 1 4 this 3 582  
65 0 0 4 73 576 0 0 257 /**
 * Sets the event name that will be triggered when the task finishes.  This
 * should only be called before the task has been started, or after it has
 * finished and before it is about to be restarted (i.e.  when get_state()
 * returns S_inactive).
 */ 2 4 this 3 584  10 done_event 1 571  
66 0 0 6 74 536 0 0 98 /**
 * Returns the amount of time elapsed during the task's previous run cycle, in
 * seconds.
 */ 1 4 this 3 582  
67 0 0 6 75 536 0 0 118 /**
 * Returns the maximum amount of time elapsed during any one of the task's
 * previous run cycles, in seconds.
 */ 1 4 this 3 582  
68 0 0 6 76 536 0 0 115 /**
 * Returns the average amount of time elapsed during each of the task's
 * previous run cycles, in seconds.
 */ 1 4 this 3 582  
69 0 0 4 77 576 0 0 10 /**
 *
 */ 2 4 this 3 582  3 out 1 574  
70 0 0 7 162 581 0 0 0 0 
71 0 0 7 41 577 0 0 0 1 4 this 3 584  
72 0 0 6 44 585 0 0 0 1 4 this 3 584  
73 0 0 7 88 531 321 0 10 /**
 *
 */ 1 4 name 1 571  
74 0 0 4 90 576 0 0 118 /**
 * Stops all threads and messily empties the task list.  This is intended to
 * be called on destruction only.
 */ 1 4 this 3 531  
75 0 0 4 91 576 0 0 286 /**
 * Replaces the clock pointer used within the AsyncTaskManager.  This is used
 * to control when tasks with a set_delay() specified will be scheduled.  It
 * can also be ticked automatically each epoch, if set_tick_clock() is true.
 *
 * The default is the global clock pointer.
 */ 2 4 this 3 531  5 clock 1 533  
76 0 0 7 92 533 0 0 91 /**
 * Returns the clock pointer used within the AsyncTaskManager.  See
 * set_clock().
 */ 1 4 this 3 531  
77 0 0 6 96 540 0 0 55 /**
 * Returns the number of different task chains.
 */ 1 4 this 3 586  
78 0 0 7 97 588 375 0 38 /**
 * Returns the nth task chain.
 */ 2 4 this 3 586  1 n 1 540  
79 0 0 7 99 588 375 0 178 /**
 * Creates a new AsyncTaskChain of the indicated name and stores it within the
 * AsyncTaskManager.  If a task chain with this name already exists, returns
 * it instead.
 */ 2 4 this 3 531  4 name 1 571  
80 0 0 7 99 588 375 0 187 /**
 * Creates a new threaded AsyncTaskChain of the indicated name and stores it
 * within the AsyncTaskManager.  If a task chain with this name already exists,
 * returns it instead.
 */ 4 4 this 3 531  4 name 1 571  11 num_threads 1 540  15 thread_priority 1 589  
81 0 0 7 100 588 375 0 113 /**
 * Searches a new AsyncTaskChain of the indicated name and returns it if it
 * exists, or NULL otherwise.
 */ 2 4 this 3 531  4 name 1 571  
82 0 0 6 101 530 0 0 211 /**
 * Removes the AsyncTaskChain of the indicated name.  If the chain still has
 * tasks, this will block until all tasks are finished.
 *
 * Returns true if successful, or false if the chain did not exist.
 */ 2 4 this 3 531  4 name 1 571  
83 0 0 4 102 576 0 0 138 /**
 * Adds the indicated task to the active queue.  It is an error if the task is
 * already added to this or any other active queue.
 */ 2 4 this 3 531  4 task 1 584  
84 0 0 6 103 530 0 0 106 /**
 * Returns true if the indicated task has been added to this AsyncTaskManager,
 * false otherwise.
 */ 2 4 this 3 586  4 task 1 584  
85 0 0 7 104 584 286 0 210 /**
 * Returns the first task found with the indicated name, or NULL if there is
 * no task with the indicated name.
 *
 * If there are multiple tasks with the same name, returns one of them
 * arbitrarily.
 */ 2 4 this 3 586  4 name 1 571  
86 0 0 7 105 590 345 0 67 /**
 * Returns the list of tasks found with the indicated name.
 */ 2 4 this 3 586  4 name 1 571  
87 0 0 7 106 590 345 0 111 /**
 * Returns the list of tasks found whose name matches the indicated glob
 * pattern, e.g.  "my_task_*".
 */ 2 4 this 3 586  7 pattern 1 591  
88 0 0 6 107 530 0 0 143 /**
 * Removes the indicated task from the active queue.  Returns true if the task
 * is successfully removed, or false if it wasn't there.
 */ 2 4 this 3 531  4 task 1 584  
89 0 0 6 107 596 0 0 104 /**
 * Removes all of the tasks in the AsyncTaskCollection.  Returns the number of
 * tasks removed.
 */ 2 4 this 3 531  5 tasks 1 594  
90 0 0 4 108 576 0 0 47 /**
 * Blocks until the task list is empty.
 */ 1 4 this 3 531  
91 0 0 4 109 576 0 0 215 /**
 * Stops any threads that are currently running.  If any tasks are still
 * pending and have not yet been picked up by a thread, they will not be
 * serviced unless poll() or start_threads() is later called.
 */ 1 4 this 3 531  
92 0 0 4 110 576 0 0 171 /**
 * Starts any requested threads to service the tasks on the queue.  This is
 * normally not necessary, since adding a task will start the threads
 * automatically.
 */ 1 4 this 3 531  
93 0 0 6 111 596 0 0 104 /**
 * Returns the number of tasks that are currently active or sleeping within
 * the task manager.
 */ 1 4 this 3 586  
94 0 0 7 112 590 345 0 112 /**
 * Returns the set of tasks that are active or sleeping on the task manager,
 * at the time of the call.
 */ 1 4 this 3 586  
95 0 0 7 113 590 345 0 119 /**
 * Returns the set of tasks that are active (and not sleeping) on the task
 * manager, at the time of the call.
 */ 1 4 this 3 586  
96 0 0 7 114 590 345 0 119 /**
 * Returns the set of tasks that are sleeping (and not active) on the task
 * manager, at the time of the call.
 */ 1 4 this 3 586  
97 0 0 4 139 576 0 0 233 /**
 * Runs through all the tasks in the task list, once, if the task manager is
 * running in single-threaded mode (no threads available).  This method does
 * nothing in threaded mode, so it may safely be called in either case.
 */ 1 4 this 3 531  
98 0 0 6 140 536 0 0 169 /**
 * Returns the scheduled time (on the manager's clock) of the next sleeping
 * task, on any task chain, to awaken.  Returns -1 if there are no sleeping
 * tasks.
 */ 1 4 this 3 586  
99 0 0 4 143 576 0 0 10 /**
 *
 */ 2 4 this 3 586  3 out 1 574  
100 0 0 4 144 576 0 0 10 /**
 *
 */ 3 4 this 3 586  3 out 1 574  12 indent_level 5 540  
101 0 0 7 145 531 321 0 152 /**
 * Returns a pointer to the global AsyncTaskManager.  This is the
 * AsyncTaskManager that most code should use for queueing tasks and suchlike.
 */ 0 
102 0 0 7 146 581 0 0 0 0 
103 0 0 7 84 572 0 0 0 1 4 this 3 531  
104 0 0 6 86 585 0 0 0 1 4 this 3 531  
105 0 0 7 117 590 345 0 10 /**
 *
 */ 0 
106 0 0 15 117 590 345 0 10 /**
 *
 */ 1 4 copy 1 594  
107 0 0 6 118 590 0 0 0 2 4 this 3 590  4 copy 1 594  
108 0 0 4 120 576 0 0 50 /**
 * Adds a new AsyncTask to the collection.
 */ 2 4 this 3 590  4 task 1 584  
109 0 0 6 121 530 0 0 153 /**
 * Removes the indicated AsyncTask from the collection.  Returns true if the
 * task was removed, false if it was not a member of the collection.
 */ 2 4 this 3 590  4 task 1 584  
110 0 0 4 121 576 0 0 57 /**
 * Removes the nth AsyncTask from the collection.
 */ 2 4 this 3 590  5 index 1 596  
111 0 0 4 122 576 0 0 204 /**
 * Adds all the AsyncTasks indicated in the other collection to this task.
 * The other tasks are simply appended to the end of the tasks in this list;
 * duplicates are not automatically removed.
 */ 2 4 this 3 590  5 other 1 594  
112 0 0 4 123 576 0 0 96 /**
 * Removes from this collection all of the AsyncTasks listed in the other
 * collection.
 */ 2 4 this 3 590  5 other 1 594  
113 0 0 4 124 576 0 0 198 /**
 * Removes any duplicate entries of the same AsyncTasks on this collection.
 * If a AsyncTask appears multiple times, the first appearance is retained;
 * subsequent appearances are removed.
 */ 1 4 this 3 590  
114 0 0 6 125 530 0 0 98 /**
 * Returns true if the indicated AsyncTask appears in this collection, false
 * otherwise.
 */ 2 4 this 3 594  4 task 1 584  
115 0 0 4 126 576 0 0 54 /**
 * Removes all AsyncTasks from the collection.
 */ 1 4 this 3 590  
116 0 0 7 127 584 286 0 115 /**
 * Returns the task in the collection with the indicated name, if any, or NULL
 * if no task has that name.
 */ 2 4 this 3 594  4 name 1 571  
117 0 0 6 128 596 0 0 62 /**
 * Returns the number of AsyncTasks in the collection.
 */ 1 4 this 3 594  
118 0 0 7 129 584 286 0 55 /**
 * Returns the nth AsyncTask in the collection.
 */ 2 4 this 3 594  5 index 1 596  
119 0 0 7 131 584 286 0 141 /**
 * Returns the nth AsyncTask in the collection.  This is the same as
 * get_task(), but it may be a more convenient way to access it.
 */ 2 4 this 3 594  5 index 1 596  
120 0 0 6 132 596 0 0 104 /**
 * Returns the number of tasks in the collection.  This is the same thing as
 * get_num_tasks().
 */ 1 4 this 3 594  
121 0 0 6 133 590 0 0 0 2 4 this 3 590  5 other 1 594  
122 0 0 7 134 590 345 0 0 2 4 this 3 594  5 other 1 594  
123 0 0 4 135 576 0 0 108 /**
 * Writes a brief one-line description of the AsyncTaskCollection to the
 * indicated output stream.
 */ 2 4 this 3 594  3 out 1 574  
124 0 0 4 136 576 0 0 113 /**
 * Writes a complete multi-line description of the AsyncTaskCollection to the
 * indicated output stream.
 */ 3 4 this 3 594  3 out 1 574  12 indent_level 5 540  
125 0 0 4 169 576 0 0 155 /**
 * Sets the tick_clock flag.  When this is true, get_clock()->tick() will be
 * called automatically at each task epoch.  This is false by default.
 */ 2 4 this 3 588  10 tick_clock 1 530  
126 0 0 6 170 530 0 0 62 /**
 * Returns the tick_clock flag.  See set_tick_clock().
 */ 1 4 this 3 598  
127 0 0 4 171 576 0 0 132 /**
 * Changes the number of threads for this task chain.  This may require
 * stopping the threads if they are already running.
 */ 2 4 this 3 588  11 num_threads 1 540  
128 0 0 6 172 540 0 0 124 /**
 * Returns the number of threads that will be servicing tasks for this chain.
 * Also see get_num_running_threads().
 */ 1 4 this 3 598  
129 0 0 6 173 540 0 0 211 /**
 * Returns the number of threads that have been created and are actively
 * running.  This will return 0 before the threads have been started; it will
 * also return 0 if thread support is not available.
 */ 1 4 this 3 598  
130 0 0 4 174 576 0 0 153 /**
 * Changes the priority associated with threads that serve this task chain.
 * This may require stopping the threads if they are already running.
 */ 2 4 this 3 588  8 priority 1 589  
131 0 0 6 175 589 0 0 83 /**
 * Returns the priority associated with threads that serve this task chain.
 */ 1 4 this 3 598  
132 0 0 4 176 576 0 0 414 /**
 * Sets the maximum amount of time per frame the tasks on this chain are
 * granted for execution.  If this is less than zero, there is no limit; if it
 * is >= 0, it represents a maximum amount of time (in seconds) that will be
 * used to execute tasks.  If this time is exceeded in any one frame, the task
 * chain will stop executing tasks until the next frame, as defined by the
 * TaskManager's clock.
 */ 2 4 this 3 588  12 frame_budget 1 536  
133 0 0 6 177 536 0 0 134 /**
 * Returns the maximum amount of time per frame the tasks on this chain are
 * granted for execution.  See set_frame_budget().
 */ 1 4 this 3 598  
134 0 0 4 178 576 0 0 638 /**
 * Sets the frame_sync flag.  When this flag is true, this task chain will be
 * forced to sync with the TaskManager's clock.  It will run no faster than
 * one epoch per clock frame.
 *
 * When this flag is false, the default, the task chain will finish all of its
 * tasks and then immediately start from the first task again, regardless of
 * the clock frame.  When it is true, the task chain will finish all of its
 * tasks and then wait for the clock to tick to the next frame before resuming
 * the first task.
 *
 * This only makes sense for threaded task chains.  Non-threaded task chains
 * are automatically synchronous.
 */ 2 4 this 3 588  10 frame_sync 1 530  
135 0 0 6 179 530 0 0 62 /**
 * Returns the frame_sync flag.  See set_frame_sync().
 */ 1 4 this 3 598  
136 0 0 4 180 576 0 0 903 /**
 * Sets the timeslice_priority flag.  This changes the interpretation of
 * priority, and the number of times per epoch each task will run.
 *
 * When this flag is true, some tasks might not run in any given epoch.
 * Instead, tasks with priority higher than 1 will be given precedence, in
 * proportion to the amount of time they have already used.  This gives
 * higher-priority tasks more runtime than lower-priority tasks.  Each task
 * gets the amount of time proportional to its priority value, so a task with
 * priority 100 will get five times as much processing time as a task with
 * priority 20.  For these purposes, priority values less than 1 are deemed to
 * be equal to 1.
 *
 * When this flag is false (the default), all tasks are run exactly once each
 * epoch, round-robin style.  Priority is only used to determine which task
 * runs first within tasks of the same sort value.
 */ 2 4 this 3 588  18 timeslice_priority 1 530  
137 0 0 6 181 530 0 0 184 /**
 * Returns the timeslice_priority flag.  This changes the interpretation of
 * priority, and the number of times per epoch each task will run.  See
 * set_timeslice_priority().
 */ 1 4 this 3 598  
138 0 0 4 182 576 0 0 215 /**
 * Stops any threads that are currently running.  If any tasks are still
 * pending and have not yet been picked up by a thread, they will not be
 * serviced unless poll() or start_threads() is later called.
 */ 1 4 this 3 588  
139 0 0 4 183 576 0 0 171 /**
 * Starts any requested threads to service the tasks on the queue.  This is
 * normally not necessary, since adding a task will start the threads
 * automatically.
 */ 1 4 this 3 588  
140 0 0 6 184 530 0 0 212 /**
 * Returns true if the thread(s) have been started and are ready to service
 * requests, false otherwise.  If this is false, the next call to add() or
 * add_and_do() will automatically start the threads.
 */ 1 4 this 3 598  
141 0 0 4 185 576 0 0 156 /**
 * Adds the indicated task to the active queue.  The task must be inactive, and
 * may not have been added to any queue (including the current one).
 */ 2 4 this 3 588  4 task 1 584  
142 0 0 6 186 530 0 0 104 /**
 * Returns true if the indicated task has been added to this AsyncTaskChain,
 * false otherwise.
 */ 2 4 this 3 598  4 task 1 584  
143 0 0 4 187 576 0 0 47 /**
 * Blocks until the task list is empty.
 */ 1 4 this 3 588  
144 0 0 6 188 540 0 0 102 /**
 * Returns the number of tasks that are currently active or sleeping within
 * the task chain.
 */ 1 4 this 3 598  
145 0 0 7 189 590 345 0 110 /**
 * Returns the set of tasks that are active or sleeping on the task chain, at
 * the time of the call.
 */ 1 4 this 3 598  
146 0 0 7 190 590 345 0 117 /**
 * Returns the set of tasks that are active (and not sleeping) on the task
 * chain, at the time of the call.
 */ 1 4 this 3 598  
147 0 0 7 191 590 345 0 117 /**
 * Returns the set of tasks that are sleeping (and not active) on the task
 * chain, at the time of the call.
 */ 1 4 this 3 598  
148 0 0 4 192 576 0 0 381 /**
 * Runs through all the tasks in the task list, once, if the task chain is
 * running in single-threaded mode (no threads available).  This method does
 * nothing in threaded mode, so it may safely be called in either case.
 *
 * Normally, you would not call this function directly; instead, call
 * AsyncTaskManager::poll(), which polls all of the task chains in sequence.
 */ 1 4 this 3 588  
149 0 0 6 193 536 0 0 169 /**
 * Returns the scheduled time (on the manager's clock) of the next sleeping
 * task, on any task chain, to awaken.  Returns -1 if there are no sleeping
 * tasks.
 */ 1 4 this 3 598  
150 0 0 4 194 576 0 0 10 /**
 *
 */ 2 4 this 3 598  3 out 1 574  
151 0 0 4 195 576 0 0 10 /**
 *
 */ 3 4 this 3 598  3 out 1 574  12 indent_level 5 540  
152 0 0 7 196 581 0 0 0 0 
153 0 0 7 164 572 0 0 0 1 4 this 3 588  
154 0 0 6 166 585 0 0 0 1 4 this 3 588  
155 0 0 23 198 600 409 0 10 /**
 *
 */ 1 5 delay 1 536  
156 0 0 4 199 576 0 0 0 2 4 this 3 600  4 size 1 596  
157 0 0 7 202 581 0 0 0 0 
158 0 0 7 209 601 415 0 10 /**
 *
 */ 1 4 name 1 571  
159 0 0 4 211 576 0 0 0 2 4 this 3 601  4 size 1 596  
160 0 0 4 214 576 0 0 251 /**
 * Sets the repeat count of the sequence.  If the count is 0 or 1, the
 * sequence will run exactly once.  If it is greater than 0, it will run that
 * number of times.  If it is negative, it will run forever until it is
 * explicitly removed.
 */ 2 4 this 3 601  12 repeat_count 1 540  
161 0 0 6 215 540 0 0 77 /**
 * Returns the repeat count of the sequence.  See set_repeat_count().
 */ 1 4 this 3 602  
162 0 0 6 216 596 0 0 142 /**
 * Returns the index of the task within the sequence that is currently being
 * executed (or that will be executed at the next epoch).
 */ 1 4 this 3 602  
163 0 0 7 217 581 0 0 0 0 
164 0 0 7 205 584 286 0 0 1 4 this 3 601  
165 0 0 6 207 590 0 0 0 1 4 this 3 601  
166 0 0 6 220 530 0 0 0 2 4 this 3 604  5 other 1 604  
167 0 0 6 221 530 0 0 0 2 4 this 3 604  5 other 1 604  
168 0 0 6 222 530 0 0 0 2 4 this 3 604  5 other 1 604  
169 0 0 7 235 605 441 0 10 /**
 *
 */ 0 
170 0 0 15 235 605 441 0 10 /**
 *
 */ 1 4 copy 1 606  
171 0 0 7 236 605 441 0 0 2 4 this 3 605  4 copy 1 606  
172 0 0 4 237 576 0 0 51 /**
 * Adds a new event to the end of the list.
 */ 2 4 this 3 605  5 event 1 608  
173 0 0 6 238 540 0 0 52 /**
 * Returns the number of events in the list.
 */ 1 4 this 3 606  
174 0 0 6 239 604 0 0 169 /**
 * Returns the nth event in the list.  This does not remove the event from the
 * list; the only way to remove events is to empty the whole list with
 * clear().
 */ 2 4 this 3 606  1 n 1 540  
175 0 0 4 240 576 0 0 48 /**
 * Empties all the events from the list.
 */ 1 4 this 3 605  
176 0 0 4 241 576 0 0 75 /**
 * Appends the events from the other list onto the end of this one.
 */ 2 4 this 3 605  5 other 1 606  
177 0 0 4 242 576 0 0 124 /**
 * Updates the indicated ModifierButtons object with all of the button up/down
 * transitions indicated in the list.
 */ 2 4 this 3 606  4 mods 1 609  
178 0 0 4 243 576 0 0 10 /**
 *
 */ 3 4 this 3 606  3 out 1 574  12 indent_level 5 540  
179 0 0 7 246 581 0 0 0 0 
180 0 0 15 249 613 0 0 10 /**
 *
 */ 1 4 copy 1 611  
181 0 0 23 249 613 0 0 10 /**
 *
 */ 2 10 event_name 1 571  8 receiver 5 551  
182 0 0 7 250 613 0 0 0 2 4 this 3 613  4 copy 1 611  
183 0 0 4 251 576 0 0 10 /**
 *
 */ 2 4 this 3 613  4 name 1 571  
184 0 0 4 252 576 0 0 44 /**
 * Resets the Event's name to empty.
 */ 1 4 this 3 613  
185 0 0 6 253 530 0 0 92 /**
 * Returns true if the Event has a nonempty name set, false if the name is
 * empty.
 */ 1 4 this 3 611  
186 0 0 6 254 571 0 0 10 /**
 *
 */ 1 4 this 3 611  
187 0 0 4 255 576 0 0 10 /**
 *
 */ 2 4 this 3 613  3 obj 1 562  
188 0 0 6 256 540 0 0 10 /**
 *
 */ 1 4 this 3 611  
189 0 0 7 257 561 252 0 10 /**
 *
 */ 2 4 this 3 611  1 n 1 540  
190 0 0 6 259 530 0 0 10 /**
 *
 */ 1 4 this 3 611  
191 0 0 6 260 551 0 0 10 /**
 *
 */ 1 4 this 3 611  
192 0 0 4 261 576 0 0 10 /**
 *
 */ 2 4 this 3 613  8 receiver 1 551  
193 0 0 4 262 576 0 0 10 /**
 *
 */ 1 4 this 3 613  
194 0 0 4 263 576 0 0 10 /**
 *
 */ 2 4 this 3 611  3 out 1 574  
195 0 0 7 269 581 0 0 0 0 
196 0 0 7 272 615 0 0 10 /**
 *
 */ 1 8 ev_queue 1 614  
197 0 0 7 273 577 0 0 96 /**
 * Returns a pending future that will be marked as done when the event is next
 * fired.
 */ 2 4 this 3 615  10 event_name 1 571  
198 0 0 4 274 576 0 0 188 /**
 * The main processing loop of the EventHandler.  This function must be called
 * periodically to service events.  Walks through each pending event and calls
 * its assigned hooks.
 */ 1 4 this 3 615  
199 0 0 4 275 576 0 0 66 /**
 * Calls the hooks assigned to the indicated single event.
 */ 2 4 this 3 615  5 event 1 611  
200 0 0 4 276 576 0 0 10 /**
 *
 */ 2 4 this 3 616  3 out 1 574  
201 0 0 6 277 615 0 0 139 /**
 * Returns a pointer to the one global EventHandler object.  If the global
 * object has not yet been created, this will create it.
 */ 1 5 queue 5 614  
202 0 0 7 278 581 0 0 0 0 
203 0 0 7 280 614 465 0 10 /**
 *
 */ 0 
204 0 0 4 282 576 0 0 10 /**
 *
 */ 2 4 this 3 614  5 event 1 611  
205 0 0 4 283 576 0 0 71 /**
 * Empties all events on the queue, throwing them on the floor.
 */ 1 4 this 3 614  
206 0 0 6 284 530 0 0 10 /**
 *
 */ 1 4 this 3 618  
207 0 0 6 285 530 0 0 73 /**
 * @deprecated Always returns false; the queue can never be full.
 */ 1 4 this 3 618  
208 0 0 7 286 611 0 0 10 /**
 *
 */ 1 4 this 3 614  
209 0 0 6 287 614 0 0 137 /**
 * Returns a pointer to the one global EventQueue object.  If the global
 * object has not yet been created, this will create it.
 */ 0 
210 0 0 7 289 620 491 0 10 /**
 *
 */ 0 
211 0 0 6 290 596 0 0 52 /**
 * Returns the number of events in the list.
 */ 1 4 this 3 621  
212 0 0 6 291 530 0 0 51 /**
 * Get the in-window flag of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
213 0 0 6 292 540 0 0 49 /**
 * Get the x-coordinate of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
214 0 0 6 293 540 0 0 49 /**
 * Get the y-coordinate of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
215 0 0 6 294 536 0 0 44 /**
 * Get the x-delta of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
216 0 0 6 295 536 0 0 44 /**
 * Get the y-delta of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
217 0 0 6 296 540 0 0 52 /**
 * Get the sequence number of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
218 0 0 6 297 536 0 0 43 /**
 * Get the length of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
219 0 0 6 298 536 0 0 46 /**
 * Get the direction of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
220 0 0 6 299 536 0 0 45 /**
 * Get the rotation of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
221 0 0 6 300 536 0 0 46 /**
 * Get the timestamp of the nth event.
 */ 2 4 this 3 621  1 n 1 596  
222 0 0 4 301 576 0 0 48 /**
 * Empties all the events from the list.
 */ 1 4 this 3 620  
223 0 0 4 302 576 0 0 48 /**
 * Discards the first event on the list.
 */ 1 4 this 3 620  
224 0 0 4 303 576 0 0 62 /**
 * Adds a new event from the given PointerData object.
 */ 4 4 this 3 620  4 data 1 623  3 seq 1 540  4 time 1 536  
225 0 0 4 303 576 0 0 85 /**
 * Adds a new event to the end of the list based on the given mouse movement.
 */ 8 4 this 3 620  6 in_win 1 530  4 xpos 1 540  4 ypos 1 540  6 xdelta 1 536  6 ydelta 1 536  3 seq 1 540  4 time 1 536  
226 0 0 4 303 576 0 0 153 /**
 * Adds a new event to the end of the list.  Automatically calculates the dx,
 * dy, length, direction, and rotation for all but the first event.
 */ 6 4 this 3 620  6 in_win 1 530  4 xpos 1 540  4 ypos 1 540  3 seq 1 540  4 time 1 536  
227 0 0 6 304 530 0 0 70 /**
 * Returns true if the trail loops around the specified point.
 */ 3 4 this 3 621  1 x 1 540  1 y 1 540  
228 0 0 6 305 536 0 0 279 /**
 * returns the total angular deviation that the trail has made in the
 * specified time period.  A small number means that the trail is moving in a
 * relatively straight line, a large number means that the trail is zig-
 * zagging or spinning.  The result is in degrees.
 */ 2 4 this 3 621  3 sec 1 536  
229 0 0 6 306 536 0 0 540 /**
 * This function is not implemented yet.  It is a work in progress.  The
 * intent is as follows:
 *
 * Returns a nonzero value if the mouse movements match the specified pattern.
 * The higher the value, the better the match.  The pattern is a sequence of
 * compass directions (ie, "E", "NE", etc) separated by spaces.  If rot is
 * nonzero, then the pattern is rotated counterclockwise by the specified
 * amount before testing.  Seglen is the minimum length a mouse movement needs
 * to be in order to be considered significant.
 */ 4 4 this 3 620  7 pattern 1 571  3 rot 1 536  6 seglen 1 536  
230 0 0 7 307 581 0 0 0 0 
231 0 0 23 310 626 286 0 0 2 8 function 5 558  4 name 5 571  
232 0 0 4 311 576 0 0 0 2 4 this 3 626  4 size 1 596  
233 0 0 4 314 576 0 0 0 2 4 this 3 626  8 function 1 558  
234 0 0 6 315 558 0 0 66 /**
 * Returns the function that is called when the task runs.
 */ 1 4 this 3 626  
235 0 0 4 316 576 0 0 0 3 4 this 3 626  4 args 1 558  11 append_task 1 530  
236 0 0 6 317 558 0 0 0 1 4 this 3 626  
237 0 0 4 318 576 0 0 0 2 4 this 3 626  10 upon_death 1 558  
238 0 0 6 319 558 0 0 70 /**
 * Returns the function that is called when the task finishes.
 */ 1 4 this 3 626  
239 0 0 4 320 576 0 0 0 2 4 this 3 626  5 owner 1 558  
240 0 0 6 321 558 0 0 56 /**
 * Returns the "owner" object.  See set_owner().
 */ 1 4 this 3 627  
241 0 0 4 322 576 0 0 172 /**
 * Sets the "result" of this task.  This is the value returned from an "await"
 * expression on this task.
 * This can only be called while the task is still alive.
 */ 2 4 this 3 626  6 result 1 558  
242 0 0 6 323 540 0 0 0 3 4 this 3 626  4 attr 1 558  1 v 1 558  
243 0 0 6 324 540 0 0 0 2 4 this 3 626  4 attr 1 558  
244 0 0 6 325 558 0 0 0 2 4 this 3 627  4 attr 1 558  
245 0 0 6 326 540 0 0 0 3 4 this 3 626  5 visit 1 629  3 arg 1 630  
246 0 0 6 327 540 0 0 0 1 4 this 3 626  
247 0 0 7 347 581 0 0 0 0 
248 0 0 6 335 530 0 0 101 /**
 * Returns true if a delay has been set for this task via set_delay(), or
 * false otherwise.
 */ 1 4 this 3 627  
249 0 0 4 337 576 0 0 216 /**
 * Removes any delay specified for the task.  The next time the task is added
 * to the queue, it will run immediately.  This does not affect the task's
 * wake time if it has already been added to the queue.
 */ 1 4 this 3 626  
111
520 14 EventParameter 0 26625 14 EventParameter 14 EventParameter 0 0 0 1 250 252 0 14 251 253 254 255 256 257 258 259 260 261 262 263 264 265 0 0 0 0 0 389
/**
 * An optional parameter associated with an event.  Each event may have zero
 * or more of these.  Each parameter stores a pointer to a
 * TypedWritableReferenceCount object, which of course could be pretty much
 * anything.  To store a simple value like a double or a string, the
 * EventParameter constructors transparently use the ParamValue template class
 * from paramValue.h.
 */

521 11 AsyncFuture 0 75777 11 AsyncFuture 11 AsyncFuture 0 0 0 1 266 0 1 631 15 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 0 0 1 0 522 0 0 0 0 1711
/**
 * This class represents a thread-safe handle to a promised future result of
 * an asynchronous operation, providing methods to query its status and result
 * as well as register callbacks for this future's completion.
 *
 * An AsyncFuture can be awaited from within a coroutine or task.  It keeps
 * track of tasks waiting for this future and automatically reactivates them
 * upon this future's completion.
 *
 * A task itself is also a subclass of AsyncFuture.  Other subclasses are
 * not generally necessary, except to override the function of `cancel()`.
 *
 * Until the future is done, it is "owned" by the resolver thread, though it's
 * still legal for other threads to query its state.  When the resolver thread
 * resolves this future using `set_result()`, or any thread calls `cancel()`,
 * it instantly enters the "done" state, after which the result becomes a
 * read-only field that all threads can access.
 *
 * When the future returns true for done(), a thread can use cancelled() to
 * determine whether the future was cancelled or get_result() to access the
 * result of the operation.  Not all operations define a meaningful result
 * value, so some will always return nullptr.
 *
 * In Python, the `cancelled()`, `wait()` and `get_result()` methods are
 * wrapped up into a single `result()` method which waits for the future to
 * complete before either returning the result or throwing an exception if the
 * future was cancelled.
 * However, it is preferable to use the `await` keyword when running from a
 * coroutine, which only suspends the current task and not the entire thread.
 *
 * This API aims to mirror and be compatible with Python's Future class.
 *
 * @since 1.10.0
 */

522 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

523 12 string const 0 8832 17 std::string const 17 std::string const 0 0 524 0 0 0 0 0 0 0 0 0 0

524 6 string 0 2105344 11 std::string 11 std::string 0 0 525 0 0 0 0 0 0 0 0 0 0

525 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

526 9 AsyncTask 0 26625 9 AsyncTask 9 AsyncTask 0 0 0 0 286 12 632 633 634 640 641 642 643 644 645 646 647 648 30 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 370 0 0 2 3 521 282 283 3 527 284 285 0 2 528 529 217
/**
 * This class represents a concrete task performed by an AsyncManager.
 * Normally, you would subclass from this class, and override do_task(), to
 * define the functionality you wish to have the task perform.
 */

527 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

528 10 DoneStatus 0 794624 21 AsyncTask::DoneStatus 21 AsyncTask::DoneStatus 526 0 0 0 0 0 0 0 0 0 8 7 DS_done 18 AsyncTask::DS_done 25
// normal task completion
0 7 DS_cont 18 AsyncTask::DS_cont 28
// run task again next epoch
1 8 DS_again 19 AsyncTask::DS_again 41
// start the task over from the beginning
2 9 DS_pickup 20 AsyncTask::DS_pickup 52
// run task again this frame, if frame budget allows
3 7 DS_exit 18 AsyncTask::DS_exit 30
// stop the enclosing sequence
4 8 DS_pause 19 AsyncTask::DS_pause 46
// pause, then exit (useful within a sequence)
5 12 DS_interrupt 23 AsyncTask::DS_interrupt 49
// interrupt the task manager, but run task again
6 8 DS_await 19 AsyncTask::DS_await 38
// await a different task's completion
7 0 0

529 5 State 0 794624 16 AsyncTask::State 16 AsyncTask::State 526 0 0 0 0 0 0 0 0 0 7 10 S_inactive 21 AsyncTask::S_inactive 0
0 8 S_active 19 AsyncTask::S_active 0
1 11 S_servicing 22 AsyncTask::S_servicing 0
2 19 S_servicing_removed 30 AsyncTask::S_servicing_removed 51
// Still servicing, but wants removal from manager.
3 10 S_sleeping 21 AsyncTask::S_sleeping 0
4 15 S_active_nested 26 AsyncTask::S_active_nested 28
// active within a sequence.
5 10 S_awaiting 21 AsyncTask::S_awaiting 43
// Waiting for a dependent task to complete
6 0 0

530 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

531 18 AsyncTaskManager * 0 8576 18 AsyncTaskManager * 18 AsyncTaskManager * 0 0 532 0 0 0 0 0 0 0 0 0 0

532 16 AsyncTaskManager 0 26625 16 AsyncTaskManager 16 AsyncTaskManager 0 0 0 1 320 321 5 635 636 637 638 639 27 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 362 363 364 365 366 367 1 664 0 2 3 522 316 317 3 527 318 319 0 0 674
/**
 * A class to manage a loose queue of isolated tasks, which can be performed
 * either synchronously (in the foreground thread) or asynchronously (by a
 * background thread).
 *
 * The AsyncTaskManager is actually a collection of AsyncTaskChains, each of
 * which maintains a list of tasks.  Each chain can be either foreground or
 * background (it may run only in the main thread, or it may be serviced by
 * one or more background threads). See AsyncTaskChain for more information.
 *
 * If you do not require background processing, it is perfectly acceptable to
 * create only one AsyncTaskChain, which runs in the main thread.  This is a
 * common configuration.
 */

533 13 ClockObject * 0 8576 13 ClockObject * 13 ClockObject * 0 0 534 0 0 0 0 0 0 0 0 0 0

534 11 ClockObject 0 2048 11 ClockObject 11 ClockObject 0 0 0 0 0 0 0 0 0 0 0 0 1000
/**
 * A ClockObject keeps track of elapsed real time and discrete time.  In
 * normal mode, get_frame_time() returns the time as of the last time tick()
 * was called.  This is the "discrete" time, and is usually used to get the
 * time as of, for instance, the beginning of the current frame.
 *
 * In other modes, as set by set_mode() or the clock-mode config variable,
 * get_frame_time() may return other values to simulate different timing
 * effects, for instance to perform non-real-time animation.  See set_mode().
 *
 * In all modes, get_real_time() always returns the elapsed real time in
 * seconds since the ClockObject was constructed, or since it was last reset.
 *
 * You can create your own ClockObject whenever you want to have your own
 * local timer.  There is also a default, global ClockObject intended to
 * represent global time for the application; this is normally set up to tick
 * every frame so that its get_frame_time() will return the time for the
 * current frame.
 */

535 19 AsyncTaskCollection 0 26625 19 AsyncTaskCollection 19 AsyncTaskCollection 0 0 0 1 343 345 0 17 344 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 1 665 0 0 0 0 199
/**
 * A list of tasks, for instance as returned by some of the AsyncTaskManager
 * query functions.  This also serves to define an AsyncTaskSequence.
 *
 * TODO: None of this is thread-safe yet.
 */

536 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

537 7 Integer 0 2367488 21 AtomicAdjust::Integer 21 AtomicAdjust::Integer 538 0 539 0 0 0 0 0 0 0 0 0 0

538 12 AtomicAdjust 0 1024 12 AtomicAdjust 12 AtomicAdjust 0 0 0 0 0 0 0 0 0 0 0 0 0

539 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0

540 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

541 14 AsyncTaskChain 0 26625 14 AsyncTaskChain 14 AsyncTaskChain 0 0 0 0 375 0 28 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 0 0 2 3 522 371 372 3 527 373 374 0 0 1007
/**
 * The AsyncTaskChain is a subset of the AsyncTaskManager.  Each chain
 * maintains a separate list of tasks, and will execute them with its own set
 * of threads.  Each chain may thereby operate independently of the other
 * chains.
 *
 * The AsyncTaskChain will spawn a specified number of threads (possibly 0) to
 * serve the tasks.  If there are no threads, you must call poll() from time
 * to time to serve the tasks in the main thread.  Normally this is done by
 * calling AsyncTaskManager::poll().
 *
 * Each task will run exactly once each epoch.  Beyond that, the tasks' sort
 * and priority values control the order in which they are run: tasks are run
 * in increasing order by sort value, and within the same sort value, they are
 * run roughly in decreasing order by priority value, with some exceptions for
 * parallelism.  Tasks with different sort values are never run in parallel
 * together, but tasks with different priority values might be (if there is
 * more than one thread).
 */

542 14 AsyncTaskPause 0 141313 14 AsyncTaskPause 14 AsyncTaskPause 0 0 0 1 404 409 0 4 405 406 407 408 0 0 1 0 526 0 0 0 0 184
/**
 * A special kind of task that simple returns DS_pause, to pause for a
 * specified number of seconds and then finish.  It's intended to be used
 * within an AsyncTaskSequence.
 */

543 17 AsyncTaskSequence 0 26625 17 AsyncTaskSequence 17 AsyncTaskSequence 0 0 0 1 414 415 0 7 416 417 418 419 420 421 422 0 0 2 3 526 410 411 3 535 412 413 0 0 400
/**
 * A special kind of task that serves as a list of tasks internally.  Each
 * task on the list is executed in sequence, one per epoch.
 *
 * This is similar to a Sequence interval, though it has some slightly
 * different abilities.  For instance, although you can't start at any
 * arbitrary point in the sequence, you can construct a task sequence whose
 * duration changes during playback.
 */

544 11 ButtonEvent 0 141313 11 ButtonEvent 11 ButtonEvent 0 0 0 0 430 4 649 650 651 652 3 423 424 425 0 0 0 0 1 545 1081
/**
 * Records a button event of some kind.  This is either a keyboard or mouse
 * button (or some other kind of button) changing state from up to down, or
 * vice-versa, or it is a single "keystroke".
 *
 * A keystroke is different than a button event in that (a) it does not
 * necessarily correspond to a physical button on a keyboard, but might be the
 * result of a combination of buttons (e.g.  "A" is the result of shift +
 * "a"); and (b) it does not manage separate "up" and "down" events, but is
 * itself an instantaneous event.
 *
 * Normal up/down button events can be used to track the state of a particular
 * button on the keyboard, while keystroke events are best used to monitor
 * what a user is attempting to type.
 *
 * Button up/down events are defined across all the physical keys on the
 * keyboard (and other buttons for which there is a corresponding ButtonHandle
 * object), while keystroke events are defined across the entire Unicode
 * character set.
 *
 * This API should not be considered stable and may change in a future version
 * of Panda3D.
 */

545 4 Type 0 794624 17 ButtonEvent::Type 17 ButtonEvent::Type 544 0 0 0 0 0 0 0 0 0 9 6 T_down 19 ButtonEvent::T_down 49
// T_down is sent when a button was just pressed.
0 13 T_resume_down 26 ButtonEvent::T_resume_down 446
// T_resume_down is a special event that is only thrown when focus is
// returned to a window and a button is detected as being held down at that
// point; it indicates that the button should be considered down now (if it
// wasn't already), but it didn't just get pressed down at this moment, it
// was depressed some time ago.  It's mainly used for correct tracking of
// modifier keys like shift and control, and can be ignored for other keys.
1 4 T_up 17 ButtonEvent::T_up 44
// T_down is sent when a button is released.
2 8 T_repeat 21 ButtonEvent::T_repeat 196
// T_repeat is sent for each a keyrepeat event generated by the system,
// for a button that is continually held down.  If you want to respect
// keyrepeat, treat T_down and T_repeat equivalently.
3 11 T_keystroke 24 ButtonEvent::T_keystroke 115
// T_keystroke is a special keystroke event, and is sent along with a
// Unicode keycode value, not a ButtonHandle.
4 11 T_candidate 24 ButtonEvent::T_candidate 144
// T_candidate is used to indicate that the user is using the IME and has
// in the process of selecting some possible text to type from a menu.
5 6 T_move 19 ButtonEvent::T_move 143
// T_move is used to indicate that the mouse has moved within the current
// region.  Button drag mode needs this, others may ignore this event
6 10 T_raw_down 23 ButtonEvent::T_raw_down 241
// T_raw_down is usually sent together with T_down, except that this is
// the original, untransformed scan key sent by the keyboard.  It is not
// altered by modifier keys and acts as if the user is using the US
// (qwerty) keyboard layout.
7 8 T_raw_up 21 ButtonEvent::T_raw_up 0
8 0 0

546 12 ButtonHandle 0 16779264 12 ButtonHandle 12 ButtonHandle 0 0 0 0 0 0 0 0 0 0 0 0 162
/**
 * A ButtonHandle represents a single button from any device, including
 * keyboard buttons and mouse buttons (but see KeyboardButton and
 * MouseButton).
 */

547 15 ButtonEventList 0 141313 15 ButtonEventList 15 ButtonEventList 0 0 0 1 431 441 1 653 9 432 433 434 435 436 437 438 439 440 0 0 1 0 548 0 0 0 0 225
/**
 * Records a set of button events that happened recently.  This class is
 * usually used only in the data graph, to transmit the recent button presses,
 * but it may be used anywhere a list of ButtonEvents is desired.
 */

548 14 ParamValueBase 0 2048 14 ParamValueBase 14 ParamValueBase 0 0 0 0 0 0 0 0 0 0 0 0 141
/**
 * A non-template base class of ParamValue (below), which serves mainly to
 * define the placeholder for the virtual output function.
 */

549 17 ButtonEvent const 0 8832 17 ButtonEvent const 17 ButtonEvent const 0 0 544 0 0 0 0 0 0 0 0 0 0

550 5 Event 0 75777 5 Event 5 Event 0 0 0 1 442 0 3 654 655 656 14 443 444 445 446 447 448 449 450 451 452 453 454 455 456 1 666 0 1 0 522 0 0 0 0 391
/**
 * A named event, possibly with parameters.  Anyone in any thread may throw an
 * event at any time; there will be one process responsible for reading and
 * dispacting on the events (but not necessarily immediately).
 *
 * This function use to inherit from Namable, but that makes it too expensive
 * to get its name the Python code.  Now it just copies the Namable interface
 * in.
 */

551 15 EventReceiver * 0 8576 15 EventReceiver * 15 EventReceiver * 0 0 552 0 0 0 0 0 0 0 0 0 0

552 13 EventReceiver 0 1050624 13 EventReceiver 13 EventReceiver 0 0 0 0 0 0 0 0 0 0 0 0 225
/**
 * An abstract base class for anything that might care about receiving events.
 * An object that might receive an event should inherit from this class; each
 * event may be sent with an optional EventReceiver pointer.
 */

553 12 EventHandler 0 75777 12 EventHandler 12 EventHandler 0 0 0 1 457 0 0 6 458 459 460 461 462 463 0 0 1 0 554 0 0 0 0 384
/**
 * A class to monitor events from the C++ side of things.  It maintains a set
 * of "hooks", function pointers assigned to event names, and calls the
 * appropriate hooks when the matching event is detected.
 *
 * This class is not necessary when the hooks are detected and processed
 * entirely by the scripting language, e.g.  via Scheme hooks or the messenger
 * in Python.
 */

554 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file):
 * @code
 * public:
 *   static TypeHandle get_class_type() {
 *     return _type_handle;
 *   }
 *   static void init_type() {
 *     <<<BaseClassOne>>>::init_type();
 *     <<<BaseClassTwo>>>::init_type();
 *     <<<BaseClassN>>>::init_type();
 *     register_type(_type_handle, "<<<ThisClassStringName>>>",
 *                   <<<BaseClassOne>>>::get_class_type(),
 *                   <<<BaseClassTwo>>>::get_class_type(),
 *                   <<<BaseClassN>>>::get_class_type());
 *   }
 *   virtual TypeHandle get_type() const {
 *     return get_class_type();
 *   }
 *   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private:
 *   static TypeHandle _type_handle;
 * @endcode
 *
 * @par In the class .cxx file:
 * @code
 * TypeHandle <<<ThisClassStringName>>>::_type_handle;
 * @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file:
 * @code
 * ConfigureFn(config_<<<PackageName>>>) {
 *   <<<ClassOne>>>::init_type();
 *   <<<ClassTwo>>>::init_type();
 *   <<<ClassN>>>::init_type();
 * }
 * @endcode
 */

555 10 EventQueue 0 26625 10 EventQueue 10 EventQueue 0 0 0 1 464 465 0 6 466 467 468 469 470 471 0 0 0 0 0 175
/**
 * A queue of pending events.  As events are thrown, they are added to this
 * queue; eventually, they will be extracted out again by an EventHandler and
 * processed.
 */

556 16 PointerEventList 0 141313 16 PointerEventList 16 PointerEventList 0 0 0 1 472 491 0 18 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 0 0 1 0 548 0 0 0 0 228
/**
 * Records a set of pointer events that happened recently.  This class is
 * usually used only in the data graph, to transmit the recent pointer
 * presses, but it may be used anywhere a list of PointerEvents is desired.
 */

557 10 PythonTask 0 16852993 10 PythonTask 10 PythonTask 0 0 0 1 492 286 7 657 658 659 660 661 662 663 18 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 519 0 0 1 0 526 0 0 0 0 113
/**
 * This class exists to allow association of a Python function or coroutine
 * with the AsyncTaskManager.
 */

558 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 559 0 0 0 0 0 0 0 0 0 0

559 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 560 0 0 0 0 0 0 0 0 0 0

560 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

561 16 EventParameter * 0 8576 16 EventParameter * 16 EventParameter * 0 0 520 0 0 0 0 0 0 0 0 0 0

562 22 EventParameter const * 0 8576 22 EventParameter const * 22 EventParameter const * 0 0 563 0 0 0 0 0 0 0 0 0 0

563 20 EventParameter const 0 8832 20 EventParameter const 20 EventParameter const 0 0 520 0 0 0 0 0 0 0 0 0 0

564 27 TypedReferenceCount const * 0 8576 27 TypedReferenceCount const * 27 TypedReferenceCount const * 0 0 565 0 0 0 0 0 0 0 0 0 0

565 25 TypedReferenceCount const 0 8832 25 TypedReferenceCount const 25 TypedReferenceCount const 0 0 522 0 0 0 0 0 0 0 0 0 0

566 35 TypedWritableReferenceCount const * 0 8576 35 TypedWritableReferenceCount const * 35 TypedWritableReferenceCount const * 0 0 567 0 0 0 0 0 0 0 0 0 0

567 33 TypedWritableReferenceCount const 0 8832 33 TypedWritableReferenceCount const 33 TypedWritableReferenceCount const 0 0 568 0 0 0 0 0 0 0 0 0 0

568 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

569 9 nullptr_t 0 2105344 14 std::nullptr_t 14 std::nullptr_t 0 0 570 0 0 0 0 0 0 0 0 0 0

570 17 decltype(nullptr) 0 8194 17 decltype(nullptr) 17 decltype(nullptr) 0 9 0 0 0 0 0 0 0 0 0 0 0

571 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

572 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 522 0 0 0 0 0 0 0 0 0 0

573 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 568 0 0 0 0 0 0 0 0 0 0

574 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 575 0 0 0 0 0 0 0 0 0 0

575 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

576 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

577 13 AsyncFuture * 0 8576 13 AsyncFuture * 13 AsyncFuture * 0 0 521 0 0 0 0 0 0 0 0 0 0

578 19 AsyncFuture const * 0 8576 19 AsyncFuture const * 19 AsyncFuture const * 0 0 579 0 0 0 0 0 0 0 0 0 0

579 17 AsyncFuture const 0 8832 17 AsyncFuture const 17 AsyncFuture const 0 0 521 0 0 0 0 0 0 0 0 0 0

580 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

581 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 580 0 0 0 0 0 0 0 0 0 0

582 17 AsyncTask const * 0 8576 17 AsyncTask const * 17 AsyncTask const * 0 0 583 0 0 0 0 0 0 0 0 0 0

583 15 AsyncTask const 0 8832 15 AsyncTask const 15 AsyncTask const 0 0 526 0 0 0 0 0 0 0 0 0 0

584 11 AsyncTask * 0 8576 11 AsyncTask * 11 AsyncTask * 0 0 526 0 0 0 0 0 0 0 0 0 0

585 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 527 0 0 0 0 0 0 0 0 0 0

586 24 AsyncTaskManager const * 0 8576 24 AsyncTaskManager const * 24 AsyncTaskManager const * 0 0 587 0 0 0 0 0 0 0 0 0 0

587 22 AsyncTaskManager const 0 8832 22 AsyncTaskManager const 22 AsyncTaskManager const 0 0 532 0 0 0 0 0 0 0 0 0 0

588 16 AsyncTaskChain * 0 8576 16 AsyncTaskChain * 16 AsyncTaskChain * 0 0 541 0 0 0 0 0 0 0 0 0 0

589 14 ThreadPriority 0 532480 14 ThreadPriority 14 ThreadPriority 0 0 0 0 0 0 0 0 0 0 4 6 TP_low 6 TP_low 0
0 9 TP_normal 9 TP_normal 0
1 7 TP_high 7 TP_high 0
2 9 TP_urgent 9 TP_urgent 0
3 0 105
// An enumerated type used by Thread to specify a suggested relative priority
// for a particular thread.

590 21 AsyncTaskCollection * 0 8576 21 AsyncTaskCollection * 21 AsyncTaskCollection * 0 0 535 0 0 0 0 0 0 0 0 0 0

591 19 GlobPattern const * 0 8576 19 GlobPattern const * 19 GlobPattern const * 0 0 592 0 0 0 0 0 0 0 0 0 0

592 17 GlobPattern const 0 8832 17 GlobPattern const 17 GlobPattern const 0 0 593 0 0 0 0 0 0 0 0 0 0

593 11 GlobPattern 0 2048 11 GlobPattern 11 GlobPattern 0 0 0 0 0 0 0 0 0 0 0 0 538
/**
 * This class can be used to test for string matches against standard Unix-
 * shell filename globbing conventions.  It serves as a portable standin for
 * the Posix fnmatch() call.
 *
 * A GlobPattern is given a pattern string, which can contain operators like
 * *, ?, and [].  Then it can be tested against any number of candidate
 * strings; for each candidate, it will indicate whether the string matches
 * the pattern or not.  It can be used, for example, to scan a directory for
 * all files matching a particular pattern.
 */

594 27 AsyncTaskCollection const * 0 8576 27 AsyncTaskCollection const * 27 AsyncTaskCollection const * 0 0 595 0 0 0 0 0 0 0 0 0 0

595 25 AsyncTaskCollection const 0 8832 25 AsyncTaskCollection const 25 AsyncTaskCollection const 0 0 535 0 0 0 0 0 0 0 0 0 0

596 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 597 0 0 0 0 0 0 0 0 0 0

597 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

598 22 AsyncTaskChain const * 0 8576 22 AsyncTaskChain const * 22 AsyncTaskChain const * 0 0 599 0 0 0 0 0 0 0 0 0 0

599 20 AsyncTaskChain const 0 8832 20 AsyncTaskChain const 20 AsyncTaskChain const 0 0 541 0 0 0 0 0 0 0 0 0 0

600 16 AsyncTaskPause * 0 8576 16 AsyncTaskPause * 16 AsyncTaskPause * 0 0 542 0 0 0 0 0 0 0 0 0 0

601 19 AsyncTaskSequence * 0 8576 19 AsyncTaskSequence * 19 AsyncTaskSequence * 0 0 543 0 0 0 0 0 0 0 0 0 0

602 25 AsyncTaskSequence const * 0 8576 25 AsyncTaskSequence const * 25 AsyncTaskSequence const * 0 0 603 0 0 0 0 0 0 0 0 0 0

603 23 AsyncTaskSequence const 0 8832 23 AsyncTaskSequence const 23 AsyncTaskSequence const 0 0 543 0 0 0 0 0 0 0 0 0 0

604 19 ButtonEvent const * 0 8576 19 ButtonEvent const * 19 ButtonEvent const * 0 0 549 0 0 0 0 0 0 0 0 0 0

605 17 ButtonEventList * 0 8576 17 ButtonEventList * 17 ButtonEventList * 0 0 547 0 0 0 0 0 0 0 0 0 0

606 23 ButtonEventList const * 0 8576 23 ButtonEventList const * 23 ButtonEventList const * 0 0 607 0 0 0 0 0 0 0 0 0 0

607 21 ButtonEventList const 0 8832 21 ButtonEventList const 21 ButtonEventList const 0 0 547 0 0 0 0 0 0 0 0 0 0

608 13 ButtonEvent * 0 8576 13 ButtonEvent * 13 ButtonEvent * 0 0 544 0 0 0 0 0 0 0 0 0 0

609 17 ModifierButtons * 0 8576 17 ModifierButtons * 17 ModifierButtons * 0 0 610 0 0 0 0 0 0 0 0 0 0

610 15 ModifierButtons 0 2048 15 ModifierButtons 15 ModifierButtons 0 0 0 0 0 0 0 0 0 0 0 0 135
/**
 * This class monitors the state of a number of individual buttons and tracks
 * whether each button is known to be down or up.
 */

611 13 Event const * 0 8576 13 Event const * 13 Event const * 0 0 612 0 0 0 0 0 0 0 0 0 0

612 11 Event const 0 8832 11 Event const 11 Event const 0 0 550 0 0 0 0 0 0 0 0 0 0

613 7 Event * 0 8576 7 Event * 7 Event * 0 0 550 0 0 0 0 0 0 0 0 0 0

614 12 EventQueue * 0 8576 12 EventQueue * 12 EventQueue * 0 0 555 0 0 0 0 0 0 0 0 0 0

615 14 EventHandler * 0 8576 14 EventHandler * 14 EventHandler * 0 0 553 0 0 0 0 0 0 0 0 0 0

616 20 EventHandler const * 0 8576 20 EventHandler const * 20 EventHandler const * 0 0 617 0 0 0 0 0 0 0 0 0 0

617 18 EventHandler const 0 8832 18 EventHandler const 18 EventHandler const 0 0 553 0 0 0 0 0 0 0 0 0 0

618 18 EventQueue const * 0 8576 18 EventQueue const * 18 EventQueue const * 0 0 619 0 0 0 0 0 0 0 0 0 0

619 16 EventQueue const 0 8832 16 EventQueue const 16 EventQueue const 0 0 555 0 0 0 0 0 0 0 0 0 0

620 18 PointerEventList * 0 8576 18 PointerEventList * 18 PointerEventList * 0 0 556 0 0 0 0 0 0 0 0 0 0

621 24 PointerEventList const * 0 8576 24 PointerEventList const * 24 PointerEventList const * 0 0 622 0 0 0 0 0 0 0 0 0 0

622 22 PointerEventList const 0 8832 22 PointerEventList const 22 PointerEventList const 0 0 556 0 0 0 0 0 0 0 0 0 0

623 19 PointerData const * 0 8576 19 PointerData const * 19 PointerData const * 0 0 624 0 0 0 0 0 0 0 0 0 0

624 17 PointerData const 0 8832 17 PointerData const 17 PointerData const 0 0 625 0 0 0 0 0 0 0 0 0 0

625 11 PointerData 0 2048 11 PointerData 11 PointerData 0 0 0 0 0 0 0 0 0 0 0 0 124
/**
 * Holds the data that might be generated by a 2-d pointer input device, such
 * as the mouse in the GraphicsWindow.
 */

626 12 PythonTask * 0 8576 12 PythonTask * 12 PythonTask * 0 0 557 0 0 0 0 0 0 0 0 0 0

627 18 PythonTask const * 0 8576 18 PythonTask const * 18 PythonTask const * 0 0 628 0 0 0 0 0 0 0 0 0 0

628 16 PythonTask const 0 8832 16 PythonTask const 16 PythonTask const 0 0 557 0 0 0 0 0 0 0 0 0 0

629 9 visitproc 0 2105344 9 visitproc 9 visitproc 0 0 630 0 0 0 0 0 0 0 0 0 0

630 6 void * 0 8576 6 void * 6 void * 0 0 576 0 0 0 0 0 0 0 0 0 0

0
33
631 10 done_event 0 6 523 274 273 0 0 0 0 0 0 23 AsyncFuture::done_event 0

632 5 state 0 2 529 287 0 0 0 0 0 0 0 16 AsyncTask::state 0

633 5 alive 0 2 530 288 0 0 0 0 0 0 0 16 AsyncTask::alive 0

634 7 manager 0 2 531 289 0 0 0 0 0 0 0 18 AsyncTask::manager 0

635 5 clock 0 6 533 324 323 0 0 0 0 0 0 23 AsyncTaskManager::clock 0

636 5 tasks 0 2 535 340 0 0 0 0 0 0 0 23 AsyncTaskManager::tasks 0

637 12 active_tasks 0 2 535 341 0 0 0 0 0 0 0 30 AsyncTaskManager::active_tasks 0

638 14 sleeping_tasks 0 2 535 342 0 0 0 0 0 0 0 32 AsyncTaskManager::sleeping_tasks 0

639 14 next_wake_time 0 2 536 363 0 0 0 0 0 0 0 32 AsyncTaskManager::next_wake_time 0

640 4 name 0 6 523 368 301 0 0 0 0 0 0 15 AsyncTask::name 25
// The name of this task.

641 2 id 0 2 537 304 0 0 0 0 0 0 0 13 AsyncTask::id 99
// This is a number guaranteed to be unique for each different AsyncTask
// object in the universe.

642 10 task_chain 0 6 523 306 305 0 0 0 0 0 0 21 AsyncTask::task_chain 0

643 4 sort 0 6 540 308 307 0 0 0 0 0 0 15 AsyncTask::sort 0

644 8 priority 0 6 540 310 309 0 0 0 0 0 0 19 AsyncTask::priority 0

645 10 done_event 0 6 523 369 311 0 0 0 0 0 0 21 AsyncTask::done_event 107
/**
 * Returns the event name that will be triggered when the future finishes.
 * See set_done_event().
 */

646 2 dt 0 2 536 312 0 0 0 0 0 0 0 13 AsyncTask::dt 0

647 6 max_dt 0 2 536 313 0 0 0 0 0 0 0 17 AsyncTask::max_dt 0

648 10 average_dt 0 2 536 314 0 0 0 0 0 0 0 21 AsyncTask::average_dt 0

649 6 button 0 2 546 426 0 0 0 0 0 0 0 19 ButtonEvent::button 0

650 7 keycode 0 2 540 427 0 0 0 0 0 0 0 20 ButtonEvent::keycode 0

651 4 type 0 2 545 428 0 0 0 0 0 0 0 17 ButtonEvent::type 0

652 4 time 0 2 536 429 0 0 0 0 0 0 0 17 ButtonEvent::time 0

653 6 events 0 66 549 435 0 0 0 0 434 0 0 23 ButtonEventList::events 0

654 4 name 0 6 523 447 444 0 0 0 0 0 0 11 Event::name 0

655 10 parameters 0 66 520 450 0 0 0 0 449 0 0 17 Event::parameters 0

656 8 receiver 0 30 551 452 453 451 454 0 0 0 0 15 Event::receiver 0

657 4 time 0 2 536 510 0 0 0 0 0 0 0 16 PythonTask::time 112
// The amount of seconds that have elapsed since the task was started,
// according to the task manager's clock.

658 9 wake_time 0 2 536 511 0 0 0 0 0 0 0 21 PythonTask::wake_time 345
// If this task has been added to an AsyncTaskManager with a delay in
// effect, this contains the time at which the task is expected to awaken.
// It has no meaning of the task has not yet been added to a queue, or if
// there was no delay in effect at the time the task was added.  If the
// task's status is not S_sleeping, this contains 0.0.

659 8 wakeTime 0 2 536 511 0 0 0 0 0 0 0 20 PythonTask::wakeTime 22
// Alias of wake_time.

660 10 delay_time 0 30 536 512 514 513 515 0 0 0 0 22 PythonTask::delay_time 67
// The delay value that has been set on this task, if any, or None.

661 9 delayTime 0 30 536 512 514 513 515 0 0 0 0 21 PythonTask::delayTime 23
// Alias of delay_time.

662 5 frame 0 2 540 516 0 0 0 0 0 0 0 17 PythonTask::frame 111
// The number of frames that have elapsed since the task was started,
// according to the task manager's clock.

663 8 __dict__ 0 6 558 517 518 0 0 0 0 0 0 20 PythonTask::__dict__ 105
// This is a special variable to hold the instance dictionary in which
// custom variables may be stored.

3
664 15 get_task_chains 0 325 326 33 AsyncTaskManager::get_task_chains 0

665 9 get_tasks 0 354 355 30 AsyncTaskCollection::get_tasks 0

666 14 get_parameters 0 449 450 21 Event::get_parameters 0

