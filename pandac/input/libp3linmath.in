1713074391
3 3
12 libp3linmath 4 Ns0b 12 panda3d.core 
1594
1984 11 MathNumbers 0 260 3578 24 MathNumbers::MathNumbers 0 2 1 2 0
112
inline MathNumbers::MathNumbers(void) = default;
inline MathNumbers::MathNumbers(MathNumbers const &) = default;

1985 12 ~MathNumbers 0 516 3578 25 MathNumbers::~MathNumbers 0 0 0
32
MathNumbers::~MathNumbers(void);

1986 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1894 1895 0
67
inline double deg_2_rad(double f);
inline float deg_2_rad(float f);

1987 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1896 1897 0
67
inline double rad_2_deg(double f);
inline float rad_2_deg(float f);

1988 10 LVecBase2f 0 260 3579 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22
/**
 *
 */

/**
 *
 */
205
inline LVecBase2f::LVecBase2f(void) = default;
inline LVecBase2f::LVecBase2f(float fill_value);
inline LVecBase2f::LVecBase2f(float x, float y);
inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default;

1989 12 operator new 0 4 3579 24 LVecBase2f::operator new 0 1 7 0
124
inline void *LVecBase2f::operator new(std::size_t size);
inline void *LVecBase2f::operator new(std::size_t size, void *ptr);

1990 15 operator delete 0 4 3579 27 LVecBase2f::operator delete 0 0 0
108
inline void LVecBase2f::operator delete(void *ptr);
inline void LVecBase2f::operator delete(void *, void *);

1991 12 validate_ptr 0 4 3579 24 LVecBase2f::validate_ptr 0 0 0
61
static inline bool LVecBase2f::validate_ptr(void const *ptr);

1992 10 operator = 0 4 3579 22 LVecBase2f::operator = 0 2 8 9 0
119
void LVecBase2f::operator =(LVecBase2f const &copy) = default;
void LVecBase2f::operator =(float fill_value) = default;

1993 4 zero 0 4 3579 16 LVecBase2f::zero 0 1 10 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2f const &LVecBase2f::zero(void);

1994 6 unit_x 0 4 3579 18 LVecBase2f::unit_x 0 1 11 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_x(void);

1995 6 unit_y 0 4 3579 18 LVecBase2f::unit_y 0 1 12 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_y(void);

1996 10 __reduce__ 0 4 3579 22 LVecBase2f::__reduce__ 0 1 13 0
62
inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;

1997 11 __getattr__ 0 4 3579 23 LVecBase2f::__getattr__ 0 1 14 0
93
inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const;

1998 11 __setattr__ 0 4 3579 23 LVecBase2f::__setattr__ 0 1 15 0
99
inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

1999 11 operator [] 0 4 3579 23 LVecBase2f::operator [] 0 2 16 17 10
/**
 *
 */
96
inline float LVecBase2f::operator [](int i) const;
inline float &LVecBase2f::operator [](int i);

2000 12 operator []= 0 1028 3579 24 LVecBase2f::operator []= 0 1 18 0
62
void LVecBase2f::operator []=(int i, float const &assign_val);

2001 4 size 0 4 3579 16 LVecBase2f::size 0 1 19 0
44
static constexpr int LVecBase2f::size(void);

2002 6 is_nan 0 4 3579 18 LVecBase2f::is_nan 0 1 20 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2f::is_nan(void) const;

2003 8 get_cell 0 4 3579 20 LVecBase2f::get_cell 0 1 21 10
/**
 *
 */
47
inline float LVecBase2f::get_cell(int i) const;

2004 8 set_cell 0 4 3579 20 LVecBase2f::set_cell 0 1 22 10
/**
 *
 */
53
inline void LVecBase2f::set_cell(int i, float value);

2005 5 get_x 0 4 3579 17 LVecBase2f::get_x 0 1 23 10
/**
 *
 */
43
inline float LVecBase2f::get_x(void) const;

2006 5 get_y 0 4 3579 17 LVecBase2f::get_y 0 1 24 10
/**
 *
 */
43
inline float LVecBase2f::get_y(void) const;

2007 5 set_x 0 4 3579 17 LVecBase2f::set_x 0 1 25 10
/**
 *
 */
43
inline void LVecBase2f::set_x(float value);

2008 5 set_y 0 4 3579 17 LVecBase2f::set_y 0 1 26 10
/**
 *
 */
43
inline void LVecBase2f::set_y(float value);

2009 11 add_to_cell 0 4 3579 23 LVecBase2f::add_to_cell 0 1 27 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase2f::add_to_cell(int i, float value);

2010 5 add_x 0 4 3579 17 LVecBase2f::add_x 0 1 28 10
/**
 *
 */
43
inline void LVecBase2f::add_x(float value);

2011 5 add_y 0 4 3579 17 LVecBase2f::add_y 0 1 29 10
/**
 *
 */
43
inline void LVecBase2f::add_y(float value);

2012 8 get_data 0 4 3579 20 LVecBase2f::get_data 0 1 30 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
53
inline float const *LVecBase2f::get_data(void) const;

2013 18 get_num_components 0 4 3579 30 LVecBase2f::get_num_components 0 1 31 0
58
static constexpr int LVecBase2f::get_num_components(void);

2014 4 fill 0 4 3579 16 LVecBase2f::fill 0 1 32 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase2f::fill(float fill_value);

2015 3 set 0 4 3579 15 LVecBase2f::set 0 1 33 10
/**
 *
 */
46
inline void LVecBase2f::set(float x, float y);

2016 3 dot 0 4 3579 15 LVecBase2f::dot 0 1 34 10
/**
 *
 */
60
inline float LVecBase2f::dot(LVecBase2f const &other) const;

2017 14 length_squared 0 4 3579 26 LVecBase2f::length_squared 0 1 35 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase2f::length_squared(void) const;

2018 6 length 0 4 3579 18 LVecBase2f::length 0 1 36 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase2f::length(void) const;

2019 9 normalize 0 4 3579 21 LVecBase2f::normalize 0 1 37 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2f::normalize(void);

2020 10 normalized 0 4 3579 22 LVecBase2f::normalized 0 1 38 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2f LVecBase2f::normalized(void) const;

2021 7 project 0 4 3579 19 LVecBase2f::project 0 1 39 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const;

2022 10 operator < 0 4 3579 22 LVecBase2f::operator < 0 1 40 0
66
inline bool LVecBase2f::operator <(LVecBase2f const &other) const;

2023 11 operator == 0 4 3579 23 LVecBase2f::operator == 0 1 41 0
67
inline bool LVecBase2f::operator ==(LVecBase2f const &other) const;

2024 11 operator != 0 4 3579 23 LVecBase2f::operator != 0 1 42 0
67
inline bool LVecBase2f::operator !=(LVecBase2f const &other) const;

2025 10 compare_to 0 4 3579 22 LVecBase2f::compare_to 0 2 43 44 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase2f::compare_to(LVecBase2f const &other) const;
inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const;

2026 8 get_hash 0 4 3579 20 LVecBase2f::get_hash 0 2 45 46 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase2f::get_hash(void) const;
inline std::size_t LVecBase2f::get_hash(float threshold) const;

2027 8 add_hash 0 4 3579 20 LVecBase2f::add_hash 0 2 47 48 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;

2028 13 generate_hash 0 4 3579 25 LVecBase2f::generate_hash 0 2 49 50 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2029 10 operator - 0 68 3579 22 LVecBase2f::operator - 0 1 51 0
53
inline LVecBase2f LVecBase2f::operator -(void) const;

2030 10 operator + 0 4 3579 22 LVecBase2f::operator + 0 1 52 0
72
inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const;

2031 10 operator - 0 4 3579 22 LVecBase2f::operator - 0 1 53 0
72
inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const;

2032 10 operator * 0 4 3579 22 LVecBase2f::operator * 0 1 54 0
61
inline LVecBase2f LVecBase2f::operator *(float scalar) const;

2033 10 operator / 0 4 3579 22 LVecBase2f::operator / 0 1 55 0
61
inline LVecBase2f LVecBase2f::operator /(float scalar) const;

2034 11 operator += 0 4 3579 23 LVecBase2f::operator += 0 1 56 0
61
inline void LVecBase2f::operator +=(LVecBase2f const &other);

2035 11 operator -= 0 4 3579 23 LVecBase2f::operator -= 0 1 57 0
61
inline void LVecBase2f::operator -=(LVecBase2f const &other);

2036 11 operator *= 0 4 3579 23 LVecBase2f::operator *= 0 1 58 0
50
inline void LVecBase2f::operator *=(float scalar);

2037 11 operator /= 0 4 3579 23 LVecBase2f::operator /= 0 1 59 0
50
inline void LVecBase2f::operator /=(float scalar);

2038 18 componentwise_mult 0 4 3579 30 LVecBase2f::componentwise_mult 0 1 60 10
/**
 *
 */
68
inline void LVecBase2f::componentwise_mult(LVecBase2f const &other);

2039 8 __rmul__ 0 4 3579 20 LVecBase2f::__rmul__ 0 1 61 0
74
inline PyObject *LVecBase2f::__rmul__(PyObject *self, float scalar) const;

2040 12 __floordiv__ 0 4 3579 24 LVecBase2f::__floordiv__ 0 1 62 0
78
inline PyObject *LVecBase2f::__floordiv__(PyObject *self, float scalar) const;

2041 13 __ifloordiv__ 0 4 3579 25 LVecBase2f::__ifloordiv__ 0 1 63 0
73
inline PyObject *LVecBase2f::__ifloordiv__(PyObject *self, float scalar);

2042 7 __pow__ 0 4 3579 19 LVecBase2f::__pow__ 0 1 64 0
75
inline PyObject *LVecBase2f::__pow__(PyObject *self, float exponent) const;

2043 8 __ipow__ 0 4 3579 20 LVecBase2f::__ipow__ 0 1 65 0
70
inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);

2044 9 __round__ 0 4 3579 21 LVecBase2f::__round__ 0 1 66 0
55
inline PyObject *LVecBase2f::__round__(PyObject *self);

2045 9 __floor__ 0 4 3579 21 LVecBase2f::__floor__ 0 1 67 0
55
inline PyObject *LVecBase2f::__floor__(PyObject *self);

2046 8 __ceil__ 0 4 3579 20 LVecBase2f::__ceil__ 0 1 68 0
54
inline PyObject *LVecBase2f::__ceil__(PyObject *self);

2047 4 fmax 0 4 3579 16 LVecBase2f::fmax 0 1 69 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const;

2048 4 fmin 0 4 3579 16 LVecBase2f::fmin 0 1 70 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const;

2049 12 almost_equal 0 4 3579 24 LVecBase2f::almost_equal 0 2 71 72 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const;
inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const;

2050 6 output 0 4 3579 18 LVecBase2f::output 0 1 73 10
/**
 *
 */
56
inline void LVecBase2f::output(std::ostream &out) const;

2051 8 __repr__ 0 4 3579 20 LVecBase2f::__repr__ 0 1 74 0
52
inline std::string LVecBase2f::__repr__(void) const;

2052 20 write_datagram_fixed 0 4 3579 32 LVecBase2f::write_datagram_fixed 0 1 75 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const;

2053 19 read_datagram_fixed 0 4 3579 31 LVecBase2f::read_datagram_fixed 0 1 76 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source);

2054 14 write_datagram 0 4 3579 26 LVecBase2f::write_datagram 0 1 77 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2f::write_datagram(Datagram &destination) const;

2055 13 read_datagram 0 4 3579 25 LVecBase2f::read_datagram 0 1 78 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2f::read_datagram(DatagramIterator &source);

2056 13 __getbuffer__ 0 4 3579 25 LVecBase2f::__getbuffer__ 0 1 79 0
87
inline int LVecBase2f::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2057 14 get_class_type 0 4 3579 26 LVecBase2f::get_class_type 0 1 80 0
51
static TypeHandle LVecBase2f::get_class_type(void);

2058 11 ~LVecBase2f 0 516 3579 23 LVecBase2f::~LVecBase2f 0 0 0
30
LVecBase2f::~LVecBase2f(void);

2059 10 LVecBase2d 0 260 3582 22 LVecBase2d::LVecBase2d 0 4 81 82 83 84 22
/**
 *
 */

/**
 *
 */
208
inline LVecBase2d::LVecBase2d(void) = default;
inline LVecBase2d::LVecBase2d(double fill_value);
inline LVecBase2d::LVecBase2d(double x, double y);
inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default;

2060 12 operator new 0 4 3582 24 LVecBase2d::operator new 0 1 85 0
124
inline void *LVecBase2d::operator new(std::size_t size);
inline void *LVecBase2d::operator new(std::size_t size, void *ptr);

2061 15 operator delete 0 4 3582 27 LVecBase2d::operator delete 0 0 0
108
inline void LVecBase2d::operator delete(void *ptr);
inline void LVecBase2d::operator delete(void *, void *);

2062 12 validate_ptr 0 4 3582 24 LVecBase2d::validate_ptr 0 0 0
61
static inline bool LVecBase2d::validate_ptr(void const *ptr);

2063 10 operator = 0 4 3582 22 LVecBase2d::operator = 0 2 86 87 0
120
void LVecBase2d::operator =(LVecBase2d const &copy) = default;
void LVecBase2d::operator =(double fill_value) = default;

2064 4 zero 0 4 3582 16 LVecBase2d::zero 0 1 88 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2d const &LVecBase2d::zero(void);

2065 6 unit_x 0 4 3582 18 LVecBase2d::unit_x 0 1 89 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_x(void);

2066 6 unit_y 0 4 3582 18 LVecBase2d::unit_y 0 1 90 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_y(void);

2067 10 __reduce__ 0 4 3582 22 LVecBase2d::__reduce__ 0 1 91 0
62
inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;

2068 11 __getattr__ 0 4 3582 23 LVecBase2d::__getattr__ 0 1 92 0
93
inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2069 11 __setattr__ 0 4 3582 23 LVecBase2d::__setattr__ 0 1 93 0
99
inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2070 11 operator [] 0 4 3582 23 LVecBase2d::operator [] 0 2 94 95 10
/**
 *
 */
98
inline double LVecBase2d::operator [](int i) const;
inline double &LVecBase2d::operator [](int i);

2071 12 operator []= 0 1028 3582 24 LVecBase2d::operator []= 0 1 96 0
63
void LVecBase2d::operator []=(int i, double const &assign_val);

2072 4 size 0 4 3582 16 LVecBase2d::size 0 1 97 0
44
static constexpr int LVecBase2d::size(void);

2073 6 is_nan 0 4 3582 18 LVecBase2d::is_nan 0 1 98 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2d::is_nan(void) const;

2074 8 get_cell 0 4 3582 20 LVecBase2d::get_cell 0 1 99 10
/**
 *
 */
48
inline double LVecBase2d::get_cell(int i) const;

2075 8 set_cell 0 4 3582 20 LVecBase2d::set_cell 0 1 100 10
/**
 *
 */
54
inline void LVecBase2d::set_cell(int i, double value);

2076 5 get_x 0 4 3582 17 LVecBase2d::get_x 0 1 101 10
/**
 *
 */
44
inline double LVecBase2d::get_x(void) const;

2077 5 get_y 0 4 3582 17 LVecBase2d::get_y 0 1 102 10
/**
 *
 */
44
inline double LVecBase2d::get_y(void) const;

2078 5 set_x 0 4 3582 17 LVecBase2d::set_x 0 1 103 10
/**
 *
 */
44
inline void LVecBase2d::set_x(double value);

2079 5 set_y 0 4 3582 17 LVecBase2d::set_y 0 1 104 10
/**
 *
 */
44
inline void LVecBase2d::set_y(double value);

2080 11 add_to_cell 0 4 3582 23 LVecBase2d::add_to_cell 0 1 105 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase2d::add_to_cell(int i, double value);

2081 5 add_x 0 4 3582 17 LVecBase2d::add_x 0 1 106 10
/**
 *
 */
44
inline void LVecBase2d::add_x(double value);

2082 5 add_y 0 4 3582 17 LVecBase2d::add_y 0 1 107 10
/**
 *
 */
44
inline void LVecBase2d::add_y(double value);

2083 8 get_data 0 4 3582 20 LVecBase2d::get_data 0 1 108 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
54
inline double const *LVecBase2d::get_data(void) const;

2084 18 get_num_components 0 4 3582 30 LVecBase2d::get_num_components 0 1 109 0
58
static constexpr int LVecBase2d::get_num_components(void);

2085 4 fill 0 4 3582 16 LVecBase2d::fill 0 1 110 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase2d::fill(double fill_value);

2086 3 set 0 4 3582 15 LVecBase2d::set 0 1 111 10
/**
 *
 */
48
inline void LVecBase2d::set(double x, double y);

2087 3 dot 0 4 3582 15 LVecBase2d::dot 0 1 112 10
/**
 *
 */
61
inline double LVecBase2d::dot(LVecBase2d const &other) const;

2088 14 length_squared 0 4 3582 26 LVecBase2d::length_squared 0 1 113 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase2d::length_squared(void) const;

2089 6 length 0 4 3582 18 LVecBase2d::length 0 1 114 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase2d::length(void) const;

2090 9 normalize 0 4 3582 21 LVecBase2d::normalize 0 1 115 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2d::normalize(void);

2091 10 normalized 0 4 3582 22 LVecBase2d::normalized 0 1 116 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2d LVecBase2d::normalized(void) const;

2092 7 project 0 4 3582 19 LVecBase2d::project 0 1 117 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const;

2093 10 operator < 0 4 3582 22 LVecBase2d::operator < 0 1 118 0
66
inline bool LVecBase2d::operator <(LVecBase2d const &other) const;

2094 11 operator == 0 4 3582 23 LVecBase2d::operator == 0 1 119 0
67
inline bool LVecBase2d::operator ==(LVecBase2d const &other) const;

2095 11 operator != 0 4 3582 23 LVecBase2d::operator != 0 1 120 0
67
inline bool LVecBase2d::operator !=(LVecBase2d const &other) const;

2096 10 compare_to 0 4 3582 22 LVecBase2d::compare_to 0 2 121 122 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase2d::compare_to(LVecBase2d const &other) const;
inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const;

2097 8 get_hash 0 4 3582 20 LVecBase2d::get_hash 0 2 123 124 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase2d::get_hash(void) const;
inline std::size_t LVecBase2d::get_hash(double threshold) const;

2098 8 add_hash 0 4 3582 20 LVecBase2d::add_hash 0 2 125 126 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;

2099 13 generate_hash 0 4 3582 25 LVecBase2d::generate_hash 0 2 127 128 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2100 10 operator - 0 68 3582 22 LVecBase2d::operator - 0 1 129 0
53
inline LVecBase2d LVecBase2d::operator -(void) const;

2101 10 operator + 0 4 3582 22 LVecBase2d::operator + 0 1 130 0
72
inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const;

2102 10 operator - 0 4 3582 22 LVecBase2d::operator - 0 1 131 0
72
inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const;

2103 10 operator * 0 4 3582 22 LVecBase2d::operator * 0 1 132 0
62
inline LVecBase2d LVecBase2d::operator *(double scalar) const;

2104 10 operator / 0 4 3582 22 LVecBase2d::operator / 0 1 133 0
62
inline LVecBase2d LVecBase2d::operator /(double scalar) const;

2105 11 operator += 0 4 3582 23 LVecBase2d::operator += 0 1 134 0
61
inline void LVecBase2d::operator +=(LVecBase2d const &other);

2106 11 operator -= 0 4 3582 23 LVecBase2d::operator -= 0 1 135 0
61
inline void LVecBase2d::operator -=(LVecBase2d const &other);

2107 11 operator *= 0 4 3582 23 LVecBase2d::operator *= 0 1 136 0
51
inline void LVecBase2d::operator *=(double scalar);

2108 11 operator /= 0 4 3582 23 LVecBase2d::operator /= 0 1 137 0
51
inline void LVecBase2d::operator /=(double scalar);

2109 18 componentwise_mult 0 4 3582 30 LVecBase2d::componentwise_mult 0 1 138 10
/**
 *
 */
68
inline void LVecBase2d::componentwise_mult(LVecBase2d const &other);

2110 8 __rmul__ 0 4 3582 20 LVecBase2d::__rmul__ 0 1 139 0
75
inline PyObject *LVecBase2d::__rmul__(PyObject *self, double scalar) const;

2111 12 __floordiv__ 0 4 3582 24 LVecBase2d::__floordiv__ 0 1 140 0
79
inline PyObject *LVecBase2d::__floordiv__(PyObject *self, double scalar) const;

2112 13 __ifloordiv__ 0 4 3582 25 LVecBase2d::__ifloordiv__ 0 1 141 0
74
inline PyObject *LVecBase2d::__ifloordiv__(PyObject *self, double scalar);

2113 7 __pow__ 0 4 3582 19 LVecBase2d::__pow__ 0 1 142 0
76
inline PyObject *LVecBase2d::__pow__(PyObject *self, double exponent) const;

2114 8 __ipow__ 0 4 3582 20 LVecBase2d::__ipow__ 0 1 143 0
71
inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);

2115 9 __round__ 0 4 3582 21 LVecBase2d::__round__ 0 1 144 0
55
inline PyObject *LVecBase2d::__round__(PyObject *self);

2116 9 __floor__ 0 4 3582 21 LVecBase2d::__floor__ 0 1 145 0
55
inline PyObject *LVecBase2d::__floor__(PyObject *self);

2117 8 __ceil__ 0 4 3582 20 LVecBase2d::__ceil__ 0 1 146 0
54
inline PyObject *LVecBase2d::__ceil__(PyObject *self);

2118 4 fmax 0 4 3582 16 LVecBase2d::fmax 0 1 147 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const;

2119 4 fmin 0 4 3582 16 LVecBase2d::fmin 0 1 148 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const;

2120 12 almost_equal 0 4 3582 24 LVecBase2d::almost_equal 0 2 149 150 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const;
inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const;

2121 6 output 0 4 3582 18 LVecBase2d::output 0 1 151 10
/**
 *
 */
56
inline void LVecBase2d::output(std::ostream &out) const;

2122 8 __repr__ 0 4 3582 20 LVecBase2d::__repr__ 0 1 152 0
52
inline std::string LVecBase2d::__repr__(void) const;

2123 20 write_datagram_fixed 0 4 3582 32 LVecBase2d::write_datagram_fixed 0 1 153 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const;

2124 19 read_datagram_fixed 0 4 3582 31 LVecBase2d::read_datagram_fixed 0 1 154 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source);

2125 14 write_datagram 0 4 3582 26 LVecBase2d::write_datagram 0 1 155 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2d::write_datagram(Datagram &destination) const;

2126 13 read_datagram 0 4 3582 25 LVecBase2d::read_datagram 0 1 156 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2d::read_datagram(DatagramIterator &source);

2127 13 __getbuffer__ 0 4 3582 25 LVecBase2d::__getbuffer__ 0 1 157 0
87
inline int LVecBase2d::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2128 14 get_class_type 0 4 3582 26 LVecBase2d::get_class_type 0 1 158 0
51
static TypeHandle LVecBase2d::get_class_type(void);

2129 11 ~LVecBase2d 0 516 3582 23 LVecBase2d::~LVecBase2d 0 0 0
30
LVecBase2d::~LVecBase2d(void);

2130 10 LVecBase2i 0 260 3585 22 LVecBase2i::LVecBase2i 0 4 159 160 161 162 22
/**
 *
 */

/**
 *
 */
199
inline LVecBase2i::LVecBase2i(void) = default;
inline LVecBase2i::LVecBase2i(int fill_value);
inline LVecBase2i::LVecBase2i(int x, int y);
inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default;

2131 12 operator new 0 4 3585 24 LVecBase2i::operator new 0 1 163 0
124
inline void *LVecBase2i::operator new(std::size_t size);
inline void *LVecBase2i::operator new(std::size_t size, void *ptr);

2132 15 operator delete 0 4 3585 27 LVecBase2i::operator delete 0 0 0
108
inline void LVecBase2i::operator delete(void *ptr);
inline void LVecBase2i::operator delete(void *, void *);

2133 12 validate_ptr 0 4 3585 24 LVecBase2i::validate_ptr 0 0 0
61
static inline bool LVecBase2i::validate_ptr(void const *ptr);

2134 10 operator = 0 4 3585 22 LVecBase2i::operator = 0 2 164 165 0
117
void LVecBase2i::operator =(LVecBase2i const &copy) = default;
void LVecBase2i::operator =(int fill_value) = default;

2135 4 zero 0 4 3585 16 LVecBase2i::zero 0 1 166 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2i const &LVecBase2i::zero(void);

2136 6 unit_x 0 4 3585 18 LVecBase2i::unit_x 0 1 167 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_x(void);

2137 6 unit_y 0 4 3585 18 LVecBase2i::unit_y 0 1 168 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_y(void);

2138 10 __reduce__ 0 4 3585 22 LVecBase2i::__reduce__ 0 1 169 0
62
inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;

2139 11 __getattr__ 0 4 3585 23 LVecBase2i::__getattr__ 0 1 170 0
93
inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2140 11 __setattr__ 0 4 3585 23 LVecBase2i::__setattr__ 0 1 171 0
99
inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2141 11 operator [] 0 4 3585 23 LVecBase2i::operator [] 0 2 172 173 10
/**
 *
 */
92
inline int LVecBase2i::operator [](int i) const;
inline int &LVecBase2i::operator [](int i);

2142 12 operator []= 0 1028 3585 24 LVecBase2i::operator []= 0 1 174 0
60
void LVecBase2i::operator []=(int i, int const &assign_val);

2143 4 size 0 4 3585 16 LVecBase2i::size 0 1 175 0
44
static constexpr int LVecBase2i::size(void);

2144 6 is_nan 0 4 3585 18 LVecBase2i::is_nan 0 1 176 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2i::is_nan(void) const;

2145 8 get_cell 0 4 3585 20 LVecBase2i::get_cell 0 1 177 10
/**
 *
 */
45
inline int LVecBase2i::get_cell(int i) const;

2146 8 set_cell 0 4 3585 20 LVecBase2i::set_cell 0 1 178 10
/**
 *
 */
51
inline void LVecBase2i::set_cell(int i, int value);

2147 5 get_x 0 4 3585 17 LVecBase2i::get_x 0 1 179 10
/**
 *
 */
41
inline int LVecBase2i::get_x(void) const;

2148 5 get_y 0 4 3585 17 LVecBase2i::get_y 0 1 180 10
/**
 *
 */
41
inline int LVecBase2i::get_y(void) const;

2149 5 set_x 0 4 3585 17 LVecBase2i::set_x 0 1 181 10
/**
 *
 */
41
inline void LVecBase2i::set_x(int value);

2150 5 set_y 0 4 3585 17 LVecBase2i::set_y 0 1 182 10
/**
 *
 */
41
inline void LVecBase2i::set_y(int value);

2151 11 add_to_cell 0 4 3585 23 LVecBase2i::add_to_cell 0 1 183 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase2i::add_to_cell(int i, int value);

2152 5 add_x 0 4 3585 17 LVecBase2i::add_x 0 1 184 10
/**
 *
 */
41
inline void LVecBase2i::add_x(int value);

2153 5 add_y 0 4 3585 17 LVecBase2i::add_y 0 1 185 10
/**
 *
 */
41
inline void LVecBase2i::add_y(int value);

2154 8 get_data 0 4 3585 20 LVecBase2i::get_data 0 1 186 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
51
inline int const *LVecBase2i::get_data(void) const;

2155 18 get_num_components 0 4 3585 30 LVecBase2i::get_num_components 0 1 187 0
58
static constexpr int LVecBase2i::get_num_components(void);

2156 4 fill 0 4 3585 16 LVecBase2i::fill 0 1 188 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase2i::fill(int fill_value);

2157 3 set 0 4 3585 15 LVecBase2i::set 0 1 189 10
/**
 *
 */
42
inline void LVecBase2i::set(int x, int y);

2158 3 dot 0 4 3585 15 LVecBase2i::dot 0 1 190 10
/**
 *
 */
58
inline int LVecBase2i::dot(LVecBase2i const &other) const;

2159 14 length_squared 0 4 3585 26 LVecBase2i::length_squared 0 1 191 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase2i::length_squared(void) const;

2160 10 operator < 0 4 3585 22 LVecBase2i::operator < 0 1 192 0
66
inline bool LVecBase2i::operator <(LVecBase2i const &other) const;

2161 11 operator == 0 4 3585 23 LVecBase2i::operator == 0 1 193 0
67
inline bool LVecBase2i::operator ==(LVecBase2i const &other) const;

2162 11 operator != 0 4 3585 23 LVecBase2i::operator != 0 1 194 0
67
inline bool LVecBase2i::operator !=(LVecBase2i const &other) const;

2163 10 compare_to 0 4 3585 22 LVecBase2i::compare_to 0 1 195 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase2i::compare_to(LVecBase2i const &other) const;

2164 8 get_hash 0 4 3585 20 LVecBase2i::get_hash 0 1 196 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase2i::get_hash(void) const;

2165 8 add_hash 0 4 3585 20 LVecBase2i::add_hash 0 1 197 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;

2166 13 generate_hash 0 4 3585 25 LVecBase2i::generate_hash 0 1 198 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase2i::generate_hash(ChecksumHashGenerator &hashgen) const;

2167 10 operator - 0 68 3585 22 LVecBase2i::operator - 0 1 199 0
53
inline LVecBase2i LVecBase2i::operator -(void) const;

2168 10 operator + 0 4 3585 22 LVecBase2i::operator + 0 1 200 0
72
inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const;

2169 10 operator - 0 4 3585 22 LVecBase2i::operator - 0 1 201 0
72
inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const;

2170 10 operator * 0 4 3585 22 LVecBase2i::operator * 0 1 202 0
59
inline LVecBase2i LVecBase2i::operator *(int scalar) const;

2171 10 operator / 0 4 3585 22 LVecBase2i::operator / 0 1 203 0
59
inline LVecBase2i LVecBase2i::operator /(int scalar) const;

2172 11 operator += 0 4 3585 23 LVecBase2i::operator += 0 1 204 0
61
inline void LVecBase2i::operator +=(LVecBase2i const &other);

2173 11 operator -= 0 4 3585 23 LVecBase2i::operator -= 0 1 205 0
61
inline void LVecBase2i::operator -=(LVecBase2i const &other);

2174 11 operator *= 0 4 3585 23 LVecBase2i::operator *= 0 1 206 0
48
inline void LVecBase2i::operator *=(int scalar);

2175 11 operator /= 0 4 3585 23 LVecBase2i::operator /= 0 1 207 0
48
inline void LVecBase2i::operator /=(int scalar);

2176 18 componentwise_mult 0 4 3585 30 LVecBase2i::componentwise_mult 0 1 208 10
/**
 *
 */
68
inline void LVecBase2i::componentwise_mult(LVecBase2i const &other);

2177 8 __rmul__ 0 4 3585 20 LVecBase2i::__rmul__ 0 1 209 0
72
inline PyObject *LVecBase2i::__rmul__(PyObject *self, int scalar) const;

2178 12 __floordiv__ 0 4 3585 24 LVecBase2i::__floordiv__ 0 1 210 0
76
inline PyObject *LVecBase2i::__floordiv__(PyObject *self, int scalar) const;

2179 13 __ifloordiv__ 0 4 3585 25 LVecBase2i::__ifloordiv__ 0 1 211 0
71
inline PyObject *LVecBase2i::__ifloordiv__(PyObject *self, int scalar);

2180 7 __pow__ 0 4 3585 19 LVecBase2i::__pow__ 0 1 212 0
73
inline PyObject *LVecBase2i::__pow__(PyObject *self, int exponent) const;

2181 8 __ipow__ 0 4 3585 20 LVecBase2i::__ipow__ 0 1 213 0
68
inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);

2182 9 __round__ 0 4 3585 21 LVecBase2i::__round__ 0 1 214 0
55
inline PyObject *LVecBase2i::__round__(PyObject *self);

2183 9 __floor__ 0 4 3585 21 LVecBase2i::__floor__ 0 1 215 0
55
inline PyObject *LVecBase2i::__floor__(PyObject *self);

2184 8 __ceil__ 0 4 3585 20 LVecBase2i::__ceil__ 0 1 216 0
54
inline PyObject *LVecBase2i::__ceil__(PyObject *self);

2185 4 fmax 0 4 3585 16 LVecBase2i::fmax 0 1 217 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const;

2186 4 fmin 0 4 3585 16 LVecBase2i::fmin 0 1 218 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const;

2187 12 almost_equal 0 4 3585 24 LVecBase2i::almost_equal 0 2 219 220 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const;
inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const;

2188 6 output 0 4 3585 18 LVecBase2i::output 0 1 221 10
/**
 *
 */
56
inline void LVecBase2i::output(std::ostream &out) const;

2189 8 __repr__ 0 4 3585 20 LVecBase2i::__repr__ 0 1 222 0
52
inline std::string LVecBase2i::__repr__(void) const;

2190 20 write_datagram_fixed 0 4 3585 32 LVecBase2i::write_datagram_fixed 0 1 223 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const;

2191 19 read_datagram_fixed 0 4 3585 31 LVecBase2i::read_datagram_fixed 0 1 224 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source);

2192 14 write_datagram 0 4 3585 26 LVecBase2i::write_datagram 0 1 225 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2i::write_datagram(Datagram &destination) const;

2193 13 read_datagram 0 4 3585 25 LVecBase2i::read_datagram 0 1 226 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2i::read_datagram(DatagramIterator &source);

2194 13 __getbuffer__ 0 4 3585 25 LVecBase2i::__getbuffer__ 0 1 227 0
87
inline int LVecBase2i::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2195 14 get_class_type 0 4 3585 26 LVecBase2i::get_class_type 0 1 228 0
51
static TypeHandle LVecBase2i::get_class_type(void);

2196 11 ~LVecBase2i 0 516 3585 23 LVecBase2i::~LVecBase2i 0 0 0
30
LVecBase2i::~LVecBase2i(void);

2197 9 LVector2f 0 260 3588 20 LVector2f::LVector2f 0 5 229 230 231 232 233 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
249
inline LVector2f::LVector2f(void) = default;
inline LVector2f::LVector2f(LVecBase2f const &copy);
inline LVector2f::LVector2f(float fill_value);
inline LVector2f::LVector2f(float x, float y);
inline LVector2f::LVector2f(LVector2f const &) = default;

2198 11 __getattr__ 0 4 3588 22 LVector2f::__getattr__ 0 1 234 0
92
inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2199 11 __setattr__ 0 4 3588 22 LVector2f::__setattr__ 0 1 235 0
98
inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2200 4 zero 0 4 3588 15 LVector2f::zero 0 1 236 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2f const &LVector2f::zero(void);

2201 6 unit_x 0 4 3588 17 LVector2f::unit_x 0 1 237 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2f const &LVector2f::unit_x(void);

2202 6 unit_y 0 4 3588 17 LVector2f::unit_y 0 1 238 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2f const &LVector2f::unit_y(void);

2203 10 operator - 0 68 3588 21 LVector2f::operator - 0 1 239 0
51
inline LVector2f LVector2f::operator -(void) const;

2204 10 operator + 0 4 3588 21 LVector2f::operator + 0 2 240 241 0
141
inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator +(LVector2f const &other) const;

2205 10 operator - 0 4 3588 21 LVector2f::operator - 0 2 242 243 0
141
inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator -(LVector2f const &other) const;

2206 10 operator * 0 4 3588 21 LVector2f::operator * 0 1 244 0
59
inline LVector2f LVector2f::operator *(float scalar) const;

2207 10 operator / 0 4 3588 21 LVector2f::operator / 0 1 245 0
59
inline LVector2f LVector2f::operator /(float scalar) const;

2208 8 __rmul__ 0 4 3588 19 LVector2f::__rmul__ 0 1 246 0
57
inline LVector2f LVector2f::__rmul__(float scalar) const;

2209 10 normalized 0 4 3588 21 LVector2f::normalized 0 1 247 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2f LVector2f::normalized(void) const;

2210 7 project 0 4 3588 18 LVector2f::project 0 1 248 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2f LVector2f::project(LVecBase2f const &onto) const;

2211 16 signed_angle_rad 0 4 3588 27 LVector2f::signed_angle_rad 0 1 249 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_rad(LVector2f const &other) const;

2212 16 signed_angle_deg 0 4 3588 27 LVector2f::signed_angle_deg 0 1 250 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_deg(LVector2f const &other) const;

2213 8 __repr__ 0 4 3588 19 LVector2f::__repr__ 0 1 251 0
51
inline std::string LVector2f::__repr__(void) const;

2214 14 get_class_type 0 4 3588 25 LVector2f::get_class_type 0 1 252 0
50
static TypeHandle LVector2f::get_class_type(void);

2215 10 ~LVector2f 0 516 3588 21 LVector2f::~LVector2f 0 0 0
28
LVector2f::~LVector2f(void);

2216 9 LVector2d 0 260 3589 20 LVector2d::LVector2d 0 5 253 254 255 256 257 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
252
inline LVector2d::LVector2d(void) = default;
inline LVector2d::LVector2d(LVecBase2d const &copy);
inline LVector2d::LVector2d(double fill_value);
inline LVector2d::LVector2d(double x, double y);
inline LVector2d::LVector2d(LVector2d const &) = default;

2217 11 __getattr__ 0 4 3589 22 LVector2d::__getattr__ 0 1 258 0
92
inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2218 11 __setattr__ 0 4 3589 22 LVector2d::__setattr__ 0 1 259 0
98
inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2219 4 zero 0 4 3589 15 LVector2d::zero 0 1 260 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2d const &LVector2d::zero(void);

2220 6 unit_x 0 4 3589 17 LVector2d::unit_x 0 1 261 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2d const &LVector2d::unit_x(void);

2221 6 unit_y 0 4 3589 17 LVector2d::unit_y 0 1 262 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2d const &LVector2d::unit_y(void);

2222 10 operator - 0 68 3589 21 LVector2d::operator - 0 1 263 0
51
inline LVector2d LVector2d::operator -(void) const;

2223 10 operator + 0 4 3589 21 LVector2d::operator + 0 2 264 265 0
141
inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator +(LVector2d const &other) const;

2224 10 operator - 0 4 3589 21 LVector2d::operator - 0 2 266 267 0
141
inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator -(LVector2d const &other) const;

2225 10 operator * 0 4 3589 21 LVector2d::operator * 0 1 268 0
60
inline LVector2d LVector2d::operator *(double scalar) const;

2226 10 operator / 0 4 3589 21 LVector2d::operator / 0 1 269 0
60
inline LVector2d LVector2d::operator /(double scalar) const;

2227 8 __rmul__ 0 4 3589 19 LVector2d::__rmul__ 0 1 270 0
58
inline LVector2d LVector2d::__rmul__(double scalar) const;

2228 10 normalized 0 4 3589 21 LVector2d::normalized 0 1 271 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2d LVector2d::normalized(void) const;

2229 7 project 0 4 3589 18 LVector2d::project 0 1 272 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2d LVector2d::project(LVecBase2d const &onto) const;

2230 16 signed_angle_rad 0 4 3589 27 LVector2d::signed_angle_rad 0 1 273 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_rad(LVector2d const &other) const;

2231 16 signed_angle_deg 0 4 3589 27 LVector2d::signed_angle_deg 0 1 274 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_deg(LVector2d const &other) const;

2232 8 __repr__ 0 4 3589 19 LVector2d::__repr__ 0 1 275 0
51
inline std::string LVector2d::__repr__(void) const;

2233 14 get_class_type 0 4 3589 25 LVector2d::get_class_type 0 1 276 0
50
static TypeHandle LVector2d::get_class_type(void);

2234 10 ~LVector2d 0 516 3589 21 LVector2d::~LVector2d 0 0 0
28
LVector2d::~LVector2d(void);

2235 9 LVector2i 0 260 3590 20 LVector2i::LVector2i 0 5 277 278 279 280 281 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
243
inline LVector2i::LVector2i(void) = default;
inline LVector2i::LVector2i(LVecBase2i const &copy);
inline LVector2i::LVector2i(int fill_value);
inline LVector2i::LVector2i(int x, int y);
inline LVector2i::LVector2i(LVector2i const &) = default;

2236 11 __getattr__ 0 4 3590 22 LVector2i::__getattr__ 0 1 282 0
92
inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2237 11 __setattr__ 0 4 3590 22 LVector2i::__setattr__ 0 1 283 0
98
inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2238 4 zero 0 4 3590 15 LVector2i::zero 0 1 284 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2i const &LVector2i::zero(void);

2239 6 unit_x 0 4 3590 17 LVector2i::unit_x 0 1 285 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2i const &LVector2i::unit_x(void);

2240 6 unit_y 0 4 3590 17 LVector2i::unit_y 0 1 286 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2i const &LVector2i::unit_y(void);

2241 10 operator - 0 68 3590 21 LVector2i::operator - 0 1 287 0
51
inline LVector2i LVector2i::operator -(void) const;

2242 10 operator + 0 4 3590 21 LVector2i::operator + 0 2 288 289 0
141
inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator +(LVector2i const &other) const;

2243 10 operator - 0 4 3590 21 LVector2i::operator - 0 2 290 291 0
141
inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator -(LVector2i const &other) const;

2244 10 operator * 0 4 3590 21 LVector2i::operator * 0 1 292 0
57
inline LVector2i LVector2i::operator *(int scalar) const;

2245 10 operator / 0 4 3590 21 LVector2i::operator / 0 1 293 0
57
inline LVector2i LVector2i::operator /(int scalar) const;

2246 8 __rmul__ 0 4 3590 19 LVector2i::__rmul__ 0 1 294 0
55
inline LVector2i LVector2i::__rmul__(int scalar) const;

2247 8 __repr__ 0 4 3590 19 LVector2i::__repr__ 0 1 295 0
51
inline std::string LVector2i::__repr__(void) const;

2248 14 get_class_type 0 4 3590 25 LVector2i::get_class_type 0 1 296 0
50
static TypeHandle LVector2i::get_class_type(void);

2249 10 ~LVector2i 0 516 3590 21 LVector2i::~LVector2i 0 0 0
28
LVector2i::~LVector2i(void);

2250 8 LPoint2f 0 260 3591 18 LPoint2f::LPoint2f 0 5 297 298 299 300 301 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
238
inline LPoint2f::LPoint2f(void) = default;
inline LPoint2f::LPoint2f(LVecBase2f const &copy);
inline LPoint2f::LPoint2f(float fill_value);
inline LPoint2f::LPoint2f(float x, float y);
inline LPoint2f::LPoint2f(LPoint2f const &) = default;

2251 11 __getattr__ 0 4 3591 21 LPoint2f::__getattr__ 0 1 302 0
91
inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2252 11 __setattr__ 0 4 3591 21 LPoint2f::__setattr__ 0 1 303 0
97
inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2253 4 zero 0 4 3591 14 LPoint2f::zero 0 1 304 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2f const &LPoint2f::zero(void);

2254 6 unit_x 0 4 3591 16 LPoint2f::unit_x 0 1 305 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2f const &LPoint2f::unit_x(void);

2255 6 unit_y 0 4 3591 16 LPoint2f::unit_y 0 1 306 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2f const &LPoint2f::unit_y(void);

2256 10 operator - 0 68 3591 20 LPoint2f::operator - 0 1 307 0
49
inline LPoint2f LPoint2f::operator -(void) const;

2257 10 operator + 0 4 3591 20 LPoint2f::operator + 0 2 308 309 0
138
inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const;
inline LPoint2f LPoint2f::operator +(LVector2f const &other) const;

2258 10 operator - 0 4 3591 20 LPoint2f::operator - 0 3 310 311 312 0
206
inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const;
inline LVector2f LPoint2f::operator -(LPoint2f const &other) const;
inline LPoint2f LPoint2f::operator -(LVector2f const &other) const;

2259 10 operator * 0 4 3591 20 LPoint2f::operator * 0 1 313 0
57
inline LPoint2f LPoint2f::operator *(float scalar) const;

2260 10 operator / 0 4 3591 20 LPoint2f::operator / 0 1 314 0
57
inline LPoint2f LPoint2f::operator /(float scalar) const;

2261 8 __rmul__ 0 4 3591 18 LPoint2f::__rmul__ 0 1 315 0
55
inline LPoint2f LPoint2f::__rmul__(float scalar) const;

2262 10 normalized 0 4 3591 20 LPoint2f::normalized 0 1 316 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2f LPoint2f::normalized(void) const;

2263 7 project 0 4 3591 17 LPoint2f::project 0 1 317 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const;

2264 8 __repr__ 0 4 3591 18 LPoint2f::__repr__ 0 1 318 0
50
inline std::string LPoint2f::__repr__(void) const;

2265 14 get_class_type 0 4 3591 24 LPoint2f::get_class_type 0 1 319 0
49
static TypeHandle LPoint2f::get_class_type(void);

2266 9 ~LPoint2f 0 516 3591 19 LPoint2f::~LPoint2f 0 0 0
26
LPoint2f::~LPoint2f(void);

2267 8 LPoint2d 0 260 3592 18 LPoint2d::LPoint2d 0 5 320 321 322 323 324 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
241
inline LPoint2d::LPoint2d(void) = default;
inline LPoint2d::LPoint2d(LVecBase2d const &copy);
inline LPoint2d::LPoint2d(double fill_value);
inline LPoint2d::LPoint2d(double x, double y);
inline LPoint2d::LPoint2d(LPoint2d const &) = default;

2268 11 __getattr__ 0 4 3592 21 LPoint2d::__getattr__ 0 1 325 0
91
inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2269 11 __setattr__ 0 4 3592 21 LPoint2d::__setattr__ 0 1 326 0
97
inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2270 4 zero 0 4 3592 14 LPoint2d::zero 0 1 327 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2d const &LPoint2d::zero(void);

2271 6 unit_x 0 4 3592 16 LPoint2d::unit_x 0 1 328 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2d const &LPoint2d::unit_x(void);

2272 6 unit_y 0 4 3592 16 LPoint2d::unit_y 0 1 329 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2d const &LPoint2d::unit_y(void);

2273 10 operator - 0 68 3592 20 LPoint2d::operator - 0 1 330 0
49
inline LPoint2d LPoint2d::operator -(void) const;

2274 10 operator + 0 4 3592 20 LPoint2d::operator + 0 2 331 332 0
138
inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const;
inline LPoint2d LPoint2d::operator +(LVector2d const &other) const;

2275 10 operator - 0 4 3592 20 LPoint2d::operator - 0 3 333 334 335 0
206
inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const;
inline LVector2d LPoint2d::operator -(LPoint2d const &other) const;
inline LPoint2d LPoint2d::operator -(LVector2d const &other) const;

2276 10 operator * 0 4 3592 20 LPoint2d::operator * 0 1 336 0
58
inline LPoint2d LPoint2d::operator *(double scalar) const;

2277 10 operator / 0 4 3592 20 LPoint2d::operator / 0 1 337 0
58
inline LPoint2d LPoint2d::operator /(double scalar) const;

2278 8 __rmul__ 0 4 3592 18 LPoint2d::__rmul__ 0 1 338 0
56
inline LPoint2d LPoint2d::__rmul__(double scalar) const;

2279 10 normalized 0 4 3592 20 LPoint2d::normalized 0 1 339 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2d LPoint2d::normalized(void) const;

2280 7 project 0 4 3592 17 LPoint2d::project 0 1 340 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const;

2281 8 __repr__ 0 4 3592 18 LPoint2d::__repr__ 0 1 341 0
50
inline std::string LPoint2d::__repr__(void) const;

2282 14 get_class_type 0 4 3592 24 LPoint2d::get_class_type 0 1 342 0
49
static TypeHandle LPoint2d::get_class_type(void);

2283 9 ~LPoint2d 0 516 3592 19 LPoint2d::~LPoint2d 0 0 0
26
LPoint2d::~LPoint2d(void);

2284 8 LPoint2i 0 260 3593 18 LPoint2i::LPoint2i 0 5 343 344 345 346 347 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
232
inline LPoint2i::LPoint2i(void) = default;
inline LPoint2i::LPoint2i(LVecBase2i const &copy);
inline LPoint2i::LPoint2i(int fill_value);
inline LPoint2i::LPoint2i(int x, int y);
inline LPoint2i::LPoint2i(LPoint2i const &) = default;

2285 11 __getattr__ 0 4 3593 21 LPoint2i::__getattr__ 0 1 348 0
91
inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2286 11 __setattr__ 0 4 3593 21 LPoint2i::__setattr__ 0 1 349 0
97
inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2287 4 zero 0 4 3593 14 LPoint2i::zero 0 1 350 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2i const &LPoint2i::zero(void);

2288 6 unit_x 0 4 3593 16 LPoint2i::unit_x 0 1 351 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2i const &LPoint2i::unit_x(void);

2289 6 unit_y 0 4 3593 16 LPoint2i::unit_y 0 1 352 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2i const &LPoint2i::unit_y(void);

2290 10 operator - 0 68 3593 20 LPoint2i::operator - 0 1 353 0
49
inline LPoint2i LPoint2i::operator -(void) const;

2291 10 operator + 0 4 3593 20 LPoint2i::operator + 0 2 354 355 0
138
inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const;
inline LPoint2i LPoint2i::operator +(LVector2i const &other) const;

2292 10 operator - 0 4 3593 20 LPoint2i::operator - 0 3 356 357 358 0
206
inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const;
inline LVector2i LPoint2i::operator -(LPoint2i const &other) const;
inline LPoint2i LPoint2i::operator -(LVector2i const &other) const;

2293 10 operator * 0 4 3593 20 LPoint2i::operator * 0 1 359 0
55
inline LPoint2i LPoint2i::operator *(int scalar) const;

2294 10 operator / 0 4 3593 20 LPoint2i::operator / 0 1 360 0
55
inline LPoint2i LPoint2i::operator /(int scalar) const;

2295 8 __rmul__ 0 4 3593 18 LPoint2i::__rmul__ 0 1 361 0
53
inline LPoint2i LPoint2i::__rmul__(int scalar) const;

2296 8 __repr__ 0 4 3593 18 LPoint2i::__repr__ 0 1 362 0
50
inline std::string LPoint2i::__repr__(void) const;

2297 14 get_class_type 0 4 3593 24 LPoint2i::get_class_type 0 1 363 0
49
static TypeHandle LPoint2i::get_class_type(void);

2298 9 ~LPoint2i 0 516 3593 19 LPoint2i::~LPoint2i 0 0 0
26
LPoint2i::~LPoint2i(void);

2299 10 LVecBase3f 0 260 3594 22 LVecBase3f::LVecBase3f 0 5 364 365 366 367 368 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
287
inline LVecBase3f::LVecBase3f(void) = default;
inline LVecBase3f::LVecBase3f(float fill_value);
inline LVecBase3f::LVecBase3f(float x, float y, float z);
inline explicit LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z);
inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default;

2300 12 operator new 0 4 3594 24 LVecBase3f::operator new 0 1 369 0
124
inline void *LVecBase3f::operator new(std::size_t size);
inline void *LVecBase3f::operator new(std::size_t size, void *ptr);

2301 15 operator delete 0 4 3594 27 LVecBase3f::operator delete 0 0 0
108
inline void LVecBase3f::operator delete(void *ptr);
inline void LVecBase3f::operator delete(void *, void *);

2302 12 validate_ptr 0 4 3594 24 LVecBase3f::validate_ptr 0 0 0
61
static inline bool LVecBase3f::validate_ptr(void const *ptr);

2303 10 operator = 0 4 3594 22 LVecBase3f::operator = 0 2 370 371 0
119
void LVecBase3f::operator =(LVecBase3f const &copy) = default;
void LVecBase3f::operator =(float fill_value) = default;

2304 4 zero 0 4 3594 16 LVecBase3f::zero 0 1 372 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3f const &LVecBase3f::zero(void);

2305 6 unit_x 0 4 3594 18 LVecBase3f::unit_x 0 1 373 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_x(void);

2306 6 unit_y 0 4 3594 18 LVecBase3f::unit_y 0 1 374 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_y(void);

2307 6 unit_z 0 4 3594 18 LVecBase3f::unit_z 0 1 375 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_z(void);

2308 10 __reduce__ 0 4 3594 22 LVecBase3f::__reduce__ 0 1 376 0
62
inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;

2309 11 __getattr__ 0 4 3594 23 LVecBase3f::__getattr__ 0 1 377 0
93
inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2310 11 __setattr__ 0 4 3594 23 LVecBase3f::__setattr__ 0 1 378 0
99
inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2311 11 operator [] 0 4 3594 23 LVecBase3f::operator [] 0 2 379 380 10
/**
 *
 */
96
inline float LVecBase3f::operator [](int i) const;
inline float &LVecBase3f::operator [](int i);

2312 12 operator []= 0 1028 3594 24 LVecBase3f::operator []= 0 1 381 0
62
void LVecBase3f::operator []=(int i, float const &assign_val);

2313 4 size 0 4 3594 16 LVecBase3f::size 0 1 382 0
44
static constexpr int LVecBase3f::size(void);

2314 6 is_nan 0 4 3594 18 LVecBase3f::is_nan 0 1 383 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3f::is_nan(void) const;

2315 8 get_cell 0 4 3594 20 LVecBase3f::get_cell 0 1 384 10
/**
 *
 */
47
inline float LVecBase3f::get_cell(int i) const;

2316 5 get_x 0 4 3594 17 LVecBase3f::get_x 0 1 385 10
/**
 *
 */
43
inline float LVecBase3f::get_x(void) const;

2317 5 get_y 0 4 3594 17 LVecBase3f::get_y 0 1 386 10
/**
 *
 */
43
inline float LVecBase3f::get_y(void) const;

2318 5 get_z 0 4 3594 17 LVecBase3f::get_z 0 1 387 10
/**
 *
 */
43
inline float LVecBase3f::get_z(void) const;

2319 8 set_cell 0 4 3594 20 LVecBase3f::set_cell 0 1 388 10
/**
 *
 */
53
inline void LVecBase3f::set_cell(int i, float value);

2320 5 set_x 0 4 3594 17 LVecBase3f::set_x 0 1 389 10
/**
 *
 */
43
inline void LVecBase3f::set_x(float value);

2321 5 set_y 0 4 3594 17 LVecBase3f::set_y 0 1 390 10
/**
 *
 */
43
inline void LVecBase3f::set_y(float value);

2322 5 set_z 0 4 3594 17 LVecBase3f::set_z 0 1 391 10
/**
 *
 */
43
inline void LVecBase3f::set_z(float value);

2323 6 get_xy 0 4 3594 18 LVecBase3f::get_xy 0 1 392 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xy(void) const;

2324 6 get_xz 0 4 3594 18 LVecBase3f::get_xz 0 1 393 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xz(void) const;

2325 6 get_yz 0 4 3594 18 LVecBase3f::get_yz 0 1 394 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_yz(void) const;

2326 11 add_to_cell 0 4 3594 23 LVecBase3f::add_to_cell 0 1 395 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase3f::add_to_cell(int i, float value);

2327 5 add_x 0 4 3594 17 LVecBase3f::add_x 0 1 396 10
/**
 *
 */
43
inline void LVecBase3f::add_x(float value);

2328 5 add_y 0 4 3594 17 LVecBase3f::add_y 0 1 397 10
/**
 *
 */
43
inline void LVecBase3f::add_y(float value);

2329 5 add_z 0 4 3594 17 LVecBase3f::add_z 0 1 398 10
/**
 *
 */
43
inline void LVecBase3f::add_z(float value);

2330 8 get_data 0 4 3594 20 LVecBase3f::get_data 0 1 399 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase3f::get_data(void) const;

2331 18 get_num_components 0 4 3594 30 LVecBase3f::get_num_components 0 1 400 0
58
static constexpr int LVecBase3f::get_num_components(void);

2332 4 fill 0 4 3594 16 LVecBase3f::fill 0 1 401 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase3f::fill(float fill_value);

2333 3 set 0 4 3594 15 LVecBase3f::set 0 1 402 10
/**
 *
 */
55
inline void LVecBase3f::set(float x, float y, float z);

2334 3 dot 0 4 3594 15 LVecBase3f::dot 0 1 403 10
/**
 *
 */
60
inline float LVecBase3f::dot(LVecBase3f const &other) const;

2335 14 length_squared 0 4 3594 26 LVecBase3f::length_squared 0 1 404 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase3f::length_squared(void) const;

2336 6 length 0 4 3594 18 LVecBase3f::length 0 1 405 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase3f::length(void) const;

2337 9 normalize 0 4 3594 21 LVecBase3f::normalize 0 1 406 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3f::normalize(void);

2338 10 normalized 0 4 3594 22 LVecBase3f::normalized 0 1 407 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3f LVecBase3f::normalized(void) const;

2339 7 project 0 4 3594 19 LVecBase3f::project 0 1 408 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const;

2340 5 cross 0 4 3594 17 LVecBase3f::cross 0 1 409 10
/**
 *
 */
67
inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const;

2341 10 operator < 0 4 3594 22 LVecBase3f::operator < 0 1 410 0
66
inline bool LVecBase3f::operator <(LVecBase3f const &other) const;

2342 11 operator == 0 4 3594 23 LVecBase3f::operator == 0 1 411 0
67
inline bool LVecBase3f::operator ==(LVecBase3f const &other) const;

2343 11 operator != 0 4 3594 23 LVecBase3f::operator != 0 1 412 0
67
inline bool LVecBase3f::operator !=(LVecBase3f const &other) const;

2344 20 get_standardized_hpr 0 4 3594 32 LVecBase3f::get_standardized_hpr 0 1 413 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;

2345 10 compare_to 0 4 3594 22 LVecBase3f::compare_to 0 2 414 415 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase3f::compare_to(LVecBase3f const &other) const;
inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const;

2346 8 get_hash 0 4 3594 20 LVecBase3f::get_hash 0 2 416 417 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase3f::get_hash(void) const;
inline std::size_t LVecBase3f::get_hash(float threshold) const;

2347 8 add_hash 0 4 3594 20 LVecBase3f::add_hash 0 2 418 419 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;

2348 13 generate_hash 0 4 3594 25 LVecBase3f::generate_hash 0 2 420 421 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2349 10 operator - 0 68 3594 22 LVecBase3f::operator - 0 1 422 0
53
inline LVecBase3f LVecBase3f::operator -(void) const;

2350 10 operator + 0 4 3594 22 LVecBase3f::operator + 0 1 423 0
72
inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const;

2351 10 operator - 0 4 3594 22 LVecBase3f::operator - 0 1 424 0
72
inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const;

2352 10 operator * 0 4 3594 22 LVecBase3f::operator * 0 1 425 0
61
inline LVecBase3f LVecBase3f::operator *(float scalar) const;

2353 10 operator / 0 4 3594 22 LVecBase3f::operator / 0 1 426 0
61
inline LVecBase3f LVecBase3f::operator /(float scalar) const;

2354 11 operator += 0 4 3594 23 LVecBase3f::operator += 0 1 427 0
61
inline void LVecBase3f::operator +=(LVecBase3f const &other);

2355 11 operator -= 0 4 3594 23 LVecBase3f::operator -= 0 1 428 0
61
inline void LVecBase3f::operator -=(LVecBase3f const &other);

2356 11 operator *= 0 4 3594 23 LVecBase3f::operator *= 0 1 429 0
50
inline void LVecBase3f::operator *=(float scalar);

2357 11 operator /= 0 4 3594 23 LVecBase3f::operator /= 0 1 430 0
50
inline void LVecBase3f::operator /=(float scalar);

2358 18 componentwise_mult 0 4 3594 30 LVecBase3f::componentwise_mult 0 1 431 10
/**
 *
 */
68
inline void LVecBase3f::componentwise_mult(LVecBase3f const &other);

2359 8 __rmul__ 0 4 3594 20 LVecBase3f::__rmul__ 0 1 432 0
74
inline PyObject *LVecBase3f::__rmul__(PyObject *self, float scalar) const;

2360 12 __floordiv__ 0 4 3594 24 LVecBase3f::__floordiv__ 0 1 433 0
78
inline PyObject *LVecBase3f::__floordiv__(PyObject *self, float scalar) const;

2361 13 __ifloordiv__ 0 4 3594 25 LVecBase3f::__ifloordiv__ 0 1 434 0
73
inline PyObject *LVecBase3f::__ifloordiv__(PyObject *self, float scalar);

2362 7 __pow__ 0 4 3594 19 LVecBase3f::__pow__ 0 1 435 0
75
inline PyObject *LVecBase3f::__pow__(PyObject *self, float exponent) const;

2363 8 __ipow__ 0 4 3594 20 LVecBase3f::__ipow__ 0 1 436 0
70
inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);

2364 9 __round__ 0 4 3594 21 LVecBase3f::__round__ 0 1 437 0
55
inline PyObject *LVecBase3f::__round__(PyObject *self);

2365 9 __floor__ 0 4 3594 21 LVecBase3f::__floor__ 0 1 438 0
55
inline PyObject *LVecBase3f::__floor__(PyObject *self);

2366 8 __ceil__ 0 4 3594 20 LVecBase3f::__ceil__ 0 1 439 0
54
inline PyObject *LVecBase3f::__ceil__(PyObject *self);

2367 4 fmax 0 4 3594 16 LVecBase3f::fmax 0 1 440 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const;

2368 4 fmin 0 4 3594 16 LVecBase3f::fmin 0 1 441 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const;

2369 10 cross_into 0 4 3594 22 LVecBase3f::cross_into 0 1 442 10
/**
 *
 */
60
inline void LVecBase3f::cross_into(LVecBase3f const &other);

2370 12 almost_equal 0 4 3594 24 LVecBase3f::almost_equal 0 2 443 444 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const;
inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const;

2371 6 output 0 4 3594 18 LVecBase3f::output 0 1 445 10
/**
 *
 */
56
inline void LVecBase3f::output(std::ostream &out) const;

2372 8 __repr__ 0 4 3594 20 LVecBase3f::__repr__ 0 1 446 0
52
inline std::string LVecBase3f::__repr__(void) const;

2373 20 write_datagram_fixed 0 4 3594 32 LVecBase3f::write_datagram_fixed 0 1 447 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const;

2374 19 read_datagram_fixed 0 4 3594 31 LVecBase3f::read_datagram_fixed 0 1 448 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source);

2375 14 write_datagram 0 4 3594 26 LVecBase3f::write_datagram 0 1 449 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3f::write_datagram(Datagram &destination) const;

2376 13 read_datagram 0 4 3594 25 LVecBase3f::read_datagram 0 1 450 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3f::read_datagram(DatagramIterator &source);

2377 13 __getbuffer__ 0 4 3594 25 LVecBase3f::__getbuffer__ 0 1 451 0
87
inline int LVecBase3f::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2378 14 get_class_type 0 4 3594 26 LVecBase3f::get_class_type 0 1 452 0
51
static TypeHandle LVecBase3f::get_class_type(void);

2379 11 ~LVecBase3f 0 516 3594 23 LVecBase3f::~LVecBase3f 0 0 0
30
LVecBase3f::~LVecBase3f(void);

2380 10 LVecBase3d 0 260 3596 22 LVecBase3d::LVecBase3d 0 5 453 454 455 456 457 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
292
inline LVecBase3d::LVecBase3d(void) = default;
inline LVecBase3d::LVecBase3d(double fill_value);
inline LVecBase3d::LVecBase3d(double x, double y, double z);
inline explicit LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z);
inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default;

2381 12 operator new 0 4 3596 24 LVecBase3d::operator new 0 1 458 0
124
inline void *LVecBase3d::operator new(std::size_t size);
inline void *LVecBase3d::operator new(std::size_t size, void *ptr);

2382 15 operator delete 0 4 3596 27 LVecBase3d::operator delete 0 0 0
108
inline void LVecBase3d::operator delete(void *ptr);
inline void LVecBase3d::operator delete(void *, void *);

2383 12 validate_ptr 0 4 3596 24 LVecBase3d::validate_ptr 0 0 0
61
static inline bool LVecBase3d::validate_ptr(void const *ptr);

2384 10 operator = 0 4 3596 22 LVecBase3d::operator = 0 2 459 460 0
120
void LVecBase3d::operator =(LVecBase3d const &copy) = default;
void LVecBase3d::operator =(double fill_value) = default;

2385 4 zero 0 4 3596 16 LVecBase3d::zero 0 1 461 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3d const &LVecBase3d::zero(void);

2386 6 unit_x 0 4 3596 18 LVecBase3d::unit_x 0 1 462 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_x(void);

2387 6 unit_y 0 4 3596 18 LVecBase3d::unit_y 0 1 463 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_y(void);

2388 6 unit_z 0 4 3596 18 LVecBase3d::unit_z 0 1 464 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_z(void);

2389 10 __reduce__ 0 4 3596 22 LVecBase3d::__reduce__ 0 1 465 0
62
inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;

2390 11 __getattr__ 0 4 3596 23 LVecBase3d::__getattr__ 0 1 466 0
93
inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2391 11 __setattr__ 0 4 3596 23 LVecBase3d::__setattr__ 0 1 467 0
99
inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2392 11 operator [] 0 4 3596 23 LVecBase3d::operator [] 0 2 468 469 10
/**
 *
 */
98
inline double LVecBase3d::operator [](int i) const;
inline double &LVecBase3d::operator [](int i);

2393 12 operator []= 0 1028 3596 24 LVecBase3d::operator []= 0 1 470 0
63
void LVecBase3d::operator []=(int i, double const &assign_val);

2394 4 size 0 4 3596 16 LVecBase3d::size 0 1 471 0
44
static constexpr int LVecBase3d::size(void);

2395 6 is_nan 0 4 3596 18 LVecBase3d::is_nan 0 1 472 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3d::is_nan(void) const;

2396 8 get_cell 0 4 3596 20 LVecBase3d::get_cell 0 1 473 10
/**
 *
 */
48
inline double LVecBase3d::get_cell(int i) const;

2397 5 get_x 0 4 3596 17 LVecBase3d::get_x 0 1 474 10
/**
 *
 */
44
inline double LVecBase3d::get_x(void) const;

2398 5 get_y 0 4 3596 17 LVecBase3d::get_y 0 1 475 10
/**
 *
 */
44
inline double LVecBase3d::get_y(void) const;

2399 5 get_z 0 4 3596 17 LVecBase3d::get_z 0 1 476 10
/**
 *
 */
44
inline double LVecBase3d::get_z(void) const;

2400 8 set_cell 0 4 3596 20 LVecBase3d::set_cell 0 1 477 10
/**
 *
 */
54
inline void LVecBase3d::set_cell(int i, double value);

2401 5 set_x 0 4 3596 17 LVecBase3d::set_x 0 1 478 10
/**
 *
 */
44
inline void LVecBase3d::set_x(double value);

2402 5 set_y 0 4 3596 17 LVecBase3d::set_y 0 1 479 10
/**
 *
 */
44
inline void LVecBase3d::set_y(double value);

2403 5 set_z 0 4 3596 17 LVecBase3d::set_z 0 1 480 10
/**
 *
 */
44
inline void LVecBase3d::set_z(double value);

2404 6 get_xy 0 4 3596 18 LVecBase3d::get_xy 0 1 481 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xy(void) const;

2405 6 get_xz 0 4 3596 18 LVecBase3d::get_xz 0 1 482 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xz(void) const;

2406 6 get_yz 0 4 3596 18 LVecBase3d::get_yz 0 1 483 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_yz(void) const;

2407 11 add_to_cell 0 4 3596 23 LVecBase3d::add_to_cell 0 1 484 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase3d::add_to_cell(int i, double value);

2408 5 add_x 0 4 3596 17 LVecBase3d::add_x 0 1 485 10
/**
 *
 */
44
inline void LVecBase3d::add_x(double value);

2409 5 add_y 0 4 3596 17 LVecBase3d::add_y 0 1 486 10
/**
 *
 */
44
inline void LVecBase3d::add_y(double value);

2410 5 add_z 0 4 3596 17 LVecBase3d::add_z 0 1 487 10
/**
 *
 */
44
inline void LVecBase3d::add_z(double value);

2411 8 get_data 0 4 3596 20 LVecBase3d::get_data 0 1 488 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase3d::get_data(void) const;

2412 18 get_num_components 0 4 3596 30 LVecBase3d::get_num_components 0 1 489 0
58
static constexpr int LVecBase3d::get_num_components(void);

2413 4 fill 0 4 3596 16 LVecBase3d::fill 0 1 490 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase3d::fill(double fill_value);

2414 3 set 0 4 3596 15 LVecBase3d::set 0 1 491 10
/**
 *
 */
58
inline void LVecBase3d::set(double x, double y, double z);

2415 3 dot 0 4 3596 15 LVecBase3d::dot 0 1 492 10
/**
 *
 */
61
inline double LVecBase3d::dot(LVecBase3d const &other) const;

2416 14 length_squared 0 4 3596 26 LVecBase3d::length_squared 0 1 493 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase3d::length_squared(void) const;

2417 6 length 0 4 3596 18 LVecBase3d::length 0 1 494 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase3d::length(void) const;

2418 9 normalize 0 4 3596 21 LVecBase3d::normalize 0 1 495 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3d::normalize(void);

2419 10 normalized 0 4 3596 22 LVecBase3d::normalized 0 1 496 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3d LVecBase3d::normalized(void) const;

2420 7 project 0 4 3596 19 LVecBase3d::project 0 1 497 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const;

2421 5 cross 0 4 3596 17 LVecBase3d::cross 0 1 498 10
/**
 *
 */
67
inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const;

2422 10 operator < 0 4 3596 22 LVecBase3d::operator < 0 1 499 0
66
inline bool LVecBase3d::operator <(LVecBase3d const &other) const;

2423 11 operator == 0 4 3596 23 LVecBase3d::operator == 0 1 500 0
67
inline bool LVecBase3d::operator ==(LVecBase3d const &other) const;

2424 11 operator != 0 4 3596 23 LVecBase3d::operator != 0 1 501 0
67
inline bool LVecBase3d::operator !=(LVecBase3d const &other) const;

2425 20 get_standardized_hpr 0 4 3596 32 LVecBase3d::get_standardized_hpr 0 1 502 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;

2426 10 compare_to 0 4 3596 22 LVecBase3d::compare_to 0 2 503 504 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase3d::compare_to(LVecBase3d const &other) const;
inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const;

2427 8 get_hash 0 4 3596 20 LVecBase3d::get_hash 0 2 505 506 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase3d::get_hash(void) const;
inline std::size_t LVecBase3d::get_hash(double threshold) const;

2428 8 add_hash 0 4 3596 20 LVecBase3d::add_hash 0 2 507 508 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;

2429 13 generate_hash 0 4 3596 25 LVecBase3d::generate_hash 0 2 509 510 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2430 10 operator - 0 68 3596 22 LVecBase3d::operator - 0 1 511 0
53
inline LVecBase3d LVecBase3d::operator -(void) const;

2431 10 operator + 0 4 3596 22 LVecBase3d::operator + 0 1 512 0
72
inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const;

2432 10 operator - 0 4 3596 22 LVecBase3d::operator - 0 1 513 0
72
inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const;

2433 10 operator * 0 4 3596 22 LVecBase3d::operator * 0 1 514 0
62
inline LVecBase3d LVecBase3d::operator *(double scalar) const;

2434 10 operator / 0 4 3596 22 LVecBase3d::operator / 0 1 515 0
62
inline LVecBase3d LVecBase3d::operator /(double scalar) const;

2435 11 operator += 0 4 3596 23 LVecBase3d::operator += 0 1 516 0
61
inline void LVecBase3d::operator +=(LVecBase3d const &other);

2436 11 operator -= 0 4 3596 23 LVecBase3d::operator -= 0 1 517 0
61
inline void LVecBase3d::operator -=(LVecBase3d const &other);

2437 11 operator *= 0 4 3596 23 LVecBase3d::operator *= 0 1 518 0
51
inline void LVecBase3d::operator *=(double scalar);

2438 11 operator /= 0 4 3596 23 LVecBase3d::operator /= 0 1 519 0
51
inline void LVecBase3d::operator /=(double scalar);

2439 18 componentwise_mult 0 4 3596 30 LVecBase3d::componentwise_mult 0 1 520 10
/**
 *
 */
68
inline void LVecBase3d::componentwise_mult(LVecBase3d const &other);

2440 8 __rmul__ 0 4 3596 20 LVecBase3d::__rmul__ 0 1 521 0
75
inline PyObject *LVecBase3d::__rmul__(PyObject *self, double scalar) const;

2441 12 __floordiv__ 0 4 3596 24 LVecBase3d::__floordiv__ 0 1 522 0
79
inline PyObject *LVecBase3d::__floordiv__(PyObject *self, double scalar) const;

2442 13 __ifloordiv__ 0 4 3596 25 LVecBase3d::__ifloordiv__ 0 1 523 0
74
inline PyObject *LVecBase3d::__ifloordiv__(PyObject *self, double scalar);

2443 7 __pow__ 0 4 3596 19 LVecBase3d::__pow__ 0 1 524 0
76
inline PyObject *LVecBase3d::__pow__(PyObject *self, double exponent) const;

2444 8 __ipow__ 0 4 3596 20 LVecBase3d::__ipow__ 0 1 525 0
71
inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);

2445 9 __round__ 0 4 3596 21 LVecBase3d::__round__ 0 1 526 0
55
inline PyObject *LVecBase3d::__round__(PyObject *self);

2446 9 __floor__ 0 4 3596 21 LVecBase3d::__floor__ 0 1 527 0
55
inline PyObject *LVecBase3d::__floor__(PyObject *self);

2447 8 __ceil__ 0 4 3596 20 LVecBase3d::__ceil__ 0 1 528 0
54
inline PyObject *LVecBase3d::__ceil__(PyObject *self);

2448 4 fmax 0 4 3596 16 LVecBase3d::fmax 0 1 529 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const;

2449 4 fmin 0 4 3596 16 LVecBase3d::fmin 0 1 530 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const;

2450 10 cross_into 0 4 3596 22 LVecBase3d::cross_into 0 1 531 10
/**
 *
 */
60
inline void LVecBase3d::cross_into(LVecBase3d const &other);

2451 12 almost_equal 0 4 3596 24 LVecBase3d::almost_equal 0 2 532 533 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const;
inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const;

2452 6 output 0 4 3596 18 LVecBase3d::output 0 1 534 10
/**
 *
 */
56
inline void LVecBase3d::output(std::ostream &out) const;

2453 8 __repr__ 0 4 3596 20 LVecBase3d::__repr__ 0 1 535 0
52
inline std::string LVecBase3d::__repr__(void) const;

2454 20 write_datagram_fixed 0 4 3596 32 LVecBase3d::write_datagram_fixed 0 1 536 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const;

2455 19 read_datagram_fixed 0 4 3596 31 LVecBase3d::read_datagram_fixed 0 1 537 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source);

2456 14 write_datagram 0 4 3596 26 LVecBase3d::write_datagram 0 1 538 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3d::write_datagram(Datagram &destination) const;

2457 13 read_datagram 0 4 3596 25 LVecBase3d::read_datagram 0 1 539 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3d::read_datagram(DatagramIterator &source);

2458 13 __getbuffer__ 0 4 3596 25 LVecBase3d::__getbuffer__ 0 1 540 0
87
inline int LVecBase3d::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2459 14 get_class_type 0 4 3596 26 LVecBase3d::get_class_type 0 1 541 0
51
static TypeHandle LVecBase3d::get_class_type(void);

2460 11 ~LVecBase3d 0 516 3596 23 LVecBase3d::~LVecBase3d 0 0 0
30
LVecBase3d::~LVecBase3d(void);

2461 10 LVecBase3i 0 260 3598 22 LVecBase3i::LVecBase3i 0 5 542 543 544 545 546 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
277
inline LVecBase3i::LVecBase3i(void) = default;
inline LVecBase3i::LVecBase3i(int fill_value);
inline LVecBase3i::LVecBase3i(int x, int y, int z);
inline explicit LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z);
inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default;

2462 12 operator new 0 4 3598 24 LVecBase3i::operator new 0 1 547 0
124
inline void *LVecBase3i::operator new(std::size_t size);
inline void *LVecBase3i::operator new(std::size_t size, void *ptr);

2463 15 operator delete 0 4 3598 27 LVecBase3i::operator delete 0 0 0
108
inline void LVecBase3i::operator delete(void *ptr);
inline void LVecBase3i::operator delete(void *, void *);

2464 12 validate_ptr 0 4 3598 24 LVecBase3i::validate_ptr 0 0 0
61
static inline bool LVecBase3i::validate_ptr(void const *ptr);

2465 10 operator = 0 4 3598 22 LVecBase3i::operator = 0 2 548 549 0
117
void LVecBase3i::operator =(LVecBase3i const &copy) = default;
void LVecBase3i::operator =(int fill_value) = default;

2466 4 zero 0 4 3598 16 LVecBase3i::zero 0 1 550 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3i const &LVecBase3i::zero(void);

2467 6 unit_x 0 4 3598 18 LVecBase3i::unit_x 0 1 551 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_x(void);

2468 6 unit_y 0 4 3598 18 LVecBase3i::unit_y 0 1 552 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_y(void);

2469 6 unit_z 0 4 3598 18 LVecBase3i::unit_z 0 1 553 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_z(void);

2470 10 __reduce__ 0 4 3598 22 LVecBase3i::__reduce__ 0 1 554 0
62
inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;

2471 11 __getattr__ 0 4 3598 23 LVecBase3i::__getattr__ 0 1 555 0
93
inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2472 11 __setattr__ 0 4 3598 23 LVecBase3i::__setattr__ 0 1 556 0
99
inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2473 11 operator [] 0 4 3598 23 LVecBase3i::operator [] 0 2 557 558 10
/**
 *
 */
92
inline int LVecBase3i::operator [](int i) const;
inline int &LVecBase3i::operator [](int i);

2474 12 operator []= 0 1028 3598 24 LVecBase3i::operator []= 0 1 559 0
60
void LVecBase3i::operator []=(int i, int const &assign_val);

2475 4 size 0 4 3598 16 LVecBase3i::size 0 1 560 0
44
static constexpr int LVecBase3i::size(void);

2476 6 is_nan 0 4 3598 18 LVecBase3i::is_nan 0 1 561 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3i::is_nan(void) const;

2477 8 get_cell 0 4 3598 20 LVecBase3i::get_cell 0 1 562 10
/**
 *
 */
45
inline int LVecBase3i::get_cell(int i) const;

2478 5 get_x 0 4 3598 17 LVecBase3i::get_x 0 1 563 10
/**
 *
 */
41
inline int LVecBase3i::get_x(void) const;

2479 5 get_y 0 4 3598 17 LVecBase3i::get_y 0 1 564 10
/**
 *
 */
41
inline int LVecBase3i::get_y(void) const;

2480 5 get_z 0 4 3598 17 LVecBase3i::get_z 0 1 565 10
/**
 *
 */
41
inline int LVecBase3i::get_z(void) const;

2481 8 set_cell 0 4 3598 20 LVecBase3i::set_cell 0 1 566 10
/**
 *
 */
51
inline void LVecBase3i::set_cell(int i, int value);

2482 5 set_x 0 4 3598 17 LVecBase3i::set_x 0 1 567 10
/**
 *
 */
41
inline void LVecBase3i::set_x(int value);

2483 5 set_y 0 4 3598 17 LVecBase3i::set_y 0 1 568 10
/**
 *
 */
41
inline void LVecBase3i::set_y(int value);

2484 5 set_z 0 4 3598 17 LVecBase3i::set_z 0 1 569 10
/**
 *
 */
41
inline void LVecBase3i::set_z(int value);

2485 6 get_xy 0 4 3598 18 LVecBase3i::get_xy 0 1 570 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xy(void) const;

2486 6 get_xz 0 4 3598 18 LVecBase3i::get_xz 0 1 571 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xz(void) const;

2487 6 get_yz 0 4 3598 18 LVecBase3i::get_yz 0 1 572 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_yz(void) const;

2488 11 add_to_cell 0 4 3598 23 LVecBase3i::add_to_cell 0 1 573 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase3i::add_to_cell(int i, int value);

2489 5 add_x 0 4 3598 17 LVecBase3i::add_x 0 1 574 10
/**
 *
 */
41
inline void LVecBase3i::add_x(int value);

2490 5 add_y 0 4 3598 17 LVecBase3i::add_y 0 1 575 10
/**
 *
 */
41
inline void LVecBase3i::add_y(int value);

2491 5 add_z 0 4 3598 17 LVecBase3i::add_z 0 1 576 10
/**
 *
 */
41
inline void LVecBase3i::add_z(int value);

2492 8 get_data 0 4 3598 20 LVecBase3i::get_data 0 1 577 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase3i::get_data(void) const;

2493 18 get_num_components 0 4 3598 30 LVecBase3i::get_num_components 0 1 578 0
58
static constexpr int LVecBase3i::get_num_components(void);

2494 4 fill 0 4 3598 16 LVecBase3i::fill 0 1 579 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase3i::fill(int fill_value);

2495 3 set 0 4 3598 15 LVecBase3i::set 0 1 580 10
/**
 *
 */
49
inline void LVecBase3i::set(int x, int y, int z);

2496 3 dot 0 4 3598 15 LVecBase3i::dot 0 1 581 10
/**
 *
 */
58
inline int LVecBase3i::dot(LVecBase3i const &other) const;

2497 14 length_squared 0 4 3598 26 LVecBase3i::length_squared 0 1 582 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase3i::length_squared(void) const;

2498 5 cross 0 4 3598 17 LVecBase3i::cross 0 1 583 10
/**
 *
 */
67
inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const;

2499 10 operator < 0 4 3598 22 LVecBase3i::operator < 0 1 584 0
66
inline bool LVecBase3i::operator <(LVecBase3i const &other) const;

2500 11 operator == 0 4 3598 23 LVecBase3i::operator == 0 1 585 0
67
inline bool LVecBase3i::operator ==(LVecBase3i const &other) const;

2501 11 operator != 0 4 3598 23 LVecBase3i::operator != 0 1 586 0
67
inline bool LVecBase3i::operator !=(LVecBase3i const &other) const;

2502 10 compare_to 0 4 3598 22 LVecBase3i::compare_to 0 1 587 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase3i::compare_to(LVecBase3i const &other) const;

2503 8 get_hash 0 4 3598 20 LVecBase3i::get_hash 0 1 588 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase3i::get_hash(void) const;

2504 8 add_hash 0 4 3598 20 LVecBase3i::add_hash 0 1 589 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;

2505 13 generate_hash 0 4 3598 25 LVecBase3i::generate_hash 0 1 590 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase3i::generate_hash(ChecksumHashGenerator &hashgen) const;

2506 10 operator - 0 68 3598 22 LVecBase3i::operator - 0 1 591 0
53
inline LVecBase3i LVecBase3i::operator -(void) const;

2507 10 operator + 0 4 3598 22 LVecBase3i::operator + 0 1 592 0
72
inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const;

2508 10 operator - 0 4 3598 22 LVecBase3i::operator - 0 1 593 0
72
inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const;

2509 10 operator * 0 4 3598 22 LVecBase3i::operator * 0 1 594 0
59
inline LVecBase3i LVecBase3i::operator *(int scalar) const;

2510 10 operator / 0 4 3598 22 LVecBase3i::operator / 0 1 595 0
59
inline LVecBase3i LVecBase3i::operator /(int scalar) const;

2511 11 operator += 0 4 3598 23 LVecBase3i::operator += 0 1 596 0
61
inline void LVecBase3i::operator +=(LVecBase3i const &other);

2512 11 operator -= 0 4 3598 23 LVecBase3i::operator -= 0 1 597 0
61
inline void LVecBase3i::operator -=(LVecBase3i const &other);

2513 11 operator *= 0 4 3598 23 LVecBase3i::operator *= 0 1 598 0
48
inline void LVecBase3i::operator *=(int scalar);

2514 11 operator /= 0 4 3598 23 LVecBase3i::operator /= 0 1 599 0
48
inline void LVecBase3i::operator /=(int scalar);

2515 18 componentwise_mult 0 4 3598 30 LVecBase3i::componentwise_mult 0 1 600 10
/**
 *
 */
68
inline void LVecBase3i::componentwise_mult(LVecBase3i const &other);

2516 8 __rmul__ 0 4 3598 20 LVecBase3i::__rmul__ 0 1 601 0
72
inline PyObject *LVecBase3i::__rmul__(PyObject *self, int scalar) const;

2517 12 __floordiv__ 0 4 3598 24 LVecBase3i::__floordiv__ 0 1 602 0
76
inline PyObject *LVecBase3i::__floordiv__(PyObject *self, int scalar) const;

2518 13 __ifloordiv__ 0 4 3598 25 LVecBase3i::__ifloordiv__ 0 1 603 0
71
inline PyObject *LVecBase3i::__ifloordiv__(PyObject *self, int scalar);

2519 7 __pow__ 0 4 3598 19 LVecBase3i::__pow__ 0 1 604 0
73
inline PyObject *LVecBase3i::__pow__(PyObject *self, int exponent) const;

2520 8 __ipow__ 0 4 3598 20 LVecBase3i::__ipow__ 0 1 605 0
68
inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);

2521 9 __round__ 0 4 3598 21 LVecBase3i::__round__ 0 1 606 0
55
inline PyObject *LVecBase3i::__round__(PyObject *self);

2522 9 __floor__ 0 4 3598 21 LVecBase3i::__floor__ 0 1 607 0
55
inline PyObject *LVecBase3i::__floor__(PyObject *self);

2523 8 __ceil__ 0 4 3598 20 LVecBase3i::__ceil__ 0 1 608 0
54
inline PyObject *LVecBase3i::__ceil__(PyObject *self);

2524 4 fmax 0 4 3598 16 LVecBase3i::fmax 0 1 609 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const;

2525 4 fmin 0 4 3598 16 LVecBase3i::fmin 0 1 610 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const;

2526 10 cross_into 0 4 3598 22 LVecBase3i::cross_into 0 1 611 10
/**
 *
 */
60
inline void LVecBase3i::cross_into(LVecBase3i const &other);

2527 12 almost_equal 0 4 3598 24 LVecBase3i::almost_equal 0 2 612 613 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const;
inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const;

2528 6 output 0 4 3598 18 LVecBase3i::output 0 1 614 10
/**
 *
 */
56
inline void LVecBase3i::output(std::ostream &out) const;

2529 8 __repr__ 0 4 3598 20 LVecBase3i::__repr__ 0 1 615 0
52
inline std::string LVecBase3i::__repr__(void) const;

2530 20 write_datagram_fixed 0 4 3598 32 LVecBase3i::write_datagram_fixed 0 1 616 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const;

2531 19 read_datagram_fixed 0 4 3598 31 LVecBase3i::read_datagram_fixed 0 1 617 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source);

2532 14 write_datagram 0 4 3598 26 LVecBase3i::write_datagram 0 1 618 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3i::write_datagram(Datagram &destination) const;

2533 13 read_datagram 0 4 3598 25 LVecBase3i::read_datagram 0 1 619 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3i::read_datagram(DatagramIterator &source);

2534 13 __getbuffer__ 0 4 3598 25 LVecBase3i::__getbuffer__ 0 1 620 0
87
inline int LVecBase3i::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2535 14 get_class_type 0 4 3598 26 LVecBase3i::get_class_type 0 1 621 0
51
static TypeHandle LVecBase3i::get_class_type(void);

2536 11 ~LVecBase3i 0 516 3598 23 LVecBase3i::~LVecBase3i 0 0 0
30
LVecBase3i::~LVecBase3i(void);

2537 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1898 0
53
CoordinateSystem get_default_coordinate_system(void);

2538 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1899 0
72
CoordinateSystem parse_coordinate_system_string(std::string const &str);

2539 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1900 0
58
std::string format_coordinate_system(CoordinateSystem cs);

2540 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1901 0
57
bool is_right_handed(CoordinateSystem cs = ::CS_default);

2541 9 LVector3f 0 260 3601 20 LVector3f::LVector3f 0 6 622 623 624 625 626 627 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
329
inline LVector3f::LVector3f(void) = default;
inline LVector3f::LVector3f(LVecBase3f const &copy);
inline LVector3f::LVector3f(float fill_value);
inline LVector3f::LVector3f(float x, float y, float z);
inline explicit LVector3f::LVector3f(LVecBase2f const &copy, float z);
inline LVector3f::LVector3f(LVector3f const &) = default;

2542 11 __getattr__ 0 4 3601 22 LVector3f::__getattr__ 0 1 628 0
92
inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2543 11 __setattr__ 0 4 3601 22 LVector3f::__setattr__ 0 1 629 0
98
inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2544 4 zero 0 4 3601 15 LVector3f::zero 0 1 630 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3f const &LVector3f::zero(void);

2545 6 unit_x 0 4 3601 17 LVector3f::unit_x 0 1 631 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3f const &LVector3f::unit_x(void);

2546 6 unit_y 0 4 3601 17 LVector3f::unit_y 0 1 632 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3f const &LVector3f::unit_y(void);

2547 6 unit_z 0 4 3601 17 LVector3f::unit_z 0 1 633 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3f const &LVector3f::unit_z(void);

2548 6 get_xy 0 4 3601 17 LVector3f::get_xy 0 1 634 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_xy(void) const;

2549 6 get_xz 0 4 3601 17 LVector3f::get_xz 0 1 635 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2f LVector3f::get_xz(void) const;

2550 6 get_yz 0 4 3601 17 LVector3f::get_yz 0 1 636 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_yz(void) const;

2551 10 operator - 0 68 3601 21 LVector3f::operator - 0 1 637 0
51
inline LVector3f LVector3f::operator -(void) const;

2552 10 operator + 0 4 3601 21 LVector3f::operator + 0 2 638 639 0
141
inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator +(LVector3f const &other) const;

2553 10 operator - 0 4 3601 21 LVector3f::operator - 0 2 640 641 0
141
inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator -(LVector3f const &other) const;

2554 5 cross 0 4 3601 16 LVector3f::cross 0 1 642 10
/**
 *
 */
65
inline LVector3f LVector3f::cross(LVecBase3f const &other) const;

2555 10 normalized 0 4 3601 21 LVector3f::normalized 0 1 643 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3f LVector3f::normalized(void) const;

2556 7 project 0 4 3601 18 LVector3f::project 0 1 644 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3f LVector3f::project(LVecBase3f const &onto) const;

2557 9 angle_rad 0 4 3601 20 LVector3f::angle_rad 0 1 645 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_rad(LVector3f const &other) const;

2558 9 angle_deg 0 4 3601 20 LVector3f::angle_deg 0 1 646 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_deg(LVector3f const &other) const;

2559 16 signed_angle_rad 0 4 3601 27 LVector3f::signed_angle_rad 0 1 647 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const;

2560 16 signed_angle_deg 0 4 3601 27 LVector3f::signed_angle_deg 0 1 648 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const;

2561 18 relative_angle_rad 0 4 3601 29 LVector3f::relative_angle_rad 0 1 649 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_rad(LVector3f const &other) const;

2562 18 relative_angle_deg 0 4 3601 29 LVector3f::relative_angle_deg 0 1 650 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_deg(LVector3f const &other) const;

2563 10 operator * 0 4 3601 21 LVector3f::operator * 0 1 651 0
59
inline LVector3f LVector3f::operator *(float scalar) const;

2564 10 operator / 0 4 3601 21 LVector3f::operator / 0 1 652 0
59
inline LVector3f LVector3f::operator /(float scalar) const;

2565 8 __rmul__ 0 4 3601 19 LVector3f::__rmul__ 0 1 653 0
57
inline LVector3f LVector3f::__rmul__(float scalar) const;

2566 2 up 0 4 3601 13 LVector3f::up 0 1 654 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);

2567 5 right 0 4 3601 16 LVector3f::right 0 1 655 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);

2568 7 forward 0 4 3601 18 LVector3f::forward 0 1 656 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);

2569 4 down 0 4 3601 15 LVector3f::down 0 1 657 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);

2570 4 left 0 4 3601 15 LVector3f::left 0 1 658 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);

2571 4 back 0 4 3601 15 LVector3f::back 0 1 659 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);

2572 3 rfu 0 4 3601 14 LVector3f::rfu 0 1 660 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
109
static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2573 8 __repr__ 0 4 3601 19 LVector3f::__repr__ 0 1 661 0
51
inline std::string LVector3f::__repr__(void) const;

2574 14 get_class_type 0 4 3601 25 LVector3f::get_class_type 0 1 662 0
50
static TypeHandle LVector3f::get_class_type(void);

2575 10 ~LVector3f 0 516 3601 21 LVector3f::~LVector3f 0 0 0
28
LVector3f::~LVector3f(void);

2576 9 LVector3d 0 260 3602 20 LVector3d::LVector3d 0 6 663 664 665 666 667 668 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
334
inline LVector3d::LVector3d(void) = default;
inline LVector3d::LVector3d(LVecBase3d const &copy);
inline LVector3d::LVector3d(double fill_value);
inline LVector3d::LVector3d(double x, double y, double z);
inline explicit LVector3d::LVector3d(LVecBase2d const &copy, double z);
inline LVector3d::LVector3d(LVector3d const &) = default;

2577 11 __getattr__ 0 4 3602 22 LVector3d::__getattr__ 0 1 669 0
92
inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2578 11 __setattr__ 0 4 3602 22 LVector3d::__setattr__ 0 1 670 0
98
inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2579 4 zero 0 4 3602 15 LVector3d::zero 0 1 671 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3d const &LVector3d::zero(void);

2580 6 unit_x 0 4 3602 17 LVector3d::unit_x 0 1 672 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3d const &LVector3d::unit_x(void);

2581 6 unit_y 0 4 3602 17 LVector3d::unit_y 0 1 673 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3d const &LVector3d::unit_y(void);

2582 6 unit_z 0 4 3602 17 LVector3d::unit_z 0 1 674 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3d const &LVector3d::unit_z(void);

2583 6 get_xy 0 4 3602 17 LVector3d::get_xy 0 1 675 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_xy(void) const;

2584 6 get_xz 0 4 3602 17 LVector3d::get_xz 0 1 676 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2d LVector3d::get_xz(void) const;

2585 6 get_yz 0 4 3602 17 LVector3d::get_yz 0 1 677 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_yz(void) const;

2586 10 operator - 0 68 3602 21 LVector3d::operator - 0 1 678 0
51
inline LVector3d LVector3d::operator -(void) const;

2587 10 operator + 0 4 3602 21 LVector3d::operator + 0 2 679 680 0
141
inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator +(LVector3d const &other) const;

2588 10 operator - 0 4 3602 21 LVector3d::operator - 0 2 681 682 0
141
inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator -(LVector3d const &other) const;

2589 5 cross 0 4 3602 16 LVector3d::cross 0 1 683 10
/**
 *
 */
65
inline LVector3d LVector3d::cross(LVecBase3d const &other) const;

2590 10 normalized 0 4 3602 21 LVector3d::normalized 0 1 684 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3d LVector3d::normalized(void) const;

2591 7 project 0 4 3602 18 LVector3d::project 0 1 685 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3d LVector3d::project(LVecBase3d const &onto) const;

2592 9 angle_rad 0 4 3602 20 LVector3d::angle_rad 0 1 686 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_rad(LVector3d const &other) const;

2593 9 angle_deg 0 4 3602 20 LVector3d::angle_deg 0 1 687 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_deg(LVector3d const &other) const;

2594 16 signed_angle_rad 0 4 3602 27 LVector3d::signed_angle_rad 0 1 688 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const;

2595 16 signed_angle_deg 0 4 3602 27 LVector3d::signed_angle_deg 0 1 689 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const;

2596 18 relative_angle_rad 0 4 3602 29 LVector3d::relative_angle_rad 0 1 690 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_rad(LVector3d const &other) const;

2597 18 relative_angle_deg 0 4 3602 29 LVector3d::relative_angle_deg 0 1 691 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_deg(LVector3d const &other) const;

2598 10 operator * 0 4 3602 21 LVector3d::operator * 0 1 692 0
60
inline LVector3d LVector3d::operator *(double scalar) const;

2599 10 operator / 0 4 3602 21 LVector3d::operator / 0 1 693 0
60
inline LVector3d LVector3d::operator /(double scalar) const;

2600 8 __rmul__ 0 4 3602 19 LVector3d::__rmul__ 0 1 694 0
58
inline LVector3d LVector3d::__rmul__(double scalar) const;

2601 2 up 0 4 3602 13 LVector3d::up 0 1 695 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);

2602 5 right 0 4 3602 16 LVector3d::right 0 1 696 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);

2603 7 forward 0 4 3602 18 LVector3d::forward 0 1 697 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);

2604 4 down 0 4 3602 15 LVector3d::down 0 1 698 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);

2605 4 left 0 4 3602 15 LVector3d::left 0 1 699 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);

2606 4 back 0 4 3602 15 LVector3d::back 0 1 700 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);

2607 3 rfu 0 4 3602 14 LVector3d::rfu 0 1 701 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
112
static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2608 8 __repr__ 0 4 3602 19 LVector3d::__repr__ 0 1 702 0
51
inline std::string LVector3d::__repr__(void) const;

2609 14 get_class_type 0 4 3602 25 LVector3d::get_class_type 0 1 703 0
50
static TypeHandle LVector3d::get_class_type(void);

2610 10 ~LVector3d 0 516 3602 21 LVector3d::~LVector3d 0 0 0
28
LVector3d::~LVector3d(void);

2611 9 LVector3i 0 260 3603 20 LVector3i::LVector3i 0 6 704 705 706 707 708 709 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
319
inline LVector3i::LVector3i(void) = default;
inline LVector3i::LVector3i(LVecBase3i const &copy);
inline LVector3i::LVector3i(int fill_value);
inline LVector3i::LVector3i(int x, int y, int z);
inline explicit LVector3i::LVector3i(LVecBase2i const &copy, int z);
inline LVector3i::LVector3i(LVector3i const &) = default;

2612 11 __getattr__ 0 4 3603 22 LVector3i::__getattr__ 0 1 710 0
92
inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2613 11 __setattr__ 0 4 3603 22 LVector3i::__setattr__ 0 1 711 0
98
inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2614 4 zero 0 4 3603 15 LVector3i::zero 0 1 712 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3i const &LVector3i::zero(void);

2615 6 unit_x 0 4 3603 17 LVector3i::unit_x 0 1 713 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3i const &LVector3i::unit_x(void);

2616 6 unit_y 0 4 3603 17 LVector3i::unit_y 0 1 714 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3i const &LVector3i::unit_y(void);

2617 6 unit_z 0 4 3603 17 LVector3i::unit_z 0 1 715 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3i const &LVector3i::unit_z(void);

2618 6 get_xy 0 4 3603 17 LVector3i::get_xy 0 1 716 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_xy(void) const;

2619 6 get_xz 0 4 3603 17 LVector3i::get_xz 0 1 717 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2i LVector3i::get_xz(void) const;

2620 6 get_yz 0 4 3603 17 LVector3i::get_yz 0 1 718 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_yz(void) const;

2621 10 operator - 0 68 3603 21 LVector3i::operator - 0 1 719 0
51
inline LVector3i LVector3i::operator -(void) const;

2622 10 operator + 0 4 3603 21 LVector3i::operator + 0 2 720 721 0
141
inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator +(LVector3i const &other) const;

2623 10 operator - 0 4 3603 21 LVector3i::operator - 0 2 722 723 0
141
inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator -(LVector3i const &other) const;

2624 5 cross 0 4 3603 16 LVector3i::cross 0 1 724 10
/**
 *
 */
65
inline LVector3i LVector3i::cross(LVecBase3i const &other) const;

2625 10 operator * 0 4 3603 21 LVector3i::operator * 0 1 725 0
57
inline LVector3i LVector3i::operator *(int scalar) const;

2626 10 operator / 0 4 3603 21 LVector3i::operator / 0 1 726 0
57
inline LVector3i LVector3i::operator /(int scalar) const;

2627 8 __rmul__ 0 4 3603 19 LVector3i::__rmul__ 0 1 727 0
55
inline LVector3i LVector3i::__rmul__(int scalar) const;

2628 2 up 0 4 3603 13 LVector3i::up 0 1 728 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);

2629 5 right 0 4 3603 16 LVector3i::right 0 1 729 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);

2630 7 forward 0 4 3603 18 LVector3i::forward 0 1 730 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);

2631 4 down 0 4 3603 15 LVector3i::down 0 1 731 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);

2632 4 left 0 4 3603 15 LVector3i::left 0 1 732 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);

2633 4 back 0 4 3603 15 LVector3i::back 0 1 733 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);

2634 3 rfu 0 4 3603 14 LVector3i::rfu 0 1 734 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
103
static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2635 8 __repr__ 0 4 3603 19 LVector3i::__repr__ 0 1 735 0
51
inline std::string LVector3i::__repr__(void) const;

2636 14 get_class_type 0 4 3603 25 LVector3i::get_class_type 0 1 736 0
50
static TypeHandle LVector3i::get_class_type(void);

2637 10 ~LVector3i 0 516 3603 21 LVector3i::~LVector3i 0 0 0
28
LVector3i::~LVector3i(void);

2638 8 LPoint3f 0 260 3604 18 LPoint3f::LPoint3f 0 6 737 738 739 740 741 742 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
316
inline LPoint3f::LPoint3f(void) = default;
inline LPoint3f::LPoint3f(LVecBase3f const &copy);
inline LPoint3f::LPoint3f(float fill_value);
inline LPoint3f::LPoint3f(float x, float y, float z);
inline explicit LPoint3f::LPoint3f(LVecBase2f const &copy, float z);
inline LPoint3f::LPoint3f(LPoint3f const &) = default;

2639 11 __getattr__ 0 4 3604 21 LPoint3f::__getattr__ 0 1 743 0
91
inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2640 11 __setattr__ 0 4 3604 21 LPoint3f::__setattr__ 0 1 744 0
97
inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2641 4 zero 0 4 3604 14 LPoint3f::zero 0 1 745 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3f const &LPoint3f::zero(void);

2642 6 unit_x 0 4 3604 16 LPoint3f::unit_x 0 1 746 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3f const &LPoint3f::unit_x(void);

2643 6 unit_y 0 4 3604 16 LPoint3f::unit_y 0 1 747 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3f const &LPoint3f::unit_y(void);

2644 6 unit_z 0 4 3604 16 LPoint3f::unit_z 0 1 748 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3f const &LPoint3f::unit_z(void);

2645 6 get_xy 0 4 3604 16 LPoint3f::get_xy 0 1 749 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_xy(void) const;

2646 6 get_xz 0 4 3604 16 LPoint3f::get_xz 0 1 750 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2f LPoint3f::get_xz(void) const;

2647 6 get_yz 0 4 3604 16 LPoint3f::get_yz 0 1 751 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_yz(void) const;

2648 10 operator - 0 68 3604 20 LPoint3f::operator - 0 1 752 0
49
inline LPoint3f LPoint3f::operator -(void) const;

2649 10 operator + 0 4 3604 20 LPoint3f::operator + 0 2 753 754 0
138
inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const;
inline LPoint3f LPoint3f::operator +(LVector3f const &other) const;

2650 10 operator - 0 4 3604 20 LPoint3f::operator - 0 3 755 756 757 0
206
inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const;
inline LVector3f LPoint3f::operator -(LPoint3f const &other) const;
inline LPoint3f LPoint3f::operator -(LVector3f const &other) const;

2651 5 cross 0 4 3604 15 LPoint3f::cross 0 1 758 10
/**
 *
 */
63
inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const;

2652 10 normalized 0 4 3604 20 LPoint3f::normalized 0 1 759 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3f LPoint3f::normalized(void) const;

2653 7 project 0 4 3604 17 LPoint3f::project 0 1 760 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const;

2654 10 operator * 0 4 3604 20 LPoint3f::operator * 0 1 761 0
57
inline LPoint3f LPoint3f::operator *(float scalar) const;

2655 10 operator / 0 4 3604 20 LPoint3f::operator / 0 1 762 0
57
inline LPoint3f LPoint3f::operator /(float scalar) const;

2656 8 __rmul__ 0 4 3604 18 LPoint3f::__rmul__ 0 1 763 0
55
inline LPoint3f LPoint3f::__rmul__(float scalar) const;

2657 6 origin 0 4 3604 16 LPoint3f::origin 0 1 764 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default);

2658 3 rfu 0 4 3604 13 LPoint3f::rfu 0 1 765 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
107
static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2659 8 __repr__ 0 4 3604 18 LPoint3f::__repr__ 0 1 766 0
50
inline std::string LPoint3f::__repr__(void) const;

2660 14 get_class_type 0 4 3604 24 LPoint3f::get_class_type 0 1 767 0
49
static TypeHandle LPoint3f::get_class_type(void);

2661 9 ~LPoint3f 0 516 3604 19 LPoint3f::~LPoint3f 0 0 0
26
LPoint3f::~LPoint3f(void);

2662 8 LPoint3d 0 260 3605 18 LPoint3d::LPoint3d 0 6 768 769 770 771 772 773 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
321
inline LPoint3d::LPoint3d(void) = default;
inline LPoint3d::LPoint3d(LVecBase3d const &copy);
inline LPoint3d::LPoint3d(double fill_value);
inline LPoint3d::LPoint3d(double x, double y, double z);
inline explicit LPoint3d::LPoint3d(LVecBase2d const &copy, double z);
inline LPoint3d::LPoint3d(LPoint3d const &) = default;

2663 11 __getattr__ 0 4 3605 21 LPoint3d::__getattr__ 0 1 774 0
91
inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2664 11 __setattr__ 0 4 3605 21 LPoint3d::__setattr__ 0 1 775 0
97
inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2665 4 zero 0 4 3605 14 LPoint3d::zero 0 1 776 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3d const &LPoint3d::zero(void);

2666 6 unit_x 0 4 3605 16 LPoint3d::unit_x 0 1 777 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3d const &LPoint3d::unit_x(void);

2667 6 unit_y 0 4 3605 16 LPoint3d::unit_y 0 1 778 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3d const &LPoint3d::unit_y(void);

2668 6 unit_z 0 4 3605 16 LPoint3d::unit_z 0 1 779 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3d const &LPoint3d::unit_z(void);

2669 6 get_xy 0 4 3605 16 LPoint3d::get_xy 0 1 780 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_xy(void) const;

2670 6 get_xz 0 4 3605 16 LPoint3d::get_xz 0 1 781 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2d LPoint3d::get_xz(void) const;

2671 6 get_yz 0 4 3605 16 LPoint3d::get_yz 0 1 782 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_yz(void) const;

2672 10 operator - 0 68 3605 20 LPoint3d::operator - 0 1 783 0
49
inline LPoint3d LPoint3d::operator -(void) const;

2673 10 operator + 0 4 3605 20 LPoint3d::operator + 0 2 784 785 0
138
inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const;
inline LPoint3d LPoint3d::operator +(LVector3d const &other) const;

2674 10 operator - 0 4 3605 20 LPoint3d::operator - 0 3 786 787 788 0
206
inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const;
inline LVector3d LPoint3d::operator -(LPoint3d const &other) const;
inline LPoint3d LPoint3d::operator -(LVector3d const &other) const;

2675 5 cross 0 4 3605 15 LPoint3d::cross 0 1 789 10
/**
 *
 */
63
inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const;

2676 10 normalized 0 4 3605 20 LPoint3d::normalized 0 1 790 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3d LPoint3d::normalized(void) const;

2677 7 project 0 4 3605 17 LPoint3d::project 0 1 791 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const;

2678 10 operator * 0 4 3605 20 LPoint3d::operator * 0 1 792 0
58
inline LPoint3d LPoint3d::operator *(double scalar) const;

2679 10 operator / 0 4 3605 20 LPoint3d::operator / 0 1 793 0
58
inline LPoint3d LPoint3d::operator /(double scalar) const;

2680 8 __rmul__ 0 4 3605 18 LPoint3d::__rmul__ 0 1 794 0
56
inline LPoint3d LPoint3d::__rmul__(double scalar) const;

2681 6 origin 0 4 3605 16 LPoint3d::origin 0 1 795 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default);

2682 3 rfu 0 4 3605 13 LPoint3d::rfu 0 1 796 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
110
static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2683 8 __repr__ 0 4 3605 18 LPoint3d::__repr__ 0 1 797 0
50
inline std::string LPoint3d::__repr__(void) const;

2684 14 get_class_type 0 4 3605 24 LPoint3d::get_class_type 0 1 798 0
49
static TypeHandle LPoint3d::get_class_type(void);

2685 9 ~LPoint3d 0 516 3605 19 LPoint3d::~LPoint3d 0 0 0
26
LPoint3d::~LPoint3d(void);

2686 8 LPoint3i 0 260 3606 18 LPoint3i::LPoint3i 0 6 799 800 801 802 803 804 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
306
inline LPoint3i::LPoint3i(void) = default;
inline LPoint3i::LPoint3i(LVecBase3i const &copy);
inline LPoint3i::LPoint3i(int fill_value);
inline LPoint3i::LPoint3i(int x, int y, int z);
inline explicit LPoint3i::LPoint3i(LVecBase2i const &copy, int z);
inline LPoint3i::LPoint3i(LPoint3i const &) = default;

2687 11 __getattr__ 0 4 3606 21 LPoint3i::__getattr__ 0 1 805 0
91
inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2688 11 __setattr__ 0 4 3606 21 LPoint3i::__setattr__ 0 1 806 0
97
inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2689 4 zero 0 4 3606 14 LPoint3i::zero 0 1 807 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3i const &LPoint3i::zero(void);

2690 6 unit_x 0 4 3606 16 LPoint3i::unit_x 0 1 808 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3i const &LPoint3i::unit_x(void);

2691 6 unit_y 0 4 3606 16 LPoint3i::unit_y 0 1 809 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3i const &LPoint3i::unit_y(void);

2692 6 unit_z 0 4 3606 16 LPoint3i::unit_z 0 1 810 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3i const &LPoint3i::unit_z(void);

2693 6 get_xy 0 4 3606 16 LPoint3i::get_xy 0 1 811 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_xy(void) const;

2694 6 get_xz 0 4 3606 16 LPoint3i::get_xz 0 1 812 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2i LPoint3i::get_xz(void) const;

2695 6 get_yz 0 4 3606 16 LPoint3i::get_yz 0 1 813 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_yz(void) const;

2696 10 operator - 0 68 3606 20 LPoint3i::operator - 0 1 814 0
49
inline LPoint3i LPoint3i::operator -(void) const;

2697 10 operator + 0 4 3606 20 LPoint3i::operator + 0 2 815 816 0
138
inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const;
inline LPoint3i LPoint3i::operator +(LVector3i const &other) const;

2698 10 operator - 0 4 3606 20 LPoint3i::operator - 0 3 817 818 819 0
206
inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const;
inline LVector3i LPoint3i::operator -(LPoint3i const &other) const;
inline LPoint3i LPoint3i::operator -(LVector3i const &other) const;

2699 5 cross 0 4 3606 15 LPoint3i::cross 0 1 820 10
/**
 *
 */
63
inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const;

2700 10 operator * 0 4 3606 20 LPoint3i::operator * 0 1 821 0
55
inline LPoint3i LPoint3i::operator *(int scalar) const;

2701 10 operator / 0 4 3606 20 LPoint3i::operator / 0 1 822 0
55
inline LPoint3i LPoint3i::operator /(int scalar) const;

2702 8 __rmul__ 0 4 3606 18 LPoint3i::__rmul__ 0 1 823 0
53
inline LPoint3i LPoint3i::__rmul__(int scalar) const;

2703 6 origin 0 4 3606 16 LPoint3i::origin 0 1 824 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default);

2704 3 rfu 0 4 3606 13 LPoint3i::rfu 0 1 825 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
101
static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2705 8 __repr__ 0 4 3606 18 LPoint3i::__repr__ 0 1 826 0
50
inline std::string LPoint3i::__repr__(void) const;

2706 14 get_class_type 0 4 3606 24 LPoint3i::get_class_type 0 1 827 0
49
static TypeHandle LPoint3i::get_class_type(void);

2707 9 ~LPoint3i 0 516 3606 19 LPoint3i::~LPoint3i 0 0 0
26
LPoint3i::~LPoint3i(void);

2708 10 LVecBase4f 0 260 3607 22 LVecBase4f::LVecBase4f 0 7 828 829 830 831 832 833 834 207
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
406
inline LVecBase4f::LVecBase4f(void) = default;
inline LVecBase4f::LVecBase4f(float fill_value);
inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);
inline explicit LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w);
inline LVecBase4f::LVecBase4f(LPoint3f const &point);
inline LVecBase4f::LVecBase4f(LVector3f const &vector);
inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default;

2709 12 operator new 0 4 3607 24 LVecBase4f::operator new 0 1 835 0
124
inline void *LVecBase4f::operator new(std::size_t size);
inline void *LVecBase4f::operator new(std::size_t size, void *ptr);

2710 15 operator delete 0 4 3607 27 LVecBase4f::operator delete 0 0 0
108
inline void LVecBase4f::operator delete(void *ptr);
inline void LVecBase4f::operator delete(void *, void *);

2711 12 validate_ptr 0 4 3607 24 LVecBase4f::validate_ptr 0 0 0
61
static inline bool LVecBase4f::validate_ptr(void const *ptr);

2712 10 operator = 0 4 3607 22 LVecBase4f::operator = 0 2 836 837 0
119
void LVecBase4f::operator =(LVecBase4f const &copy) = default;
void LVecBase4f::operator =(float fill_value) = default;

2713 4 zero 0 4 3607 16 LVecBase4f::zero 0 1 838 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4f const &LVecBase4f::zero(void);

2714 6 unit_x 0 4 3607 18 LVecBase4f::unit_x 0 1 839 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_x(void);

2715 6 unit_y 0 4 3607 18 LVecBase4f::unit_y 0 1 840 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_y(void);

2716 6 unit_z 0 4 3607 18 LVecBase4f::unit_z 0 1 841 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_z(void);

2717 6 unit_w 0 4 3607 18 LVecBase4f::unit_w 0 1 842 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_w(void);

2718 10 __reduce__ 0 4 3607 22 LVecBase4f::__reduce__ 0 1 843 0
62
inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;

2719 11 __getattr__ 0 4 3607 23 LVecBase4f::__getattr__ 0 1 844 0
93
inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2720 11 __setattr__ 0 4 3607 23 LVecBase4f::__setattr__ 0 1 845 0
99
inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2721 11 operator [] 0 4 3607 23 LVecBase4f::operator [] 0 2 846 847 10
/**
 *
 */
96
inline float LVecBase4f::operator [](int i) const;
inline float &LVecBase4f::operator [](int i);

2722 12 operator []= 0 1028 3607 24 LVecBase4f::operator []= 0 1 848 0
62
void LVecBase4f::operator []=(int i, float const &assign_val);

2723 4 size 0 4 3607 16 LVecBase4f::size 0 1 849 0
44
static constexpr int LVecBase4f::size(void);

2724 6 is_nan 0 4 3607 18 LVecBase4f::is_nan 0 1 850 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4f::is_nan(void) const;

2725 8 get_cell 0 4 3607 20 LVecBase4f::get_cell 0 1 851 10
/**
 *
 */
47
inline float LVecBase4f::get_cell(int i) const;

2726 8 set_cell 0 4 3607 20 LVecBase4f::set_cell 0 1 852 10
/**
 *
 */
53
inline void LVecBase4f::set_cell(int i, float value);

2727 5 get_x 0 4 3607 17 LVecBase4f::get_x 0 1 853 10
/**
 *
 */
43
inline float LVecBase4f::get_x(void) const;

2728 5 get_y 0 4 3607 17 LVecBase4f::get_y 0 1 854 10
/**
 *
 */
43
inline float LVecBase4f::get_y(void) const;

2729 5 get_z 0 4 3607 17 LVecBase4f::get_z 0 1 855 10
/**
 *
 */
43
inline float LVecBase4f::get_z(void) const;

2730 5 get_w 0 4 3607 17 LVecBase4f::get_w 0 1 856 10
/**
 *
 */
43
inline float LVecBase4f::get_w(void) const;

2731 7 get_xyz 0 4 3607 19 LVecBase4f::get_xyz 0 1 857 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3f LVecBase4f::get_xyz(void) const;

2732 6 get_xy 0 4 3607 18 LVecBase4f::get_xy 0 1 858 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2f LVecBase4f::get_xy(void) const;

2733 5 set_x 0 4 3607 17 LVecBase4f::set_x 0 1 859 10
/**
 *
 */
43
inline void LVecBase4f::set_x(float value);

2734 5 set_y 0 4 3607 17 LVecBase4f::set_y 0 1 860 10
/**
 *
 */
43
inline void LVecBase4f::set_y(float value);

2735 5 set_z 0 4 3607 17 LVecBase4f::set_z 0 1 861 10
/**
 *
 */
43
inline void LVecBase4f::set_z(float value);

2736 5 set_w 0 4 3607 17 LVecBase4f::set_w 0 1 862 10
/**
 *
 */
43
inline void LVecBase4f::set_w(float value);

2737 11 add_to_cell 0 4 3607 23 LVecBase4f::add_to_cell 0 1 863 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase4f::add_to_cell(int i, float value);

2738 5 add_x 0 4 3607 17 LVecBase4f::add_x 0 1 864 10
/**
 *
 */
43
inline void LVecBase4f::add_x(float value);

2739 5 add_y 0 4 3607 17 LVecBase4f::add_y 0 1 865 10
/**
 *
 */
43
inline void LVecBase4f::add_y(float value);

2740 5 add_z 0 4 3607 17 LVecBase4f::add_z 0 1 866 10
/**
 *
 */
43
inline void LVecBase4f::add_z(float value);

2741 5 add_w 0 4 3607 17 LVecBase4f::add_w 0 1 867 10
/**
 *
 */
43
inline void LVecBase4f::add_w(float value);

2742 8 get_data 0 4 3607 20 LVecBase4f::get_data 0 1 868 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase4f::get_data(void) const;

2743 18 get_num_components 0 4 3607 30 LVecBase4f::get_num_components 0 1 869 0
58
static constexpr int LVecBase4f::get_num_components(void);

2744 12 extract_data 0 4 3607 24 LVecBase4f::extract_data 0 0 0
46
inline void LVecBase4f::extract_data(float *);

2745 4 fill 0 4 3607 16 LVecBase4f::fill 0 1 870 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase4f::fill(float fill_value);

2746 3 set 0 4 3607 15 LVecBase4f::set 0 1 871 10
/**
 *
 */
64
inline void LVecBase4f::set(float x, float y, float z, float w);

2747 3 dot 0 4 3607 15 LVecBase4f::dot 0 1 872 10
/**
 *
 */
60
inline float LVecBase4f::dot(LVecBase4f const &other) const;

2748 14 length_squared 0 4 3607 26 LVecBase4f::length_squared 0 1 873 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase4f::length_squared(void) const;

2749 6 length 0 4 3607 18 LVecBase4f::length 0 1 874 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase4f::length(void) const;

2750 9 normalize 0 4 3607 21 LVecBase4f::normalize 0 1 875 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4f::normalize(void);

2751 10 normalized 0 4 3607 22 LVecBase4f::normalized 0 1 876 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4f LVecBase4f::normalized(void) const;

2752 7 project 0 4 3607 19 LVecBase4f::project 0 1 877 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const;

2753 10 operator < 0 4 3607 22 LVecBase4f::operator < 0 1 878 0
66
inline bool LVecBase4f::operator <(LVecBase4f const &other) const;

2754 11 operator == 0 4 3607 23 LVecBase4f::operator == 0 1 879 0
67
inline bool LVecBase4f::operator ==(LVecBase4f const &other) const;

2755 11 operator != 0 4 3607 23 LVecBase4f::operator != 0 1 880 0
67
inline bool LVecBase4f::operator !=(LVecBase4f const &other) const;

2756 10 compare_to 0 4 3607 22 LVecBase4f::compare_to 0 2 881 882 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase4f::compare_to(LVecBase4f const &other) const;
inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const;

2757 8 get_hash 0 4 3607 20 LVecBase4f::get_hash 0 2 883 884 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase4f::get_hash(void) const;
inline std::size_t LVecBase4f::get_hash(float threshold) const;

2758 8 add_hash 0 4 3607 20 LVecBase4f::add_hash 0 2 885 886 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;

2759 13 generate_hash 0 4 3607 25 LVecBase4f::generate_hash 0 2 887 888 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2760 10 operator - 0 68 3607 22 LVecBase4f::operator - 0 1 889 0
53
inline LVecBase4f LVecBase4f::operator -(void) const;

2761 10 operator + 0 4 3607 22 LVecBase4f::operator + 0 1 890 0
72
inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const;

2762 10 operator - 0 4 3607 22 LVecBase4f::operator - 0 1 891 0
72
inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const;

2763 10 operator * 0 4 3607 22 LVecBase4f::operator * 0 1 892 0
61
inline LVecBase4f LVecBase4f::operator *(float scalar) const;

2764 10 operator / 0 4 3607 22 LVecBase4f::operator / 0 1 893 0
61
inline LVecBase4f LVecBase4f::operator /(float scalar) const;

2765 11 operator += 0 4 3607 23 LVecBase4f::operator += 0 1 894 0
61
inline void LVecBase4f::operator +=(LVecBase4f const &other);

2766 11 operator -= 0 4 3607 23 LVecBase4f::operator -= 0 1 895 0
61
inline void LVecBase4f::operator -=(LVecBase4f const &other);

2767 11 operator *= 0 4 3607 23 LVecBase4f::operator *= 0 1 896 0
50
inline void LVecBase4f::operator *=(float scalar);

2768 11 operator /= 0 4 3607 23 LVecBase4f::operator /= 0 1 897 0
50
inline void LVecBase4f::operator /=(float scalar);

2769 18 componentwise_mult 0 4 3607 30 LVecBase4f::componentwise_mult 0 1 898 10
/**
 *
 */
68
inline void LVecBase4f::componentwise_mult(LVecBase4f const &other);

2770 8 __rmul__ 0 4 3607 20 LVecBase4f::__rmul__ 0 1 899 0
74
inline PyObject *LVecBase4f::__rmul__(PyObject *self, float scalar) const;

2771 12 __floordiv__ 0 4 3607 24 LVecBase4f::__floordiv__ 0 1 900 0
78
inline PyObject *LVecBase4f::__floordiv__(PyObject *self, float scalar) const;

2772 13 __ifloordiv__ 0 4 3607 25 LVecBase4f::__ifloordiv__ 0 1 901 0
73
inline PyObject *LVecBase4f::__ifloordiv__(PyObject *self, float scalar);

2773 7 __pow__ 0 4 3607 19 LVecBase4f::__pow__ 0 1 902 0
75
inline PyObject *LVecBase4f::__pow__(PyObject *self, float exponent) const;

2774 8 __ipow__ 0 4 3607 20 LVecBase4f::__ipow__ 0 1 903 0
70
inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);

2775 9 __round__ 0 4 3607 21 LVecBase4f::__round__ 0 1 904 0
55
inline PyObject *LVecBase4f::__round__(PyObject *self);

2776 9 __floor__ 0 4 3607 21 LVecBase4f::__floor__ 0 1 905 0
55
inline PyObject *LVecBase4f::__floor__(PyObject *self);

2777 8 __ceil__ 0 4 3607 20 LVecBase4f::__ceil__ 0 1 906 0
54
inline PyObject *LVecBase4f::__ceil__(PyObject *self);

2778 4 fmax 0 4 3607 16 LVecBase4f::fmax 0 1 907 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const;

2779 4 fmin 0 4 3607 16 LVecBase4f::fmin 0 1 908 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const;

2780 12 almost_equal 0 4 3607 24 LVecBase4f::almost_equal 0 2 909 910 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const;
inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const;

2781 6 output 0 4 3607 18 LVecBase4f::output 0 1 911 10
/**
 *
 */
56
inline void LVecBase4f::output(std::ostream &out) const;

2782 8 __repr__ 0 4 3607 20 LVecBase4f::__repr__ 0 1 912 0
52
inline std::string LVecBase4f::__repr__(void) const;

2783 20 write_datagram_fixed 0 4 3607 32 LVecBase4f::write_datagram_fixed 0 1 913 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const;

2784 19 read_datagram_fixed 0 4 3607 31 LVecBase4f::read_datagram_fixed 0 1 914 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source);

2785 14 write_datagram 0 4 3607 26 LVecBase4f::write_datagram 0 1 915 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4f::write_datagram(Datagram &destination) const;

2786 13 read_datagram 0 4 3607 25 LVecBase4f::read_datagram 0 1 916 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4f::read_datagram(DatagramIterator &source);

2787 13 __getbuffer__ 0 4 3607 25 LVecBase4f::__getbuffer__ 0 1 917 0
87
inline int LVecBase4f::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2788 14 get_class_type 0 4 3607 26 LVecBase4f::get_class_type 0 1 918 0
51
static TypeHandle LVecBase4f::get_class_type(void);

2789 11 ~LVecBase4f 0 516 3607 23 LVecBase4f::~LVecBase4f 0 0 0
30
LVecBase4f::~LVecBase4f(void);

2790 10 LVecBase4d 0 260 3610 22 LVecBase4d::LVecBase4d 0 7 919 920 921 922 923 924 925 207
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
412
inline LVecBase4d::LVecBase4d(void) = default;
inline LVecBase4d::LVecBase4d(double fill_value);
inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);
inline explicit LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w);
inline LVecBase4d::LVecBase4d(LPoint3d const &point);
inline LVecBase4d::LVecBase4d(LVector3d const &vector);
inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default;

2791 12 operator new 0 4 3610 24 LVecBase4d::operator new 0 1 926 0
124
inline void *LVecBase4d::operator new(std::size_t size);
inline void *LVecBase4d::operator new(std::size_t size, void *ptr);

2792 15 operator delete 0 4 3610 27 LVecBase4d::operator delete 0 0 0
108
inline void LVecBase4d::operator delete(void *ptr);
inline void LVecBase4d::operator delete(void *, void *);

2793 12 validate_ptr 0 4 3610 24 LVecBase4d::validate_ptr 0 0 0
61
static inline bool LVecBase4d::validate_ptr(void const *ptr);

2794 10 operator = 0 4 3610 22 LVecBase4d::operator = 0 2 927 928 0
120
void LVecBase4d::operator =(LVecBase4d const &copy) = default;
void LVecBase4d::operator =(double fill_value) = default;

2795 4 zero 0 4 3610 16 LVecBase4d::zero 0 1 929 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4d const &LVecBase4d::zero(void);

2796 6 unit_x 0 4 3610 18 LVecBase4d::unit_x 0 1 930 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_x(void);

2797 6 unit_y 0 4 3610 18 LVecBase4d::unit_y 0 1 931 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_y(void);

2798 6 unit_z 0 4 3610 18 LVecBase4d::unit_z 0 1 932 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_z(void);

2799 6 unit_w 0 4 3610 18 LVecBase4d::unit_w 0 1 933 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_w(void);

2800 10 __reduce__ 0 4 3610 22 LVecBase4d::__reduce__ 0 1 934 0
62
inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;

2801 11 __getattr__ 0 4 3610 23 LVecBase4d::__getattr__ 0 1 935 0
93
inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2802 11 __setattr__ 0 4 3610 23 LVecBase4d::__setattr__ 0 1 936 0
99
inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2803 11 operator [] 0 4 3610 23 LVecBase4d::operator [] 0 2 937 938 10
/**
 *
 */
98
inline double LVecBase4d::operator [](int i) const;
inline double &LVecBase4d::operator [](int i);

2804 12 operator []= 0 1028 3610 24 LVecBase4d::operator []= 0 1 939 0
63
void LVecBase4d::operator []=(int i, double const &assign_val);

2805 4 size 0 4 3610 16 LVecBase4d::size 0 1 940 0
44
static constexpr int LVecBase4d::size(void);

2806 6 is_nan 0 4 3610 18 LVecBase4d::is_nan 0 1 941 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4d::is_nan(void) const;

2807 8 get_cell 0 4 3610 20 LVecBase4d::get_cell 0 1 942 10
/**
 *
 */
48
inline double LVecBase4d::get_cell(int i) const;

2808 8 set_cell 0 4 3610 20 LVecBase4d::set_cell 0 1 943 10
/**
 *
 */
54
inline void LVecBase4d::set_cell(int i, double value);

2809 5 get_x 0 4 3610 17 LVecBase4d::get_x 0 1 944 10
/**
 *
 */
44
inline double LVecBase4d::get_x(void) const;

2810 5 get_y 0 4 3610 17 LVecBase4d::get_y 0 1 945 10
/**
 *
 */
44
inline double LVecBase4d::get_y(void) const;

2811 5 get_z 0 4 3610 17 LVecBase4d::get_z 0 1 946 10
/**
 *
 */
44
inline double LVecBase4d::get_z(void) const;

2812 5 get_w 0 4 3610 17 LVecBase4d::get_w 0 1 947 10
/**
 *
 */
44
inline double LVecBase4d::get_w(void) const;

2813 7 get_xyz 0 4 3610 19 LVecBase4d::get_xyz 0 1 948 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3d LVecBase4d::get_xyz(void) const;

2814 6 get_xy 0 4 3610 18 LVecBase4d::get_xy 0 1 949 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2d LVecBase4d::get_xy(void) const;

2815 5 set_x 0 4 3610 17 LVecBase4d::set_x 0 1 950 10
/**
 *
 */
44
inline void LVecBase4d::set_x(double value);

2816 5 set_y 0 4 3610 17 LVecBase4d::set_y 0 1 951 10
/**
 *
 */
44
inline void LVecBase4d::set_y(double value);

2817 5 set_z 0 4 3610 17 LVecBase4d::set_z 0 1 952 10
/**
 *
 */
44
inline void LVecBase4d::set_z(double value);

2818 5 set_w 0 4 3610 17 LVecBase4d::set_w 0 1 953 10
/**
 *
 */
44
inline void LVecBase4d::set_w(double value);

2819 11 add_to_cell 0 4 3610 23 LVecBase4d::add_to_cell 0 1 954 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase4d::add_to_cell(int i, double value);

2820 5 add_x 0 4 3610 17 LVecBase4d::add_x 0 1 955 10
/**
 *
 */
44
inline void LVecBase4d::add_x(double value);

2821 5 add_y 0 4 3610 17 LVecBase4d::add_y 0 1 956 10
/**
 *
 */
44
inline void LVecBase4d::add_y(double value);

2822 5 add_z 0 4 3610 17 LVecBase4d::add_z 0 1 957 10
/**
 *
 */
44
inline void LVecBase4d::add_z(double value);

2823 5 add_w 0 4 3610 17 LVecBase4d::add_w 0 1 958 10
/**
 *
 */
44
inline void LVecBase4d::add_w(double value);

2824 8 get_data 0 4 3610 20 LVecBase4d::get_data 0 1 959 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase4d::get_data(void) const;

2825 18 get_num_components 0 4 3610 30 LVecBase4d::get_num_components 0 1 960 0
58
static constexpr int LVecBase4d::get_num_components(void);

2826 12 extract_data 0 4 3610 24 LVecBase4d::extract_data 0 0 0
46
inline void LVecBase4d::extract_data(float *);

2827 4 fill 0 4 3610 16 LVecBase4d::fill 0 1 961 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase4d::fill(double fill_value);

2828 3 set 0 4 3610 15 LVecBase4d::set 0 1 962 10
/**
 *
 */
68
inline void LVecBase4d::set(double x, double y, double z, double w);

2829 3 dot 0 4 3610 15 LVecBase4d::dot 0 1 963 10
/**
 *
 */
61
inline double LVecBase4d::dot(LVecBase4d const &other) const;

2830 14 length_squared 0 4 3610 26 LVecBase4d::length_squared 0 1 964 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase4d::length_squared(void) const;

2831 6 length 0 4 3610 18 LVecBase4d::length 0 1 965 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase4d::length(void) const;

2832 9 normalize 0 4 3610 21 LVecBase4d::normalize 0 1 966 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4d::normalize(void);

2833 10 normalized 0 4 3610 22 LVecBase4d::normalized 0 1 967 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4d LVecBase4d::normalized(void) const;

2834 7 project 0 4 3610 19 LVecBase4d::project 0 1 968 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const;

2835 10 operator < 0 4 3610 22 LVecBase4d::operator < 0 1 969 0
66
inline bool LVecBase4d::operator <(LVecBase4d const &other) const;

2836 11 operator == 0 4 3610 23 LVecBase4d::operator == 0 1 970 0
67
inline bool LVecBase4d::operator ==(LVecBase4d const &other) const;

2837 11 operator != 0 4 3610 23 LVecBase4d::operator != 0 1 971 0
67
inline bool LVecBase4d::operator !=(LVecBase4d const &other) const;

2838 10 compare_to 0 4 3610 22 LVecBase4d::compare_to 0 2 972 973 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase4d::compare_to(LVecBase4d const &other) const;
inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const;

2839 8 get_hash 0 4 3610 20 LVecBase4d::get_hash 0 2 974 975 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase4d::get_hash(void) const;
inline std::size_t LVecBase4d::get_hash(double threshold) const;

2840 8 add_hash 0 4 3610 20 LVecBase4d::add_hash 0 2 976 977 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;

2841 13 generate_hash 0 4 3610 25 LVecBase4d::generate_hash 0 2 978 979 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2842 10 operator - 0 68 3610 22 LVecBase4d::operator - 0 1 980 0
53
inline LVecBase4d LVecBase4d::operator -(void) const;

2843 10 operator + 0 4 3610 22 LVecBase4d::operator + 0 1 981 0
72
inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const;

2844 10 operator - 0 4 3610 22 LVecBase4d::operator - 0 1 982 0
72
inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const;

2845 10 operator * 0 4 3610 22 LVecBase4d::operator * 0 1 983 0
62
inline LVecBase4d LVecBase4d::operator *(double scalar) const;

2846 10 operator / 0 4 3610 22 LVecBase4d::operator / 0 1 984 0
62
inline LVecBase4d LVecBase4d::operator /(double scalar) const;

2847 11 operator += 0 4 3610 23 LVecBase4d::operator += 0 1 985 0
61
inline void LVecBase4d::operator +=(LVecBase4d const &other);

2848 11 operator -= 0 4 3610 23 LVecBase4d::operator -= 0 1 986 0
61
inline void LVecBase4d::operator -=(LVecBase4d const &other);

2849 11 operator *= 0 4 3610 23 LVecBase4d::operator *= 0 1 987 0
51
inline void LVecBase4d::operator *=(double scalar);

2850 11 operator /= 0 4 3610 23 LVecBase4d::operator /= 0 1 988 0
51
inline void LVecBase4d::operator /=(double scalar);

2851 18 componentwise_mult 0 4 3610 30 LVecBase4d::componentwise_mult 0 1 989 10
/**
 *
 */
68
inline void LVecBase4d::componentwise_mult(LVecBase4d const &other);

2852 8 __rmul__ 0 4 3610 20 LVecBase4d::__rmul__ 0 1 990 0
75
inline PyObject *LVecBase4d::__rmul__(PyObject *self, double scalar) const;

2853 12 __floordiv__ 0 4 3610 24 LVecBase4d::__floordiv__ 0 1 991 0
79
inline PyObject *LVecBase4d::__floordiv__(PyObject *self, double scalar) const;

2854 13 __ifloordiv__ 0 4 3610 25 LVecBase4d::__ifloordiv__ 0 1 992 0
74
inline PyObject *LVecBase4d::__ifloordiv__(PyObject *self, double scalar);

2855 7 __pow__ 0 4 3610 19 LVecBase4d::__pow__ 0 1 993 0
76
inline PyObject *LVecBase4d::__pow__(PyObject *self, double exponent) const;

2856 8 __ipow__ 0 4 3610 20 LVecBase4d::__ipow__ 0 1 994 0
71
inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);

2857 9 __round__ 0 4 3610 21 LVecBase4d::__round__ 0 1 995 0
55
inline PyObject *LVecBase4d::__round__(PyObject *self);

2858 9 __floor__ 0 4 3610 21 LVecBase4d::__floor__ 0 1 996 0
55
inline PyObject *LVecBase4d::__floor__(PyObject *self);

2859 8 __ceil__ 0 4 3610 20 LVecBase4d::__ceil__ 0 1 997 0
54
inline PyObject *LVecBase4d::__ceil__(PyObject *self);

2860 4 fmax 0 4 3610 16 LVecBase4d::fmax 0 1 998 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const;

2861 4 fmin 0 4 3610 16 LVecBase4d::fmin 0 1 999 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const;

2862 12 almost_equal 0 4 3610 24 LVecBase4d::almost_equal 0 2 1000 1001 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const;
inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const;

2863 6 output 0 4 3610 18 LVecBase4d::output 0 1 1002 10
/**
 *
 */
56
inline void LVecBase4d::output(std::ostream &out) const;

2864 8 __repr__ 0 4 3610 20 LVecBase4d::__repr__ 0 1 1003 0
52
inline std::string LVecBase4d::__repr__(void) const;

2865 20 write_datagram_fixed 0 4 3610 32 LVecBase4d::write_datagram_fixed 0 1 1004 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const;

2866 19 read_datagram_fixed 0 4 3610 31 LVecBase4d::read_datagram_fixed 0 1 1005 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source);

2867 14 write_datagram 0 4 3610 26 LVecBase4d::write_datagram 0 1 1006 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4d::write_datagram(Datagram &destination) const;

2868 13 read_datagram 0 4 3610 25 LVecBase4d::read_datagram 0 1 1007 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4d::read_datagram(DatagramIterator &source);

2869 13 __getbuffer__ 0 4 3610 25 LVecBase4d::__getbuffer__ 0 1 1008 0
87
inline int LVecBase4d::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2870 14 get_class_type 0 4 3610 26 LVecBase4d::get_class_type 0 1 1009 0
51
static TypeHandle LVecBase4d::get_class_type(void);

2871 11 ~LVecBase4d 0 516 3610 23 LVecBase4d::~LVecBase4d 0 0 0
30
LVecBase4d::~LVecBase4d(void);

2872 10 LVecBase4i 0 260 3612 22 LVecBase4i::LVecBase4i 0 7 1010 1011 1012 1013 1014 1015 1016 207
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
394
inline LVecBase4i::LVecBase4i(void) = default;
inline LVecBase4i::LVecBase4i(int fill_value);
inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);
inline explicit LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w);
inline LVecBase4i::LVecBase4i(LPoint3i const &point);
inline LVecBase4i::LVecBase4i(LVector3i const &vector);
inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default;

2873 12 operator new 0 4 3612 24 LVecBase4i::operator new 0 1 1017 0
124
inline void *LVecBase4i::operator new(std::size_t size);
inline void *LVecBase4i::operator new(std::size_t size, void *ptr);

2874 15 operator delete 0 4 3612 27 LVecBase4i::operator delete 0 0 0
108
inline void LVecBase4i::operator delete(void *ptr);
inline void LVecBase4i::operator delete(void *, void *);

2875 12 validate_ptr 0 4 3612 24 LVecBase4i::validate_ptr 0 0 0
61
static inline bool LVecBase4i::validate_ptr(void const *ptr);

2876 10 operator = 0 4 3612 22 LVecBase4i::operator = 0 2 1018 1019 0
117
void LVecBase4i::operator =(LVecBase4i const &copy) = default;
void LVecBase4i::operator =(int fill_value) = default;

2877 4 zero 0 4 3612 16 LVecBase4i::zero 0 1 1020 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4i const &LVecBase4i::zero(void);

2878 6 unit_x 0 4 3612 18 LVecBase4i::unit_x 0 1 1021 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_x(void);

2879 6 unit_y 0 4 3612 18 LVecBase4i::unit_y 0 1 1022 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_y(void);

2880 6 unit_z 0 4 3612 18 LVecBase4i::unit_z 0 1 1023 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_z(void);

2881 6 unit_w 0 4 3612 18 LVecBase4i::unit_w 0 1 1024 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_w(void);

2882 10 __reduce__ 0 4 3612 22 LVecBase4i::__reduce__ 0 1 1025 0
62
inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;

2883 11 __getattr__ 0 4 3612 23 LVecBase4i::__getattr__ 0 1 1026 0
93
inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2884 11 __setattr__ 0 4 3612 23 LVecBase4i::__setattr__ 0 1 1027 0
99
inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2885 11 operator [] 0 4 3612 23 LVecBase4i::operator [] 0 2 1028 1029 10
/**
 *
 */
92
inline int LVecBase4i::operator [](int i) const;
inline int &LVecBase4i::operator [](int i);

2886 12 operator []= 0 1028 3612 24 LVecBase4i::operator []= 0 1 1030 0
60
void LVecBase4i::operator []=(int i, int const &assign_val);

2887 4 size 0 4 3612 16 LVecBase4i::size 0 1 1031 0
44
static constexpr int LVecBase4i::size(void);

2888 6 is_nan 0 4 3612 18 LVecBase4i::is_nan 0 1 1032 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4i::is_nan(void) const;

2889 8 get_cell 0 4 3612 20 LVecBase4i::get_cell 0 1 1033 10
/**
 *
 */
45
inline int LVecBase4i::get_cell(int i) const;

2890 8 set_cell 0 4 3612 20 LVecBase4i::set_cell 0 1 1034 10
/**
 *
 */
51
inline void LVecBase4i::set_cell(int i, int value);

2891 5 get_x 0 4 3612 17 LVecBase4i::get_x 0 1 1035 10
/**
 *
 */
41
inline int LVecBase4i::get_x(void) const;

2892 5 get_y 0 4 3612 17 LVecBase4i::get_y 0 1 1036 10
/**
 *
 */
41
inline int LVecBase4i::get_y(void) const;

2893 5 get_z 0 4 3612 17 LVecBase4i::get_z 0 1 1037 10
/**
 *
 */
41
inline int LVecBase4i::get_z(void) const;

2894 5 get_w 0 4 3612 17 LVecBase4i::get_w 0 1 1038 10
/**
 *
 */
41
inline int LVecBase4i::get_w(void) const;

2895 7 get_xyz 0 4 3612 19 LVecBase4i::get_xyz 0 1 1039 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3i LVecBase4i::get_xyz(void) const;

2896 6 get_xy 0 4 3612 18 LVecBase4i::get_xy 0 1 1040 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2i LVecBase4i::get_xy(void) const;

2897 5 set_x 0 4 3612 17 LVecBase4i::set_x 0 1 1041 10
/**
 *
 */
41
inline void LVecBase4i::set_x(int value);

2898 5 set_y 0 4 3612 17 LVecBase4i::set_y 0 1 1042 10
/**
 *
 */
41
inline void LVecBase4i::set_y(int value);

2899 5 set_z 0 4 3612 17 LVecBase4i::set_z 0 1 1043 10
/**
 *
 */
41
inline void LVecBase4i::set_z(int value);

2900 5 set_w 0 4 3612 17 LVecBase4i::set_w 0 1 1044 10
/**
 *
 */
41
inline void LVecBase4i::set_w(int value);

2901 11 add_to_cell 0 4 3612 23 LVecBase4i::add_to_cell 0 1 1045 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase4i::add_to_cell(int i, int value);

2902 5 add_x 0 4 3612 17 LVecBase4i::add_x 0 1 1046 10
/**
 *
 */
41
inline void LVecBase4i::add_x(int value);

2903 5 add_y 0 4 3612 17 LVecBase4i::add_y 0 1 1047 10
/**
 *
 */
41
inline void LVecBase4i::add_y(int value);

2904 5 add_z 0 4 3612 17 LVecBase4i::add_z 0 1 1048 10
/**
 *
 */
41
inline void LVecBase4i::add_z(int value);

2905 5 add_w 0 4 3612 17 LVecBase4i::add_w 0 1 1049 10
/**
 *
 */
41
inline void LVecBase4i::add_w(int value);

2906 8 get_data 0 4 3612 20 LVecBase4i::get_data 0 1 1050 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase4i::get_data(void) const;

2907 18 get_num_components 0 4 3612 30 LVecBase4i::get_num_components 0 1 1051 0
58
static constexpr int LVecBase4i::get_num_components(void);

2908 12 extract_data 0 4 3612 24 LVecBase4i::extract_data 0 0 0
46
inline void LVecBase4i::extract_data(float *);

2909 4 fill 0 4 3612 16 LVecBase4i::fill 0 1 1052 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase4i::fill(int fill_value);

2910 3 set 0 4 3612 15 LVecBase4i::set 0 1 1053 10
/**
 *
 */
56
inline void LVecBase4i::set(int x, int y, int z, int w);

2911 3 dot 0 4 3612 15 LVecBase4i::dot 0 1 1054 10
/**
 *
 */
58
inline int LVecBase4i::dot(LVecBase4i const &other) const;

2912 14 length_squared 0 4 3612 26 LVecBase4i::length_squared 0 1 1055 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase4i::length_squared(void) const;

2913 10 operator < 0 4 3612 22 LVecBase4i::operator < 0 1 1056 0
66
inline bool LVecBase4i::operator <(LVecBase4i const &other) const;

2914 11 operator == 0 4 3612 23 LVecBase4i::operator == 0 1 1057 0
67
inline bool LVecBase4i::operator ==(LVecBase4i const &other) const;

2915 11 operator != 0 4 3612 23 LVecBase4i::operator != 0 1 1058 0
67
inline bool LVecBase4i::operator !=(LVecBase4i const &other) const;

2916 10 compare_to 0 4 3612 22 LVecBase4i::compare_to 0 1 1059 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase4i::compare_to(LVecBase4i const &other) const;

2917 8 get_hash 0 4 3612 20 LVecBase4i::get_hash 0 1 1060 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase4i::get_hash(void) const;

2918 8 add_hash 0 4 3612 20 LVecBase4i::add_hash 0 1 1061 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;

2919 13 generate_hash 0 4 3612 25 LVecBase4i::generate_hash 0 1 1062 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase4i::generate_hash(ChecksumHashGenerator &hashgen) const;

2920 10 operator - 0 68 3612 22 LVecBase4i::operator - 0 1 1063 0
53
inline LVecBase4i LVecBase4i::operator -(void) const;

2921 10 operator + 0 4 3612 22 LVecBase4i::operator + 0 1 1064 0
72
inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const;

2922 10 operator - 0 4 3612 22 LVecBase4i::operator - 0 1 1065 0
72
inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const;

2923 10 operator * 0 4 3612 22 LVecBase4i::operator * 0 1 1066 0
59
inline LVecBase4i LVecBase4i::operator *(int scalar) const;

2924 10 operator / 0 4 3612 22 LVecBase4i::operator / 0 1 1067 0
59
inline LVecBase4i LVecBase4i::operator /(int scalar) const;

2925 11 operator += 0 4 3612 23 LVecBase4i::operator += 0 1 1068 0
61
inline void LVecBase4i::operator +=(LVecBase4i const &other);

2926 11 operator -= 0 4 3612 23 LVecBase4i::operator -= 0 1 1069 0
61
inline void LVecBase4i::operator -=(LVecBase4i const &other);

2927 11 operator *= 0 4 3612 23 LVecBase4i::operator *= 0 1 1070 0
48
inline void LVecBase4i::operator *=(int scalar);

2928 11 operator /= 0 4 3612 23 LVecBase4i::operator /= 0 1 1071 0
48
inline void LVecBase4i::operator /=(int scalar);

2929 18 componentwise_mult 0 4 3612 30 LVecBase4i::componentwise_mult 0 1 1072 10
/**
 *
 */
68
inline void LVecBase4i::componentwise_mult(LVecBase4i const &other);

2930 8 __rmul__ 0 4 3612 20 LVecBase4i::__rmul__ 0 1 1073 0
72
inline PyObject *LVecBase4i::__rmul__(PyObject *self, int scalar) const;

2931 12 __floordiv__ 0 4 3612 24 LVecBase4i::__floordiv__ 0 1 1074 0
76
inline PyObject *LVecBase4i::__floordiv__(PyObject *self, int scalar) const;

2932 13 __ifloordiv__ 0 4 3612 25 LVecBase4i::__ifloordiv__ 0 1 1075 0
71
inline PyObject *LVecBase4i::__ifloordiv__(PyObject *self, int scalar);

2933 7 __pow__ 0 4 3612 19 LVecBase4i::__pow__ 0 1 1076 0
73
inline PyObject *LVecBase4i::__pow__(PyObject *self, int exponent) const;

2934 8 __ipow__ 0 4 3612 20 LVecBase4i::__ipow__ 0 1 1077 0
68
inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);

2935 9 __round__ 0 4 3612 21 LVecBase4i::__round__ 0 1 1078 0
55
inline PyObject *LVecBase4i::__round__(PyObject *self);

2936 9 __floor__ 0 4 3612 21 LVecBase4i::__floor__ 0 1 1079 0
55
inline PyObject *LVecBase4i::__floor__(PyObject *self);

2937 8 __ceil__ 0 4 3612 20 LVecBase4i::__ceil__ 0 1 1080 0
54
inline PyObject *LVecBase4i::__ceil__(PyObject *self);

2938 4 fmax 0 4 3612 16 LVecBase4i::fmax 0 1 1081 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const;

2939 4 fmin 0 4 3612 16 LVecBase4i::fmin 0 1 1082 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const;

2940 12 almost_equal 0 4 3612 24 LVecBase4i::almost_equal 0 2 1083 1084 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const;
inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const;

2941 6 output 0 4 3612 18 LVecBase4i::output 0 1 1085 10
/**
 *
 */
56
inline void LVecBase4i::output(std::ostream &out) const;

2942 8 __repr__ 0 4 3612 20 LVecBase4i::__repr__ 0 1 1086 0
52
inline std::string LVecBase4i::__repr__(void) const;

2943 20 write_datagram_fixed 0 4 3612 32 LVecBase4i::write_datagram_fixed 0 1 1087 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const;

2944 19 read_datagram_fixed 0 4 3612 31 LVecBase4i::read_datagram_fixed 0 1 1088 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source);

2945 14 write_datagram 0 4 3612 26 LVecBase4i::write_datagram 0 1 1089 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4i::write_datagram(Datagram &destination) const;

2946 13 read_datagram 0 4 3612 25 LVecBase4i::read_datagram 0 1 1090 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4i::read_datagram(DatagramIterator &source);

2947 13 __getbuffer__ 0 4 3612 25 LVecBase4i::__getbuffer__ 0 1 1091 0
87
inline int LVecBase4i::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2948 14 get_class_type 0 4 3612 26 LVecBase4i::get_class_type 0 1 1092 0
51
static TypeHandle LVecBase4i::get_class_type(void);

2949 11 ~LVecBase4i 0 516 3612 23 LVecBase4i::~LVecBase4i 0 0 0
30
LVecBase4i::~LVecBase4i(void);

2950 9 LVector4f 0 260 3614 20 LVector4f::LVector4f 0 6 1093 1094 1095 1096 1097 1098 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
338
inline LVector4f::LVector4f(void) = default;
inline LVector4f::LVector4f(LVecBase4f const &copy);
inline LVector4f::LVector4f(float fill_value);
inline LVector4f::LVector4f(float x, float y, float z, float w);
inline explicit LVector4f::LVector4f(LVecBase3f const &copy, float w);
inline LVector4f::LVector4f(LVector4f const &) = default;

2951 11 __getattr__ 0 4 3614 22 LVector4f::__getattr__ 0 1 1099 0
92
inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2952 11 __setattr__ 0 4 3614 22 LVector4f::__setattr__ 0 1 1100 0
98
inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2953 4 zero 0 4 3614 15 LVector4f::zero 0 1 1101 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4f const &LVector4f::zero(void);

2954 6 unit_x 0 4 3614 17 LVector4f::unit_x 0 1 1102 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4f const &LVector4f::unit_x(void);

2955 6 unit_y 0 4 3614 17 LVector4f::unit_y 0 1 1103 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4f const &LVector4f::unit_y(void);

2956 6 unit_z 0 4 3614 17 LVector4f::unit_z 0 1 1104 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4f const &LVector4f::unit_z(void);

2957 6 unit_w 0 4 3614 17 LVector4f::unit_w 0 1 1105 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4f const &LVector4f::unit_w(void);

2958 7 get_xyz 0 4 3614 18 LVector4f::get_xyz 0 1 1106 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3f LVector4f::get_xyz(void) const;

2959 6 get_xy 0 4 3614 17 LVector4f::get_xy 0 1 1107 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2f LVector4f::get_xy(void) const;

2960 10 operator - 0 68 3614 21 LVector4f::operator - 0 1 1108 0
51
inline LVector4f LVector4f::operator -(void) const;

2961 10 operator + 0 4 3614 21 LVector4f::operator + 0 2 1109 1110 0
141
inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator +(LVector4f const &other) const;

2962 10 operator - 0 4 3614 21 LVector4f::operator - 0 2 1111 1112 0
141
inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator -(LVector4f const &other) const;

2963 10 operator * 0 4 3614 21 LVector4f::operator * 0 1 1113 0
59
inline LVector4f LVector4f::operator *(float scalar) const;

2964 10 operator / 0 4 3614 21 LVector4f::operator / 0 1 1114 0
59
inline LVector4f LVector4f::operator /(float scalar) const;

2965 8 __rmul__ 0 4 3614 19 LVector4f::__rmul__ 0 1 1115 0
57
inline LVector4f LVector4f::__rmul__(float scalar) const;

2966 10 normalized 0 4 3614 21 LVector4f::normalized 0 1 1116 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4f LVector4f::normalized(void) const;

2967 7 project 0 4 3614 18 LVector4f::project 0 1 1117 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4f LVector4f::project(LVecBase4f const &onto) const;

2968 8 __repr__ 0 4 3614 19 LVector4f::__repr__ 0 1 1118 0
51
inline std::string LVector4f::__repr__(void) const;

2969 14 get_class_type 0 4 3614 25 LVector4f::get_class_type 0 1 1119 0
50
static TypeHandle LVector4f::get_class_type(void);

2970 10 ~LVector4f 0 516 3614 21 LVector4f::~LVector4f 0 0 0
28
LVector4f::~LVector4f(void);

2971 9 LVector4d 0 260 3615 20 LVector4d::LVector4d 0 6 1120 1121 1122 1123 1124 1125 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
344
inline LVector4d::LVector4d(void) = default;
inline LVector4d::LVector4d(LVecBase4d const &copy);
inline LVector4d::LVector4d(double fill_value);
inline LVector4d::LVector4d(double x, double y, double z, double w);
inline explicit LVector4d::LVector4d(LVecBase3d const &copy, double w);
inline LVector4d::LVector4d(LVector4d const &) = default;

2972 11 __getattr__ 0 4 3615 22 LVector4d::__getattr__ 0 1 1126 0
92
inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2973 11 __setattr__ 0 4 3615 22 LVector4d::__setattr__ 0 1 1127 0
98
inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2974 4 zero 0 4 3615 15 LVector4d::zero 0 1 1128 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4d const &LVector4d::zero(void);

2975 6 unit_x 0 4 3615 17 LVector4d::unit_x 0 1 1129 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4d const &LVector4d::unit_x(void);

2976 6 unit_y 0 4 3615 17 LVector4d::unit_y 0 1 1130 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4d const &LVector4d::unit_y(void);

2977 6 unit_z 0 4 3615 17 LVector4d::unit_z 0 1 1131 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4d const &LVector4d::unit_z(void);

2978 6 unit_w 0 4 3615 17 LVector4d::unit_w 0 1 1132 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4d const &LVector4d::unit_w(void);

2979 7 get_xyz 0 4 3615 18 LVector4d::get_xyz 0 1 1133 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3d LVector4d::get_xyz(void) const;

2980 6 get_xy 0 4 3615 17 LVector4d::get_xy 0 1 1134 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2d LVector4d::get_xy(void) const;

2981 10 operator - 0 68 3615 21 LVector4d::operator - 0 1 1135 0
51
inline LVector4d LVector4d::operator -(void) const;

2982 10 operator + 0 4 3615 21 LVector4d::operator + 0 2 1136 1137 0
141
inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator +(LVector4d const &other) const;

2983 10 operator - 0 4 3615 21 LVector4d::operator - 0 2 1138 1139 0
141
inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator -(LVector4d const &other) const;

2984 10 operator * 0 4 3615 21 LVector4d::operator * 0 1 1140 0
60
inline LVector4d LVector4d::operator *(double scalar) const;

2985 10 operator / 0 4 3615 21 LVector4d::operator / 0 1 1141 0
60
inline LVector4d LVector4d::operator /(double scalar) const;

2986 8 __rmul__ 0 4 3615 19 LVector4d::__rmul__ 0 1 1142 0
58
inline LVector4d LVector4d::__rmul__(double scalar) const;

2987 10 normalized 0 4 3615 21 LVector4d::normalized 0 1 1143 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4d LVector4d::normalized(void) const;

2988 7 project 0 4 3615 18 LVector4d::project 0 1 1144 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4d LVector4d::project(LVecBase4d const &onto) const;

2989 8 __repr__ 0 4 3615 19 LVector4d::__repr__ 0 1 1145 0
51
inline std::string LVector4d::__repr__(void) const;

2990 14 get_class_type 0 4 3615 25 LVector4d::get_class_type 0 1 1146 0
50
static TypeHandle LVector4d::get_class_type(void);

2991 10 ~LVector4d 0 516 3615 21 LVector4d::~LVector4d 0 0 0
28
LVector4d::~LVector4d(void);

2992 9 LVector4i 0 260 3616 20 LVector4i::LVector4i 0 6 1147 1148 1149 1150 1151 1152 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
326
inline LVector4i::LVector4i(void) = default;
inline LVector4i::LVector4i(LVecBase4i const &copy);
inline LVector4i::LVector4i(int fill_value);
inline LVector4i::LVector4i(int x, int y, int z, int w);
inline explicit LVector4i::LVector4i(LVecBase3i const &copy, int w);
inline LVector4i::LVector4i(LVector4i const &) = default;

2993 11 __getattr__ 0 4 3616 22 LVector4i::__getattr__ 0 1 1153 0
92
inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2994 11 __setattr__ 0 4 3616 22 LVector4i::__setattr__ 0 1 1154 0
98
inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2995 4 zero 0 4 3616 15 LVector4i::zero 0 1 1155 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4i const &LVector4i::zero(void);

2996 6 unit_x 0 4 3616 17 LVector4i::unit_x 0 1 1156 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4i const &LVector4i::unit_x(void);

2997 6 unit_y 0 4 3616 17 LVector4i::unit_y 0 1 1157 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4i const &LVector4i::unit_y(void);

2998 6 unit_z 0 4 3616 17 LVector4i::unit_z 0 1 1158 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4i const &LVector4i::unit_z(void);

2999 6 unit_w 0 4 3616 17 LVector4i::unit_w 0 1 1159 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4i const &LVector4i::unit_w(void);

3000 7 get_xyz 0 4 3616 18 LVector4i::get_xyz 0 1 1160 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3i LVector4i::get_xyz(void) const;

3001 6 get_xy 0 4 3616 17 LVector4i::get_xy 0 1 1161 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2i LVector4i::get_xy(void) const;

3002 10 operator - 0 68 3616 21 LVector4i::operator - 0 1 1162 0
51
inline LVector4i LVector4i::operator -(void) const;

3003 10 operator + 0 4 3616 21 LVector4i::operator + 0 2 1163 1164 0
141
inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator +(LVector4i const &other) const;

3004 10 operator - 0 4 3616 21 LVector4i::operator - 0 2 1165 1166 0
141
inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator -(LVector4i const &other) const;

3005 10 operator * 0 4 3616 21 LVector4i::operator * 0 1 1167 0
57
inline LVector4i LVector4i::operator *(int scalar) const;

3006 10 operator / 0 4 3616 21 LVector4i::operator / 0 1 1168 0
57
inline LVector4i LVector4i::operator /(int scalar) const;

3007 8 __rmul__ 0 4 3616 19 LVector4i::__rmul__ 0 1 1169 0
55
inline LVector4i LVector4i::__rmul__(int scalar) const;

3008 8 __repr__ 0 4 3616 19 LVector4i::__repr__ 0 1 1170 0
51
inline std::string LVector4i::__repr__(void) const;

3009 14 get_class_type 0 4 3616 25 LVector4i::get_class_type 0 1 1171 0
50
static TypeHandle LVector4i::get_class_type(void);

3010 10 ~LVector4i 0 516 3616 21 LVector4i::~LVector4i 0 0 0
28
LVector4i::~LVector4i(void);

3011 8 LPoint4f 0 260 3617 18 LPoint4f::LPoint4f 0 6 1172 1173 1174 1175 1176 1177 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
325
inline LPoint4f::LPoint4f(void) = default;
inline LPoint4f::LPoint4f(LVecBase4f const &copy);
inline LPoint4f::LPoint4f(float fill_value);
inline LPoint4f::LPoint4f(float x, float y, float z, float w);
inline explicit LPoint4f::LPoint4f(LVecBase3f const &copy, float w);
inline LPoint4f::LPoint4f(LPoint4f const &) = default;

3012 11 __getattr__ 0 4 3617 21 LPoint4f::__getattr__ 0 1 1178 0
91
inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const;

3013 11 __setattr__ 0 4 3617 21 LPoint4f::__setattr__ 0 1 1179 0
97
inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3014 4 zero 0 4 3617 14 LPoint4f::zero 0 1 1180 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4f const &LPoint4f::zero(void);

3015 6 unit_x 0 4 3617 16 LPoint4f::unit_x 0 1 1181 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4f const &LPoint4f::unit_x(void);

3016 6 unit_y 0 4 3617 16 LPoint4f::unit_y 0 1 1182 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4f const &LPoint4f::unit_y(void);

3017 6 unit_z 0 4 3617 16 LPoint4f::unit_z 0 1 1183 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4f const &LPoint4f::unit_z(void);

3018 6 unit_w 0 4 3617 16 LPoint4f::unit_w 0 1 1184 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4f const &LPoint4f::unit_w(void);

3019 7 get_xyz 0 4 3617 17 LPoint4f::get_xyz 0 1 1185 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3f LPoint4f::get_xyz(void) const;

3020 6 get_xy 0 4 3617 16 LPoint4f::get_xy 0 1 1186 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2f LPoint4f::get_xy(void) const;

3021 10 operator - 0 68 3617 20 LPoint4f::operator - 0 1 1187 0
49
inline LPoint4f LPoint4f::operator -(void) const;

3022 10 operator + 0 4 3617 20 LPoint4f::operator + 0 2 1188 1189 0
138
inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const;
inline LPoint4f LPoint4f::operator +(LVector4f const &other) const;

3023 10 operator - 0 4 3617 20 LPoint4f::operator - 0 3 1190 1191 1192 0
206
inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const;
inline LVector4f LPoint4f::operator -(LPoint4f const &other) const;
inline LPoint4f LPoint4f::operator -(LVector4f const &other) const;

3024 10 operator * 0 4 3617 20 LPoint4f::operator * 0 1 1193 0
57
inline LPoint4f LPoint4f::operator *(float scalar) const;

3025 10 operator / 0 4 3617 20 LPoint4f::operator / 0 1 1194 0
57
inline LPoint4f LPoint4f::operator /(float scalar) const;

3026 8 __rmul__ 0 4 3617 18 LPoint4f::__rmul__ 0 1 1195 0
55
inline LPoint4f LPoint4f::__rmul__(float scalar) const;

3027 10 normalized 0 4 3617 20 LPoint4f::normalized 0 1 1196 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4f LPoint4f::normalized(void) const;

3028 7 project 0 4 3617 17 LPoint4f::project 0 1 1197 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const;

3029 8 __repr__ 0 4 3617 18 LPoint4f::__repr__ 0 1 1198 0
50
inline std::string LPoint4f::__repr__(void) const;

3030 14 get_class_type 0 4 3617 24 LPoint4f::get_class_type 0 1 1199 0
49
static TypeHandle LPoint4f::get_class_type(void);

3031 9 ~LPoint4f 0 516 3617 19 LPoint4f::~LPoint4f 0 0 0
26
LPoint4f::~LPoint4f(void);

3032 8 LPoint4d 0 260 3618 18 LPoint4d::LPoint4d 0 6 1200 1201 1202 1203 1204 1205 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
331
inline LPoint4d::LPoint4d(void) = default;
inline LPoint4d::LPoint4d(LVecBase4d const &copy);
inline LPoint4d::LPoint4d(double fill_value);
inline LPoint4d::LPoint4d(double x, double y, double z, double w);
inline explicit LPoint4d::LPoint4d(LVecBase3d const &copy, double w);
inline LPoint4d::LPoint4d(LPoint4d const &) = default;

3033 11 __getattr__ 0 4 3618 21 LPoint4d::__getattr__ 0 1 1206 0
91
inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const;

3034 11 __setattr__ 0 4 3618 21 LPoint4d::__setattr__ 0 1 1207 0
97
inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3035 4 zero 0 4 3618 14 LPoint4d::zero 0 1 1208 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4d const &LPoint4d::zero(void);

3036 6 unit_x 0 4 3618 16 LPoint4d::unit_x 0 1 1209 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4d const &LPoint4d::unit_x(void);

3037 6 unit_y 0 4 3618 16 LPoint4d::unit_y 0 1 1210 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4d const &LPoint4d::unit_y(void);

3038 6 unit_z 0 4 3618 16 LPoint4d::unit_z 0 1 1211 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4d const &LPoint4d::unit_z(void);

3039 6 unit_w 0 4 3618 16 LPoint4d::unit_w 0 1 1212 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4d const &LPoint4d::unit_w(void);

3040 7 get_xyz 0 4 3618 17 LPoint4d::get_xyz 0 1 1213 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3d LPoint4d::get_xyz(void) const;

3041 6 get_xy 0 4 3618 16 LPoint4d::get_xy 0 1 1214 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2d LPoint4d::get_xy(void) const;

3042 10 operator - 0 68 3618 20 LPoint4d::operator - 0 1 1215 0
49
inline LPoint4d LPoint4d::operator -(void) const;

3043 10 operator + 0 4 3618 20 LPoint4d::operator + 0 2 1216 1217 0
138
inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const;
inline LPoint4d LPoint4d::operator +(LVector4d const &other) const;

3044 10 operator - 0 4 3618 20 LPoint4d::operator - 0 3 1218 1219 1220 0
206
inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const;
inline LVector4d LPoint4d::operator -(LPoint4d const &other) const;
inline LPoint4d LPoint4d::operator -(LVector4d const &other) const;

3045 10 operator * 0 4 3618 20 LPoint4d::operator * 0 1 1221 0
58
inline LPoint4d LPoint4d::operator *(double scalar) const;

3046 10 operator / 0 4 3618 20 LPoint4d::operator / 0 1 1222 0
58
inline LPoint4d LPoint4d::operator /(double scalar) const;

3047 8 __rmul__ 0 4 3618 18 LPoint4d::__rmul__ 0 1 1223 0
56
inline LPoint4d LPoint4d::__rmul__(double scalar) const;

3048 10 normalized 0 4 3618 20 LPoint4d::normalized 0 1 1224 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4d LPoint4d::normalized(void) const;

3049 7 project 0 4 3618 17 LPoint4d::project 0 1 1225 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const;

3050 8 __repr__ 0 4 3618 18 LPoint4d::__repr__ 0 1 1226 0
50
inline std::string LPoint4d::__repr__(void) const;

3051 14 get_class_type 0 4 3618 24 LPoint4d::get_class_type 0 1 1227 0
49
static TypeHandle LPoint4d::get_class_type(void);

3052 9 ~LPoint4d 0 516 3618 19 LPoint4d::~LPoint4d 0 0 0
26
LPoint4d::~LPoint4d(void);

3053 8 LPoint4i 0 260 3619 18 LPoint4i::LPoint4i 0 6 1228 1229 1230 1231 1232 1233 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
313
inline LPoint4i::LPoint4i(void) = default;
inline LPoint4i::LPoint4i(LVecBase4i const &copy);
inline LPoint4i::LPoint4i(int fill_value);
inline LPoint4i::LPoint4i(int x, int y, int z, int w);
inline explicit LPoint4i::LPoint4i(LVecBase3i const &copy, int w);
inline LPoint4i::LPoint4i(LPoint4i const &) = default;

3054 11 __getattr__ 0 4 3619 21 LPoint4i::__getattr__ 0 1 1234 0
91
inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const;

3055 11 __setattr__ 0 4 3619 21 LPoint4i::__setattr__ 0 1 1235 0
97
inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3056 4 zero 0 4 3619 14 LPoint4i::zero 0 1 1236 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4i const &LPoint4i::zero(void);

3057 6 unit_x 0 4 3619 16 LPoint4i::unit_x 0 1 1237 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4i const &LPoint4i::unit_x(void);

3058 6 unit_y 0 4 3619 16 LPoint4i::unit_y 0 1 1238 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4i const &LPoint4i::unit_y(void);

3059 6 unit_z 0 4 3619 16 LPoint4i::unit_z 0 1 1239 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4i const &LPoint4i::unit_z(void);

3060 6 unit_w 0 4 3619 16 LPoint4i::unit_w 0 1 1240 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4i const &LPoint4i::unit_w(void);

3061 7 get_xyz 0 4 3619 17 LPoint4i::get_xyz 0 1 1241 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3i LPoint4i::get_xyz(void) const;

3062 6 get_xy 0 4 3619 16 LPoint4i::get_xy 0 1 1242 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2i LPoint4i::get_xy(void) const;

3063 10 operator - 0 68 3619 20 LPoint4i::operator - 0 1 1243 0
49
inline LPoint4i LPoint4i::operator -(void) const;

3064 10 operator + 0 4 3619 20 LPoint4i::operator + 0 2 1244 1245 0
138
inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const;
inline LPoint4i LPoint4i::operator +(LVector4i const &other) const;

3065 10 operator - 0 4 3619 20 LPoint4i::operator - 0 3 1246 1247 1248 0
206
inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const;
inline LVector4i LPoint4i::operator -(LPoint4i const &other) const;
inline LPoint4i LPoint4i::operator -(LVector4i const &other) const;

3066 10 operator * 0 4 3619 20 LPoint4i::operator * 0 1 1249 0
55
inline LPoint4i LPoint4i::operator *(int scalar) const;

3067 10 operator / 0 4 3619 20 LPoint4i::operator / 0 1 1250 0
55
inline LPoint4i LPoint4i::operator /(int scalar) const;

3068 8 __rmul__ 0 4 3619 18 LPoint4i::__rmul__ 0 1 1251 0
53
inline LPoint4i LPoint4i::__rmul__(int scalar) const;

3069 8 __repr__ 0 4 3619 18 LPoint4i::__repr__ 0 1 1252 0
50
inline std::string LPoint4i::__repr__(void) const;

3070 14 get_class_type 0 4 3619 24 LPoint4i::get_class_type 0 1 1253 0
49
static TypeHandle LPoint4i::get_class_type(void);

3071 9 ~LPoint4i 0 516 3619 19 LPoint4i::~LPoint4i 0 0 0
26
LPoint4i::~LPoint4i(void);

3072 11 operator [] 0 4 3622 27 LMatrix3f::Row::operator [] 0 2 1357 1358 10
/**
 *
 */
104
inline float LMatrix3f::Row::operator [](int i) const;
inline float &LMatrix3f::Row::operator [](int i);

3073 12 operator []= 0 1028 3622 28 LMatrix3f::Row::operator []= 0 1 1359 0
66
void LMatrix3f::Row::operator []=(int i, float const &assign_val);

3074 4 size 0 4 3622 20 LMatrix3f::Row::size 0 1 1360 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3f::Row::size(void);

3075 17 operator typecast 0 132 3622 33 LMatrix3f::Row::operator typecast 0 1 1361 0
47
inline operator LVecBase3f const &(void) const;

3076 3 Row 0 260 3622 19 LMatrix3f::Row::Row 0 1 1356 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default;

3077 4 ~Row 0 516 3622 20 LMatrix3f::Row::~Row 0 0 0
27
LMatrix3f::Row::~Row(void);

3078 11 operator [] 0 4 3623 28 LMatrix3f::CRow::operator [] 0 1 1363 0
55
inline float LMatrix3f::CRow::operator [](int i) const;

3079 4 size 0 4 3623 21 LMatrix3f::CRow::size 0 1 1364 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3f::CRow::size(void);

3080 17 operator typecast 0 132 3623 34 LMatrix3f::CRow::operator typecast 0 1 1365 0
47
inline operator LVecBase3f const &(void) const;

3081 4 CRow 0 260 3623 21 LMatrix3f::CRow::CRow 0 1 1362 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default;

3082 5 ~CRow 0 516 3623 22 LMatrix3f::CRow::~CRow 0 0 0
29
LMatrix3f::CRow::~CRow(void);

3083 9 LMatrix3f 0 260 3620 20 LMatrix3f::LMatrix3f 0 4 1254 1255 1256 1257 72
/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
297
inline LMatrix3f::LMatrix3f(void) = default;
inline LMatrix3f::LMatrix3f(LMatrix3f const &other) = default;
inline LMatrix3f::LMatrix3f(float , float , float , float , float , float , float , float , float );
inline LMatrix3f::LMatrix3f(LVecBase3f const &, LVecBase3f const &, LVecBase3f const &);

3084 10 operator = 0 4 3620 21 LMatrix3f::operator = 0 2 1258 1259 10
/**
 *
 */
121
inline void LMatrix3f::operator =(LMatrix3f const &other) = default;
inline void LMatrix3f::operator =(float fill_value);

3085 12 operator new 0 4 3620 23 LMatrix3f::operator new 0 1 1260 0
122
inline void *LMatrix3f::operator new(std::size_t size);
inline void *LMatrix3f::operator new(std::size_t size, void *ptr);

3086 15 operator delete 0 4 3620 26 LMatrix3f::operator delete 0 0 0
106
inline void LMatrix3f::operator delete(void *ptr);
inline void LMatrix3f::operator delete(void *, void *);

3087 12 validate_ptr 0 4 3620 23 LMatrix3f::validate_ptr 0 0 0
60
static inline bool LMatrix3f::validate_ptr(void const *ptr);

3088 10 __reduce__ 0 4 3620 21 LMatrix3f::__reduce__ 0 1 1261 0
61
inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;

3089 4 fill 0 4 3620 15 LMatrix3f::fill 0 1 1262 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
39
void LMatrix3f::fill(float fill_value);

3090 3 set 0 4 3620 14 LMatrix3f::set 0 1 1263 10
/**
 *
 */
126
inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

3091 11 operator [] 0 4 3620 22 LMatrix3f::operator [] 0 2 1264 1265 0
112
inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;
inline LMatrix3f::Row LMatrix3f::operator [](int i);

3092 4 size 0 4 3620 15 LMatrix3f::size 0 1 1266 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3f::size(void);

3093 7 set_row 0 4 3620 18 LMatrix3f::set_row 0 2 1267 1268 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3f::set_row(int row, LVecBase3f const &v);
inline void LMatrix3f::set_row(int row, LVecBase2f const &v);

3094 7 set_col 0 4 3620 18 LMatrix3f::set_col 0 2 1269 1270 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3f::set_col(int col, LVecBase3f const &v);
inline void LMatrix3f::set_col(int col, LVecBase2f const &v);

3095 7 get_row 0 4 3620 18 LMatrix3f::get_row 0 2 1271 1272 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3f LMatrix3f::get_row(int row) const;
inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const;

3096 7 get_col 0 4 3620 18 LMatrix3f::get_col 0 1 1273 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3f LMatrix3f::get_col(int col) const;

3097 8 get_row2 0 4 3620 19 LMatrix3f::get_row2 0 1 1274 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2f LMatrix3f::get_row2(int row) const;

3098 8 get_col2 0 4 3620 19 LMatrix3f::get_col2 0 1 1275 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2f LMatrix3f::get_col2(int col) const;

3099 11 operator () 0 4 3620 22 LMatrix3f::operator () 0 2 1276 1277 10
/**
 *
 */
116
inline float &LMatrix3f::operator ()(int row, int col);
inline float LMatrix3f::operator ()(int row, int col) const;

3100 6 is_nan 0 4 3620 17 LMatrix3f::is_nan 0 1 1278 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3f::is_nan(void) const;

3101 11 is_identity 0 4 3620 22 LMatrix3f::is_identity 0 1 1279 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3f::is_identity(void) const;

3102 8 get_cell 0 4 3620 19 LMatrix3f::get_cell 0 1 1280 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix3f::get_cell(int row, int col) const;

3103 8 set_cell 0 4 3620 19 LMatrix3f::set_cell 0 1 1281 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix3f::set_cell(int row, int col, float value);

3104 8 get_data 0 4 3620 19 LMatrix3f::get_data 0 1 1282 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix3f::get_data(void) const;

3105 18 get_num_components 0 4 3620 29 LMatrix3f::get_num_components 0 1 1283 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3f::get_num_components(void) const;

3106 10 operator < 0 4 3620 21 LMatrix3f::operator < 0 1 1284 0
64
inline bool LMatrix3f::operator <(LMatrix3f const &other) const;

3107 11 operator == 0 4 3620 22 LMatrix3f::operator == 0 1 1285 0
65
inline bool LMatrix3f::operator ==(LMatrix3f const &other) const;

3108 11 operator != 0 4 3620 22 LMatrix3f::operator != 0 1 1286 0
65
inline bool LMatrix3f::operator !=(LMatrix3f const &other) const;

3109 10 compare_to 0 4 3620 21 LMatrix3f::compare_to 0 2 1287 1288 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix3f::compare_to(LMatrix3f const &other) const;
int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const;

3110 8 get_hash 0 4 3620 19 LMatrix3f::get_hash 0 2 1289 1290 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix3f::get_hash(void) const;
inline std::size_t LMatrix3f::get_hash(float threshold) const;

3111 8 add_hash 0 4 3620 19 LMatrix3f::add_hash 0 2 1291 1292 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;

3112 5 xform 0 4 3620 16 LMatrix3f::xform 0 1 1293 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const;

3113 11 xform_point 0 4 3620 22 LMatrix3f::xform_point 0 1 1294 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const;

3114 9 xform_vec 0 4 3620 20 LMatrix3f::xform_vec 0 2 1295 1296 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const;
inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const;

3115 17 xform_vec_general 0 4 3620 28 LMatrix3f::xform_vec_general 0 1 1297 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const;

3116 14 xform_in_place 0 4 3620 25 LMatrix3f::xform_in_place 0 1 1298 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3f::xform_in_place(LVecBase3f &v) const;

3117 20 xform_point_in_place 0 4 3620 31 LMatrix3f::xform_point_in_place 0 1 1299 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const;

3118 18 xform_vec_in_place 0 4 3620 29 LMatrix3f::xform_vec_in_place 0 2 1300 1301 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const;
inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const;

3119 26 xform_vec_general_in_place 0 4 3620 37 LMatrix3f::xform_vec_general_in_place 0 1 1302 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const;

3120 8 multiply 0 4 3620 19 LMatrix3f::multiply 0 1 1303 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2);

3121 10 operator * 0 4 3620 21 LMatrix3f::operator * 0 2 1304 1305 0
129
inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const;
inline LMatrix3f LMatrix3f::operator *(float scalar) const;

3122 10 operator / 0 4 3620 21 LMatrix3f::operator / 0 1 1306 0
59
inline LMatrix3f LMatrix3f::operator /(float scalar) const;

3123 11 operator += 0 4 3620 22 LMatrix3f::operator += 0 1 1307 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other);

3124 11 operator -= 0 4 3620 22 LMatrix3f::operator -= 0 1 1308 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other);

3125 11 operator *= 0 4 3620 22 LMatrix3f::operator *= 0 2 1309 1310 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
121
inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator *=(float scalar);

3126 11 operator /= 0 4 3620 22 LMatrix3f::operator /= 0 1 1311 39
/**
 * Performs a memberwise scale.
 */
55
inline LMatrix3f &LMatrix3f::operator /=(float scalar);

3127 8 __rmul__ 0 4 3620 19 LMatrix3f::__rmul__ 0 1 1312 0
57
inline LMatrix3f LMatrix3f::__rmul__(float scalar) const;

3128 18 componentwise_mult 0 4 3620 29 LMatrix3f::componentwise_mult 0 1 1313 10
/**
 *
 */
66
inline void LMatrix3f::componentwise_mult(LMatrix3f const &other);

3129 11 determinant 0 4 3620 22 LMatrix3f::determinant 0 1 1314 49
/**
 * Returns the determinant of the matrix.
 */
48
inline float LMatrix3f::determinant(void) const;

3130 14 transpose_from 0 4 3620 25 LMatrix3f::transpose_from 0 1 1315 10
/**
 *
 */
62
inline void LMatrix3f::transpose_from(LMatrix3f const &other);

3131 18 transpose_in_place 0 4 3620 29 LMatrix3f::transpose_in_place 0 1 1316 10
/**
 *
 */
48
inline void LMatrix3f::transpose_in_place(void);

3132 11 invert_from 0 4 3620 22 LMatrix3f::invert_from 0 1 1317 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3f::invert_from(LMatrix3f const &other);

3133 15 invert_in_place 0 4 3620 26 LMatrix3f::invert_in_place 0 1 1318 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3f::invert_in_place(void);

3134 21 invert_transpose_from 0 4 3620 32 LMatrix3f::invert_transpose_from 0 2 1319 1320 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other);
inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other);

3135 9 ident_mat 0 4 3620 20 LMatrix3f::ident_mat 0 1 1321 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3f const &LMatrix3f::ident_mat(void);

3136 17 set_translate_mat 0 4 3620 28 LMatrix3f::set_translate_mat 0 1 1322 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans);

3137 14 set_rotate_mat 0 4 3620 25 LMatrix3f::set_rotate_mat 0 2 1323 1324 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
156
inline void LMatrix3f::set_rotate_mat(float angle);
void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3138 13 set_scale_mat 0 4 3620 24 LMatrix3f::set_scale_mat 0 2 1325 1326 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale);
inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale);

3139 13 translate_mat 0 4 3620 24 LMatrix3f::translate_mat 0 2 1327 1328 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
144
static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans);
static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);

3140 10 rotate_mat 0 4 3620 21 LMatrix3f::rotate_mat 0 2 1329 1330 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
179
static inline LMatrix3f LMatrix3f::rotate_mat(float angle);
static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3141 9 scale_mat 0 4 3620 20 LMatrix3f::scale_mat 0 4 1331 1332 1333 1334 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
283
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);

3142 23 set_rotate_mat_normaxis 0 4 3620 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1335 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
113
void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3143 19 rotate_mat_normaxis 0 4 3620 30 LMatrix3f::rotate_mat_normaxis 0 1 1336 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
128
static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3144 13 set_shear_mat 0 4 3620 24 LMatrix3f::set_shear_mat 0 1 1337 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3145 9 shear_mat 0 4 3620 20 LMatrix3f::shear_mat 0 2 1338 1339 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3146 19 set_scale_shear_mat 0 4 3620 30 LMatrix3f::set_scale_shear_mat 0 1 1340 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3147 15 scale_shear_mat 0 4 3620 26 LMatrix3f::scale_shear_mat 0 2 1341 1342 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3148 11 convert_mat 0 4 3620 22 LMatrix3f::convert_mat 0 1 1343 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3149 12 almost_equal 0 4 3620 23 LMatrix3f::almost_equal 0 2 1344 1345 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
143
bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const;
inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const;

3150 6 output 0 4 3620 17 LMatrix3f::output 0 1 1346 10
/**
 *
 */
48
void LMatrix3f::output(std::ostream &out) const;

3151 5 write 0 4 3620 16 LMatrix3f::write 0 1 1347 10
/**
 *
 */
69
void LMatrix3f::write(std::ostream &out, int indent_level = 0) const;

3152 8 __repr__ 0 4 3620 19 LMatrix3f::__repr__ 0 1 1348 0
51
inline std::string LMatrix3f::__repr__(void) const;

3153 13 generate_hash 0 4 3620 24 LMatrix3f::generate_hash 0 2 1349 1350 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
161
inline void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

3154 20 write_datagram_fixed 0 4 3620 31 LMatrix3f::write_datagram_fixed 0 1 1351 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3f::write_datagram_fixed(Datagram &destination) const;

3155 19 read_datagram_fixed 0 4 3620 30 LMatrix3f::read_datagram_fixed 0 1 1352 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3f::read_datagram_fixed(DatagramIterator &scan);

3156 14 write_datagram 0 4 3620 25 LMatrix3f::write_datagram 0 1 1353 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3f::write_datagram(Datagram &destination) const;

3157 13 read_datagram 0 4 3620 24 LMatrix3f::read_datagram 0 1 1354 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3f::read_datagram(DatagramIterator &source);

3158 14 get_class_type 0 4 3620 25 LMatrix3f::get_class_type 0 1 1355 0
50
static TypeHandle LMatrix3f::get_class_type(void);

3159 10 ~LMatrix3f 0 516 3620 21 LMatrix3f::~LMatrix3f 0 0 0
28
LMatrix3f::~LMatrix3f(void);

3160 9 transpose 0 1 0 9 transpose 0 4 1902 1903 1904 1905 0
191
inline LMatrix3f transpose(LMatrix3f const &a);
inline LMatrix4f transpose(LMatrix4f const &a);
inline LMatrix3d transpose(LMatrix3d const &a);
inline LMatrix4d transpose(LMatrix4d const &a);

3161 6 invert 0 1 0 6 invert 0 6 1906 1907 1908 1909 1910 1911 0
281
inline LMatrix3f invert(LMatrix3f const &a);
inline LMatrix4f invert(LMatrix4f const &a);
inline LMatrix3d invert(LMatrix3d const &a);
inline LMatrix4d invert(LMatrix4d const &a);
inline LQuaternionf invert(LQuaternionf const &a);
inline LQuaterniond invert(LQuaterniond const &a);

3162 11 operator [] 0 4 3626 27 LMatrix4f::Row::operator [] 0 2 1477 1478 10
/**
 *
 */
104
inline float LMatrix4f::Row::operator [](int i) const;
inline float &LMatrix4f::Row::operator [](int i);

3163 12 operator []= 0 1028 3626 28 LMatrix4f::Row::operator []= 0 1 1479 0
66
void LMatrix4f::Row::operator []=(int i, float const &assign_val);

3164 4 size 0 4 3626 20 LMatrix4f::Row::size 0 1 1480 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4f::Row::size(void);

3165 17 operator typecast 0 132 3626 33 LMatrix4f::Row::operator typecast 0 1 1481 0
47
inline operator LVecBase4f const &(void) const;

3166 3 Row 0 260 3626 19 LMatrix4f::Row::Row 0 1 1476 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default;

3167 4 ~Row 0 516 3626 20 LMatrix4f::Row::~Row 0 0 0
27
LMatrix4f::Row::~Row(void);

3168 11 operator [] 0 4 3627 28 LMatrix4f::CRow::operator [] 0 1 1483 0
55
inline float LMatrix4f::CRow::operator [](int i) const;

3169 4 size 0 4 3627 21 LMatrix4f::CRow::size 0 1 1484 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4f::CRow::size(void);

3170 17 operator typecast 0 132 3627 34 LMatrix4f::CRow::operator typecast 0 1 1485 0
47
inline operator LVecBase4f const &(void) const;

3171 4 CRow 0 260 3627 21 LMatrix4f::CRow::CRow 0 1 1482 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default;

3172 5 ~CRow 0 516 3627 22 LMatrix4f::CRow::~CRow 0 0 0
29
LMatrix4f::CRow::~CRow(void);

3173 9 LMatrix4f 0 260 3624 20 LMatrix4f::LMatrix4f 0 6 1366 1367 1368 1369 1370 1371 192
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
515
inline LMatrix4f::LMatrix4f(void) = default;
inline LMatrix4f::LMatrix4f(LMatrix4f const &other) = default;
inline LMatrix4f::LMatrix4f(float , float , float , float , float , float , float , float , float , float , float , float , float , float , float , float );
inline LMatrix4f::LMatrix4f(LVecBase4f const &, LVecBase4f const &, LVecBase4f const &, LVecBase4f const &);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3);
inline explicit LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans);

3174 10 operator = 0 4 3624 21 LMatrix4f::operator = 0 2 1372 1373 10
/**
 *
 */
121
inline void LMatrix4f::operator =(LMatrix4f const &other) = default;
inline void LMatrix4f::operator =(float fill_value);

3175 12 operator new 0 4 3624 23 LMatrix4f::operator new 0 1 1374 0
122
inline void *LMatrix4f::operator new(std::size_t size);
inline void *LMatrix4f::operator new(std::size_t size, void *ptr);

3176 15 operator delete 0 4 3624 26 LMatrix4f::operator delete 0 0 0
106
inline void LMatrix4f::operator delete(void *ptr);
inline void LMatrix4f::operator delete(void *, void *);

3177 12 validate_ptr 0 4 3624 23 LMatrix4f::validate_ptr 0 0 0
60
static inline bool LMatrix4f::validate_ptr(void const *ptr);

3178 10 __reduce__ 0 4 3624 21 LMatrix4f::__reduce__ 0 1 1375 0
61
inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;

3179 4 fill 0 4 3624 15 LMatrix4f::fill 0 1 1376 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
46
inline void LMatrix4f::fill(float fill_value);

3180 3 set 0 4 3624 14 LMatrix4f::set 0 1 1377 10
/**
 *
 */
203
inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3181 11 set_upper_3 0 4 3624 22 LMatrix4f::set_upper_3 0 1 1378 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3);

3182 11 get_upper_3 0 4 3624 22 LMatrix4f::get_upper_3 0 1 1379 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3f LMatrix4f::get_upper_3(void) const;

3183 11 operator [] 0 4 3624 22 LMatrix4f::operator [] 0 2 1380 1381 0
112
inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;
inline LMatrix4f::Row LMatrix4f::operator [](int i);

3184 4 size 0 4 3624 15 LMatrix4f::size 0 1 1382 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4f::size(void);

3185 7 set_row 0 4 3624 18 LMatrix4f::set_row 0 2 1383 1384 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4f::set_row(int row, LVecBase4f const &v);
inline void LMatrix4f::set_row(int row, LVecBase3f const &v);

3186 7 set_col 0 4 3624 18 LMatrix4f::set_col 0 2 1385 1386 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4f::set_col(int col, LVecBase4f const &v);
inline void LMatrix4f::set_col(int col, LVecBase3f const &v);

3187 7 get_row 0 4 3624 18 LMatrix4f::get_row 0 2 1387 1388 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4f LMatrix4f::get_row(int row) const;
inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const;

3188 7 get_col 0 4 3624 18 LMatrix4f::get_col 0 1 1389 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4f LMatrix4f::get_col(int col) const;

3189 8 get_row3 0 4 3624 19 LMatrix4f::get_row3 0 2 1390 1391 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3f LMatrix4f::get_row3(int row) const;
inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const;

3190 8 get_col3 0 4 3624 19 LMatrix4f::get_col3 0 1 1392 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3f LMatrix4f::get_col3(int col) const;

3191 11 operator () 0 4 3624 22 LMatrix4f::operator () 0 2 1393 1394 10
/**
 *
 */
116
inline float &LMatrix4f::operator ()(int row, int col);
inline float LMatrix4f::operator ()(int row, int col) const;

3192 6 is_nan 0 4 3624 17 LMatrix4f::is_nan 0 1 1395 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4f::is_nan(void) const;

3193 11 is_identity 0 4 3624 22 LMatrix4f::is_identity 0 1 1396 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4f::is_identity(void) const;

3194 8 get_cell 0 4 3624 19 LMatrix4f::get_cell 0 1 1397 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix4f::get_cell(int row, int col) const;

3195 8 set_cell 0 4 3624 19 LMatrix4f::set_cell 0 1 1398 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix4f::set_cell(int row, int col, float value);

3196 8 get_data 0 4 3624 19 LMatrix4f::get_data 0 1 1399 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix4f::get_data(void) const;

3197 18 get_num_components 0 4 3624 29 LMatrix4f::get_num_components 0 1 1400 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4f::get_num_components(void) const;

3198 5 begin 0 4 3624 16 LMatrix4f::begin 0 2 1401 1402 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4f::iterator LMatrix4f::begin(void);
inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;

3199 3 end 0 4 3624 14 LMatrix4f::end 0 2 1403 1404 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4f::iterator LMatrix4f::end(void);
inline LMatrix4f::const_iterator LMatrix4f::end(void) const;

3200 10 operator < 0 4 3624 21 LMatrix4f::operator < 0 1 1405 0
64
inline bool LMatrix4f::operator <(LMatrix4f const &other) const;

3201 11 operator == 0 4 3624 22 LMatrix4f::operator == 0 1 1406 0
65
inline bool LMatrix4f::operator ==(LMatrix4f const &other) const;

3202 11 operator != 0 4 3624 22 LMatrix4f::operator != 0 1 1407 0
65
inline bool LMatrix4f::operator !=(LMatrix4f const &other) const;

3203 10 compare_to 0 4 3624 21 LMatrix4f::compare_to 0 2 1408 1409 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix4f::compare_to(LMatrix4f const &other) const;
int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const;

3204 8 get_hash 0 4 3624 19 LMatrix4f::get_hash 0 2 1410 1411 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix4f::get_hash(void) const;
inline std::size_t LMatrix4f::get_hash(float threshold) const;

3205 8 add_hash 0 4 3624 19 LMatrix4f::add_hash 0 2 1412 1413 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;

3206 5 xform 0 4 3624 16 LMatrix4f::xform 0 1 1414 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const;

3207 11 xform_point 0 4 3624 22 LMatrix4f::xform_point 0 1 1415 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const;

3208 19 xform_point_general 0 4 3624 30 LMatrix4f::xform_point_general 0 1 1416 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const;

3209 9 xform_vec 0 4 3624 20 LMatrix4f::xform_vec 0 1 1417 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const;

3210 17 xform_vec_general 0 4 3624 28 LMatrix4f::xform_vec_general 0 1 1418 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const;

3211 14 xform_in_place 0 4 3624 25 LMatrix4f::xform_in_place 0 1 1419 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4f::xform_in_place(LVecBase4f &v) const;

3212 20 xform_point_in_place 0 4 3624 31 LMatrix4f::xform_point_in_place 0 1 1420 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const;

3213 28 xform_point_general_in_place 0 4 3624 39 LMatrix4f::xform_point_general_in_place 0 1 1421 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const;

3214 18 xform_vec_in_place 0 4 3624 29 LMatrix4f::xform_vec_in_place 0 1 1422 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const;

3215 26 xform_vec_general_in_place 0 4 3624 37 LMatrix4f::xform_vec_general_in_place 0 1 1423 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const;

3216 8 multiply 0 4 3624 19 LMatrix4f::multiply 0 1 1424 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2);

3217 10 operator * 0 4 3624 21 LMatrix4f::operator * 0 2 1425 1426 0
129
inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const;
inline LMatrix4f LMatrix4f::operator *(float scalar) const;

3218 10 operator / 0 4 3624 21 LMatrix4f::operator / 0 1 1427 0
59
inline LMatrix4f LMatrix4f::operator /(float scalar) const;

3219 11 operator += 0 4 3624 22 LMatrix4f::operator += 0 1 1428 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other);

3220 11 operator -= 0 4 3624 22 LMatrix4f::operator -= 0 1 1429 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other);

3221 11 operator *= 0 4 3624 22 LMatrix4f::operator *= 0 2 1430 1431 22
/**
 *
 */

/**
 *
 */
121
inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator *=(float scalar);

3222 11 operator /= 0 4 3624 22 LMatrix4f::operator /= 0 1 1432 10
/**
 *
 */
55
inline LMatrix4f &LMatrix4f::operator /=(float scalar);

3223 8 __rmul__ 0 4 3624 19 LMatrix4f::__rmul__ 0 1 1433 0
57
inline LMatrix4f LMatrix4f::__rmul__(float scalar) const;

3224 18 componentwise_mult 0 4 3624 29 LMatrix4f::componentwise_mult 0 1 1434 10
/**
 *
 */
66
inline void LMatrix4f::componentwise_mult(LMatrix4f const &other);

3225 14 transpose_from 0 4 3624 25 LMatrix4f::transpose_from 0 1 1435 10
/**
 *
 */
62
inline void LMatrix4f::transpose_from(LMatrix4f const &other);

3226 18 transpose_in_place 0 4 3624 29 LMatrix4f::transpose_in_place 0 1 1436 10
/**
 *
 */
48
inline void LMatrix4f::transpose_in_place(void);

3227 11 invert_from 0 4 3624 22 LMatrix4f::invert_from 0 1 1437 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4f::invert_from(LMatrix4f const &other);

3228 18 invert_affine_from 0 4 3624 29 LMatrix4f::invert_affine_from 0 1 1438 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other);

3229 15 invert_in_place 0 4 3624 26 LMatrix4f::invert_in_place 0 1 1439 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4f::invert_in_place(void);

3230 10 accumulate 0 4 3624 21 LMatrix4f::accumulate 0 1 1440 48
/**
 * Computes `(*this) += other * weight`.
 */
72
inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight);

3231 9 ident_mat 0 4 3624 20 LMatrix4f::ident_mat 0 1 1441 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4f const &LMatrix4f::ident_mat(void);

3232 8 ones_mat 0 4 3624 19 LMatrix4f::ones_mat 0 1 1442 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4f const &LMatrix4f::ones_mat(void);

3233 9 zeros_mat 0 4 3624 20 LMatrix4f::zeros_mat 0 1 1443 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4f const &LMatrix4f::zeros_mat(void);

3234 17 set_translate_mat 0 4 3624 28 LMatrix4f::set_translate_mat 0 1 1444 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans);

3235 14 set_rotate_mat 0 4 3624 25 LMatrix4f::set_rotate_mat 0 1 1445 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
104
void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3236 23 set_rotate_mat_normaxis 0 4 3624 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1446 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
113
void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3237 13 set_scale_mat 0 4 3624 24 LMatrix4f::set_scale_mat 0 1 1447 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale);

3238 13 set_shear_mat 0 4 3624 24 LMatrix4f::set_shear_mat 0 1 1448 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3239 19 set_scale_shear_mat 0 4 3624 30 LMatrix4f::set_scale_shear_mat 0 1 1449 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3240 13 translate_mat 0 4 3624 24 LMatrix4f::translate_mat 0 2 1450 1451 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
154
static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans);
static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);

3241 10 rotate_mat 0 4 3624 21 LMatrix4f::rotate_mat 0 1 1452 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
119
static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3242 19 rotate_mat_normaxis 0 4 3624 30 LMatrix4f::rotate_mat_normaxis 0 1 1453 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
128
static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3243 9 scale_mat 0 4 3624 20 LMatrix4f::scale_mat 0 3 1454 1455 1456 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
205
static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale);
static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);
static inline LMatrix4f LMatrix4f::scale_mat(float scale);

3244 9 shear_mat 0 4 3624 20 LMatrix4f::shear_mat 0 2 1457 1458 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3245 15 scale_shear_mat 0 4 3624 26 LMatrix4f::scale_shear_mat 0 2 1459 1460 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3246 13 y_to_z_up_mat 0 4 3624 24 LMatrix4f::y_to_z_up_mat 0 1 1461 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void);

3247 13 z_to_y_up_mat 0 4 3624 24 LMatrix4f::z_to_y_up_mat 0 1 1462 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void);

3248 11 convert_mat 0 4 3624 22 LMatrix4f::convert_mat 0 1 1463 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3249 12 almost_equal 0 4 3624 23 LMatrix4f::almost_equal 0 2 1464 1465 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
143
bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const;
inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const;

3250 6 output 0 4 3624 17 LMatrix4f::output 0 1 1466 10
/**
 *
 */
48
void LMatrix4f::output(std::ostream &out) const;

3251 5 write 0 4 3624 16 LMatrix4f::write 0 1 1467 10
/**
 *
 */
69
void LMatrix4f::write(std::ostream &out, int indent_level = 0) const;

3252 8 __repr__ 0 4 3624 19 LMatrix4f::__repr__ 0 1 1468 0
51
inline std::string LMatrix4f::__repr__(void) const;

3253 13 generate_hash 0 4 3624 24 LMatrix4f::generate_hash 0 2 1469 1470 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
157
inline void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen, float scale) const;

3254 20 write_datagram_fixed 0 4 3624 31 LMatrix4f::write_datagram_fixed 0 1 1471 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4f::write_datagram_fixed(Datagram &destination) const;

3255 19 read_datagram_fixed 0 4 3624 30 LMatrix4f::read_datagram_fixed 0 1 1472 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4f::read_datagram_fixed(DatagramIterator &scan);

3256 14 write_datagram 0 4 3624 25 LMatrix4f::write_datagram 0 1 1473 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4f::write_datagram(Datagram &destination) const;

3257 13 read_datagram 0 4 3624 24 LMatrix4f::read_datagram 0 1 1474 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4f::read_datagram(DatagramIterator &source);

3258 14 get_class_type 0 4 3624 25 LMatrix4f::get_class_type 0 1 1475 0
50
static TypeHandle LMatrix4f::get_class_type(void);

3259 10 ~LMatrix4f 0 516 3624 21 LMatrix4f::~LMatrix4f 0 0 0
28
LMatrix4f::~LMatrix4f(void);

3260 11 operator [] 0 4 3630 27 LMatrix3d::Row::operator [] 0 2 1589 1590 10
/**
 *
 */
106
inline double LMatrix3d::Row::operator [](int i) const;
inline double &LMatrix3d::Row::operator [](int i);

3261 12 operator []= 0 1028 3630 28 LMatrix3d::Row::operator []= 0 1 1591 0
67
void LMatrix3d::Row::operator []=(int i, double const &assign_val);

3262 4 size 0 4 3630 20 LMatrix3d::Row::size 0 1 1592 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3d::Row::size(void);

3263 17 operator typecast 0 132 3630 33 LMatrix3d::Row::operator typecast 0 1 1593 0
47
inline operator LVecBase3d const &(void) const;

3264 3 Row 0 260 3630 19 LMatrix3d::Row::Row 0 1 1588 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default;

3265 4 ~Row 0 516 3630 20 LMatrix3d::Row::~Row 0 0 0
27
LMatrix3d::Row::~Row(void);

3266 11 operator [] 0 4 3631 28 LMatrix3d::CRow::operator [] 0 1 1595 0
56
inline double LMatrix3d::CRow::operator [](int i) const;

3267 4 size 0 4 3631 21 LMatrix3d::CRow::size 0 1 1596 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3d::CRow::size(void);

3268 17 operator typecast 0 132 3631 34 LMatrix3d::CRow::operator typecast 0 1 1597 0
47
inline operator LVecBase3d const &(void) const;

3269 4 CRow 0 260 3631 21 LMatrix3d::CRow::CRow 0 1 1594 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default;

3270 5 ~CRow 0 516 3631 22 LMatrix3d::CRow::~CRow 0 0 0
29
LMatrix3d::CRow::~CRow(void);

3271 9 LMatrix3d 0 260 3628 20 LMatrix3d::LMatrix3d 0 4 1486 1487 1488 1489 72
/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
306
inline LMatrix3d::LMatrix3d(void) = default;
inline LMatrix3d::LMatrix3d(LMatrix3d const &other) = default;
inline LMatrix3d::LMatrix3d(double , double , double , double , double , double , double , double , double );
inline LMatrix3d::LMatrix3d(LVecBase3d const &, LVecBase3d const &, LVecBase3d const &);

3272 10 operator = 0 4 3628 21 LMatrix3d::operator = 0 2 1490 1491 10
/**
 *
 */
122
inline void LMatrix3d::operator =(LMatrix3d const &other) = default;
inline void LMatrix3d::operator =(double fill_value);

3273 12 operator new 0 4 3628 23 LMatrix3d::operator new 0 1 1492 0
122
inline void *LMatrix3d::operator new(std::size_t size);
inline void *LMatrix3d::operator new(std::size_t size, void *ptr);

3274 15 operator delete 0 4 3628 26 LMatrix3d::operator delete 0 0 0
106
inline void LMatrix3d::operator delete(void *ptr);
inline void LMatrix3d::operator delete(void *, void *);

3275 12 validate_ptr 0 4 3628 23 LMatrix3d::validate_ptr 0 0 0
60
static inline bool LMatrix3d::validate_ptr(void const *ptr);

3276 10 __reduce__ 0 4 3628 21 LMatrix3d::__reduce__ 0 1 1493 0
61
inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;

3277 4 fill 0 4 3628 15 LMatrix3d::fill 0 1 1494 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
40
void LMatrix3d::fill(double fill_value);

3278 3 set 0 4 3628 14 LMatrix3d::set 0 1 1495 10
/**
 *
 */
135
inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3279 11 operator [] 0 4 3628 22 LMatrix3d::operator [] 0 2 1496 1497 0
112
inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;
inline LMatrix3d::Row LMatrix3d::operator [](int i);

3280 4 size 0 4 3628 15 LMatrix3d::size 0 1 1498 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3d::size(void);

3281 7 set_row 0 4 3628 18 LMatrix3d::set_row 0 2 1499 1500 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3d::set_row(int row, LVecBase3d const &v);
inline void LMatrix3d::set_row(int row, LVecBase2d const &v);

3282 7 set_col 0 4 3628 18 LMatrix3d::set_col 0 2 1501 1502 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3d::set_col(int col, LVecBase3d const &v);
inline void LMatrix3d::set_col(int col, LVecBase2d const &v);

3283 7 get_row 0 4 3628 18 LMatrix3d::get_row 0 2 1503 1504 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3d LMatrix3d::get_row(int row) const;
inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const;

3284 7 get_col 0 4 3628 18 LMatrix3d::get_col 0 1 1505 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3d LMatrix3d::get_col(int col) const;

3285 8 get_row2 0 4 3628 19 LMatrix3d::get_row2 0 1 1506 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2d LMatrix3d::get_row2(int row) const;

3286 8 get_col2 0 4 3628 19 LMatrix3d::get_col2 0 1 1507 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2d LMatrix3d::get_col2(int col) const;

3287 11 operator () 0 4 3628 22 LMatrix3d::operator () 0 2 1508 1509 10
/**
 *
 */
118
inline double &LMatrix3d::operator ()(int row, int col);
inline double LMatrix3d::operator ()(int row, int col) const;

3288 6 is_nan 0 4 3628 17 LMatrix3d::is_nan 0 1 1510 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3d::is_nan(void) const;

3289 11 is_identity 0 4 3628 22 LMatrix3d::is_identity 0 1 1511 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3d::is_identity(void) const;

3290 8 get_cell 0 4 3628 19 LMatrix3d::get_cell 0 1 1512 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix3d::get_cell(int row, int col) const;

3291 8 set_cell 0 4 3628 19 LMatrix3d::set_cell 0 1 1513 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix3d::set_cell(int row, int col, double value);

3292 8 get_data 0 4 3628 19 LMatrix3d::get_data 0 1 1514 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix3d::get_data(void) const;

3293 18 get_num_components 0 4 3628 29 LMatrix3d::get_num_components 0 1 1515 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3d::get_num_components(void) const;

3294 10 operator < 0 4 3628 21 LMatrix3d::operator < 0 1 1516 0
64
inline bool LMatrix3d::operator <(LMatrix3d const &other) const;

3295 11 operator == 0 4 3628 22 LMatrix3d::operator == 0 1 1517 0
65
inline bool LMatrix3d::operator ==(LMatrix3d const &other) const;

3296 11 operator != 0 4 3628 22 LMatrix3d::operator != 0 1 1518 0
65
inline bool LMatrix3d::operator !=(LMatrix3d const &other) const;

3297 10 compare_to 0 4 3628 21 LMatrix3d::compare_to 0 2 1519 1520 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix3d::compare_to(LMatrix3d const &other) const;
int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const;

3298 8 get_hash 0 4 3628 19 LMatrix3d::get_hash 0 2 1521 1522 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix3d::get_hash(void) const;
inline std::size_t LMatrix3d::get_hash(double threshold) const;

3299 8 add_hash 0 4 3628 19 LMatrix3d::add_hash 0 2 1523 1524 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;

3300 5 xform 0 4 3628 16 LMatrix3d::xform 0 1 1525 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const;

3301 11 xform_point 0 4 3628 22 LMatrix3d::xform_point 0 1 1526 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const;

3302 9 xform_vec 0 4 3628 20 LMatrix3d::xform_vec 0 2 1527 1528 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const;
inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const;

3303 17 xform_vec_general 0 4 3628 28 LMatrix3d::xform_vec_general 0 1 1529 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const;

3304 14 xform_in_place 0 4 3628 25 LMatrix3d::xform_in_place 0 1 1530 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3d::xform_in_place(LVecBase3d &v) const;

3305 20 xform_point_in_place 0 4 3628 31 LMatrix3d::xform_point_in_place 0 1 1531 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const;

3306 18 xform_vec_in_place 0 4 3628 29 LMatrix3d::xform_vec_in_place 0 2 1532 1533 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const;
inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const;

3307 26 xform_vec_general_in_place 0 4 3628 37 LMatrix3d::xform_vec_general_in_place 0 1 1534 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const;

3308 8 multiply 0 4 3628 19 LMatrix3d::multiply 0 1 1535 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2);

3309 10 operator * 0 4 3628 21 LMatrix3d::operator * 0 2 1536 1537 0
130
inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const;
inline LMatrix3d LMatrix3d::operator *(double scalar) const;

3310 10 operator / 0 4 3628 21 LMatrix3d::operator / 0 1 1538 0
60
inline LMatrix3d LMatrix3d::operator /(double scalar) const;

3311 11 operator += 0 4 3628 22 LMatrix3d::operator += 0 1 1539 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other);

3312 11 operator -= 0 4 3628 22 LMatrix3d::operator -= 0 1 1540 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other);

3313 11 operator *= 0 4 3628 22 LMatrix3d::operator *= 0 2 1541 1542 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
122
inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator *=(double scalar);

3314 11 operator /= 0 4 3628 22 LMatrix3d::operator /= 0 1 1543 39
/**
 * Performs a memberwise scale.
 */
56
inline LMatrix3d &LMatrix3d::operator /=(double scalar);

3315 8 __rmul__ 0 4 3628 19 LMatrix3d::__rmul__ 0 1 1544 0
58
inline LMatrix3d LMatrix3d::__rmul__(double scalar) const;

3316 18 componentwise_mult 0 4 3628 29 LMatrix3d::componentwise_mult 0 1 1545 10
/**
 *
 */
66
inline void LMatrix3d::componentwise_mult(LMatrix3d const &other);

3317 11 determinant 0 4 3628 22 LMatrix3d::determinant 0 1 1546 49
/**
 * Returns the determinant of the matrix.
 */
49
inline double LMatrix3d::determinant(void) const;

3318 14 transpose_from 0 4 3628 25 LMatrix3d::transpose_from 0 1 1547 10
/**
 *
 */
62
inline void LMatrix3d::transpose_from(LMatrix3d const &other);

3319 18 transpose_in_place 0 4 3628 29 LMatrix3d::transpose_in_place 0 1 1548 10
/**
 *
 */
48
inline void LMatrix3d::transpose_in_place(void);

3320 11 invert_from 0 4 3628 22 LMatrix3d::invert_from 0 1 1549 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3d::invert_from(LMatrix3d const &other);

3321 15 invert_in_place 0 4 3628 26 LMatrix3d::invert_in_place 0 1 1550 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3d::invert_in_place(void);

3322 21 invert_transpose_from 0 4 3628 32 LMatrix3d::invert_transpose_from 0 2 1551 1552 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other);
inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other);

3323 9 ident_mat 0 4 3628 20 LMatrix3d::ident_mat 0 1 1553 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3d const &LMatrix3d::ident_mat(void);

3324 17 set_translate_mat 0 4 3628 28 LMatrix3d::set_translate_mat 0 1 1554 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans);

3325 14 set_rotate_mat 0 4 3628 25 LMatrix3d::set_rotate_mat 0 2 1555 1556 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
158
inline void LMatrix3d::set_rotate_mat(double angle);
void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3326 13 set_scale_mat 0 4 3628 24 LMatrix3d::set_scale_mat 0 2 1557 1558 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale);
inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale);

3327 13 translate_mat 0 4 3628 24 LMatrix3d::translate_mat 0 2 1559 1560 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
146
static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans);
static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);

3328 10 rotate_mat 0 4 3628 21 LMatrix3d::rotate_mat 0 2 1561 1562 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
181
static inline LMatrix3d LMatrix3d::rotate_mat(double angle);
static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3329 9 scale_mat 0 4 3628 20 LMatrix3d::scale_mat 0 4 1563 1564 1565 1566 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
288
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);

3330 23 set_rotate_mat_normaxis 0 4 3628 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1567 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
114
void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3331 19 rotate_mat_normaxis 0 4 3628 30 LMatrix3d::rotate_mat_normaxis 0 1 1568 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
129
static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3332 13 set_shear_mat 0 4 3628 24 LMatrix3d::set_shear_mat 0 1 1569 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3333 9 shear_mat 0 4 3628 20 LMatrix3d::shear_mat 0 2 1570 1571 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3334 19 set_scale_shear_mat 0 4 3628 30 LMatrix3d::set_scale_shear_mat 0 1 1572 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3335 15 scale_shear_mat 0 4 3628 26 LMatrix3d::scale_shear_mat 0 2 1573 1574 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3336 11 convert_mat 0 4 3628 22 LMatrix3d::convert_mat 0 1 1575 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3337 12 almost_equal 0 4 3628 23 LMatrix3d::almost_equal 0 2 1576 1577 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
144
bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const;
inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const;

3338 6 output 0 4 3628 17 LMatrix3d::output 0 1 1578 10
/**
 *
 */
48
void LMatrix3d::output(std::ostream &out) const;

3339 5 write 0 4 3628 16 LMatrix3d::write 0 1 1579 10
/**
 *
 */
69
void LMatrix3d::write(std::ostream &out, int indent_level = 0) const;

3340 8 __repr__ 0 4 3628 19 LMatrix3d::__repr__ 0 1 1580 0
51
inline std::string LMatrix3d::__repr__(void) const;

3341 13 generate_hash 0 4 3628 24 LMatrix3d::generate_hash 0 2 1581 1582 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
162
inline void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

3342 20 write_datagram_fixed 0 4 3628 31 LMatrix3d::write_datagram_fixed 0 1 1583 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3d::write_datagram_fixed(Datagram &destination) const;

3343 19 read_datagram_fixed 0 4 3628 30 LMatrix3d::read_datagram_fixed 0 1 1584 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3d::read_datagram_fixed(DatagramIterator &scan);

3344 14 write_datagram 0 4 3628 25 LMatrix3d::write_datagram 0 1 1585 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3d::write_datagram(Datagram &destination) const;

3345 13 read_datagram 0 4 3628 24 LMatrix3d::read_datagram 0 1 1586 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3d::read_datagram(DatagramIterator &source);

3346 14 get_class_type 0 4 3628 25 LMatrix3d::get_class_type 0 1 1587 0
50
static TypeHandle LMatrix3d::get_class_type(void);

3347 10 ~LMatrix3d 0 516 3628 21 LMatrix3d::~LMatrix3d 0 0 0
28
LMatrix3d::~LMatrix3d(void);

3348 11 operator [] 0 4 3634 27 LMatrix4d::Row::operator [] 0 2 1709 1710 10
/**
 *
 */
106
inline double LMatrix4d::Row::operator [](int i) const;
inline double &LMatrix4d::Row::operator [](int i);

3349 12 operator []= 0 1028 3634 28 LMatrix4d::Row::operator []= 0 1 1711 0
67
void LMatrix4d::Row::operator []=(int i, double const &assign_val);

3350 4 size 0 4 3634 20 LMatrix4d::Row::size 0 1 1712 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4d::Row::size(void);

3351 17 operator typecast 0 132 3634 33 LMatrix4d::Row::operator typecast 0 1 1713 0
47
inline operator LVecBase4d const &(void) const;

3352 3 Row 0 260 3634 19 LMatrix4d::Row::Row 0 1 1708 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default;

3353 4 ~Row 0 516 3634 20 LMatrix4d::Row::~Row 0 0 0
27
LMatrix4d::Row::~Row(void);

3354 11 operator [] 0 4 3635 28 LMatrix4d::CRow::operator [] 0 1 1715 0
56
inline double LMatrix4d::CRow::operator [](int i) const;

3355 4 size 0 4 3635 21 LMatrix4d::CRow::size 0 1 1716 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4d::CRow::size(void);

3356 17 operator typecast 0 132 3635 34 LMatrix4d::CRow::operator typecast 0 1 1717 0
47
inline operator LVecBase4d const &(void) const;

3357 4 CRow 0 260 3635 21 LMatrix4d::CRow::CRow 0 1 1714 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default;

3358 5 ~CRow 0 516 3635 22 LMatrix4d::CRow::~CRow 0 0 0
29
LMatrix4d::CRow::~CRow(void);

3359 9 LMatrix4d 0 260 3632 20 LMatrix4d::LMatrix4d 0 6 1598 1599 1600 1601 1602 1603 192
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
531
inline LMatrix4d::LMatrix4d(void) = default;
inline LMatrix4d::LMatrix4d(LMatrix4d const &other) = default;
inline LMatrix4d::LMatrix4d(double , double , double , double , double , double , double , double , double , double , double , double , double , double , double , double );
inline LMatrix4d::LMatrix4d(LVecBase4d const &, LVecBase4d const &, LVecBase4d const &, LVecBase4d const &);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3);
inline explicit LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans);

3360 10 operator = 0 4 3632 21 LMatrix4d::operator = 0 2 1604 1605 10
/**
 *
 */
122
inline void LMatrix4d::operator =(LMatrix4d const &other) = default;
inline void LMatrix4d::operator =(double fill_value);

3361 12 operator new 0 4 3632 23 LMatrix4d::operator new 0 1 1606 0
122
inline void *LMatrix4d::operator new(std::size_t size);
inline void *LMatrix4d::operator new(std::size_t size, void *ptr);

3362 15 operator delete 0 4 3632 26 LMatrix4d::operator delete 0 0 0
106
inline void LMatrix4d::operator delete(void *ptr);
inline void LMatrix4d::operator delete(void *, void *);

3363 12 validate_ptr 0 4 3632 23 LMatrix4d::validate_ptr 0 0 0
60
static inline bool LMatrix4d::validate_ptr(void const *ptr);

3364 10 __reduce__ 0 4 3632 21 LMatrix4d::__reduce__ 0 1 1607 0
61
inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;

3365 4 fill 0 4 3632 15 LMatrix4d::fill 0 1 1608 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
47
inline void LMatrix4d::fill(double fill_value);

3366 3 set 0 4 3632 14 LMatrix4d::set 0 1 1609 10
/**
 *
 */
219
inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3367 11 set_upper_3 0 4 3632 22 LMatrix4d::set_upper_3 0 1 1610 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3);

3368 11 get_upper_3 0 4 3632 22 LMatrix4d::get_upper_3 0 1 1611 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3d LMatrix4d::get_upper_3(void) const;

3369 11 operator [] 0 4 3632 22 LMatrix4d::operator [] 0 2 1612 1613 0
112
inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;
inline LMatrix4d::Row LMatrix4d::operator [](int i);

3370 4 size 0 4 3632 15 LMatrix4d::size 0 1 1614 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4d::size(void);

3371 7 set_row 0 4 3632 18 LMatrix4d::set_row 0 2 1615 1616 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4d::set_row(int row, LVecBase4d const &v);
inline void LMatrix4d::set_row(int row, LVecBase3d const &v);

3372 7 set_col 0 4 3632 18 LMatrix4d::set_col 0 2 1617 1618 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4d::set_col(int col, LVecBase4d const &v);
inline void LMatrix4d::set_col(int col, LVecBase3d const &v);

3373 7 get_row 0 4 3632 18 LMatrix4d::get_row 0 2 1619 1620 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4d LMatrix4d::get_row(int row) const;
inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const;

3374 7 get_col 0 4 3632 18 LMatrix4d::get_col 0 1 1621 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4d LMatrix4d::get_col(int col) const;

3375 8 get_row3 0 4 3632 19 LMatrix4d::get_row3 0 2 1622 1623 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3d LMatrix4d::get_row3(int row) const;
inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const;

3376 8 get_col3 0 4 3632 19 LMatrix4d::get_col3 0 1 1624 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3d LMatrix4d::get_col3(int col) const;

3377 11 operator () 0 4 3632 22 LMatrix4d::operator () 0 2 1625 1626 10
/**
 *
 */
118
inline double &LMatrix4d::operator ()(int row, int col);
inline double LMatrix4d::operator ()(int row, int col) const;

3378 6 is_nan 0 4 3632 17 LMatrix4d::is_nan 0 1 1627 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4d::is_nan(void) const;

3379 11 is_identity 0 4 3632 22 LMatrix4d::is_identity 0 1 1628 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4d::is_identity(void) const;

3380 8 get_cell 0 4 3632 19 LMatrix4d::get_cell 0 1 1629 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix4d::get_cell(int row, int col) const;

3381 8 set_cell 0 4 3632 19 LMatrix4d::set_cell 0 1 1630 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix4d::set_cell(int row, int col, double value);

3382 8 get_data 0 4 3632 19 LMatrix4d::get_data 0 1 1631 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix4d::get_data(void) const;

3383 18 get_num_components 0 4 3632 29 LMatrix4d::get_num_components 0 1 1632 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4d::get_num_components(void) const;

3384 5 begin 0 4 3632 16 LMatrix4d::begin 0 2 1633 1634 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4d::iterator LMatrix4d::begin(void);
inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;

3385 3 end 0 4 3632 14 LMatrix4d::end 0 2 1635 1636 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4d::iterator LMatrix4d::end(void);
inline LMatrix4d::const_iterator LMatrix4d::end(void) const;

3386 10 operator < 0 4 3632 21 LMatrix4d::operator < 0 1 1637 0
64
inline bool LMatrix4d::operator <(LMatrix4d const &other) const;

3387 11 operator == 0 4 3632 22 LMatrix4d::operator == 0 1 1638 0
65
inline bool LMatrix4d::operator ==(LMatrix4d const &other) const;

3388 11 operator != 0 4 3632 22 LMatrix4d::operator != 0 1 1639 0
65
inline bool LMatrix4d::operator !=(LMatrix4d const &other) const;

3389 10 compare_to 0 4 3632 21 LMatrix4d::compare_to 0 2 1640 1641 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix4d::compare_to(LMatrix4d const &other) const;
int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const;

3390 8 get_hash 0 4 3632 19 LMatrix4d::get_hash 0 2 1642 1643 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix4d::get_hash(void) const;
inline std::size_t LMatrix4d::get_hash(double threshold) const;

3391 8 add_hash 0 4 3632 19 LMatrix4d::add_hash 0 2 1644 1645 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;

3392 5 xform 0 4 3632 16 LMatrix4d::xform 0 1 1646 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const;

3393 11 xform_point 0 4 3632 22 LMatrix4d::xform_point 0 1 1647 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const;

3394 19 xform_point_general 0 4 3632 30 LMatrix4d::xform_point_general 0 1 1648 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const;

3395 9 xform_vec 0 4 3632 20 LMatrix4d::xform_vec 0 1 1649 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const;

3396 17 xform_vec_general 0 4 3632 28 LMatrix4d::xform_vec_general 0 1 1650 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const;

3397 14 xform_in_place 0 4 3632 25 LMatrix4d::xform_in_place 0 1 1651 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4d::xform_in_place(LVecBase4d &v) const;

3398 20 xform_point_in_place 0 4 3632 31 LMatrix4d::xform_point_in_place 0 1 1652 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const;

3399 28 xform_point_general_in_place 0 4 3632 39 LMatrix4d::xform_point_general_in_place 0 1 1653 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const;

3400 18 xform_vec_in_place 0 4 3632 29 LMatrix4d::xform_vec_in_place 0 1 1654 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const;

3401 26 xform_vec_general_in_place 0 4 3632 37 LMatrix4d::xform_vec_general_in_place 0 1 1655 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const;

3402 8 multiply 0 4 3632 19 LMatrix4d::multiply 0 1 1656 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2);

3403 10 operator * 0 4 3632 21 LMatrix4d::operator * 0 2 1657 1658 0
130
inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const;
inline LMatrix4d LMatrix4d::operator *(double scalar) const;

3404 10 operator / 0 4 3632 21 LMatrix4d::operator / 0 1 1659 0
60
inline LMatrix4d LMatrix4d::operator /(double scalar) const;

3405 11 operator += 0 4 3632 22 LMatrix4d::operator += 0 1 1660 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other);

3406 11 operator -= 0 4 3632 22 LMatrix4d::operator -= 0 1 1661 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other);

3407 11 operator *= 0 4 3632 22 LMatrix4d::operator *= 0 2 1662 1663 22
/**
 *
 */

/**
 *
 */
122
inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator *=(double scalar);

3408 11 operator /= 0 4 3632 22 LMatrix4d::operator /= 0 1 1664 10
/**
 *
 */
56
inline LMatrix4d &LMatrix4d::operator /=(double scalar);

3409 8 __rmul__ 0 4 3632 19 LMatrix4d::__rmul__ 0 1 1665 0
58
inline LMatrix4d LMatrix4d::__rmul__(double scalar) const;

3410 18 componentwise_mult 0 4 3632 29 LMatrix4d::componentwise_mult 0 1 1666 10
/**
 *
 */
66
inline void LMatrix4d::componentwise_mult(LMatrix4d const &other);

3411 14 transpose_from 0 4 3632 25 LMatrix4d::transpose_from 0 1 1667 10
/**
 *
 */
62
inline void LMatrix4d::transpose_from(LMatrix4d const &other);

3412 18 transpose_in_place 0 4 3632 29 LMatrix4d::transpose_in_place 0 1 1668 10
/**
 *
 */
48
inline void LMatrix4d::transpose_in_place(void);

3413 11 invert_from 0 4 3632 22 LMatrix4d::invert_from 0 1 1669 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4d::invert_from(LMatrix4d const &other);

3414 18 invert_affine_from 0 4 3632 29 LMatrix4d::invert_affine_from 0 1 1670 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other);

3415 15 invert_in_place 0 4 3632 26 LMatrix4d::invert_in_place 0 1 1671 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4d::invert_in_place(void);

3416 10 accumulate 0 4 3632 21 LMatrix4d::accumulate 0 1 1672 48
/**
 * Computes `(*this) += other * weight`.
 */
73
inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight);

3417 9 ident_mat 0 4 3632 20 LMatrix4d::ident_mat 0 1 1673 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4d const &LMatrix4d::ident_mat(void);

3418 8 ones_mat 0 4 3632 19 LMatrix4d::ones_mat 0 1 1674 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4d const &LMatrix4d::ones_mat(void);

3419 9 zeros_mat 0 4 3632 20 LMatrix4d::zeros_mat 0 1 1675 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4d const &LMatrix4d::zeros_mat(void);

3420 17 set_translate_mat 0 4 3632 28 LMatrix4d::set_translate_mat 0 1 1676 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans);

3421 14 set_rotate_mat 0 4 3632 25 LMatrix4d::set_rotate_mat 0 1 1677 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
105
void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3422 23 set_rotate_mat_normaxis 0 4 3632 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1678 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
114
void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3423 13 set_scale_mat 0 4 3632 24 LMatrix4d::set_scale_mat 0 1 1679 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale);

3424 13 set_shear_mat 0 4 3632 24 LMatrix4d::set_shear_mat 0 1 1680 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3425 19 set_scale_shear_mat 0 4 3632 30 LMatrix4d::set_scale_shear_mat 0 1 1681 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3426 13 translate_mat 0 4 3632 24 LMatrix4d::translate_mat 0 2 1682 1683 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
157
static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans);
static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);

3427 10 rotate_mat 0 4 3632 21 LMatrix4d::rotate_mat 0 1 1684 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
120
static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3428 19 rotate_mat_normaxis 0 4 3632 30 LMatrix4d::rotate_mat_normaxis 0 1 1685 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
129
static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3429 9 scale_mat 0 4 3632 20 LMatrix4d::scale_mat 0 3 1686 1687 1688 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
209
static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale);
static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);
static inline LMatrix4d LMatrix4d::scale_mat(double scale);

3430 9 shear_mat 0 4 3632 20 LMatrix4d::shear_mat 0 2 1689 1690 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3431 15 scale_shear_mat 0 4 3632 26 LMatrix4d::scale_shear_mat 0 2 1691 1692 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3432 13 y_to_z_up_mat 0 4 3632 24 LMatrix4d::y_to_z_up_mat 0 1 1693 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void);

3433 13 z_to_y_up_mat 0 4 3632 24 LMatrix4d::z_to_y_up_mat 0 1 1694 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void);

3434 11 convert_mat 0 4 3632 22 LMatrix4d::convert_mat 0 1 1695 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3435 12 almost_equal 0 4 3632 23 LMatrix4d::almost_equal 0 2 1696 1697 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
144
bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const;
inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const;

3436 6 output 0 4 3632 17 LMatrix4d::output 0 1 1698 10
/**
 *
 */
48
void LMatrix4d::output(std::ostream &out) const;

3437 5 write 0 4 3632 16 LMatrix4d::write 0 1 1699 10
/**
 *
 */
69
void LMatrix4d::write(std::ostream &out, int indent_level = 0) const;

3438 8 __repr__ 0 4 3632 19 LMatrix4d::__repr__ 0 1 1700 0
51
inline std::string LMatrix4d::__repr__(void) const;

3439 13 generate_hash 0 4 3632 24 LMatrix4d::generate_hash 0 2 1701 1702 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
158
inline void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen, double scale) const;

3440 20 write_datagram_fixed 0 4 3632 31 LMatrix4d::write_datagram_fixed 0 1 1703 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4d::write_datagram_fixed(Datagram &destination) const;

3441 19 read_datagram_fixed 0 4 3632 30 LMatrix4d::read_datagram_fixed 0 1 1704 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4d::read_datagram_fixed(DatagramIterator &scan);

3442 14 write_datagram 0 4 3632 25 LMatrix4d::write_datagram 0 1 1705 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4d::write_datagram(Datagram &destination) const;

3443 13 read_datagram 0 4 3632 24 LMatrix4d::read_datagram 0 1 1706 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4d::read_datagram(DatagramIterator &source);

3444 14 get_class_type 0 4 3632 25 LMatrix4d::get_class_type 0 1 1707 0
50
static TypeHandle LMatrix4d::get_class_type(void);

3445 10 ~LMatrix4d 0 516 3632 21 LMatrix4d::~LMatrix4d 0 0 0
28
LMatrix4d::~LMatrix4d(void);

3446 10 operator * 0 1 0 10 operator * 0 24 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 0
1659
inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m);
inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m);
inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m);
inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m);
inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m);
inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m);
inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m);
inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m);
inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m);
inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m);
inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m);
inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m);
inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q);
inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q);
inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q);
inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q);

3447 11 operator *= 0 1 0 11 operator *= 0 16 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 0
941
inline void operator *=(LVecBase3f &v, LMatrix3f const &m);
inline void operator *=(LVector3f &v, LMatrix3f const &m);
inline void operator *=(LPoint3f &v, LMatrix3f const &m);
inline void operator *=(LVector2f &v, LMatrix3f const &m);
inline void operator *=(LPoint2f &v, LMatrix3f const &m);
inline void operator *=(LVecBase4f &v, LMatrix4f const &m);
inline void operator *=(LVector3f &v, LMatrix4f const &m);
inline void operator *=(LPoint3f &v, LMatrix4f const &m);
inline void operator *=(LVecBase3d &v, LMatrix3d const &m);
inline void operator *=(LVector3d &v, LMatrix3d const &m);
inline void operator *=(LPoint3d &v, LMatrix3d const &m);
inline void operator *=(LVector2d &v, LMatrix3d const &m);
inline void operator *=(LPoint2d &v, LMatrix3d const &m);
inline void operator *=(LVecBase4d &v, LMatrix4d const &m);
inline void operator *=(LVector3d &v, LMatrix4d const &m);
inline void operator *=(LPoint3d &v, LMatrix4d const &m);

3448 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 1952 1953 1954 1955 0
303
inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value);

3449 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 1956 1957 1958 1959 0
319
inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source);

3450 14 compose_matrix 0 1 0 14 compose_matrix 0 10 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 0
1484
void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);

3451 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 0
1408
bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);

3452 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 1980 1981 0
287
bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);

3453 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 1982 1983 0
107
LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr);
LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr);

3454 12 LQuaternionf 0 260 3636 26 LQuaternionf::LQuaternionf 0 5 1718 1719 1720 1721 1722 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
314
inline LQuaternionf::LQuaternionf(void);
inline LQuaternionf::LQuaternionf(LVecBase4f const &copy);
inline explicit LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy);
inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);
inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default;

3455 14 pure_imaginary 0 4 3636 28 LQuaternionf::pure_imaginary 0 1 1723 10
/**
 *
 */
69
static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v);

3456 9 conjugate 0 4 3636 23 LQuaternionf::conjugate 0 1 1724 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaternionf LQuaternionf::conjugate(void) const;

3457 5 xform 0 4 3636 19 LQuaternionf::xform 0 2 1725 1726 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const;
inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const;

3458 8 multiply 0 4 3636 22 LQuaternionf::multiply 0 1 1727 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const;

3459 10 operator - 0 68 3636 24 LQuaternionf::operator - 0 1 1728 0
57
inline LQuaternionf LQuaternionf::operator -(void) const;

3460 10 operator + 0 4 3636 24 LQuaternionf::operator + 0 1 1729 0
78
inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const;

3461 10 operator - 0 4 3636 24 LQuaternionf::operator - 0 1 1730 0
78
inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const;

3462 9 angle_rad 0 4 3636 23 LQuaternionf::angle_rad 0 1 1731 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
70
inline float LQuaternionf::angle_rad(LQuaternionf const &other) const;

3463 9 angle_deg 0 4 3636 23 LQuaternionf::angle_deg 0 1 1732 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
70
inline float LQuaternionf::angle_deg(LQuaternionf const &other) const;

3464 10 operator * 0 4 3636 24 LQuaternionf::operator * 0 4 1733 1734 1735 1736 0
263
inline LQuaternionf LQuaternionf::operator *(float scalar) const;
inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const;
inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &);
inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &);

3465 10 operator / 0 4 3636 24 LQuaternionf::operator / 0 1 1737 0
65
inline LQuaternionf LQuaternionf::operator /(float scalar) const;

3466 11 operator *= 0 4 3636 25 LQuaternionf::operator *= 0 1 1738 10
/**
 *
 */
69
inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &);

3467 7 __pow__ 0 4 3636 21 LQuaternionf::__pow__ 0 1 1739 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
49
LQuaternionf LQuaternionf::__pow__(float ) const;

3468 12 almost_equal 0 4 3636 26 LQuaternionf::almost_equal 0 2 1740 1741 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
162
inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const;
inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const;

3469 17 is_same_direction 0 4 3636 31 LQuaternionf::is_same_direction 0 1 1742 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const;

3470 21 almost_same_direction 0 4 3636 35 LQuaternionf::almost_same_direction 0 1 1743 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
98
inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const;

3471 6 output 0 4 3636 20 LQuaternionf::output 0 1 1744 10
/**
 *
 */
55
inline void LQuaternionf::output(std::ostream &) const;

3472 17 extract_to_matrix 0 4 3636 31 LQuaternionf::extract_to_matrix 0 2 1745 1746 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaternionf::extract_to_matrix(LMatrix3f &m) const;
void LQuaternionf::extract_to_matrix(LMatrix4f &m) const;

3473 15 set_from_matrix 0 4 3636 29 LQuaternionf::set_from_matrix 0 2 1747 1748 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaternionf::set_from_matrix(LMatrix3f const &m);
inline void LQuaternionf::set_from_matrix(LMatrix4f const &m);

3474 7 set_hpr 0 4 3636 21 LQuaternionf::set_hpr 0 1 1749 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);

3475 7 get_hpr 0 4 3636 21 LQuaternionf::get_hpr 0 1 1750 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;

3476 8 get_axis 0 4 3636 22 LQuaternionf::get_axis 0 1 1751 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3f LQuaternionf::get_axis(void) const;

3477 19 get_axis_normalized 0 4 3636 33 LQuaternionf::get_axis_normalized 0 1 1752 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3f LQuaternionf::get_axis_normalized(void) const;

3478 13 get_angle_rad 0 4 3636 27 LQuaternionf::get_angle_rad 0 1 1753 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
53
inline float LQuaternionf::get_angle_rad(void) const;

3479 9 get_angle 0 4 3636 23 LQuaternionf::get_angle 0 1 1754 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
49
inline float LQuaternionf::get_angle(void) const;

3480 23 set_from_axis_angle_rad 0 4 3636 37 LQuaternionf::set_from_axis_angle_rad 0 1 1755 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
90
inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis);

3481 19 set_from_axis_angle 0 4 3636 33 LQuaternionf::set_from_axis_angle 0 1 1756 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
86
inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis);

3482 6 get_up 0 4 3636 20 LQuaternionf::get_up 0 1 1757 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;

3483 9 get_right 0 4 3636 23 LQuaternionf::get_right 0 1 1758 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;

3484 11 get_forward 0 4 3636 25 LQuaternionf::get_forward 0 1 1759 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;

3485 5 get_r 0 4 3636 19 LQuaternionf::get_r 0 1 1760 10
/**
 *
 */
45
inline float LQuaternionf::get_r(void) const;

3486 5 get_i 0 4 3636 19 LQuaternionf::get_i 0 1 1761 10
/**
 *
 */
45
inline float LQuaternionf::get_i(void) const;

3487 5 get_j 0 4 3636 19 LQuaternionf::get_j 0 1 1762 10
/**
 *
 */
45
inline float LQuaternionf::get_j(void) const;

3488 5 get_k 0 4 3636 19 LQuaternionf::get_k 0 1 1763 10
/**
 *
 */
45
inline float LQuaternionf::get_k(void) const;

3489 5 set_r 0 4 3636 19 LQuaternionf::set_r 0 1 1764 10
/**
 *
 */
41
inline void LQuaternionf::set_r(float r);

3490 5 set_i 0 4 3636 19 LQuaternionf::set_i 0 1 1765 10
/**
 *
 */
41
inline void LQuaternionf::set_i(float i);

3491 5 set_j 0 4 3636 19 LQuaternionf::set_j 0 1 1766 10
/**
 *
 */
41
inline void LQuaternionf::set_j(float j);

3492 5 set_k 0 4 3636 19 LQuaternionf::set_k 0 1 1767 10
/**
 *
 */
41
inline void LQuaternionf::set_k(float k);

3493 9 normalize 0 4 3636 23 LQuaternionf::normalize 0 1 1768 10
/**
 *
 */
42
inline bool LQuaternionf::normalize(void);

3494 14 conjugate_from 0 4 3636 28 LQuaternionf::conjugate_from 0 1 1769 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaternionf::conjugate_from(LQuaternionf const &other);

3495 18 conjugate_in_place 0 4 3636 32 LQuaternionf::conjugate_in_place 0 1 1770 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaternionf::conjugate_in_place(void);

3496 11 invert_from 0 4 3636 25 LQuaternionf::invert_from 0 1 1771 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaternionf::invert_from(LQuaternionf const &other);

3497 15 invert_in_place 0 4 3636 29 LQuaternionf::invert_in_place 0 1 1772 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaternionf::invert_in_place(void);

3498 11 is_identity 0 4 3636 25 LQuaternionf::is_identity 0 1 1773 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaternionf::is_identity(void) const;

3499 18 is_almost_identity 0 4 3636 32 LQuaternionf::is_almost_identity 0 1 1774 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
68
inline bool LQuaternionf::is_almost_identity(float tolerance) const;

3500 10 ident_quat 0 4 3636 24 LQuaternionf::ident_quat 0 1 1775 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaternionf const &LQuaternionf::ident_quat(void);

3501 14 get_class_type 0 4 3636 28 LQuaternionf::get_class_type 0 1 1776 0
53
static TypeHandle LQuaternionf::get_class_type(void);

3502 13 ~LQuaternionf 0 516 3636 27 LQuaternionf::~LQuaternionf 0 0 0
34
LQuaternionf::~LQuaternionf(void);

3503 12 LQuaterniond 0 260 3637 26 LQuaterniond::LQuaterniond 0 5 1777 1778 1779 1780 1781 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
319
inline LQuaterniond::LQuaterniond(void);
inline LQuaterniond::LQuaterniond(LVecBase4d const &copy);
inline explicit LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy);
inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);
inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default;

3504 14 pure_imaginary 0 4 3637 28 LQuaterniond::pure_imaginary 0 1 1782 10
/**
 *
 */
69
static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v);

3505 9 conjugate 0 4 3637 23 LQuaterniond::conjugate 0 1 1783 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaterniond LQuaterniond::conjugate(void) const;

3506 5 xform 0 4 3637 19 LQuaterniond::xform 0 2 1784 1785 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const;
inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const;

3507 8 multiply 0 4 3637 22 LQuaterniond::multiply 0 1 1786 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const;

3508 10 operator - 0 68 3637 24 LQuaterniond::operator - 0 1 1787 0
57
inline LQuaterniond LQuaterniond::operator -(void) const;

3509 10 operator + 0 4 3637 24 LQuaterniond::operator + 0 1 1788 0
78
inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const;

3510 10 operator - 0 4 3637 24 LQuaterniond::operator - 0 1 1789 0
78
inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const;

3511 9 angle_rad 0 4 3637 23 LQuaterniond::angle_rad 0 1 1790 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
71
inline double LQuaterniond::angle_rad(LQuaterniond const &other) const;

3512 9 angle_deg 0 4 3637 23 LQuaterniond::angle_deg 0 1 1791 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
71
inline double LQuaterniond::angle_deg(LQuaterniond const &other) const;

3513 10 operator * 0 4 3637 24 LQuaterniond::operator * 0 4 1792 1793 1794 1795 0
264
inline LQuaterniond LQuaterniond::operator *(double scalar) const;
inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const;
inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &);
inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &);

3514 10 operator / 0 4 3637 24 LQuaterniond::operator / 0 1 1796 0
66
inline LQuaterniond LQuaterniond::operator /(double scalar) const;

3515 11 operator *= 0 4 3637 25 LQuaterniond::operator *= 0 1 1797 10
/**
 *
 */
69
inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &);

3516 7 __pow__ 0 4 3637 21 LQuaterniond::__pow__ 0 1 1798 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
50
LQuaterniond LQuaterniond::__pow__(double ) const;

3517 12 almost_equal 0 4 3637 26 LQuaterniond::almost_equal 0 2 1799 1800 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
163
inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const;
inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const;

3518 17 is_same_direction 0 4 3637 31 LQuaterniond::is_same_direction 0 1 1801 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const;

3519 21 almost_same_direction 0 4 3637 35 LQuaterniond::almost_same_direction 0 1 1802 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
99
inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const;

3520 6 output 0 4 3637 20 LQuaterniond::output 0 1 1803 10
/**
 *
 */
55
inline void LQuaterniond::output(std::ostream &) const;

3521 17 extract_to_matrix 0 4 3637 31 LQuaterniond::extract_to_matrix 0 2 1804 1805 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaterniond::extract_to_matrix(LMatrix3d &m) const;
void LQuaterniond::extract_to_matrix(LMatrix4d &m) const;

3522 15 set_from_matrix 0 4 3637 29 LQuaterniond::set_from_matrix 0 2 1806 1807 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaterniond::set_from_matrix(LMatrix3d const &m);
inline void LQuaterniond::set_from_matrix(LMatrix4d const &m);

3523 7 set_hpr 0 4 3637 21 LQuaterniond::set_hpr 0 1 1808 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);

3524 7 get_hpr 0 4 3637 21 LQuaterniond::get_hpr 0 1 1809 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;

3525 8 get_axis 0 4 3637 22 LQuaterniond::get_axis 0 1 1810 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3d LQuaterniond::get_axis(void) const;

3526 19 get_axis_normalized 0 4 3637 33 LQuaterniond::get_axis_normalized 0 1 1811 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3d LQuaterniond::get_axis_normalized(void) const;

3527 13 get_angle_rad 0 4 3637 27 LQuaterniond::get_angle_rad 0 1 1812 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
54
inline double LQuaterniond::get_angle_rad(void) const;

3528 9 get_angle 0 4 3637 23 LQuaterniond::get_angle 0 1 1813 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
50
inline double LQuaterniond::get_angle(void) const;

3529 23 set_from_axis_angle_rad 0 4 3637 37 LQuaterniond::set_from_axis_angle_rad 0 1 1814 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
91
inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis);

3530 19 set_from_axis_angle 0 4 3637 33 LQuaterniond::set_from_axis_angle 0 1 1815 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
87
inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis);

3531 6 get_up 0 4 3637 20 LQuaterniond::get_up 0 1 1816 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;

3532 9 get_right 0 4 3637 23 LQuaterniond::get_right 0 1 1817 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;

3533 11 get_forward 0 4 3637 25 LQuaterniond::get_forward 0 1 1818 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;

3534 5 get_r 0 4 3637 19 LQuaterniond::get_r 0 1 1819 10
/**
 *
 */
46
inline double LQuaterniond::get_r(void) const;

3535 5 get_i 0 4 3637 19 LQuaterniond::get_i 0 1 1820 10
/**
 *
 */
46
inline double LQuaterniond::get_i(void) const;

3536 5 get_j 0 4 3637 19 LQuaterniond::get_j 0 1 1821 10
/**
 *
 */
46
inline double LQuaterniond::get_j(void) const;

3537 5 get_k 0 4 3637 19 LQuaterniond::get_k 0 1 1822 10
/**
 *
 */
46
inline double LQuaterniond::get_k(void) const;

3538 5 set_r 0 4 3637 19 LQuaterniond::set_r 0 1 1823 10
/**
 *
 */
42
inline void LQuaterniond::set_r(double r);

3539 5 set_i 0 4 3637 19 LQuaterniond::set_i 0 1 1824 10
/**
 *
 */
42
inline void LQuaterniond::set_i(double i);

3540 5 set_j 0 4 3637 19 LQuaterniond::set_j 0 1 1825 10
/**
 *
 */
42
inline void LQuaterniond::set_j(double j);

3541 5 set_k 0 4 3637 19 LQuaterniond::set_k 0 1 1826 10
/**
 *
 */
42
inline void LQuaterniond::set_k(double k);

3542 9 normalize 0 4 3637 23 LQuaterniond::normalize 0 1 1827 10
/**
 *
 */
42
inline bool LQuaterniond::normalize(void);

3543 14 conjugate_from 0 4 3637 28 LQuaterniond::conjugate_from 0 1 1828 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaterniond::conjugate_from(LQuaterniond const &other);

3544 18 conjugate_in_place 0 4 3637 32 LQuaterniond::conjugate_in_place 0 1 1829 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaterniond::conjugate_in_place(void);

3545 11 invert_from 0 4 3637 25 LQuaterniond::invert_from 0 1 1830 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaterniond::invert_from(LQuaterniond const &other);

3546 15 invert_in_place 0 4 3637 29 LQuaterniond::invert_in_place 0 1 1831 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaterniond::invert_in_place(void);

3547 11 is_identity 0 4 3637 25 LQuaterniond::is_identity 0 1 1832 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaterniond::is_identity(void) const;

3548 18 is_almost_identity 0 4 3637 32 LQuaterniond::is_almost_identity 0 1 1833 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
69
inline bool LQuaterniond::is_almost_identity(double tolerance) const;

3549 10 ident_quat 0 4 3637 24 LQuaterniond::ident_quat 0 1 1834 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaterniond const &LQuaterniond::ident_quat(void);

3550 14 get_class_type 0 4 3637 28 LQuaterniond::get_class_type 0 1 1835 0
53
static TypeHandle LQuaterniond::get_class_type(void);

3551 13 ~LQuaterniond 0 516 3637 27 LQuaterniond::~LQuaterniond 0 0 0
34
LQuaterniond::~LQuaterniond(void);

3552 10 LRotationf 0 260 3638 22 LRotationf::LRotationf 0 9 1836 1837 1838 1839 1840 1841 1842 1843 1844 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
536
inline LRotationf::LRotationf(void);
inline LRotationf::LRotationf(LQuaternionf const &c);
inline LRotationf::LRotationf(LVecBase4f const &copy);
inline LRotationf::LRotationf(float r, float i, float j, float k);
inline explicit LRotationf::LRotationf(LVector3f const &axis, float angle);
inline explicit LRotationf::LRotationf(LMatrix3f const &m);
inline explicit LRotationf::LRotationf(LMatrix4f const &m);
inline explicit LRotationf::LRotationf(float h, float p, float r);
inline LRotationf::LRotationf(LRotationf const &) = default;

3553 10 operator * 0 4 3638 22 LRotationf::operator * 0 3 1845 1846 1847 0
211
inline LRotationf LRotationf::operator *(float scalar) const;
inline LRotationf LRotationf::operator *(LRotationf const &other) const;
inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const;

3554 10 operator / 0 4 3638 22 LRotationf::operator / 0 1 1848 0
61
inline LRotationf LRotationf::operator /(float scalar) const;

3555 14 get_class_type 0 4 3638 26 LRotationf::get_class_type 0 1 1849 0
51
static TypeHandle LRotationf::get_class_type(void);

3556 11 ~LRotationf 0 516 3638 23 LRotationf::~LRotationf 0 0 0
30
LRotationf::~LRotationf(void);

3557 10 LRotationd 0 260 3639 22 LRotationd::LRotationd 0 9 1850 1851 1852 1853 1854 1855 1856 1857 1858 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
544
inline LRotationd::LRotationd(void);
inline LRotationd::LRotationd(LQuaterniond const &c);
inline LRotationd::LRotationd(LVecBase4d const &copy);
inline LRotationd::LRotationd(double r, double i, double j, double k);
inline explicit LRotationd::LRotationd(LVector3d const &axis, double angle);
inline explicit LRotationd::LRotationd(LMatrix3d const &m);
inline explicit LRotationd::LRotationd(LMatrix4d const &m);
inline explicit LRotationd::LRotationd(double h, double p, double r);
inline LRotationd::LRotationd(LRotationd const &) = default;

3558 10 operator * 0 4 3639 22 LRotationd::operator * 0 3 1859 1860 1861 0
212
inline LRotationd LRotationd::operator *(double scalar) const;
inline LRotationd LRotationd::operator *(LRotationd const &other) const;
inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const;

3559 10 operator / 0 4 3639 22 LRotationd::operator / 0 1 1862 0
62
inline LRotationd LRotationd::operator /(double scalar) const;

3560 14 get_class_type 0 4 3639 26 LRotationd::get_class_type 0 1 1863 0
51
static TypeHandle LRotationd::get_class_type(void);

3561 11 ~LRotationd 0 516 3639 23 LRotationd::~LRotationd 0 0 0
30
LRotationd::~LRotationd(void);

3562 13 LOrientationf 0 260 3640 28 LOrientationf::LOrientationf 0 7 1864 1865 1866 1867 1868 1869 1870 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
463
inline LOrientationf::LOrientationf(void);
inline LOrientationf::LOrientationf(LQuaternionf const &c);
inline LOrientationf::LOrientationf(float r, float i, float j, float k);
inline explicit LOrientationf::LOrientationf(LVector3f const &point_at, float twist);
inline explicit LOrientationf::LOrientationf(LMatrix3f const &m);
inline explicit LOrientationf::LOrientationf(LMatrix4f const &m);
inline LOrientationf::LOrientationf(LOrientationf const &) = default;

3563 10 operator * 0 4 3640 25 LOrientationf::operator * 0 2 1871 1872 0
159
inline LOrientationf LOrientationf::operator *(LRotationf const &other) const;
inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const;

3564 14 get_class_type 0 4 3640 29 LOrientationf::get_class_type 0 1 1873 0
54
static TypeHandle LOrientationf::get_class_type(void);

3565 14 ~LOrientationf 0 516 3640 29 LOrientationf::~LOrientationf 0 0 0
36
LOrientationf::~LOrientationf(void);

3566 13 LOrientationd 0 260 3641 28 LOrientationd::LOrientationd 0 7 1874 1875 1876 1877 1878 1879 1880 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
468
inline LOrientationd::LOrientationd(void);
inline LOrientationd::LOrientationd(LQuaterniond const &c);
inline LOrientationd::LOrientationd(double r, double i, double j, double k);
inline explicit LOrientationd::LOrientationd(LVector3d const &point_at, double twist);
inline explicit LOrientationd::LOrientationd(LMatrix3d const &m);
inline explicit LOrientationd::LOrientationd(LMatrix4d const &m);
inline LOrientationd::LOrientationd(LOrientationd const &) = default;

3567 10 operator * 0 4 3641 25 LOrientationd::operator * 0 2 1881 1882 0
159
inline LOrientationd LOrientationd::operator *(LRotationd const &other) const;
inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const;

3568 14 get_class_type 0 4 3641 29 LOrientationd::get_class_type 0 1 1883 0
54
static TypeHandle LOrientationd::get_class_type(void);

3569 14 ~LOrientationd 0 516 3641 29 LOrientationd::~LOrientationd 0 0 0
36
LOrientationd::~LOrientationd(void);

3570 19 ConfigVariableColor 0 260 3717 40 ConfigVariableColor::ConfigVariableColor 0 4 1884 1885 1886 1887 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
515
inline explicit ConfigVariableColor::ConfigVariableColor(std::string const &name);
inline explicit ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0);
inline explicit ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default;

3571 10 operator = 0 4 3717 31 ConfigVariableColor::operator = 0 1 1888 0
65
inline void ConfigVariableColor::operator =(LColor const &value);

3572 17 operator typecast 0 132 3717 38 ConfigVariableColor::operator typecast 0 1 1893 0
43
inline operator LColor const &(void) const;

3573 11 operator [] 0 4 3717 32 ConfigVariableColor::operator [] 0 1 1889 0
65
inline PN_stdfloat ConfigVariableColor::operator [](int n) const;

3574 9 set_value 0 4 3717 30 ConfigVariableColor::set_value 0 1 1890 48
/**
 * Reassigns the variable's local value.
 */
64
inline void ConfigVariableColor::set_value(LColor const &value);

3575 9 get_value 0 4 3717 30 ConfigVariableColor::get_value 0 1 1891 40
/**
 * Returns the variable's value.
 */
64
inline LColor const &ConfigVariableColor::get_value(void) const;

3576 17 get_default_value 0 4 3717 38 ConfigVariableColor::get_default_value 0 1 1892 48
/**
 * Returns the variable's default value.
 */
65
inline LColor ConfigVariableColor::get_default_value(void) const;

3577 20 ~ConfigVariableColor 0 516 3717 41 ConfigVariableColor::~ConfigVariableColor 0 0 0
48
ConfigVariableColor::~ConfigVariableColor(void);

1983
1 0 0 7 2 3719 1985 0 0 0 
2 0 0 15 2 3719 1985 0 0 1 6 param0 0 3720  
3 0 0 7 8 3722 2058 0 0 0 
4 0 0 15 8 3722 2058 0 0 1 6 param0 0 3723  
5 0 0 23 8 3722 2058 0 10 /**
 *
 */ 1 10 fill_value 1 3581  
6 0 0 23 8 3722 2058 0 10 /**
 *
 */ 2 1 x 1 3581  1 y 1 3581  
7 0 0 4 9 3727 0 0 0 2 4 this 3 3722  4 size 1 3725  
8 0 0 6 12 3722 0 0 0 2 4 this 3 3722  4 copy 1 3723  
9 0 0 6 12 3722 0 0 0 2 4 this 3 3722  10 fill_value 1 3581  
10 0 0 6 13 3723 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
11 0 0 6 14 3723 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
12 0 0 6 15 3723 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
13 0 0 38 16 3728 0 0 0 1 4 this 3 3723  
14 0 0 38 17 3728 0 0 0 2 4 this 3 3723  9 attr_name 1 3731  
15 0 0 38 18 3587 0 0 0 3 4 this 3 3722  9 attr_name 1 3731  6 assign 1 3728  
16 0 0 4 19 3727 0 0 10 /**
 *
 */ 2 4 this 3 3722  1 i 1 3587  
17 0 0 6 19 3581 0 0 0 2 4 this 3 3723  1 i 1 3587  
18 0 0 4 20 3727 0 0 0 3 4 this 3 3722  1 i 1 3587  10 assign_val 1 3581  
19 0 0 6 21 3587 0 0 0 0 
20 0 0 6 22 3732 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3723  
21 0 0 6 23 3581 0 0 10 /**
 *
 */ 2 4 this 3 3723  1 i 1 3587  
22 0 0 4 24 3727 0 0 10 /**
 *
 */ 3 4 this 3 3722  1 i 1 3587  5 value 1 3581  
23 0 0 6 25 3581 0 0 10 /**
 *
 */ 1 4 this 3 3723  
24 0 0 6 26 3581 0 0 10 /**
 *
 */ 1 4 this 3 3723  
25 0 0 4 27 3727 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3581  
26 0 0 4 28 3727 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3581  
27 0 0 4 32 3727 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3722  1 i 1 3587  5 value 1 3581  
28 0 0 4 33 3727 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3581  
29 0 0 4 34 3727 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3581  
30 0 0 4 35 3727 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3723  
31 0 0 6 36 3587 0 0 0 0 
32 0 0 4 37 3727 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3722  10 fill_value 1 3581  
33 0 0 4 38 3727 0 0 10 /**
 *
 */ 3 4 this 3 3722  1 x 1 3581  1 y 1 3581  
34 0 0 6 39 3581 0 0 10 /**
 *
 */ 2 4 this 3 3723  5 other 1 3723  
35 0 0 6 40 3581 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3723  
36 0 0 6 41 3581 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3723  
37 0 0 6 42 3732 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3722  
38 0 0 7 43 3722 2058 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3723  
39 0 0 7 44 3722 2058 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3723  4 onto 1 3723  
40 0 0 6 45 3732 0 0 0 2 4 this 3 3723  5 other 1 3723  
41 0 0 6 46 3732 0 0 0 2 4 this 3 3723  5 other 1 3723  
42 0 0 6 47 3732 0 0 0 2 4 this 3 3723  5 other 1 3723  
43 0 0 6 48 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3723  5 other 1 3723  
44 0 0 6 48 3587 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3723  5 other 1 3723  9 threshold 1 3581  
45 0 0 6 49 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3723  
46 0 0 6 49 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3723  9 threshold 1 3581  
47 0 0 6 50 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3723  4 hash 1 3725  
48 0 0 6 50 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3723  4 hash 1 3725  9 threshold 1 3581  
49 0 0 4 51 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3723  7 hashgen 1 3733  
50 0 0 4 51 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3723  7 hashgen 1 3733  9 threshold 1 3581  
51 0 0 7 52 3722 2058 0 0 1 4 this 3 3723  
52 0 0 7 53 3722 2058 0 0 2 4 this 3 3723  5 other 1 3723  
53 0 0 7 54 3722 2058 0 0 2 4 this 3 3723  5 other 1 3723  
54 0 0 7 55 3722 2058 0 0 2 4 this 3 3723  6 scalar 1 3581  
55 0 0 7 56 3722 2058 0 0 2 4 this 3 3723  6 scalar 1 3581  
56 0 0 6 57 3722 0 0 0 2 4 this 3 3722  5 other 1 3723  
57 0 0 6 58 3722 0 0 0 2 4 this 3 3722  5 other 1 3723  
58 0 0 6 59 3722 0 0 0 2 4 this 3 3722  6 scalar 1 3581  
59 0 0 6 60 3722 0 0 0 2 4 this 3 3722  6 scalar 1 3581  
60 0 0 4 61 3727 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 other 1 3723  
61 0 0 38 62 3728 0 0 0 2 4 this 3 3723  6 scalar 1 3581  
62 0 0 38 63 3728 0 0 0 2 4 this 3 3723  6 scalar 1 3581  
63 0 0 38 64 3728 0 0 0 2 4 this 3 3722  6 scalar 1 3581  
64 0 0 38 65 3728 0 0 0 2 4 this 3 3723  8 exponent 1 3581  
65 0 0 38 66 3728 0 0 0 2 4 this 3 3722  8 exponent 1 3581  
66 0 0 38 67 3728 0 0 0 1 4 this 3 3722  
67 0 0 38 68 3728 0 0 0 1 4 this 3 3722  
68 0 0 38 69 3728 0 0 0 1 4 this 3 3722  
69 0 0 7 70 3722 2058 0 10 /**
 *
 */ 2 4 this 3 3723  5 other 1 3723  
70 0 0 7 71 3722 2058 0 10 /**
 *
 */ 2 4 this 3 3723  5 other 1 3723  
71 0 0 6 72 3732 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3723  5 other 1 3723  
72 0 0 6 72 3732 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3723  5 other 1 3723  9 threshold 1 3581  
73 0 0 4 73 3727 0 0 10 /**
 *
 */ 2 4 this 3 3723  3 out 1 3735  
74 0 0 38 74 3731 0 0 0 1 4 this 3 3723  
75 0 0 4 75 3727 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3723  11 destination 1 3737  
76 0 0 4 76 3727 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3722  6 source 1 3739  
77 0 0 4 77 3727 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3723  11 destination 1 3737  
78 0 0 4 78 3727 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3722  6 source 1 3739  
79 0 0 38 79 3587 0 0 0 3 4 this 3 3723  4 view 1 3741  5 flags 1 3587  
80 0 0 7 80 3745 0 0 0 0 
81 0 0 7 84 3746 2129 0 0 0 
82 0 0 15 84 3746 2129 0 0 1 6 param0 0 3747  
83 0 0 23 84 3746 2129 0 10 /**
 *
 */ 1 10 fill_value 1 3584  
84 0 0 23 84 3746 2129 0 10 /**
 *
 */ 2 1 x 1 3584  1 y 1 3584  
85 0 0 4 85 3727 0 0 0 2 4 this 3 3746  4 size 1 3725  
86 0 0 6 88 3746 0 0 0 2 4 this 3 3746  4 copy 1 3747  
87 0 0 6 88 3746 0 0 0 2 4 this 3 3746  10 fill_value 1 3584  
88 0 0 6 89 3747 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
89 0 0 6 90 3747 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
90 0 0 6 91 3747 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
91 0 0 38 92 3728 0 0 0 1 4 this 3 3747  
92 0 0 38 93 3728 0 0 0 2 4 this 3 3747  9 attr_name 1 3731  
93 0 0 38 94 3587 0 0 0 3 4 this 3 3746  9 attr_name 1 3731  6 assign 1 3728  
94 0 0 4 95 3727 0 0 10 /**
 *
 */ 2 4 this 3 3746  1 i 1 3587  
95 0 0 6 95 3584 0 0 0 2 4 this 3 3747  1 i 1 3587  
96 0 0 4 96 3727 0 0 0 3 4 this 3 3746  1 i 1 3587  10 assign_val 1 3584  
97 0 0 6 97 3587 0 0 0 0 
98 0 0 6 98 3732 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3747  
99 0 0 6 99 3584 0 0 10 /**
 *
 */ 2 4 this 3 3747  1 i 1 3587  
100 0 0 4 100 3727 0 0 10 /**
 *
 */ 3 4 this 3 3746  1 i 1 3587  5 value 1 3584  
101 0 0 6 101 3584 0 0 10 /**
 *
 */ 1 4 this 3 3747  
102 0 0 6 102 3584 0 0 10 /**
 *
 */ 1 4 this 3 3747  
103 0 0 4 103 3727 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 value 1 3584  
104 0 0 4 104 3727 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 value 1 3584  
105 0 0 4 108 3727 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3746  1 i 1 3587  5 value 1 3584  
106 0 0 4 109 3727 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 value 1 3584  
107 0 0 4 110 3727 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 value 1 3584  
108 0 0 4 111 3727 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3747  
109 0 0 6 112 3587 0 0 0 0 
110 0 0 4 113 3727 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3746  10 fill_value 1 3584  
111 0 0 4 114 3727 0 0 10 /**
 *
 */ 3 4 this 3 3746  1 x 1 3584  1 y 1 3584  
112 0 0 6 115 3584 0 0 10 /**
 *
 */ 2 4 this 3 3747  5 other 1 3747  
113 0 0 6 116 3584 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3747  
114 0 0 6 117 3584 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3747  
115 0 0 6 118 3732 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3746  
116 0 0 7 119 3746 2129 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3747  
117 0 0 7 120 3746 2129 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3747  4 onto 1 3747  
118 0 0 6 121 3732 0 0 0 2 4 this 3 3747  5 other 1 3747  
119 0 0 6 122 3732 0 0 0 2 4 this 3 3747  5 other 1 3747  
120 0 0 6 123 3732 0 0 0 2 4 this 3 3747  5 other 1 3747  
121 0 0 6 124 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3747  5 other 1 3747  
122 0 0 6 124 3587 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3747  5 other 1 3747  9 threshold 1 3584  
123 0 0 6 125 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3747  
124 0 0 6 125 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3747  9 threshold 1 3584  
125 0 0 6 126 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3747  4 hash 1 3725  
126 0 0 6 126 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3747  4 hash 1 3725  9 threshold 1 3584  
127 0 0 4 127 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3747  7 hashgen 1 3733  
128 0 0 4 127 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3747  7 hashgen 1 3733  9 threshold 1 3584  
129 0 0 7 128 3746 2129 0 0 1 4 this 3 3747  
130 0 0 7 129 3746 2129 0 0 2 4 this 3 3747  5 other 1 3747  
131 0 0 7 130 3746 2129 0 0 2 4 this 3 3747  5 other 1 3747  
132 0 0 7 131 3746 2129 0 0 2 4 this 3 3747  6 scalar 1 3584  
133 0 0 7 132 3746 2129 0 0 2 4 this 3 3747  6 scalar 1 3584  
134 0 0 6 133 3746 0 0 0 2 4 this 3 3746  5 other 1 3747  
135 0 0 6 134 3746 0 0 0 2 4 this 3 3746  5 other 1 3747  
136 0 0 6 135 3746 0 0 0 2 4 this 3 3746  6 scalar 1 3584  
137 0 0 6 136 3746 0 0 0 2 4 this 3 3746  6 scalar 1 3584  
138 0 0 4 137 3727 0 0 10 /**
 *
 */ 2 4 this 3 3746  5 other 1 3747  
139 0 0 38 138 3728 0 0 0 2 4 this 3 3747  6 scalar 1 3584  
140 0 0 38 139 3728 0 0 0 2 4 this 3 3747  6 scalar 1 3584  
141 0 0 38 140 3728 0 0 0 2 4 this 3 3746  6 scalar 1 3584  
142 0 0 38 141 3728 0 0 0 2 4 this 3 3747  8 exponent 1 3584  
143 0 0 38 142 3728 0 0 0 2 4 this 3 3746  8 exponent 1 3584  
144 0 0 38 143 3728 0 0 0 1 4 this 3 3746  
145 0 0 38 144 3728 0 0 0 1 4 this 3 3746  
146 0 0 38 145 3728 0 0 0 1 4 this 3 3746  
147 0 0 7 146 3746 2129 0 10 /**
 *
 */ 2 4 this 3 3747  5 other 1 3747  
148 0 0 7 147 3746 2129 0 10 /**
 *
 */ 2 4 this 3 3747  5 other 1 3747  
149 0 0 6 148 3732 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3747  5 other 1 3747  
150 0 0 6 148 3732 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3747  5 other 1 3747  9 threshold 1 3584  
151 0 0 4 149 3727 0 0 10 /**
 *
 */ 2 4 this 3 3747  3 out 1 3735  
152 0 0 38 150 3731 0 0 0 1 4 this 3 3747  
153 0 0 4 151 3727 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3747  11 destination 1 3737  
154 0 0 4 152 3727 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3746  6 source 1 3739  
155 0 0 4 153 3727 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3747  11 destination 1 3737  
156 0 0 4 154 3727 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3746  6 source 1 3739  
157 0 0 38 155 3587 0 0 0 3 4 this 3 3747  4 view 1 3741  5 flags 1 3587  
158 0 0 7 156 3745 0 0 0 0 
159 0 0 7 160 3749 2196 0 0 0 
160 0 0 15 160 3749 2196 0 0 1 6 param0 0 3750  
161 0 0 23 160 3749 2196 0 10 /**
 *
 */ 1 10 fill_value 1 3587  
162 0 0 23 160 3749 2196 0 10 /**
 *
 */ 2 1 x 1 3587  1 y 1 3587  
163 0 0 4 161 3727 0 0 0 2 4 this 3 3749  4 size 1 3725  
164 0 0 6 164 3749 0 0 0 2 4 this 3 3749  4 copy 1 3750  
165 0 0 6 164 3749 0 0 0 2 4 this 3 3749  10 fill_value 1 3587  
166 0 0 6 165 3750 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
167 0 0 6 166 3750 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
168 0 0 6 167 3750 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
169 0 0 38 168 3728 0 0 0 1 4 this 3 3750  
170 0 0 38 169 3728 0 0 0 2 4 this 3 3750  9 attr_name 1 3731  
171 0 0 38 170 3587 0 0 0 3 4 this 3 3749  9 attr_name 1 3731  6 assign 1 3728  
172 0 0 4 171 3727 0 0 10 /**
 *
 */ 2 4 this 3 3749  1 i 1 3587  
173 0 0 6 171 3587 0 0 0 2 4 this 3 3750  1 i 1 3587  
174 0 0 4 172 3727 0 0 0 3 4 this 3 3749  1 i 1 3587  10 assign_val 1 3587  
175 0 0 6 173 3587 0 0 0 0 
176 0 0 6 174 3732 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3750  
177 0 0 6 175 3587 0 0 10 /**
 *
 */ 2 4 this 3 3750  1 i 1 3587  
178 0 0 4 176 3727 0 0 10 /**
 *
 */ 3 4 this 3 3749  1 i 1 3587  5 value 1 3587  
179 0 0 6 177 3587 0 0 10 /**
 *
 */ 1 4 this 3 3750  
180 0 0 6 178 3587 0 0 10 /**
 *
 */ 1 4 this 3 3750  
181 0 0 4 179 3727 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3587  
182 0 0 4 180 3727 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3587  
183 0 0 4 184 3727 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3749  1 i 1 3587  5 value 1 3587  
184 0 0 4 185 3727 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3587  
185 0 0 4 186 3727 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3587  
186 0 0 4 187 3727 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3750  
187 0 0 6 188 3587 0 0 0 0 
188 0 0 4 189 3727 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3749  10 fill_value 1 3587  
189 0 0 4 190 3727 0 0 10 /**
 *
 */ 3 4 this 3 3749  1 x 1 3587  1 y 1 3587  
190 0 0 6 191 3587 0 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3750  
191 0 0 6 192 3587 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3750  
192 0 0 6 193 3732 0 0 0 2 4 this 3 3750  5 other 1 3750  
193 0 0 6 194 3732 0 0 0 2 4 this 3 3750  5 other 1 3750  
194 0 0 6 195 3732 0 0 0 2 4 this 3 3750  5 other 1 3750  
195 0 0 6 196 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3750  5 other 1 3750  
196 0 0 6 197 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3750  
197 0 0 6 198 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3750  4 hash 1 3725  
198 0 0 4 199 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3750  7 hashgen 1 3733  
199 0 0 7 200 3749 2196 0 0 1 4 this 3 3750  
200 0 0 7 201 3749 2196 0 0 2 4 this 3 3750  5 other 1 3750  
201 0 0 7 202 3749 2196 0 0 2 4 this 3 3750  5 other 1 3750  
202 0 0 7 203 3749 2196 0 0 2 4 this 3 3750  6 scalar 1 3587  
203 0 0 7 204 3749 2196 0 0 2 4 this 3 3750  6 scalar 1 3587  
204 0 0 6 205 3749 0 0 0 2 4 this 3 3749  5 other 1 3750  
205 0 0 6 206 3749 0 0 0 2 4 this 3 3749  5 other 1 3750  
206 0 0 6 207 3749 0 0 0 2 4 this 3 3749  6 scalar 1 3587  
207 0 0 6 208 3749 0 0 0 2 4 this 3 3749  6 scalar 1 3587  
208 0 0 4 209 3727 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 other 1 3750  
209 0 0 38 210 3728 0 0 0 2 4 this 3 3750  6 scalar 1 3587  
210 0 0 38 211 3728 0 0 0 2 4 this 3 3750  6 scalar 1 3587  
211 0 0 38 212 3728 0 0 0 2 4 this 3 3749  6 scalar 1 3587  
212 0 0 38 213 3728 0 0 0 2 4 this 3 3750  8 exponent 1 3587  
213 0 0 38 214 3728 0 0 0 2 4 this 3 3749  8 exponent 1 3587  
214 0 0 38 215 3728 0 0 0 1 4 this 3 3749  
215 0 0 38 216 3728 0 0 0 1 4 this 3 3749  
216 0 0 38 217 3728 0 0 0 1 4 this 3 3749  
217 0 0 7 218 3749 2196 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3750  
218 0 0 7 219 3749 2196 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3750  
219 0 0 6 220 3732 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3750  5 other 1 3750  
220 0 0 6 220 3732 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3750  5 other 1 3750  9 threshold 1 3587  
221 0 0 4 221 3727 0 0 10 /**
 *
 */ 2 4 this 3 3750  3 out 1 3735  
222 0 0 38 222 3731 0 0 0 1 4 this 3 3750  
223 0 0 4 223 3727 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3750  11 destination 1 3737  
224 0 0 4 224 3727 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3749  6 source 1 3739  
225 0 0 4 225 3727 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3750  11 destination 1 3737  
226 0 0 4 226 3727 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3749  6 source 1 3739  
227 0 0 38 227 3587 0 0 0 3 4 this 3 3750  4 view 1 3741  5 flags 1 3587  
228 0 0 7 228 3745 0 0 0 0 
229 0 0 7 231 3752 2215 0 0 0 
230 0 0 23 231 3752 2215 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3723  
231 0 0 15 231 3752 2215 0 0 1 6 param0 0 3753  
232 0 0 23 231 3752 2215 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3581  
233 0 0 23 231 3752 2215 0 10 /**
 *
 */ 2 1 x 1 3581  1 y 1 3581  
234 0 0 38 232 3728 0 0 0 2 4 this 3 3753  9 attr_name 1 3731  
235 0 0 38 233 3587 0 0 0 3 4 this 3 3752  9 attr_name 1 3731  6 assign 1 3728  
236 0 0 6 234 3753 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
237 0 0 6 235 3753 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
238 0 0 6 236 3753 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
239 0 0 7 237 3752 2215 0 0 1 4 this 3 3753  
240 0 0 7 238 3722 2058 0 0 2 4 this 3 3753  5 other 1 3723  
241 0 0 7 238 3752 2215 0 0 2 4 this 3 3753  5 other 1 3753  
242 0 0 7 239 3722 2058 0 0 2 4 this 3 3753  5 other 1 3723  
243 0 0 7 239 3752 2215 0 0 2 4 this 3 3753  5 other 1 3753  
244 0 0 7 240 3752 2215 0 0 2 4 this 3 3753  6 scalar 1 3581  
245 0 0 7 241 3752 2215 0 0 2 4 this 3 3753  6 scalar 1 3581  
246 0 0 39 242 3752 2215 0 0 2 4 this 3 3753  6 scalar 1 3581  
247 0 0 7 243 3752 2215 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3753  
248 0 0 7 244 3752 2215 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3753  4 onto 1 3723  
249 0 0 6 245 3581 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3753  5 other 1 3753  
250 0 0 6 246 3581 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3753  5 other 1 3753  
251 0 0 38 247 3731 0 0 0 1 4 this 3 3753  
252 0 0 7 248 3745 0 0 0 0 
253 0 0 7 251 3755 2234 0 0 0 
254 0 0 23 251 3755 2234 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3747  
255 0 0 15 251 3755 2234 0 0 1 6 param0 0 3756  
256 0 0 23 251 3755 2234 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3584  
257 0 0 23 251 3755 2234 0 10 /**
 *
 */ 2 1 x 1 3584  1 y 1 3584  
258 0 0 38 252 3728 0 0 0 2 4 this 3 3756  9 attr_name 1 3731  
259 0 0 38 253 3587 0 0 0 3 4 this 3 3755  9 attr_name 1 3731  6 assign 1 3728  
260 0 0 6 254 3756 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
261 0 0 6 255 3756 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
262 0 0 6 256 3756 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
263 0 0 7 257 3755 2234 0 0 1 4 this 3 3756  
264 0 0 7 258 3746 2129 0 0 2 4 this 3 3756  5 other 1 3747  
265 0 0 7 258 3755 2234 0 0 2 4 this 3 3756  5 other 1 3756  
266 0 0 7 259 3746 2129 0 0 2 4 this 3 3756  5 other 1 3747  
267 0 0 7 259 3755 2234 0 0 2 4 this 3 3756  5 other 1 3756  
268 0 0 7 260 3755 2234 0 0 2 4 this 3 3756  6 scalar 1 3584  
269 0 0 7 261 3755 2234 0 0 2 4 this 3 3756  6 scalar 1 3584  
270 0 0 39 262 3755 2234 0 0 2 4 this 3 3756  6 scalar 1 3584  
271 0 0 7 263 3755 2234 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3756  
272 0 0 7 264 3755 2234 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3756  4 onto 1 3747  
273 0 0 6 265 3584 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3756  5 other 1 3756  
274 0 0 6 266 3584 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3756  5 other 1 3756  
275 0 0 38 267 3731 0 0 0 1 4 this 3 3756  
276 0 0 7 268 3745 0 0 0 0 
277 0 0 7 271 3758 2249 0 0 0 
278 0 0 23 271 3758 2249 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3750  
279 0 0 15 271 3758 2249 0 0 1 6 param0 0 3759  
280 0 0 23 271 3758 2249 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3587  
281 0 0 23 271 3758 2249 0 10 /**
 *
 */ 2 1 x 1 3587  1 y 1 3587  
282 0 0 38 272 3728 0 0 0 2 4 this 3 3759  9 attr_name 1 3731  
283 0 0 38 273 3587 0 0 0 3 4 this 3 3758  9 attr_name 1 3731  6 assign 1 3728  
284 0 0 6 274 3759 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
285 0 0 6 275 3759 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
286 0 0 6 276 3759 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
287 0 0 7 277 3758 2249 0 0 1 4 this 3 3759  
288 0 0 7 278 3749 2196 0 0 2 4 this 3 3759  5 other 1 3750  
289 0 0 7 278 3758 2249 0 0 2 4 this 3 3759  5 other 1 3759  
290 0 0 7 279 3749 2196 0 0 2 4 this 3 3759  5 other 1 3750  
291 0 0 7 279 3758 2249 0 0 2 4 this 3 3759  5 other 1 3759  
292 0 0 7 280 3758 2249 0 0 2 4 this 3 3759  6 scalar 1 3587  
293 0 0 7 281 3758 2249 0 0 2 4 this 3 3759  6 scalar 1 3587  
294 0 0 39 282 3758 2249 0 0 2 4 this 3 3759  6 scalar 1 3587  
295 0 0 38 283 3731 0 0 0 1 4 this 3 3759  
296 0 0 7 284 3745 0 0 0 0 
297 0 0 7 287 3761 2266 0 0 0 
298 0 0 15 287 3761 2266 0 0 1 6 param0 0 3762  
299 0 0 23 287 3761 2266 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3723  
300 0 0 23 287 3761 2266 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3581  
301 0 0 23 287 3761 2266 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3581  1 y 1 3581  
302 0 0 38 288 3728 0 0 0 2 4 this 3 3762  9 attr_name 1 3731  
303 0 0 38 289 3587 0 0 0 3 4 this 3 3761  9 attr_name 1 3731  6 assign 1 3728  
304 0 0 6 290 3762 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
305 0 0 6 291 3762 0 0 34 /**
 * Returns a unit X point.
 */ 0 
306 0 0 6 292 3762 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
307 0 0 7 293 3761 2266 0 0 1 4 this 3 3762  
308 0 0 7 294 3722 2058 0 0 2 4 this 3 3762  5 other 1 3723  
309 0 0 7 294 3761 2266 0 0 2 4 this 3 3762  5 other 1 3753  
310 0 0 7 295 3752 2215 0 0 2 4 this 3 3762  5 other 1 3762  
311 0 0 7 295 3722 2058 0 0 2 4 this 3 3762  5 other 1 3723  
312 0 0 7 295 3761 2266 0 0 2 4 this 3 3762  5 other 1 3753  
313 0 0 7 296 3761 2266 0 0 2 4 this 3 3762  6 scalar 1 3581  
314 0 0 7 297 3761 2266 0 0 2 4 this 3 3762  6 scalar 1 3581  
315 0 0 39 298 3761 2266 0 0 2 4 this 3 3762  6 scalar 1 3581  
316 0 0 7 299 3761 2266 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3762  
317 0 0 7 300 3761 2266 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3762  4 onto 1 3723  
318 0 0 38 301 3731 0 0 0 1 4 this 3 3762  
319 0 0 7 302 3745 0 0 0 0 
320 0 0 7 305 3764 2283 0 0 0 
321 0 0 15 305 3764 2283 0 0 1 6 param0 0 3765  
322 0 0 23 305 3764 2283 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3747  
323 0 0 23 305 3764 2283 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3584  
324 0 0 23 305 3764 2283 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3584  1 y 1 3584  
325 0 0 38 306 3728 0 0 0 2 4 this 3 3765  9 attr_name 1 3731  
326 0 0 38 307 3587 0 0 0 3 4 this 3 3764  9 attr_name 1 3731  6 assign 1 3728  
327 0 0 6 308 3765 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
328 0 0 6 309 3765 0 0 34 /**
 * Returns a unit X point.
 */ 0 
329 0 0 6 310 3765 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
330 0 0 7 311 3764 2283 0 0 1 4 this 3 3765  
331 0 0 7 312 3746 2129 0 0 2 4 this 3 3765  5 other 1 3747  
332 0 0 7 312 3764 2283 0 0 2 4 this 3 3765  5 other 1 3756  
333 0 0 7 313 3755 2234 0 0 2 4 this 3 3765  5 other 1 3765  
334 0 0 7 313 3746 2129 0 0 2 4 this 3 3765  5 other 1 3747  
335 0 0 7 313 3764 2283 0 0 2 4 this 3 3765  5 other 1 3756  
336 0 0 7 314 3764 2283 0 0 2 4 this 3 3765  6 scalar 1 3584  
337 0 0 7 315 3764 2283 0 0 2 4 this 3 3765  6 scalar 1 3584  
338 0 0 39 316 3764 2283 0 0 2 4 this 3 3765  6 scalar 1 3584  
339 0 0 7 317 3764 2283 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3765  
340 0 0 7 318 3764 2283 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3765  4 onto 1 3747  
341 0 0 38 319 3731 0 0 0 1 4 this 3 3765  
342 0 0 7 320 3745 0 0 0 0 
343 0 0 7 323 3767 2298 0 0 0 
344 0 0 15 323 3767 2298 0 0 1 6 param0 0 3768  
345 0 0 23 323 3767 2298 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3750  
346 0 0 23 323 3767 2298 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3587  
347 0 0 23 323 3767 2298 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3587  1 y 1 3587  
348 0 0 38 324 3728 0 0 0 2 4 this 3 3768  9 attr_name 1 3731  
349 0 0 38 325 3587 0 0 0 3 4 this 3 3767  9 attr_name 1 3731  6 assign 1 3728  
350 0 0 6 326 3768 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
351 0 0 6 327 3768 0 0 34 /**
 * Returns a unit X point.
 */ 0 
352 0 0 6 328 3768 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
353 0 0 7 329 3767 2298 0 0 1 4 this 3 3768  
354 0 0 7 330 3749 2196 0 0 2 4 this 3 3768  5 other 1 3750  
355 0 0 7 330 3767 2298 0 0 2 4 this 3 3768  5 other 1 3759  
356 0 0 7 331 3758 2249 0 0 2 4 this 3 3768  5 other 1 3768  
357 0 0 7 331 3749 2196 0 0 2 4 this 3 3768  5 other 1 3750  
358 0 0 7 331 3767 2298 0 0 2 4 this 3 3768  5 other 1 3759  
359 0 0 7 332 3767 2298 0 0 2 4 this 3 3768  6 scalar 1 3587  
360 0 0 7 333 3767 2298 0 0 2 4 this 3 3768  6 scalar 1 3587  
361 0 0 39 334 3767 2298 0 0 2 4 this 3 3768  6 scalar 1 3587  
362 0 0 38 335 3731 0 0 0 1 4 this 3 3768  
363 0 0 7 336 3745 0 0 0 0 
364 0 0 7 340 3770 2379 0 0 0 
365 0 0 7 340 3770 2379 0 10 /**
 *
 */ 2 4 copy 1 3723  1 z 1 3581  
366 0 0 15 340 3770 2379 0 0 1 6 param0 0 3771  
367 0 0 23 340 3770 2379 0 10 /**
 *
 */ 1 10 fill_value 1 3581  
368 0 0 23 340 3770 2379 0 10 /**
 *
 */ 3 1 x 1 3581  1 y 1 3581  1 z 1 3581  
369 0 0 4 341 3727 0 0 0 2 4 this 3 3770  4 size 1 3725  
370 0 0 6 344 3770 0 0 0 2 4 this 3 3770  4 copy 1 3771  
371 0 0 6 344 3770 0 0 0 2 4 this 3 3770  10 fill_value 1 3581  
372 0 0 6 345 3771 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
373 0 0 6 346 3771 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
374 0 0 6 347 3771 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
375 0 0 6 348 3771 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
376 0 0 38 349 3728 0 0 0 1 4 this 3 3771  
377 0 0 38 350 3728 0 0 0 2 4 this 3 3771  9 attr_name 1 3731  
378 0 0 38 351 3587 0 0 0 3 4 this 3 3770  9 attr_name 1 3731  6 assign 1 3728  
379 0 0 4 352 3727 0 0 10 /**
 *
 */ 2 4 this 3 3770  1 i 1 3587  
380 0 0 6 352 3581 0 0 0 2 4 this 3 3771  1 i 1 3587  
381 0 0 4 353 3727 0 0 0 3 4 this 3 3770  1 i 1 3587  10 assign_val 1 3581  
382 0 0 6 354 3587 0 0 0 0 
383 0 0 6 355 3732 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3771  
384 0 0 6 356 3581 0 0 10 /**
 *
 */ 2 4 this 3 3771  1 i 1 3587  
385 0 0 6 357 3581 0 0 10 /**
 *
 */ 1 4 this 3 3771  
386 0 0 6 358 3581 0 0 10 /**
 *
 */ 1 4 this 3 3771  
387 0 0 6 359 3581 0 0 10 /**
 *
 */ 1 4 this 3 3771  
388 0 0 4 360 3727 0 0 10 /**
 *
 */ 3 4 this 3 3770  1 i 1 3587  5 value 1 3581  
389 0 0 4 361 3727 0 0 10 /**
 *
 */ 2 4 this 3 3770  5 value 1 3581  
390 0 0 4 362 3727 0 0 10 /**
 *
 */ 2 4 this 3 3770  5 value 1 3581  
391 0 0 4 363 3727 0 0 10 /**
 *
 */ 2 4 this 3 3770  5 value 1 3581  
392 0 0 7 364 3722 2058 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3771  
393 0 0 7 365 3722 2058 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3771  
394 0 0 7 366 3722 2058 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3771  
395 0 0 4 373 3727 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3770  1 i 1 3587  5 value 1 3581  
396 0 0 4 374 3727 0 0 10 /**
 *
 */ 2 4 this 3 3770  5 value 1 3581  
397 0 0 4 375 3727 0 0 10 /**
 *
 */ 2 4 this 3 3770  5 value 1 3581  
398 0 0 4 376 3727 0 0 10 /**
 *
 */ 2 4 this 3 3770  5 value 1 3581  
399 0 0 4 377 3727 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3771  
400 0 0 6 378 3587 0 0 0 0 
401 0 0 4 379 3727 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3770  10 fill_value 1 3581  
402 0 0 4 380 3727 0 0 10 /**
 *
 */ 4 4 this 3 3770  1 x 1 3581  1 y 1 3581  1 z 1 3581  
403 0 0 6 381 3581 0 0 10 /**
 *
 */ 2 4 this 3 3771  5 other 1 3771  
404 0 0 6 382 3581 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3771  
405 0 0 6 383 3581 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3771  
406 0 0 6 384 3732 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3770  
407 0 0 7 385 3770 2379 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3771  
408 0 0 7 386 3770 2379 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3771  4 onto 1 3771  
409 0 0 7 387 3770 2379 0 10 /**
 *
 */ 2 4 this 3 3771  5 other 1 3771  
410 0 0 6 388 3732 0 0 0 2 4 this 3 3771  5 other 1 3771  
411 0 0 6 389 3732 0 0 0 2 4 this 3 3771  5 other 1 3771  
412 0 0 6 390 3732 0 0 0 2 4 this 3 3771  5 other 1 3771  
413 0 0 7 391 3770 2379 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3771  
414 0 0 6 392 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3771  5 other 1 3771  
415 0 0 6 392 3587 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3771  5 other 1 3771  9 threshold 1 3581  
416 0 0 6 393 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3771  
417 0 0 6 393 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3771  9 threshold 1 3581  
418 0 0 6 394 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3771  4 hash 1 3725  
419 0 0 6 394 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3771  4 hash 1 3725  9 threshold 1 3581  
420 0 0 4 395 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3771  7 hashgen 1 3733  
421 0 0 4 395 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3771  7 hashgen 1 3733  9 threshold 1 3581  
422 0 0 7 396 3770 2379 0 0 1 4 this 3 3771  
423 0 0 7 397 3770 2379 0 0 2 4 this 3 3771  5 other 1 3771  
424 0 0 7 398 3770 2379 0 0 2 4 this 3 3771  5 other 1 3771  
425 0 0 7 399 3770 2379 0 0 2 4 this 3 3771  6 scalar 1 3581  
426 0 0 7 400 3770 2379 0 0 2 4 this 3 3771  6 scalar 1 3581  
427 0 0 6 401 3770 0 0 0 2 4 this 3 3770  5 other 1 3771  
428 0 0 6 402 3770 0 0 0 2 4 this 3 3770  5 other 1 3771  
429 0 0 6 403 3770 0 0 0 2 4 this 3 3770  6 scalar 1 3581  
430 0 0 6 404 3770 0 0 0 2 4 this 3 3770  6 scalar 1 3581  
431 0 0 4 405 3727 0 0 10 /**
 *
 */ 2 4 this 3 3770  5 other 1 3771  
432 0 0 38 406 3728 0 0 0 2 4 this 3 3771  6 scalar 1 3581  
433 0 0 38 407 3728 0 0 0 2 4 this 3 3771  6 scalar 1 3581  
434 0 0 38 408 3728 0 0 0 2 4 this 3 3770  6 scalar 1 3581  
435 0 0 38 409 3728 0 0 0 2 4 this 3 3771  8 exponent 1 3581  
436 0 0 38 410 3728 0 0 0 2 4 this 3 3770  8 exponent 1 3581  
437 0 0 38 411 3728 0 0 0 1 4 this 3 3770  
438 0 0 38 412 3728 0 0 0 1 4 this 3 3770  
439 0 0 38 413 3728 0 0 0 1 4 this 3 3770  
440 0 0 7 414 3770 2379 0 10 /**
 *
 */ 2 4 this 3 3771  5 other 1 3771  
441 0 0 7 415 3770 2379 0 10 /**
 *
 */ 2 4 this 3 3771  5 other 1 3771  
442 0 0 4 416 3727 0 0 10 /**
 *
 */ 2 4 this 3 3770  5 other 1 3771  
443 0 0 6 417 3732 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3771  5 other 1 3771  
444 0 0 6 417 3732 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3771  5 other 1 3771  9 threshold 1 3581  
445 0 0 4 418 3727 0 0 10 /**
 *
 */ 2 4 this 3 3771  3 out 1 3735  
446 0 0 38 419 3731 0 0 0 1 4 this 3 3771  
447 0 0 4 420 3727 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3771  11 destination 1 3737  
448 0 0 4 421 3727 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3770  6 source 1 3739  
449 0 0 4 422 3727 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3771  11 destination 1 3737  
450 0 0 4 423 3727 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3770  6 source 1 3739  
451 0 0 38 424 3587 0 0 0 3 4 this 3 3771  4 view 1 3741  5 flags 1 3587  
452 0 0 7 425 3745 0 0 0 0 
453 0 0 7 429 3773 2460 0 0 0 
454 0 0 7 429 3773 2460 0 10 /**
 *
 */ 2 4 copy 1 3747  1 z 1 3584  
455 0 0 15 429 3773 2460 0 0 1 6 param0 0 3774  
456 0 0 23 429 3773 2460 0 10 /**
 *
 */ 1 10 fill_value 1 3584  
457 0 0 23 429 3773 2460 0 10 /**
 *
 */ 3 1 x 1 3584  1 y 1 3584  1 z 1 3584  
458 0 0 4 430 3727 0 0 0 2 4 this 3 3773  4 size 1 3725  
459 0 0 6 433 3773 0 0 0 2 4 this 3 3773  4 copy 1 3774  
460 0 0 6 433 3773 0 0 0 2 4 this 3 3773  10 fill_value 1 3584  
461 0 0 6 434 3774 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
462 0 0 6 435 3774 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
463 0 0 6 436 3774 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
464 0 0 6 437 3774 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
465 0 0 38 438 3728 0 0 0 1 4 this 3 3774  
466 0 0 38 439 3728 0 0 0 2 4 this 3 3774  9 attr_name 1 3731  
467 0 0 38 440 3587 0 0 0 3 4 this 3 3773  9 attr_name 1 3731  6 assign 1 3728  
468 0 0 4 441 3727 0 0 10 /**
 *
 */ 2 4 this 3 3773  1 i 1 3587  
469 0 0 6 441 3584 0 0 0 2 4 this 3 3774  1 i 1 3587  
470 0 0 4 442 3727 0 0 0 3 4 this 3 3773  1 i 1 3587  10 assign_val 1 3584  
471 0 0 6 443 3587 0 0 0 0 
472 0 0 6 444 3732 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3774  
473 0 0 6 445 3584 0 0 10 /**
 *
 */ 2 4 this 3 3774  1 i 1 3587  
474 0 0 6 446 3584 0 0 10 /**
 *
 */ 1 4 this 3 3774  
475 0 0 6 447 3584 0 0 10 /**
 *
 */ 1 4 this 3 3774  
476 0 0 6 448 3584 0 0 10 /**
 *
 */ 1 4 this 3 3774  
477 0 0 4 449 3727 0 0 10 /**
 *
 */ 3 4 this 3 3773  1 i 1 3587  5 value 1 3584  
478 0 0 4 450 3727 0 0 10 /**
 *
 */ 2 4 this 3 3773  5 value 1 3584  
479 0 0 4 451 3727 0 0 10 /**
 *
 */ 2 4 this 3 3773  5 value 1 3584  
480 0 0 4 452 3727 0 0 10 /**
 *
 */ 2 4 this 3 3773  5 value 1 3584  
481 0 0 7 453 3746 2129 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3774  
482 0 0 7 454 3746 2129 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3774  
483 0 0 7 455 3746 2129 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3774  
484 0 0 4 462 3727 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3773  1 i 1 3587  5 value 1 3584  
485 0 0 4 463 3727 0 0 10 /**
 *
 */ 2 4 this 3 3773  5 value 1 3584  
486 0 0 4 464 3727 0 0 10 /**
 *
 */ 2 4 this 3 3773  5 value 1 3584  
487 0 0 4 465 3727 0 0 10 /**
 *
 */ 2 4 this 3 3773  5 value 1 3584  
488 0 0 4 466 3727 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3774  
489 0 0 6 467 3587 0 0 0 0 
490 0 0 4 468 3727 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3773  10 fill_value 1 3584  
491 0 0 4 469 3727 0 0 10 /**
 *
 */ 4 4 this 3 3773  1 x 1 3584  1 y 1 3584  1 z 1 3584  
492 0 0 6 470 3584 0 0 10 /**
 *
 */ 2 4 this 3 3774  5 other 1 3774  
493 0 0 6 471 3584 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3774  
494 0 0 6 472 3584 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3774  
495 0 0 6 473 3732 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3773  
496 0 0 7 474 3773 2460 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3774  
497 0 0 7 475 3773 2460 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3774  4 onto 1 3774  
498 0 0 7 476 3773 2460 0 10 /**
 *
 */ 2 4 this 3 3774  5 other 1 3774  
499 0 0 6 477 3732 0 0 0 2 4 this 3 3774  5 other 1 3774  
500 0 0 6 478 3732 0 0 0 2 4 this 3 3774  5 other 1 3774  
501 0 0 6 479 3732 0 0 0 2 4 this 3 3774  5 other 1 3774  
502 0 0 7 480 3773 2460 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3774  
503 0 0 6 481 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3774  5 other 1 3774  
504 0 0 6 481 3587 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3774  5 other 1 3774  9 threshold 1 3584  
505 0 0 6 482 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3774  
506 0 0 6 482 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3774  9 threshold 1 3584  
507 0 0 6 483 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3774  4 hash 1 3725  
508 0 0 6 483 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3774  4 hash 1 3725  9 threshold 1 3584  
509 0 0 4 484 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3774  7 hashgen 1 3733  
510 0 0 4 484 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3774  7 hashgen 1 3733  9 threshold 1 3584  
511 0 0 7 485 3773 2460 0 0 1 4 this 3 3774  
512 0 0 7 486 3773 2460 0 0 2 4 this 3 3774  5 other 1 3774  
513 0 0 7 487 3773 2460 0 0 2 4 this 3 3774  5 other 1 3774  
514 0 0 7 488 3773 2460 0 0 2 4 this 3 3774  6 scalar 1 3584  
515 0 0 7 489 3773 2460 0 0 2 4 this 3 3774  6 scalar 1 3584  
516 0 0 6 490 3773 0 0 0 2 4 this 3 3773  5 other 1 3774  
517 0 0 6 491 3773 0 0 0 2 4 this 3 3773  5 other 1 3774  
518 0 0 6 492 3773 0 0 0 2 4 this 3 3773  6 scalar 1 3584  
519 0 0 6 493 3773 0 0 0 2 4 this 3 3773  6 scalar 1 3584  
520 0 0 4 494 3727 0 0 10 /**
 *
 */ 2 4 this 3 3773  5 other 1 3774  
521 0 0 38 495 3728 0 0 0 2 4 this 3 3774  6 scalar 1 3584  
522 0 0 38 496 3728 0 0 0 2 4 this 3 3774  6 scalar 1 3584  
523 0 0 38 497 3728 0 0 0 2 4 this 3 3773  6 scalar 1 3584  
524 0 0 38 498 3728 0 0 0 2 4 this 3 3774  8 exponent 1 3584  
525 0 0 38 499 3728 0 0 0 2 4 this 3 3773  8 exponent 1 3584  
526 0 0 38 500 3728 0 0 0 1 4 this 3 3773  
527 0 0 38 501 3728 0 0 0 1 4 this 3 3773  
528 0 0 38 502 3728 0 0 0 1 4 this 3 3773  
529 0 0 7 503 3773 2460 0 10 /**
 *
 */ 2 4 this 3 3774  5 other 1 3774  
530 0 0 7 504 3773 2460 0 10 /**
 *
 */ 2 4 this 3 3774  5 other 1 3774  
531 0 0 4 505 3727 0 0 10 /**
 *
 */ 2 4 this 3 3773  5 other 1 3774  
532 0 0 6 506 3732 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3774  5 other 1 3774  
533 0 0 6 506 3732 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3774  5 other 1 3774  9 threshold 1 3584  
534 0 0 4 507 3727 0 0 10 /**
 *
 */ 2 4 this 3 3774  3 out 1 3735  
535 0 0 38 508 3731 0 0 0 1 4 this 3 3774  
536 0 0 4 509 3727 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3774  11 destination 1 3737  
537 0 0 4 510 3727 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3773  6 source 1 3739  
538 0 0 4 511 3727 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3774  11 destination 1 3737  
539 0 0 4 512 3727 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3773  6 source 1 3739  
540 0 0 38 513 3587 0 0 0 3 4 this 3 3774  4 view 1 3741  5 flags 1 3587  
541 0 0 7 514 3745 0 0 0 0 
542 0 0 7 518 3776 2536 0 0 0 
543 0 0 7 518 3776 2536 0 10 /**
 *
 */ 2 4 copy 1 3750  1 z 1 3587  
544 0 0 15 518 3776 2536 0 0 1 6 param0 0 3777  
545 0 0 23 518 3776 2536 0 10 /**
 *
 */ 1 10 fill_value 1 3587  
546 0 0 23 518 3776 2536 0 10 /**
 *
 */ 3 1 x 1 3587  1 y 1 3587  1 z 1 3587  
547 0 0 4 519 3727 0 0 0 2 4 this 3 3776  4 size 1 3725  
548 0 0 6 522 3776 0 0 0 2 4 this 3 3776  4 copy 1 3777  
549 0 0 6 522 3776 0 0 0 2 4 this 3 3776  10 fill_value 1 3587  
550 0 0 6 523 3777 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
551 0 0 6 524 3777 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
552 0 0 6 525 3777 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
553 0 0 6 526 3777 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
554 0 0 38 527 3728 0 0 0 1 4 this 3 3777  
555 0 0 38 528 3728 0 0 0 2 4 this 3 3777  9 attr_name 1 3731  
556 0 0 38 529 3587 0 0 0 3 4 this 3 3776  9 attr_name 1 3731  6 assign 1 3728  
557 0 0 4 530 3727 0 0 10 /**
 *
 */ 2 4 this 3 3776  1 i 1 3587  
558 0 0 6 530 3587 0 0 0 2 4 this 3 3777  1 i 1 3587  
559 0 0 4 531 3727 0 0 0 3 4 this 3 3776  1 i 1 3587  10 assign_val 1 3587  
560 0 0 6 532 3587 0 0 0 0 
561 0 0 6 533 3732 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3777  
562 0 0 6 534 3587 0 0 10 /**
 *
 */ 2 4 this 3 3777  1 i 1 3587  
563 0 0 6 535 3587 0 0 10 /**
 *
 */ 1 4 this 3 3777  
564 0 0 6 536 3587 0 0 10 /**
 *
 */ 1 4 this 3 3777  
565 0 0 6 537 3587 0 0 10 /**
 *
 */ 1 4 this 3 3777  
566 0 0 4 538 3727 0 0 10 /**
 *
 */ 3 4 this 3 3776  1 i 1 3587  5 value 1 3587  
567 0 0 4 539 3727 0 0 10 /**
 *
 */ 2 4 this 3 3776  5 value 1 3587  
568 0 0 4 540 3727 0 0 10 /**
 *
 */ 2 4 this 3 3776  5 value 1 3587  
569 0 0 4 541 3727 0 0 10 /**
 *
 */ 2 4 this 3 3776  5 value 1 3587  
570 0 0 7 542 3749 2196 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3777  
571 0 0 7 543 3749 2196 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3777  
572 0 0 7 544 3749 2196 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3777  
573 0 0 4 551 3727 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3776  1 i 1 3587  5 value 1 3587  
574 0 0 4 552 3727 0 0 10 /**
 *
 */ 2 4 this 3 3776  5 value 1 3587  
575 0 0 4 553 3727 0 0 10 /**
 *
 */ 2 4 this 3 3776  5 value 1 3587  
576 0 0 4 554 3727 0 0 10 /**
 *
 */ 2 4 this 3 3776  5 value 1 3587  
577 0 0 4 555 3727 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3777  
578 0 0 6 556 3587 0 0 0 0 
579 0 0 4 557 3727 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3776  10 fill_value 1 3587  
580 0 0 4 558 3727 0 0 10 /**
 *
 */ 4 4 this 3 3776  1 x 1 3587  1 y 1 3587  1 z 1 3587  
581 0 0 6 559 3587 0 0 10 /**
 *
 */ 2 4 this 3 3777  5 other 1 3777  
582 0 0 6 560 3587 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3777  
583 0 0 7 561 3776 2536 0 10 /**
 *
 */ 2 4 this 3 3777  5 other 1 3777  
584 0 0 6 562 3732 0 0 0 2 4 this 3 3777  5 other 1 3777  
585 0 0 6 563 3732 0 0 0 2 4 this 3 3777  5 other 1 3777  
586 0 0 6 564 3732 0 0 0 2 4 this 3 3777  5 other 1 3777  
587 0 0 6 565 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3777  5 other 1 3777  
588 0 0 6 566 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3777  
589 0 0 6 567 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3777  4 hash 1 3725  
590 0 0 4 568 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3777  7 hashgen 1 3733  
591 0 0 7 569 3776 2536 0 0 1 4 this 3 3777  
592 0 0 7 570 3776 2536 0 0 2 4 this 3 3777  5 other 1 3777  
593 0 0 7 571 3776 2536 0 0 2 4 this 3 3777  5 other 1 3777  
594 0 0 7 572 3776 2536 0 0 2 4 this 3 3777  6 scalar 1 3587  
595 0 0 7 573 3776 2536 0 0 2 4 this 3 3777  6 scalar 1 3587  
596 0 0 6 574 3776 0 0 0 2 4 this 3 3776  5 other 1 3777  
597 0 0 6 575 3776 0 0 0 2 4 this 3 3776  5 other 1 3777  
598 0 0 6 576 3776 0 0 0 2 4 this 3 3776  6 scalar 1 3587  
599 0 0 6 577 3776 0 0 0 2 4 this 3 3776  6 scalar 1 3587  
600 0 0 4 578 3727 0 0 10 /**
 *
 */ 2 4 this 3 3776  5 other 1 3777  
601 0 0 38 579 3728 0 0 0 2 4 this 3 3777  6 scalar 1 3587  
602 0 0 38 580 3728 0 0 0 2 4 this 3 3777  6 scalar 1 3587  
603 0 0 38 581 3728 0 0 0 2 4 this 3 3776  6 scalar 1 3587  
604 0 0 38 582 3728 0 0 0 2 4 this 3 3777  8 exponent 1 3587  
605 0 0 38 583 3728 0 0 0 2 4 this 3 3776  8 exponent 1 3587  
606 0 0 38 584 3728 0 0 0 1 4 this 3 3776  
607 0 0 38 585 3728 0 0 0 1 4 this 3 3776  
608 0 0 38 586 3728 0 0 0 1 4 this 3 3776  
609 0 0 7 587 3776 2536 0 10 /**
 *
 */ 2 4 this 3 3777  5 other 1 3777  
610 0 0 7 588 3776 2536 0 10 /**
 *
 */ 2 4 this 3 3777  5 other 1 3777  
611 0 0 4 589 3727 0 0 10 /**
 *
 */ 2 4 this 3 3776  5 other 1 3777  
612 0 0 6 590 3732 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3777  5 other 1 3777  
613 0 0 6 590 3732 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3777  5 other 1 3777  9 threshold 1 3587  
614 0 0 4 591 3727 0 0 10 /**
 *
 */ 2 4 this 3 3777  3 out 1 3735  
615 0 0 38 592 3731 0 0 0 1 4 this 3 3777  
616 0 0 4 593 3727 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3777  11 destination 1 3737  
617 0 0 4 594 3727 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3776  6 source 1 3739  
618 0 0 4 595 3727 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3777  11 destination 1 3737  
619 0 0 4 596 3727 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3776  6 source 1 3739  
620 0 0 38 597 3587 0 0 0 3 4 this 3 3777  4 view 1 3741  5 flags 1 3587  
621 0 0 7 598 3745 0 0 0 0 
622 0 0 7 606 3779 2575 0 0 0 
623 0 0 7 606 3779 2575 0 10 /**
 *
 */ 2 4 copy 1 3723  1 z 1 3581  
624 0 0 23 606 3779 2575 0 10 /**
 *
 */ 1 4 copy 1 3771  
625 0 0 15 606 3779 2575 0 0 1 6 param0 0 3780  
626 0 0 23 606 3779 2575 0 10 /**
 *
 */ 1 10 fill_value 1 3581  
627 0 0 23 606 3779 2575 0 10 /**
 *
 */ 3 1 x 1 3581  1 y 1 3581  1 z 1 3581  
628 0 0 38 607 3728 0 0 0 2 4 this 3 3780  9 attr_name 1 3731  
629 0 0 38 608 3587 0 0 0 3 4 this 3 3779  9 attr_name 1 3731  6 assign 1 3728  
630 0 0 6 609 3780 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
631 0 0 6 610 3780 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
632 0 0 6 611 3780 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
633 0 0 6 612 3780 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
634 0 0 7 613 3752 2215 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3780  
635 0 0 7 614 3752 2215 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3780  
636 0 0 7 615 3752 2215 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3780  
637 0 0 7 619 3779 2575 0 0 1 4 this 3 3780  
638 0 0 7 620 3770 2379 0 0 2 4 this 3 3780  5 other 1 3771  
639 0 0 7 620 3779 2575 0 0 2 4 this 3 3780  5 other 1 3780  
640 0 0 7 621 3770 2379 0 0 2 4 this 3 3780  5 other 1 3771  
641 0 0 7 621 3779 2575 0 0 2 4 this 3 3780  5 other 1 3780  
642 0 0 7 622 3779 2575 0 10 /**
 *
 */ 2 4 this 3 3780  5 other 1 3771  
643 0 0 7 623 3779 2575 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3780  
644 0 0 7 624 3779 2575 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3780  4 onto 1 3771  
645 0 0 6 625 3581 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3780  5 other 1 3780  
646 0 0 6 626 3581 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3780  5 other 1 3780  
647 0 0 6 627 3581 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3780  5 other 1 3780  3 ref 1 3780  
648 0 0 6 628 3581 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3780  5 other 1 3780  3 ref 1 3780  
649 0 0 6 629 3581 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3780  5 other 1 3780  
650 0 0 6 630 3581 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3780  5 other 1 3780  
651 0 0 7 631 3779 2575 0 0 2 4 this 3 3780  6 scalar 1 3581  
652 0 0 7 632 3779 2575 0 0 2 4 this 3 3780  6 scalar 1 3581  
653 0 0 39 633 3779 2575 0 0 2 4 this 3 3780  6 scalar 1 3581  
654 0 0 7 634 3779 2575 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 5 3600  
655 0 0 7 635 3779 2575 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 5 3600  
656 0 0 7 636 3779 2575 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 5 3600  
657 0 0 7 637 3779 2575 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 5 3600  
658 0 0 7 638 3779 2575 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 5 3600  
659 0 0 7 639 3779 2575 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 5 3600  
660 0 0 7 640 3779 2575 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3581  3 fwd 1 3581  2 up 1 3581  2 cs 5 3600  
661 0 0 38 641 3731 0 0 0 1 4 this 3 3780  
662 0 0 7 642 3745 0 0 0 0 
663 0 0 7 645 3782 2610 0 0 0 
664 0 0 7 645 3782 2610 0 10 /**
 *
 */ 2 4 copy 1 3747  1 z 1 3584  
665 0 0 23 645 3782 2610 0 10 /**
 *
 */ 1 4 copy 1 3774  
666 0 0 15 645 3782 2610 0 0 1 6 param0 0 3783  
667 0 0 23 645 3782 2610 0 10 /**
 *
 */ 1 10 fill_value 1 3584  
668 0 0 23 645 3782 2610 0 10 /**
 *
 */ 3 1 x 1 3584  1 y 1 3584  1 z 1 3584  
669 0 0 38 646 3728 0 0 0 2 4 this 3 3783  9 attr_name 1 3731  
670 0 0 38 647 3587 0 0 0 3 4 this 3 3782  9 attr_name 1 3731  6 assign 1 3728  
671 0 0 6 648 3783 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
672 0 0 6 649 3783 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
673 0 0 6 650 3783 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
674 0 0 6 651 3783 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
675 0 0 7 652 3755 2234 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3783  
676 0 0 7 653 3755 2234 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3783  
677 0 0 7 654 3755 2234 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3783  
678 0 0 7 658 3782 2610 0 0 1 4 this 3 3783  
679 0 0 7 659 3773 2460 0 0 2 4 this 3 3783  5 other 1 3774  
680 0 0 7 659 3782 2610 0 0 2 4 this 3 3783  5 other 1 3783  
681 0 0 7 660 3773 2460 0 0 2 4 this 3 3783  5 other 1 3774  
682 0 0 7 660 3782 2610 0 0 2 4 this 3 3783  5 other 1 3783  
683 0 0 7 661 3782 2610 0 10 /**
 *
 */ 2 4 this 3 3783  5 other 1 3774  
684 0 0 7 662 3782 2610 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3783  
685 0 0 7 663 3782 2610 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3783  4 onto 1 3774  
686 0 0 6 664 3584 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3783  5 other 1 3783  
687 0 0 6 665 3584 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3783  5 other 1 3783  
688 0 0 6 666 3584 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3783  5 other 1 3783  3 ref 1 3783  
689 0 0 6 667 3584 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3783  5 other 1 3783  3 ref 1 3783  
690 0 0 6 668 3584 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3783  5 other 1 3783  
691 0 0 6 669 3584 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3783  5 other 1 3783  
692 0 0 7 670 3782 2610 0 0 2 4 this 3 3783  6 scalar 1 3584  
693 0 0 7 671 3782 2610 0 0 2 4 this 3 3783  6 scalar 1 3584  
694 0 0 39 672 3782 2610 0 0 2 4 this 3 3783  6 scalar 1 3584  
695 0 0 7 673 3782 2610 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 5 3600  
696 0 0 7 674 3782 2610 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 5 3600  
697 0 0 7 675 3782 2610 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 5 3600  
698 0 0 7 676 3782 2610 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 5 3600  
699 0 0 7 677 3782 2610 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 5 3600  
700 0 0 7 678 3782 2610 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 5 3600  
701 0 0 7 679 3782 2610 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3584  3 fwd 1 3584  2 up 1 3584  2 cs 5 3600  
702 0 0 38 680 3731 0 0 0 1 4 this 3 3783  
703 0 0 7 681 3745 0 0 0 0 
704 0 0 7 684 3785 2637 0 0 0 
705 0 0 7 684 3785 2637 0 10 /**
 *
 */ 2 4 copy 1 3750  1 z 1 3587  
706 0 0 23 684 3785 2637 0 10 /**
 *
 */ 1 4 copy 1 3777  
707 0 0 15 684 3785 2637 0 0 1 6 param0 0 3786  
708 0 0 23 684 3785 2637 0 10 /**
 *
 */ 1 10 fill_value 1 3587  
709 0 0 23 684 3785 2637 0 10 /**
 *
 */ 3 1 x 1 3587  1 y 1 3587  1 z 1 3587  
710 0 0 38 685 3728 0 0 0 2 4 this 3 3786  9 attr_name 1 3731  
711 0 0 38 686 3587 0 0 0 3 4 this 3 3785  9 attr_name 1 3731  6 assign 1 3728  
712 0 0 6 687 3786 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
713 0 0 6 688 3786 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
714 0 0 6 689 3786 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
715 0 0 6 690 3786 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
716 0 0 7 691 3758 2249 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3786  
717 0 0 7 692 3758 2249 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3786  
718 0 0 7 693 3758 2249 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3786  
719 0 0 7 697 3785 2637 0 0 1 4 this 3 3786  
720 0 0 7 698 3776 2536 0 0 2 4 this 3 3786  5 other 1 3777  
721 0 0 7 698 3785 2637 0 0 2 4 this 3 3786  5 other 1 3786  
722 0 0 7 699 3776 2536 0 0 2 4 this 3 3786  5 other 1 3777  
723 0 0 7 699 3785 2637 0 0 2 4 this 3 3786  5 other 1 3786  
724 0 0 7 700 3785 2637 0 10 /**
 *
 */ 2 4 this 3 3786  5 other 1 3777  
725 0 0 7 701 3785 2637 0 0 2 4 this 3 3786  6 scalar 1 3587  
726 0 0 7 702 3785 2637 0 0 2 4 this 3 3786  6 scalar 1 3587  
727 0 0 39 703 3785 2637 0 0 2 4 this 3 3786  6 scalar 1 3587  
728 0 0 7 704 3785 2637 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 5 3600  
729 0 0 7 705 3785 2637 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 5 3600  
730 0 0 7 706 3785 2637 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 5 3600  
731 0 0 7 707 3785 2637 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 5 3600  
732 0 0 7 708 3785 2637 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 5 3600  
733 0 0 7 709 3785 2637 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 5 3600  
734 0 0 7 710 3785 2637 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3587  3 fwd 1 3587  2 up 1 3587  2 cs 5 3600  
735 0 0 38 711 3731 0 0 0 1 4 this 3 3786  
736 0 0 7 712 3745 0 0 0 0 
737 0 0 7 715 3788 2661 0 0 0 
738 0 0 15 715 3788 2661 0 0 1 6 param0 0 3789  
739 0 0 7 715 3788 2661 0 10 /**
 *
 */ 2 4 copy 1 3723  1 z 1 3581  
740 0 0 23 715 3788 2661 0 10 /**
 *
 */ 1 4 copy 1 3771  
741 0 0 23 715 3788 2661 0 10 /**
 *
 */ 1 10 fill_value 1 3581  
742 0 0 23 715 3788 2661 0 10 /**
 *
 */ 3 1 x 1 3581  1 y 1 3581  1 z 1 3581  
743 0 0 38 716 3728 0 0 0 2 4 this 3 3789  9 attr_name 1 3731  
744 0 0 38 717 3587 0 0 0 3 4 this 3 3788  9 attr_name 1 3731  6 assign 1 3728  
745 0 0 6 718 3789 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
746 0 0 6 719 3789 0 0 34 /**
 * Returns a unit X point.
 */ 0 
747 0 0 6 720 3789 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
748 0 0 6 721 3789 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
749 0 0 7 722 3761 2266 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3789  
750 0 0 7 723 3761 2266 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3789  
751 0 0 7 724 3761 2266 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3789  
752 0 0 7 728 3788 2661 0 0 1 4 this 3 3789  
753 0 0 7 729 3770 2379 0 0 2 4 this 3 3789  5 other 1 3771  
754 0 0 7 729 3788 2661 0 0 2 4 this 3 3789  5 other 1 3780  
755 0 0 7 730 3779 2575 0 0 2 4 this 3 3789  5 other 1 3789  
756 0 0 7 730 3770 2379 0 0 2 4 this 3 3789  5 other 1 3771  
757 0 0 7 730 3788 2661 0 0 2 4 this 3 3789  5 other 1 3780  
758 0 0 7 731 3788 2661 0 10 /**
 *
 */ 2 4 this 3 3789  5 other 1 3771  
759 0 0 7 732 3788 2661 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3789  
760 0 0 7 733 3788 2661 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3789  4 onto 1 3771  
761 0 0 7 734 3788 2661 0 0 2 4 this 3 3789  6 scalar 1 3581  
762 0 0 7 735 3788 2661 0 0 2 4 this 3 3789  6 scalar 1 3581  
763 0 0 39 736 3788 2661 0 0 2 4 this 3 3789  6 scalar 1 3581  
764 0 0 6 737 3789 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 5 3600  
765 0 0 7 738 3788 2661 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3581  3 fwd 1 3581  2 up 1 3581  2 cs 5 3600  
766 0 0 38 739 3731 0 0 0 1 4 this 3 3789  
767 0 0 7 740 3745 0 0 0 0 
768 0 0 7 743 3791 2685 0 0 0 
769 0 0 15 743 3791 2685 0 0 1 6 param0 0 3792  
770 0 0 7 743 3791 2685 0 10 /**
 *
 */ 2 4 copy 1 3747  1 z 1 3584  
771 0 0 23 743 3791 2685 0 10 /**
 *
 */ 1 4 copy 1 3774  
772 0 0 23 743 3791 2685 0 10 /**
 *
 */ 1 10 fill_value 1 3584  
773 0 0 23 743 3791 2685 0 10 /**
 *
 */ 3 1 x 1 3584  1 y 1 3584  1 z 1 3584  
774 0 0 38 744 3728 0 0 0 2 4 this 3 3792  9 attr_name 1 3731  
775 0 0 38 745 3587 0 0 0 3 4 this 3 3791  9 attr_name 1 3731  6 assign 1 3728  
776 0 0 6 746 3792 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
777 0 0 6 747 3792 0 0 34 /**
 * Returns a unit X point.
 */ 0 
778 0 0 6 748 3792 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
779 0 0 6 749 3792 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
780 0 0 7 750 3764 2283 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3792  
781 0 0 7 751 3764 2283 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3792  
782 0 0 7 752 3764 2283 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3792  
783 0 0 7 756 3791 2685 0 0 1 4 this 3 3792  
784 0 0 7 757 3773 2460 0 0 2 4 this 3 3792  5 other 1 3774  
785 0 0 7 757 3791 2685 0 0 2 4 this 3 3792  5 other 1 3783  
786 0 0 7 758 3782 2610 0 0 2 4 this 3 3792  5 other 1 3792  
787 0 0 7 758 3773 2460 0 0 2 4 this 3 3792  5 other 1 3774  
788 0 0 7 758 3791 2685 0 0 2 4 this 3 3792  5 other 1 3783  
789 0 0 7 759 3791 2685 0 10 /**
 *
 */ 2 4 this 3 3792  5 other 1 3774  
790 0 0 7 760 3791 2685 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3792  
791 0 0 7 761 3791 2685 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3792  4 onto 1 3774  
792 0 0 7 762 3791 2685 0 0 2 4 this 3 3792  6 scalar 1 3584  
793 0 0 7 763 3791 2685 0 0 2 4 this 3 3792  6 scalar 1 3584  
794 0 0 39 764 3791 2685 0 0 2 4 this 3 3792  6 scalar 1 3584  
795 0 0 6 765 3792 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 5 3600  
796 0 0 7 766 3791 2685 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3584  3 fwd 1 3584  2 up 1 3584  2 cs 5 3600  
797 0 0 38 767 3731 0 0 0 1 4 this 3 3792  
798 0 0 7 768 3745 0 0 0 0 
799 0 0 7 771 3794 2707 0 0 0 
800 0 0 15 771 3794 2707 0 0 1 6 param0 0 3795  
801 0 0 7 771 3794 2707 0 10 /**
 *
 */ 2 4 copy 1 3750  1 z 1 3587  
802 0 0 23 771 3794 2707 0 10 /**
 *
 */ 1 4 copy 1 3777  
803 0 0 23 771 3794 2707 0 10 /**
 *
 */ 1 10 fill_value 1 3587  
804 0 0 23 771 3794 2707 0 10 /**
 *
 */ 3 1 x 1 3587  1 y 1 3587  1 z 1 3587  
805 0 0 38 772 3728 0 0 0 2 4 this 3 3795  9 attr_name 1 3731  
806 0 0 38 773 3587 0 0 0 3 4 this 3 3794  9 attr_name 1 3731  6 assign 1 3728  
807 0 0 6 774 3795 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
808 0 0 6 775 3795 0 0 34 /**
 * Returns a unit X point.
 */ 0 
809 0 0 6 776 3795 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
810 0 0 6 777 3795 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
811 0 0 7 778 3767 2298 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3795  
812 0 0 7 779 3767 2298 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3795  
813 0 0 7 780 3767 2298 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3795  
814 0 0 7 784 3794 2707 0 0 1 4 this 3 3795  
815 0 0 7 785 3776 2536 0 0 2 4 this 3 3795  5 other 1 3777  
816 0 0 7 785 3794 2707 0 0 2 4 this 3 3795  5 other 1 3786  
817 0 0 7 786 3785 2637 0 0 2 4 this 3 3795  5 other 1 3795  
818 0 0 7 786 3776 2536 0 0 2 4 this 3 3795  5 other 1 3777  
819 0 0 7 786 3794 2707 0 0 2 4 this 3 3795  5 other 1 3786  
820 0 0 7 787 3794 2707 0 10 /**
 *
 */ 2 4 this 3 3795  5 other 1 3777  
821 0 0 7 788 3794 2707 0 0 2 4 this 3 3795  6 scalar 1 3587  
822 0 0 7 789 3794 2707 0 0 2 4 this 3 3795  6 scalar 1 3587  
823 0 0 39 790 3794 2707 0 0 2 4 this 3 3795  6 scalar 1 3587  
824 0 0 6 791 3795 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 5 3600  
825 0 0 7 792 3794 2707 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3587  3 fwd 1 3587  2 up 1 3587  2 cs 5 3600  
826 0 0 38 793 3731 0 0 0 1 4 this 3 3795  
827 0 0 7 794 3745 0 0 0 0 
828 0 0 7 799 3797 2789 0 0 0 
829 0 0 23 799 3797 2789 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3789  
830 0 0 7 799 3797 2789 0 10 /**
 *
 */ 2 4 copy 1 3771  1 w 1 3581  
831 0 0 15 799 3797 2789 0 0 1 6 param0 0 3798  
832 0 0 23 799 3797 2789 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3780  
833 0 0 23 799 3797 2789 0 10 /**
 *
 */ 1 10 fill_value 1 3581  
834 0 0 23 799 3797 2789 0 10 /**
 *
 */ 4 1 x 1 3581  1 y 1 3581  1 z 1 3581  1 w 1 3581  
835 0 0 4 800 3727 0 0 0 2 4 this 3 3797  4 size 1 3725  
836 0 0 6 803 3797 0 0 0 2 4 this 3 3797  4 copy 1 3798  
837 0 0 6 803 3797 0 0 0 2 4 this 3 3797  10 fill_value 1 3581  
838 0 0 6 804 3798 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
839 0 0 6 805 3798 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
840 0 0 6 806 3798 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
841 0 0 6 807 3798 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
842 0 0 6 808 3798 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
843 0 0 38 809 3728 0 0 0 1 4 this 3 3798  
844 0 0 38 810 3728 0 0 0 2 4 this 3 3798  9 attr_name 1 3731  
845 0 0 38 811 3587 0 0 0 3 4 this 3 3797  9 attr_name 1 3731  6 assign 1 3728  
846 0 0 4 812 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  1 i 1 3587  
847 0 0 6 812 3581 0 0 0 2 4 this 3 3798  1 i 1 3587  
848 0 0 4 813 3727 0 0 0 3 4 this 3 3797  1 i 1 3587  10 assign_val 1 3581  
849 0 0 6 814 3587 0 0 0 0 
850 0 0 6 815 3732 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3798  
851 0 0 6 816 3581 0 0 10 /**
 *
 */ 2 4 this 3 3798  1 i 1 3587  
852 0 0 4 817 3727 0 0 10 /**
 *
 */ 3 4 this 3 3797  1 i 1 3587  5 value 1 3581  
853 0 0 6 818 3581 0 0 10 /**
 *
 */ 1 4 this 3 3798  
854 0 0 6 819 3581 0 0 10 /**
 *
 */ 1 4 this 3 3798  
855 0 0 6 820 3581 0 0 10 /**
 *
 */ 1 4 this 3 3798  
856 0 0 6 821 3581 0 0 10 /**
 *
 */ 1 4 this 3 3798  
857 0 0 7 822 3770 2379 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3798  
858 0 0 7 823 3722 2058 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3798  
859 0 0 4 824 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  5 value 1 3581  
860 0 0 4 825 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  5 value 1 3581  
861 0 0 4 826 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  5 value 1 3581  
862 0 0 4 827 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  5 value 1 3581  
863 0 0 4 833 3727 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3797  1 i 1 3587  5 value 1 3581  
864 0 0 4 834 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  5 value 1 3581  
865 0 0 4 835 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  5 value 1 3581  
866 0 0 4 836 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  5 value 1 3581  
867 0 0 4 837 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  5 value 1 3581  
868 0 0 4 838 3727 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3798  
869 0 0 6 839 3587 0 0 0 0 
870 0 0 4 841 3727 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3797  10 fill_value 1 3581  
871 0 0 4 842 3727 0 0 10 /**
 *
 */ 5 4 this 3 3797  1 x 1 3581  1 y 1 3581  1 z 1 3581  1 w 1 3581  
872 0 0 6 843 3581 0 0 10 /**
 *
 */ 2 4 this 3 3798  5 other 1 3798  
873 0 0 6 844 3581 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3798  
874 0 0 6 845 3581 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3798  
875 0 0 6 846 3732 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3797  
876 0 0 7 847 3797 2789 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3798  
877 0 0 7 848 3797 2789 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3798  4 onto 1 3798  
878 0 0 6 849 3732 0 0 0 2 4 this 3 3798  5 other 1 3798  
879 0 0 6 850 3732 0 0 0 2 4 this 3 3798  5 other 1 3798  
880 0 0 6 851 3732 0 0 0 2 4 this 3 3798  5 other 1 3798  
881 0 0 6 852 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3798  5 other 1 3798  
882 0 0 6 852 3587 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3798  5 other 1 3798  9 threshold 1 3581  
883 0 0 6 853 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3798  
884 0 0 6 853 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3798  9 threshold 1 3581  
885 0 0 6 854 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3798  4 hash 1 3725  
886 0 0 6 854 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3798  4 hash 1 3725  9 threshold 1 3581  
887 0 0 4 855 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3798  7 hashgen 1 3733  
888 0 0 4 855 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3798  7 hashgen 1 3733  9 threshold 1 3581  
889 0 0 7 856 3797 2789 0 0 1 4 this 3 3798  
890 0 0 7 857 3797 2789 0 0 2 4 this 3 3798  5 other 1 3798  
891 0 0 7 858 3797 2789 0 0 2 4 this 3 3798  5 other 1 3798  
892 0 0 7 859 3797 2789 0 0 2 4 this 3 3798  6 scalar 1 3581  
893 0 0 7 860 3797 2789 0 0 2 4 this 3 3798  6 scalar 1 3581  
894 0 0 6 861 3797 0 0 0 2 4 this 3 3797  5 other 1 3798  
895 0 0 6 862 3797 0 0 0 2 4 this 3 3797  5 other 1 3798  
896 0 0 6 863 3797 0 0 0 2 4 this 3 3797  6 scalar 1 3581  
897 0 0 6 864 3797 0 0 0 2 4 this 3 3797  6 scalar 1 3581  
898 0 0 4 865 3727 0 0 10 /**
 *
 */ 2 4 this 3 3797  5 other 1 3798  
899 0 0 38 866 3728 0 0 0 2 4 this 3 3798  6 scalar 1 3581  
900 0 0 38 867 3728 0 0 0 2 4 this 3 3798  6 scalar 1 3581  
901 0 0 38 868 3728 0 0 0 2 4 this 3 3797  6 scalar 1 3581  
902 0 0 38 869 3728 0 0 0 2 4 this 3 3798  8 exponent 1 3581  
903 0 0 38 870 3728 0 0 0 2 4 this 3 3797  8 exponent 1 3581  
904 0 0 38 871 3728 0 0 0 1 4 this 3 3797  
905 0 0 38 872 3728 0 0 0 1 4 this 3 3797  
906 0 0 38 873 3728 0 0 0 1 4 this 3 3797  
907 0 0 7 874 3797 2789 0 10 /**
 *
 */ 2 4 this 3 3798  5 other 1 3798  
908 0 0 7 875 3797 2789 0 10 /**
 *
 */ 2 4 this 3 3798  5 other 1 3798  
909 0 0 6 876 3732 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3798  5 other 1 3798  
910 0 0 6 876 3732 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3798  5 other 1 3798  9 threshold 1 3581  
911 0 0 4 877 3727 0 0 10 /**
 *
 */ 2 4 this 3 3798  3 out 1 3735  
912 0 0 38 878 3731 0 0 0 1 4 this 3 3798  
913 0 0 4 879 3727 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3798  11 destination 1 3737  
914 0 0 4 880 3727 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3797  6 source 1 3739  
915 0 0 4 881 3727 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3798  11 destination 1 3737  
916 0 0 4 882 3727 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3797  6 source 1 3739  
917 0 0 38 883 3587 0 0 0 3 4 this 3 3798  4 view 1 3741  5 flags 1 3587  
918 0 0 7 884 3745 0 0 0 0 
919 0 0 7 888 3800 2871 0 0 0 
920 0 0 23 888 3800 2871 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3792  
921 0 0 7 888 3800 2871 0 10 /**
 *
 */ 2 4 copy 1 3774  1 w 1 3584  
922 0 0 15 888 3800 2871 0 0 1 6 param0 0 3801  
923 0 0 23 888 3800 2871 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3783  
924 0 0 23 888 3800 2871 0 10 /**
 *
 */ 1 10 fill_value 1 3584  
925 0 0 23 888 3800 2871 0 10 /**
 *
 */ 4 1 x 1 3584  1 y 1 3584  1 z 1 3584  1 w 1 3584  
926 0 0 4 889 3727 0 0 0 2 4 this 3 3800  4 size 1 3725  
927 0 0 6 892 3800 0 0 0 2 4 this 3 3800  4 copy 1 3801  
928 0 0 6 892 3800 0 0 0 2 4 this 3 3800  10 fill_value 1 3584  
929 0 0 6 893 3801 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
930 0 0 6 894 3801 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
931 0 0 6 895 3801 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
932 0 0 6 896 3801 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
933 0 0 6 897 3801 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
934 0 0 38 898 3728 0 0 0 1 4 this 3 3801  
935 0 0 38 899 3728 0 0 0 2 4 this 3 3801  9 attr_name 1 3731  
936 0 0 38 900 3587 0 0 0 3 4 this 3 3800  9 attr_name 1 3731  6 assign 1 3728  
937 0 0 4 901 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  1 i 1 3587  
938 0 0 6 901 3584 0 0 0 2 4 this 3 3801  1 i 1 3587  
939 0 0 4 902 3727 0 0 0 3 4 this 3 3800  1 i 1 3587  10 assign_val 1 3584  
940 0 0 6 903 3587 0 0 0 0 
941 0 0 6 904 3732 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3801  
942 0 0 6 905 3584 0 0 10 /**
 *
 */ 2 4 this 3 3801  1 i 1 3587  
943 0 0 4 906 3727 0 0 10 /**
 *
 */ 3 4 this 3 3800  1 i 1 3587  5 value 1 3584  
944 0 0 6 907 3584 0 0 10 /**
 *
 */ 1 4 this 3 3801  
945 0 0 6 908 3584 0 0 10 /**
 *
 */ 1 4 this 3 3801  
946 0 0 6 909 3584 0 0 10 /**
 *
 */ 1 4 this 3 3801  
947 0 0 6 910 3584 0 0 10 /**
 *
 */ 1 4 this 3 3801  
948 0 0 7 911 3773 2460 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3801  
949 0 0 7 912 3746 2129 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3801  
950 0 0 4 913 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 value 1 3584  
951 0 0 4 914 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 value 1 3584  
952 0 0 4 915 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 value 1 3584  
953 0 0 4 916 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 value 1 3584  
954 0 0 4 922 3727 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3800  1 i 1 3587  5 value 1 3584  
955 0 0 4 923 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 value 1 3584  
956 0 0 4 924 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 value 1 3584  
957 0 0 4 925 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 value 1 3584  
958 0 0 4 926 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 value 1 3584  
959 0 0 4 927 3727 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3801  
960 0 0 6 928 3587 0 0 0 0 
961 0 0 4 930 3727 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3800  10 fill_value 1 3584  
962 0 0 4 931 3727 0 0 10 /**
 *
 */ 5 4 this 3 3800  1 x 1 3584  1 y 1 3584  1 z 1 3584  1 w 1 3584  
963 0 0 6 932 3584 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 other 1 3801  
964 0 0 6 933 3584 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3801  
965 0 0 6 934 3584 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3801  
966 0 0 6 935 3732 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3800  
967 0 0 7 936 3800 2871 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3801  
968 0 0 7 937 3800 2871 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3801  4 onto 1 3801  
969 0 0 6 938 3732 0 0 0 2 4 this 3 3801  5 other 1 3801  
970 0 0 6 939 3732 0 0 0 2 4 this 3 3801  5 other 1 3801  
971 0 0 6 940 3732 0 0 0 2 4 this 3 3801  5 other 1 3801  
972 0 0 6 941 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3801  5 other 1 3801  
973 0 0 6 941 3587 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3801  5 other 1 3801  9 threshold 1 3584  
974 0 0 6 942 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3801  
975 0 0 6 942 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3801  9 threshold 1 3584  
976 0 0 6 943 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3801  4 hash 1 3725  
977 0 0 6 943 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3801  4 hash 1 3725  9 threshold 1 3584  
978 0 0 4 944 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3801  7 hashgen 1 3733  
979 0 0 4 944 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3801  7 hashgen 1 3733  9 threshold 1 3584  
980 0 0 7 945 3800 2871 0 0 1 4 this 3 3801  
981 0 0 7 946 3800 2871 0 0 2 4 this 3 3801  5 other 1 3801  
982 0 0 7 947 3800 2871 0 0 2 4 this 3 3801  5 other 1 3801  
983 0 0 7 948 3800 2871 0 0 2 4 this 3 3801  6 scalar 1 3584  
984 0 0 7 949 3800 2871 0 0 2 4 this 3 3801  6 scalar 1 3584  
985 0 0 6 950 3800 0 0 0 2 4 this 3 3800  5 other 1 3801  
986 0 0 6 951 3800 0 0 0 2 4 this 3 3800  5 other 1 3801  
987 0 0 6 952 3800 0 0 0 2 4 this 3 3800  6 scalar 1 3584  
988 0 0 6 953 3800 0 0 0 2 4 this 3 3800  6 scalar 1 3584  
989 0 0 4 954 3727 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 other 1 3801  
990 0 0 38 955 3728 0 0 0 2 4 this 3 3801  6 scalar 1 3584  
991 0 0 38 956 3728 0 0 0 2 4 this 3 3801  6 scalar 1 3584  
992 0 0 38 957 3728 0 0 0 2 4 this 3 3800  6 scalar 1 3584  
993 0 0 38 958 3728 0 0 0 2 4 this 3 3801  8 exponent 1 3584  
994 0 0 38 959 3728 0 0 0 2 4 this 3 3800  8 exponent 1 3584  
995 0 0 38 960 3728 0 0 0 1 4 this 3 3800  
996 0 0 38 961 3728 0 0 0 1 4 this 3 3800  
997 0 0 38 962 3728 0 0 0 1 4 this 3 3800  
998 0 0 7 963 3800 2871 0 10 /**
 *
 */ 2 4 this 3 3801  5 other 1 3801  
999 0 0 7 964 3800 2871 0 10 /**
 *
 */ 2 4 this 3 3801  5 other 1 3801  
1000 0 0 6 965 3732 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3801  5 other 1 3801  
1001 0 0 6 965 3732 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3801  5 other 1 3801  9 threshold 1 3584  
1002 0 0 4 966 3727 0 0 10 /**
 *
 */ 2 4 this 3 3801  3 out 1 3735  
1003 0 0 38 967 3731 0 0 0 1 4 this 3 3801  
1004 0 0 4 968 3727 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3801  11 destination 1 3737  
1005 0 0 4 969 3727 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3800  6 source 1 3739  
1006 0 0 4 970 3727 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3801  11 destination 1 3737  
1007 0 0 4 971 3727 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3800  6 source 1 3739  
1008 0 0 38 972 3587 0 0 0 3 4 this 3 3801  4 view 1 3741  5 flags 1 3587  
1009 0 0 7 973 3745 0 0 0 0 
1010 0 0 7 977 3803 2949 0 0 0 
1011 0 0 23 977 3803 2949 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3795  
1012 0 0 7 977 3803 2949 0 10 /**
 *
 */ 2 4 copy 1 3777  1 w 1 3587  
1013 0 0 15 977 3803 2949 0 0 1 6 param0 0 3804  
1014 0 0 23 977 3803 2949 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3786  
1015 0 0 23 977 3803 2949 0 10 /**
 *
 */ 1 10 fill_value 1 3587  
1016 0 0 23 977 3803 2949 0 10 /**
 *
 */ 4 1 x 1 3587  1 y 1 3587  1 z 1 3587  1 w 1 3587  
1017 0 0 4 978 3727 0 0 0 2 4 this 3 3803  4 size 1 3725  
1018 0 0 6 981 3803 0 0 0 2 4 this 3 3803  4 copy 1 3804  
1019 0 0 6 981 3803 0 0 0 2 4 this 3 3803  10 fill_value 1 3587  
1020 0 0 6 982 3804 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1021 0 0 6 983 3804 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1022 0 0 6 984 3804 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1023 0 0 6 985 3804 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1024 0 0 6 986 3804 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1025 0 0 38 987 3728 0 0 0 1 4 this 3 3804  
1026 0 0 38 988 3728 0 0 0 2 4 this 3 3804  9 attr_name 1 3731  
1027 0 0 38 989 3587 0 0 0 3 4 this 3 3803  9 attr_name 1 3731  6 assign 1 3728  
1028 0 0 4 990 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  1 i 1 3587  
1029 0 0 6 990 3587 0 0 0 2 4 this 3 3804  1 i 1 3587  
1030 0 0 4 991 3727 0 0 0 3 4 this 3 3803  1 i 1 3587  10 assign_val 1 3587  
1031 0 0 6 992 3587 0 0 0 0 
1032 0 0 6 993 3732 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3804  
1033 0 0 6 994 3587 0 0 10 /**
 *
 */ 2 4 this 3 3804  1 i 1 3587  
1034 0 0 4 995 3727 0 0 10 /**
 *
 */ 3 4 this 3 3803  1 i 1 3587  5 value 1 3587  
1035 0 0 6 996 3587 0 0 10 /**
 *
 */ 1 4 this 3 3804  
1036 0 0 6 997 3587 0 0 10 /**
 *
 */ 1 4 this 3 3804  
1037 0 0 6 998 3587 0 0 10 /**
 *
 */ 1 4 this 3 3804  
1038 0 0 6 999 3587 0 0 10 /**
 *
 */ 1 4 this 3 3804  
1039 0 0 7 1000 3776 2536 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3804  
1040 0 0 7 1001 3749 2196 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3804  
1041 0 0 4 1002 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 value 1 3587  
1042 0 0 4 1003 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 value 1 3587  
1043 0 0 4 1004 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 value 1 3587  
1044 0 0 4 1005 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 value 1 3587  
1045 0 0 4 1011 3727 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3803  1 i 1 3587  5 value 1 3587  
1046 0 0 4 1012 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 value 1 3587  
1047 0 0 4 1013 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 value 1 3587  
1048 0 0 4 1014 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 value 1 3587  
1049 0 0 4 1015 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 value 1 3587  
1050 0 0 4 1016 3727 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3804  
1051 0 0 6 1017 3587 0 0 0 0 
1052 0 0 4 1019 3727 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3803  10 fill_value 1 3587  
1053 0 0 4 1020 3727 0 0 10 /**
 *
 */ 5 4 this 3 3803  1 x 1 3587  1 y 1 3587  1 z 1 3587  1 w 1 3587  
1054 0 0 6 1021 3587 0 0 10 /**
 *
 */ 2 4 this 3 3804  5 other 1 3804  
1055 0 0 6 1022 3587 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3804  
1056 0 0 6 1023 3732 0 0 0 2 4 this 3 3804  5 other 1 3804  
1057 0 0 6 1024 3732 0 0 0 2 4 this 3 3804  5 other 1 3804  
1058 0 0 6 1025 3732 0 0 0 2 4 this 3 3804  5 other 1 3804  
1059 0 0 6 1026 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3804  5 other 1 3804  
1060 0 0 6 1027 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3804  
1061 0 0 6 1028 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3804  4 hash 1 3725  
1062 0 0 4 1029 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3804  7 hashgen 1 3733  
1063 0 0 7 1030 3803 2949 0 0 1 4 this 3 3804  
1064 0 0 7 1031 3803 2949 0 0 2 4 this 3 3804  5 other 1 3804  
1065 0 0 7 1032 3803 2949 0 0 2 4 this 3 3804  5 other 1 3804  
1066 0 0 7 1033 3803 2949 0 0 2 4 this 3 3804  6 scalar 1 3587  
1067 0 0 7 1034 3803 2949 0 0 2 4 this 3 3804  6 scalar 1 3587  
1068 0 0 6 1035 3803 0 0 0 2 4 this 3 3803  5 other 1 3804  
1069 0 0 6 1036 3803 0 0 0 2 4 this 3 3803  5 other 1 3804  
1070 0 0 6 1037 3803 0 0 0 2 4 this 3 3803  6 scalar 1 3587  
1071 0 0 6 1038 3803 0 0 0 2 4 this 3 3803  6 scalar 1 3587  
1072 0 0 4 1039 3727 0 0 10 /**
 *
 */ 2 4 this 3 3803  5 other 1 3804  
1073 0 0 38 1040 3728 0 0 0 2 4 this 3 3804  6 scalar 1 3587  
1074 0 0 38 1041 3728 0 0 0 2 4 this 3 3804  6 scalar 1 3587  
1075 0 0 38 1042 3728 0 0 0 2 4 this 3 3803  6 scalar 1 3587  
1076 0 0 38 1043 3728 0 0 0 2 4 this 3 3804  8 exponent 1 3587  
1077 0 0 38 1044 3728 0 0 0 2 4 this 3 3803  8 exponent 1 3587  
1078 0 0 38 1045 3728 0 0 0 1 4 this 3 3803  
1079 0 0 38 1046 3728 0 0 0 1 4 this 3 3803  
1080 0 0 38 1047 3728 0 0 0 1 4 this 3 3803  
1081 0 0 7 1048 3803 2949 0 10 /**
 *
 */ 2 4 this 3 3804  5 other 1 3804  
1082 0 0 7 1049 3803 2949 0 10 /**
 *
 */ 2 4 this 3 3804  5 other 1 3804  
1083 0 0 6 1050 3732 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3804  5 other 1 3804  
1084 0 0 6 1050 3732 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3804  5 other 1 3804  9 threshold 1 3587  
1085 0 0 4 1051 3727 0 0 10 /**
 *
 */ 2 4 this 3 3804  3 out 1 3735  
1086 0 0 38 1052 3731 0 0 0 1 4 this 3 3804  
1087 0 0 4 1053 3727 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3804  11 destination 1 3737  
1088 0 0 4 1054 3727 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3803  6 source 1 3739  
1089 0 0 4 1055 3727 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3804  11 destination 1 3737  
1090 0 0 4 1056 3727 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3803  6 source 1 3739  
1091 0 0 38 1057 3587 0 0 0 3 4 this 3 3804  4 view 1 3741  5 flags 1 3587  
1092 0 0 7 1058 3745 0 0 0 0 
1093 0 0 7 1061 3806 2970 0 0 0 
1094 0 0 7 1061 3806 2970 0 10 /**
 *
 */ 2 4 copy 1 3771  1 w 1 3581  
1095 0 0 23 1061 3806 2970 0 10 /**
 *
 */ 1 4 copy 1 3798  
1096 0 0 15 1061 3806 2970 0 0 1 6 param0 0 3807  
1097 0 0 23 1061 3806 2970 0 10 /**
 *
 */ 1 10 fill_value 1 3581  
1098 0 0 23 1061 3806 2970 0 10 /**
 *
 */ 4 1 x 1 3581  1 y 1 3581  1 z 1 3581  1 w 1 3581  
1099 0 0 38 1062 3728 0 0 0 2 4 this 3 3807  9 attr_name 1 3731  
1100 0 0 38 1063 3587 0 0 0 3 4 this 3 3806  9 attr_name 1 3731  6 assign 1 3728  
1101 0 0 6 1064 3807 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1102 0 0 6 1065 3807 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1103 0 0 6 1066 3807 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1104 0 0 6 1067 3807 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1105 0 0 6 1068 3807 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1106 0 0 7 1069 3779 2575 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3807  
1107 0 0 7 1070 3752 2215 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3807  
1108 0 0 7 1073 3806 2970 0 0 1 4 this 3 3807  
1109 0 0 7 1074 3797 2789 0 0 2 4 this 3 3807  5 other 1 3798  
1110 0 0 7 1074 3806 2970 0 0 2 4 this 3 3807  5 other 1 3807  
1111 0 0 7 1075 3797 2789 0 0 2 4 this 3 3807  5 other 1 3798  
1112 0 0 7 1075 3806 2970 0 0 2 4 this 3 3807  5 other 1 3807  
1113 0 0 7 1076 3806 2970 0 0 2 4 this 3 3807  6 scalar 1 3581  
1114 0 0 7 1077 3806 2970 0 0 2 4 this 3 3807  6 scalar 1 3581  
1115 0 0 39 1078 3806 2970 0 0 2 4 this 3 3807  6 scalar 1 3581  
1116 0 0 7 1079 3806 2970 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3807  
1117 0 0 7 1080 3806 2970 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3807  4 onto 1 3798  
1118 0 0 38 1081 3731 0 0 0 1 4 this 3 3807  
1119 0 0 7 1082 3745 0 0 0 0 
1120 0 0 7 1085 3809 2991 0 0 0 
1121 0 0 7 1085 3809 2991 0 10 /**
 *
 */ 2 4 copy 1 3774  1 w 1 3584  
1122 0 0 23 1085 3809 2991 0 10 /**
 *
 */ 1 4 copy 1 3801  
1123 0 0 15 1085 3809 2991 0 0 1 6 param0 0 3810  
1124 0 0 23 1085 3809 2991 0 10 /**
 *
 */ 1 10 fill_value 1 3584  
1125 0 0 23 1085 3809 2991 0 10 /**
 *
 */ 4 1 x 1 3584  1 y 1 3584  1 z 1 3584  1 w 1 3584  
1126 0 0 38 1086 3728 0 0 0 2 4 this 3 3810  9 attr_name 1 3731  
1127 0 0 38 1087 3587 0 0 0 3 4 this 3 3809  9 attr_name 1 3731  6 assign 1 3728  
1128 0 0 6 1088 3810 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1129 0 0 6 1089 3810 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1130 0 0 6 1090 3810 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1131 0 0 6 1091 3810 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1132 0 0 6 1092 3810 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1133 0 0 7 1093 3782 2610 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3810  
1134 0 0 7 1094 3755 2234 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3810  
1135 0 0 7 1097 3809 2991 0 0 1 4 this 3 3810  
1136 0 0 7 1098 3800 2871 0 0 2 4 this 3 3810  5 other 1 3801  
1137 0 0 7 1098 3809 2991 0 0 2 4 this 3 3810  5 other 1 3810  
1138 0 0 7 1099 3800 2871 0 0 2 4 this 3 3810  5 other 1 3801  
1139 0 0 7 1099 3809 2991 0 0 2 4 this 3 3810  5 other 1 3810  
1140 0 0 7 1100 3809 2991 0 0 2 4 this 3 3810  6 scalar 1 3584  
1141 0 0 7 1101 3809 2991 0 0 2 4 this 3 3810  6 scalar 1 3584  
1142 0 0 39 1102 3809 2991 0 0 2 4 this 3 3810  6 scalar 1 3584  
1143 0 0 7 1103 3809 2991 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3810  
1144 0 0 7 1104 3809 2991 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3810  4 onto 1 3801  
1145 0 0 38 1105 3731 0 0 0 1 4 this 3 3810  
1146 0 0 7 1106 3745 0 0 0 0 
1147 0 0 7 1109 3812 3010 0 0 0 
1148 0 0 7 1109 3812 3010 0 10 /**
 *
 */ 2 4 copy 1 3777  1 w 1 3587  
1149 0 0 23 1109 3812 3010 0 10 /**
 *
 */ 1 4 copy 1 3804  
1150 0 0 15 1109 3812 3010 0 0 1 6 param0 0 3813  
1151 0 0 23 1109 3812 3010 0 10 /**
 *
 */ 1 10 fill_value 1 3587  
1152 0 0 23 1109 3812 3010 0 10 /**
 *
 */ 4 1 x 1 3587  1 y 1 3587  1 z 1 3587  1 w 1 3587  
1153 0 0 38 1110 3728 0 0 0 2 4 this 3 3813  9 attr_name 1 3731  
1154 0 0 38 1111 3587 0 0 0 3 4 this 3 3812  9 attr_name 1 3731  6 assign 1 3728  
1155 0 0 6 1112 3813 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1156 0 0 6 1113 3813 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1157 0 0 6 1114 3813 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1158 0 0 6 1115 3813 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1159 0 0 6 1116 3813 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1160 0 0 7 1117 3785 2637 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3813  
1161 0 0 7 1118 3758 2249 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3813  
1162 0 0 7 1121 3812 3010 0 0 1 4 this 3 3813  
1163 0 0 7 1122 3803 2949 0 0 2 4 this 3 3813  5 other 1 3804  
1164 0 0 7 1122 3812 3010 0 0 2 4 this 3 3813  5 other 1 3813  
1165 0 0 7 1123 3803 2949 0 0 2 4 this 3 3813  5 other 1 3804  
1166 0 0 7 1123 3812 3010 0 0 2 4 this 3 3813  5 other 1 3813  
1167 0 0 7 1124 3812 3010 0 0 2 4 this 3 3813  6 scalar 1 3587  
1168 0 0 7 1125 3812 3010 0 0 2 4 this 3 3813  6 scalar 1 3587  
1169 0 0 39 1126 3812 3010 0 0 2 4 this 3 3813  6 scalar 1 3587  
1170 0 0 38 1127 3731 0 0 0 1 4 this 3 3813  
1171 0 0 7 1128 3745 0 0 0 0 
1172 0 0 7 1131 3815 3031 0 0 0 
1173 0 0 15 1131 3815 3031 0 0 1 6 param0 0 3816  
1174 0 0 7 1131 3815 3031 0 10 /**
 *
 */ 2 4 copy 1 3771  1 w 1 3581  
1175 0 0 23 1131 3815 3031 0 10 /**
 *
 */ 1 4 copy 1 3798  
1176 0 0 23 1131 3815 3031 0 10 /**
 *
 */ 1 10 fill_value 1 3581  
1177 0 0 23 1131 3815 3031 0 10 /**
 *
 */ 4 1 x 1 3581  1 y 1 3581  1 z 1 3581  1 w 1 3581  
1178 0 0 38 1132 3728 0 0 0 2 4 this 3 3816  9 attr_name 1 3731  
1179 0 0 38 1133 3587 0 0 0 3 4 this 3 3815  9 attr_name 1 3731  6 assign 1 3728  
1180 0 0 6 1134 3816 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1181 0 0 6 1135 3816 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1182 0 0 6 1136 3816 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1183 0 0 6 1137 3816 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1184 0 0 6 1138 3816 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1185 0 0 7 1139 3788 2661 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3816  
1186 0 0 7 1140 3761 2266 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3816  
1187 0 0 7 1143 3815 3031 0 0 1 4 this 3 3816  
1188 0 0 7 1144 3797 2789 0 0 2 4 this 3 3816  5 other 1 3798  
1189 0 0 7 1144 3815 3031 0 0 2 4 this 3 3816  5 other 1 3807  
1190 0 0 7 1145 3806 2970 0 0 2 4 this 3 3816  5 other 1 3816  
1191 0 0 7 1145 3797 2789 0 0 2 4 this 3 3816  5 other 1 3798  
1192 0 0 7 1145 3815 3031 0 0 2 4 this 3 3816  5 other 1 3807  
1193 0 0 7 1146 3815 3031 0 0 2 4 this 3 3816  6 scalar 1 3581  
1194 0 0 7 1147 3815 3031 0 0 2 4 this 3 3816  6 scalar 1 3581  
1195 0 0 39 1148 3815 3031 0 0 2 4 this 3 3816  6 scalar 1 3581  
1196 0 0 7 1149 3815 3031 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3816  
1197 0 0 7 1150 3815 3031 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3816  4 onto 1 3798  
1198 0 0 38 1151 3731 0 0 0 1 4 this 3 3816  
1199 0 0 7 1152 3745 0 0 0 0 
1200 0 0 7 1155 3818 3052 0 0 0 
1201 0 0 15 1155 3818 3052 0 0 1 6 param0 0 3819  
1202 0 0 7 1155 3818 3052 0 10 /**
 *
 */ 2 4 copy 1 3774  1 w 1 3584  
1203 0 0 23 1155 3818 3052 0 10 /**
 *
 */ 1 4 copy 1 3801  
1204 0 0 23 1155 3818 3052 0 10 /**
 *
 */ 1 10 fill_value 1 3584  
1205 0 0 23 1155 3818 3052 0 10 /**
 *
 */ 4 1 x 1 3584  1 y 1 3584  1 z 1 3584  1 w 1 3584  
1206 0 0 38 1156 3728 0 0 0 2 4 this 3 3819  9 attr_name 1 3731  
1207 0 0 38 1157 3587 0 0 0 3 4 this 3 3818  9 attr_name 1 3731  6 assign 1 3728  
1208 0 0 6 1158 3819 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1209 0 0 6 1159 3819 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1210 0 0 6 1160 3819 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1211 0 0 6 1161 3819 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1212 0 0 6 1162 3819 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1213 0 0 7 1163 3791 2685 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3819  
1214 0 0 7 1164 3764 2283 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3819  
1215 0 0 7 1167 3818 3052 0 0 1 4 this 3 3819  
1216 0 0 7 1168 3800 2871 0 0 2 4 this 3 3819  5 other 1 3801  
1217 0 0 7 1168 3818 3052 0 0 2 4 this 3 3819  5 other 1 3810  
1218 0 0 7 1169 3809 2991 0 0 2 4 this 3 3819  5 other 1 3819  
1219 0 0 7 1169 3800 2871 0 0 2 4 this 3 3819  5 other 1 3801  
1220 0 0 7 1169 3818 3052 0 0 2 4 this 3 3819  5 other 1 3810  
1221 0 0 7 1170 3818 3052 0 0 2 4 this 3 3819  6 scalar 1 3584  
1222 0 0 7 1171 3818 3052 0 0 2 4 this 3 3819  6 scalar 1 3584  
1223 0 0 39 1172 3818 3052 0 0 2 4 this 3 3819  6 scalar 1 3584  
1224 0 0 7 1173 3818 3052 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3819  
1225 0 0 7 1174 3818 3052 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3819  4 onto 1 3801  
1226 0 0 38 1175 3731 0 0 0 1 4 this 3 3819  
1227 0 0 7 1176 3745 0 0 0 0 
1228 0 0 7 1179 3821 3071 0 0 0 
1229 0 0 15 1179 3821 3071 0 0 1 6 param0 0 3822  
1230 0 0 7 1179 3821 3071 0 10 /**
 *
 */ 2 4 copy 1 3777  1 w 1 3587  
1231 0 0 23 1179 3821 3071 0 10 /**
 *
 */ 1 4 copy 1 3804  
1232 0 0 23 1179 3821 3071 0 10 /**
 *
 */ 1 10 fill_value 1 3587  
1233 0 0 23 1179 3821 3071 0 10 /**
 *
 */ 4 1 x 1 3587  1 y 1 3587  1 z 1 3587  1 w 1 3587  
1234 0 0 38 1180 3728 0 0 0 2 4 this 3 3822  9 attr_name 1 3731  
1235 0 0 38 1181 3587 0 0 0 3 4 this 3 3821  9 attr_name 1 3731  6 assign 1 3728  
1236 0 0 6 1182 3822 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1237 0 0 6 1183 3822 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1238 0 0 6 1184 3822 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1239 0 0 6 1185 3822 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1240 0 0 6 1186 3822 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1241 0 0 7 1187 3794 2707 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3822  
1242 0 0 7 1188 3767 2298 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3822  
1243 0 0 7 1191 3821 3071 0 0 1 4 this 3 3822  
1244 0 0 7 1192 3803 2949 0 0 2 4 this 3 3822  5 other 1 3804  
1245 0 0 7 1192 3821 3071 0 0 2 4 this 3 3822  5 other 1 3813  
1246 0 0 7 1193 3812 3010 0 0 2 4 this 3 3822  5 other 1 3822  
1247 0 0 7 1193 3803 2949 0 0 2 4 this 3 3822  5 other 1 3804  
1248 0 0 7 1193 3821 3071 0 0 2 4 this 3 3822  5 other 1 3813  
1249 0 0 7 1194 3821 3071 0 0 2 4 this 3 3822  6 scalar 1 3587  
1250 0 0 7 1195 3821 3071 0 0 2 4 this 3 3822  6 scalar 1 3587  
1251 0 0 39 1196 3821 3071 0 0 2 4 this 3 3822  6 scalar 1 3587  
1252 0 0 38 1197 3731 0 0 0 1 4 this 3 3822  
1253 0 0 7 1198 3745 0 0 0 0 
1254 0 0 7 1215 3824 3159 0 0 0 
1255 0 0 15 1215 3824 3159 0 0 1 5 other 1 3825  
1256 0 0 23 1215 3824 3159 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3771  6 param1 0 3771  6 param2 0 3771  
1257 0 0 23 1215 3824 3159 0 10 /**
 *
 */ 9 6 param0 0 3581  6 param1 0 3581  6 param2 0 3581  6 param3 0 3581  6 param4 0 3581  6 param5 0 3581  6 param6 0 3581  6 param7 0 3581  6 param8 0 3581  
1258 0 0 6 1216 3824 0 0 0 2 4 this 3 3824  5 other 1 3825  
1259 0 0 6 1216 3824 0 0 10 /**
 *
 */ 2 4 this 3 3824  10 fill_value 1 3581  
1260 0 0 4 1217 3727 0 0 0 2 4 this 3 3824  4 size 1 3725  
1261 0 0 38 1220 3728 0 0 0 1 4 this 3 3825  
1262 0 0 4 1221 3727 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3824  10 fill_value 1 3581  
1263 0 0 4 1222 3727 0 0 10 /**
 *
 */ 10 4 this 3 3824  3 e00 1 3581  3 e01 1 3581  3 e02 1 3581  3 e10 1 3581  3 e11 1 3581  3 e12 1 3581  3 e20 1 3581  3 e21 1 3581  3 e22 1 3581  
1264 0 0 7 1223 3827 3077 0 0 2 4 this 3 3824  1 i 1 3587  
1265 0 0 7 1223 3828 3082 0 0 2 4 this 3 3825  1 i 1 3587  
1266 0 0 6 1224 3587 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1267 0 0 4 1225 3727 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3824  3 row 1 3587  1 v 1 3723  
1268 0 0 4 1225 3727 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3824  3 row 1 3587  1 v 1 3771  
1269 0 0 4 1226 3727 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3824  3 col 1 3587  1 v 1 3723  
1270 0 0 4 1226 3727 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3824  3 col 1 3587  1 v 1 3771  
1271 0 0 4 1227 3727 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3825  10 result_vec 1 3770  3 row 1 3587  
1272 0 0 7 1227 3770 2379 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3825  3 row 1 3587  
1273 0 0 7 1228 3770 2379 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3825  3 col 1 3587  
1274 0 0 7 1233 3722 2058 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3825  3 row 1 3587  
1275 0 0 7 1234 3722 2058 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3825  3 col 1 3587  
1276 0 0 4 1237 3727 0 0 10 /**
 *
 */ 3 4 this 3 3824  3 row 1 3587  3 col 1 3587  
1277 0 0 6 1237 3581 0 0 0 3 4 this 3 3825  3 row 1 3587  3 col 1 3587  
1278 0 0 6 1238 3732 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3825  
1279 0 0 6 1239 3732 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3825  
1280 0 0 6 1240 3581 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3825  3 row 1 3587  3 col 1 3587  
1281 0 0 4 1241 3727 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3824  3 row 1 3587  3 col 1 3587  5 value 1 3581  
1282 0 0 4 1242 3727 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3825  
1283 0 0 6 1243 3587 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3825  
1284 0 0 6 1244 3732 0 0 0 2 4 this 3 3825  5 other 1 3825  
1285 0 0 6 1245 3732 0 0 0 2 4 this 3 3825  5 other 1 3825  
1286 0 0 6 1246 3732 0 0 0 2 4 this 3 3825  5 other 1 3825  
1287 0 0 6 1247 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3825  5 other 1 3825  
1288 0 0 6 1247 3587 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3825  5 other 1 3825  9 threshold 1 3581  
1289 0 0 6 1248 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3825  
1290 0 0 6 1248 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3825  9 threshold 1 3581  
1291 0 0 6 1249 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3825  4 hash 1 3725  
1292 0 0 6 1249 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3825  4 hash 1 3725  9 threshold 1 3581  
1293 0 0 7 1250 3770 2379 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3825  1 v 1 3771  
1294 0 0 7 1251 3722 2058 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3825  1 v 1 3723  
1295 0 0 7 1252 3722 2058 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3825  1 v 1 3723  
1296 0 0 7 1252 3770 2379 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3825  1 v 1 3771  
1297 0 0 7 1253 3770 2379 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3825  1 v 1 3771  
1298 0 0 4 1254 3727 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3825  1 v 1 3770  
1299 0 0 4 1255 3727 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3825  1 v 1 3722  
1300 0 0 4 1256 3727 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3825  1 v 1 3722  
1301 0 0 4 1256 3727 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3825  1 v 1 3770  
1302 0 0 4 1257 3727 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3825  1 v 1 3770  
1303 0 0 4 1258 3727 0 0 25 // this = other1 * other2 3 4 this 3 3824  6 other1 1 3825  6 other2 1 3825  
1304 0 0 7 1259 3824 3159 0 0 2 4 this 3 3825  5 other 1 3825  
1305 0 0 7 1259 3824 3159 0 0 2 4 this 3 3825  6 scalar 1 3581  
1306 0 0 7 1260 3824 3159 0 0 2 4 this 3 3825  6 scalar 1 3581  
1307 0 0 6 1261 3824 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3824  5 other 1 3825  
1308 0 0 6 1262 3824 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3824  5 other 1 3825  
1309 0 0 6 1263 3824 0 0 10 /**
 *
 */ 2 4 this 3 3824  5 other 1 3825  
1310 0 0 6 1263 3824 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3824  6 scalar 1 3581  
1311 0 0 6 1264 3824 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3824  6 scalar 1 3581  
1312 0 0 39 1265 3824 3159 0 0 2 4 this 3 3825  6 scalar 1 3581  
1313 0 0 4 1266 3727 0 0 10 /**
 *
 */ 2 4 this 3 3824  5 other 1 3825  
1314 0 0 6 1267 3581 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3825  
1315 0 0 4 1268 3727 0 0 10 /**
 *
 */ 2 4 this 3 3824  5 other 1 3825  
1316 0 0 4 1269 3727 0 0 10 /**
 *
 */ 1 4 this 3 3824  
1317 0 0 6 1270 3732 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3824  5 other 1 3825  
1318 0 0 6 1271 3732 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3824  
1319 0 0 6 1272 3732 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3824  5 other 1 3825  
1320 0 0 6 1272 3732 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3824  5 other 1 3829  
1321 0 0 6 1273 3825 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1322 0 0 4 1274 3727 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3824  5 trans 1 3723  
1323 0 0 4 1275 3727 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3824  5 angle 1 3581  
1324 0 0 4 1275 3727 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3824  5 angle 1 3581  4 axis 1 3771  2 cs 5 3600  
1325 0 0 4 1276 3727 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3824  5 scale 1 3723  
1326 0 0 4 1276 3727 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3824  5 scale 1 3771  
1327 0 0 7 1277 3824 3159 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3723  
1328 0 0 7 1277 3824 3159 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3581  2 ty 1 3581  
1329 0 0 7 1278 3824 3159 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3581  
1330 0 0 7 1278 3824 3159 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3581  4 axis 1 3771  2 cs 5 3600  
1331 0 0 7 1279 3824 3159 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3723  
1332 0 0 7 1279 3824 3159 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3771  
1333 0 0 7 1279 3824 3159 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3581  2 sy 1 3581  
1334 0 0 7 1279 3824 3159 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3581  2 sy 1 3581  2 sz 1 3581  
1335 0 0 4 1280 3727 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3824  5 angle 1 3581  4 axis 1 3771  2 cs 5 3600  
1336 0 0 7 1281 3824 3159 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3581  4 axis 1 3771  2 cs 5 3600  
1337 0 0 4 1282 3727 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3824  5 shear 1 3771  2 cs 5 3600  
1338 0 0 7 1283 3824 3159 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3771  2 cs 5 3600  
1339 0 0 7 1283 3824 3159 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3581  4 shxz 1 3581  4 shyz 1 3581  2 cs 5 3600  
1340 0 0 4 1284 3727 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3824  5 scale 1 3771  5 shear 1 3771  2 cs 5 3600  
1341 0 0 7 1285 3824 3159 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3771  5 shear 1 3771  2 cs 5 3600  
1342 0 0 7 1285 3824 3159 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3581  2 sy 1 3581  2 sz 1 3581  4 shxy 1 3581  4 shxz 1 3581  4 shyz 1 3581  2 cs 5 3600  
1343 0 0 6 1286 3825 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3600  2 to 1 3600  
1344 0 0 6 1287 3732 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3825  5 other 1 3825  
1345 0 0 6 1287 3732 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3825  5 other 1 3825  9 threshold 1 3581  
1346 0 0 4 1288 3727 0 0 10 /**
 *
 */ 2 4 this 3 3825  3 out 1 3735  
1347 0 0 4 1289 3727 0 0 10 /**
 *
 */ 3 4 this 3 3825  3 out 1 3735  12 indent_level 5 3587  
1348 0 0 38 1290 3731 0 0 0 1 4 this 3 3825  
1349 0 0 4 1291 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3825  7 hashgen 1 3733  
1350 0 0 4 1291 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3825  7 hashgen 1 3733  9 threshold 1 3581  
1351 0 0 4 1292 3727 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3825  11 destination 1 3737  
1352 0 0 4 1293 3727 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3824  4 scan 1 3739  
1353 0 0 4 1294 3727 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3825  11 destination 1 3737  
1354 0 0 4 1295 3727 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3824  6 source 1 3739  
1355 0 0 7 1296 3745 0 0 0 0 
1356 0 0 15 1207 3827 3077 0 0 1 6 param0 0 3831  
1357 0 0 4 1203 3727 0 0 10 /**
 *
 */ 2 4 this 3 3827  1 i 1 3587  
1358 0 0 6 1203 3581 0 0 0 2 4 this 3 3831  1 i 1 3587  
1359 0 0 4 1204 3727 0 0 0 3 4 this 3 3827  1 i 1 3587  10 assign_val 1 3581  
1360 0 0 6 1205 3587 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1361 0 0 6 1206 3771 0 0 0 1 4 this 3 3831  
1362 0 0 15 1213 3828 3082 0 0 1 6 param0 0 3833  
1363 0 0 6 1210 3581 0 0 0 2 4 this 3 3833  1 i 1 3587  
1364 0 0 6 1211 3587 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1365 0 0 6 1212 3771 0 0 0 1 4 this 3 3833  
1366 0 0 7 1315 3835 3259 0 0 0 
1367 0 0 23 1315 3835 3259 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3825  
1368 0 0 7 1315 3835 3259 0 10 /**
 *
 */ 2 6 upper3 1 3825  5 trans 1 3771  
1369 0 0 15 1315 3835 3259 0 0 1 5 other 1 3829  
1370 0 0 23 1315 3835 3259 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3798  6 param1 0 3798  6 param2 0 3798  6 param3 0 3798  
1371 0 0 23 1315 3835 3259 0 10 /**
 *
 */ 16 6 param0 0 3581  6 param1 0 3581  6 param2 0 3581  6 param3 0 3581  6 param4 0 3581  6 param5 0 3581  6 param6 0 3581  6 param7 0 3581  6 param8 0 3581  6 param9 0 3581  7 param10 0 3581  7 param11 0 3581  7 param12 0 3581  7 param13 0 3581  7 param14 0 3581  7 param15 0 3581  
1372 0 0 6 1316 3835 0 0 0 2 4 this 3 3835  5 other 1 3829  
1373 0 0 6 1316 3835 0 0 10 /**
 *
 */ 2 4 this 3 3835  10 fill_value 1 3581  
1374 0 0 4 1317 3727 0 0 0 2 4 this 3 3835  4 size 1 3725  
1375 0 0 38 1320 3728 0 0 0 1 4 this 3 3829  
1376 0 0 4 1321 3727 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3835  10 fill_value 1 3581  
1377 0 0 4 1322 3727 0 0 10 /**
 *
 */ 17 4 this 3 3835  3 e00 1 3581  3 e01 1 3581  3 e02 1 3581  3 e03 1 3581  3 e10 1 3581  3 e11 1 3581  3 e12 1 3581  3 e13 1 3581  3 e20 1 3581  3 e21 1 3581  3 e22 1 3581  3 e23 1 3581  3 e30 1 3581  3 e31 1 3581  3 e32 1 3581  3 e33 1 3581  
1378 0 0 4 1323 3727 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3835  6 upper3 1 3825  
1379 0 0 7 1324 3824 3159 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3829  
1380 0 0 7 1325 3836 3167 0 0 2 4 this 3 3835  1 i 1 3587  
1381 0 0 7 1325 3837 3172 0 0 2 4 this 3 3829  1 i 1 3587  
1382 0 0 6 1326 3587 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1383 0 0 4 1327 3727 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3835  3 row 1 3587  1 v 1 3771  
1384 0 0 4 1327 3727 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3835  3 row 1 3587  1 v 1 3798  
1385 0 0 4 1328 3727 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3835  3 col 1 3587  1 v 1 3771  
1386 0 0 4 1328 3727 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3835  3 col 1 3587  1 v 1 3798  
1387 0 0 4 1329 3727 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3829  10 result_vec 1 3797  3 row 1 3587  
1388 0 0 7 1329 3797 2789 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3829  3 row 1 3587  
1389 0 0 7 1330 3797 2789 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3829  3 col 1 3587  
1390 0 0 4 1331 3727 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3829  10 result_vec 1 3770  3 row 1 3587  
1391 0 0 7 1331 3770 2379 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3829  3 row 1 3587  
1392 0 0 7 1337 3770 2379 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3829  3 col 1 3587  
1393 0 0 4 1338 3727 0 0 10 /**
 *
 */ 3 4 this 3 3835  3 row 1 3587  3 col 1 3587  
1394 0 0 6 1338 3581 0 0 0 3 4 this 3 3829  3 row 1 3587  3 col 1 3587  
1395 0 0 6 1339 3732 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3829  
1396 0 0 6 1340 3732 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3829  
1397 0 0 6 1341 3581 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3829  3 row 1 3587  3 col 1 3587  
1398 0 0 4 1342 3727 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3835  3 row 1 3587  3 col 1 3587  5 value 1 3581  
1399 0 0 4 1343 3727 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3829  
1400 0 0 6 1344 3587 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3829  
1401 0 0 4 1345 3727 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3835  
1402 0 0 4 1345 3727 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3829  
1403 0 0 4 1346 3727 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3835  
1404 0 0 4 1346 3727 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3829  
1405 0 0 6 1347 3732 0 0 0 2 4 this 3 3829  5 other 1 3829  
1406 0 0 6 1348 3732 0 0 0 2 4 this 3 3829  5 other 1 3829  
1407 0 0 6 1349 3732 0 0 0 2 4 this 3 3829  5 other 1 3829  
1408 0 0 6 1350 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3829  5 other 1 3829  
1409 0 0 6 1350 3587 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3829  5 other 1 3829  9 threshold 1 3581  
1410 0 0 6 1351 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3829  
1411 0 0 6 1351 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3829  9 threshold 1 3581  
1412 0 0 6 1352 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3829  4 hash 1 3725  
1413 0 0 6 1352 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3829  4 hash 1 3725  9 threshold 1 3581  
1414 0 0 7 1353 3797 2789 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3829  1 v 1 3798  
1415 0 0 7 1354 3770 2379 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3829  1 v 1 3771  
1416 0 0 7 1355 3770 2379 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3829  1 v 1 3771  
1417 0 0 7 1356 3770 2379 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3829  1 v 1 3771  
1418 0 0 7 1357 3770 2379 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3829  1 v 1 3771  
1419 0 0 4 1358 3727 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3829  1 v 1 3797  
1420 0 0 4 1359 3727 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3829  1 v 1 3770  
1421 0 0 4 1360 3727 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3829  1 v 1 3770  
1422 0 0 4 1361 3727 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3829  1 v 1 3770  
1423 0 0 4 1362 3727 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3829  1 v 1 3770  
1424 0 0 4 1363 3727 0 0 25 // this = other1 * other2 3 4 this 3 3835  6 other1 1 3829  6 other2 1 3829  
1425 0 0 7 1364 3835 3259 0 0 2 4 this 3 3829  5 other 1 3829  
1426 0 0 7 1364 3835 3259 0 0 2 4 this 3 3829  6 scalar 1 3581  
1427 0 0 7 1365 3835 3259 0 0 2 4 this 3 3829  6 scalar 1 3581  
1428 0 0 6 1366 3835 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3835  5 other 1 3829  
1429 0 0 6 1367 3835 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3835  5 other 1 3829  
1430 0 0 6 1368 3835 0 0 10 /**
 *
 */ 2 4 this 3 3835  5 other 1 3829  
1431 0 0 6 1368 3835 0 0 10 /**
 *
 */ 2 4 this 3 3835  6 scalar 1 3581  
1432 0 0 6 1369 3835 0 0 10 /**
 *
 */ 2 4 this 3 3835  6 scalar 1 3581  
1433 0 0 39 1370 3835 3259 0 0 2 4 this 3 3829  6 scalar 1 3581  
1434 0 0 4 1371 3727 0 0 10 /**
 *
 */ 2 4 this 3 3835  5 other 1 3829  
1435 0 0 4 1372 3727 0 0 10 /**
 *
 */ 2 4 this 3 3835  5 other 1 3829  
1436 0 0 4 1373 3727 0 0 10 /**
 *
 */ 1 4 this 3 3835  
1437 0 0 6 1374 3732 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3835  5 other 1 3829  
1438 0 0 6 1375 3732 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3835  5 other 1 3829  
1439 0 0 6 1376 3732 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3835  
1440 0 0 4 1377 3727 0 0 48 /**
 * Computes `(*this) += other * weight`.
 */ 3 4 this 3 3835  5 other 1 3829  6 weight 1 3581  
1441 0 0 6 1378 3829 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1442 0 0 6 1379 3829 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1443 0 0 6 1380 3829 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1444 0 0 4 1381 3727 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3835  5 trans 1 3771  
1445 0 0 4 1382 3727 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3835  5 angle 1 3581  4 axis 1 3771  2 cs 5 3600  
1446 0 0 4 1383 3727 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3835  5 angle 1 3581  4 axis 1 3771  2 cs 5 3600  
1447 0 0 4 1384 3727 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3835  5 scale 1 3771  
1448 0 0 4 1385 3727 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3835  5 shear 1 3771  2 cs 5 3600  
1449 0 0 4 1386 3727 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3835  5 scale 1 3771  5 shear 1 3771  2 cs 5 3600  
1450 0 0 7 1387 3835 3259 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3771  
1451 0 0 7 1387 3835 3259 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3581  2 ty 1 3581  2 tz 1 3581  
1452 0 0 7 1388 3835 3259 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3581  4 axis 1 3771  2 cs 5 3600  
1453 0 0 7 1389 3835 3259 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3581  4 axis 1 3771  2 cs 5 3600  
1454 0 0 7 1390 3835 3259 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3771  
1455 0 0 7 1390 3835 3259 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3581  
1456 0 0 7 1390 3835 3259 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3581  2 sy 1 3581  2 sz 1 3581  
1457 0 0 7 1391 3835 3259 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3771  2 cs 5 3600  
1458 0 0 7 1391 3835 3259 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3581  4 shxz 1 3581  4 shyz 1 3581  2 cs 5 3600  
1459 0 0 7 1392 3835 3259 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3771  5 shear 1 3771  2 cs 5 3600  
1460 0 0 7 1392 3835 3259 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3581  2 sy 1 3581  2 sz 1 3581  4 shxy 1 3581  4 shxz 1 3581  4 shyz 1 3581  2 cs 5 3600  
1461 0 0 6 1393 3829 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1462 0 0 6 1394 3829 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1463 0 0 6 1395 3829 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3600  2 to 1 3600  
1464 0 0 6 1396 3732 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3829  5 other 1 3829  
1465 0 0 6 1396 3732 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3829  5 other 1 3829  9 threshold 1 3581  
1466 0 0 4 1397 3727 0 0 10 /**
 *
 */ 2 4 this 3 3829  3 out 1 3735  
1467 0 0 4 1398 3727 0 0 10 /**
 *
 */ 3 4 this 3 3829  3 out 1 3735  12 indent_level 5 3587  
1468 0 0 38 1399 3731 0 0 0 1 4 this 3 3829  
1469 0 0 4 1400 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3829  7 hashgen 1 3733  
1470 0 0 4 1400 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3829  7 hashgen 1 3733  5 scale 1 3581  
1471 0 0 4 1401 3727 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3829  11 destination 1 3737  
1472 0 0 4 1402 3727 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3835  4 scan 1 3739  
1473 0 0 4 1403 3727 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3829  11 destination 1 3737  
1474 0 0 4 1404 3727 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3835  6 source 1 3739  
1475 0 0 7 1405 3745 0 0 0 0 
1476 0 0 15 1307 3836 3167 0 0 1 6 param0 0 3838  
1477 0 0 4 1303 3727 0 0 10 /**
 *
 */ 2 4 this 3 3836  1 i 1 3587  
1478 0 0 6 1303 3581 0 0 0 2 4 this 3 3838  1 i 1 3587  
1479 0 0 4 1304 3727 0 0 0 3 4 this 3 3836  1 i 1 3587  10 assign_val 1 3581  
1480 0 0 6 1305 3587 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1481 0 0 6 1306 3798 0 0 0 1 4 this 3 3838  
1482 0 0 15 1313 3837 3172 0 0 1 6 param0 0 3840  
1483 0 0 6 1310 3581 0 0 0 2 4 this 3 3840  1 i 1 3587  
1484 0 0 6 1311 3587 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1485 0 0 6 1312 3798 0 0 0 1 4 this 3 3840  
1486 0 0 7 1422 3842 3347 0 0 0 
1487 0 0 15 1422 3842 3347 0 0 1 5 other 1 3843  
1488 0 0 23 1422 3842 3347 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3774  6 param1 0 3774  6 param2 0 3774  
1489 0 0 23 1422 3842 3347 0 10 /**
 *
 */ 9 6 param0 0 3584  6 param1 0 3584  6 param2 0 3584  6 param3 0 3584  6 param4 0 3584  6 param5 0 3584  6 param6 0 3584  6 param7 0 3584  6 param8 0 3584  
1490 0 0 6 1423 3842 0 0 0 2 4 this 3 3842  5 other 1 3843  
1491 0 0 6 1423 3842 0 0 10 /**
 *
 */ 2 4 this 3 3842  10 fill_value 1 3584  
1492 0 0 4 1424 3727 0 0 0 2 4 this 3 3842  4 size 1 3725  
1493 0 0 38 1427 3728 0 0 0 1 4 this 3 3843  
1494 0 0 4 1428 3727 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3842  10 fill_value 1 3584  
1495 0 0 4 1429 3727 0 0 10 /**
 *
 */ 10 4 this 3 3842  3 e00 1 3584  3 e01 1 3584  3 e02 1 3584  3 e10 1 3584  3 e11 1 3584  3 e12 1 3584  3 e20 1 3584  3 e21 1 3584  3 e22 1 3584  
1496 0 0 7 1430 3845 3265 0 0 2 4 this 3 3842  1 i 1 3587  
1497 0 0 7 1430 3846 3270 0 0 2 4 this 3 3843  1 i 1 3587  
1498 0 0 6 1431 3587 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1499 0 0 4 1432 3727 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3842  3 row 1 3587  1 v 1 3747  
1500 0 0 4 1432 3727 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3842  3 row 1 3587  1 v 1 3774  
1501 0 0 4 1433 3727 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3842  3 col 1 3587  1 v 1 3747  
1502 0 0 4 1433 3727 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3842  3 col 1 3587  1 v 1 3774  
1503 0 0 4 1434 3727 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3843  10 result_vec 1 3773  3 row 1 3587  
1504 0 0 7 1434 3773 2460 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3843  3 row 1 3587  
1505 0 0 7 1435 3773 2460 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3843  3 col 1 3587  
1506 0 0 7 1440 3746 2129 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3843  3 row 1 3587  
1507 0 0 7 1441 3746 2129 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3843  3 col 1 3587  
1508 0 0 4 1444 3727 0 0 10 /**
 *
 */ 3 4 this 3 3842  3 row 1 3587  3 col 1 3587  
1509 0 0 6 1444 3584 0 0 0 3 4 this 3 3843  3 row 1 3587  3 col 1 3587  
1510 0 0 6 1445 3732 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3843  
1511 0 0 6 1446 3732 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3843  
1512 0 0 6 1447 3584 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3843  3 row 1 3587  3 col 1 3587  
1513 0 0 4 1448 3727 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3842  3 row 1 3587  3 col 1 3587  5 value 1 3584  
1514 0 0 4 1449 3727 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3843  
1515 0 0 6 1450 3587 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3843  
1516 0 0 6 1451 3732 0 0 0 2 4 this 3 3843  5 other 1 3843  
1517 0 0 6 1452 3732 0 0 0 2 4 this 3 3843  5 other 1 3843  
1518 0 0 6 1453 3732 0 0 0 2 4 this 3 3843  5 other 1 3843  
1519 0 0 6 1454 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3843  5 other 1 3843  
1520 0 0 6 1454 3587 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3843  5 other 1 3843  9 threshold 1 3584  
1521 0 0 6 1455 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3843  
1522 0 0 6 1455 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3843  9 threshold 1 3584  
1523 0 0 6 1456 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3843  4 hash 1 3725  
1524 0 0 6 1456 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3843  4 hash 1 3725  9 threshold 1 3584  
1525 0 0 7 1457 3773 2460 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3843  1 v 1 3774  
1526 0 0 7 1458 3746 2129 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3843  1 v 1 3747  
1527 0 0 7 1459 3746 2129 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3843  1 v 1 3747  
1528 0 0 7 1459 3773 2460 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3843  1 v 1 3774  
1529 0 0 7 1460 3773 2460 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3843  1 v 1 3774  
1530 0 0 4 1461 3727 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3843  1 v 1 3773  
1531 0 0 4 1462 3727 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3843  1 v 1 3746  
1532 0 0 4 1463 3727 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3843  1 v 1 3746  
1533 0 0 4 1463 3727 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3843  1 v 1 3773  
1534 0 0 4 1464 3727 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3843  1 v 1 3773  
1535 0 0 4 1465 3727 0 0 25 // this = other1 * other2 3 4 this 3 3842  6 other1 1 3843  6 other2 1 3843  
1536 0 0 7 1466 3842 3347 0 0 2 4 this 3 3843  5 other 1 3843  
1537 0 0 7 1466 3842 3347 0 0 2 4 this 3 3843  6 scalar 1 3584  
1538 0 0 7 1467 3842 3347 0 0 2 4 this 3 3843  6 scalar 1 3584  
1539 0 0 6 1468 3842 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3842  5 other 1 3843  
1540 0 0 6 1469 3842 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3842  5 other 1 3843  
1541 0 0 6 1470 3842 0 0 10 /**
 *
 */ 2 4 this 3 3842  5 other 1 3843  
1542 0 0 6 1470 3842 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3842  6 scalar 1 3584  
1543 0 0 6 1471 3842 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3842  6 scalar 1 3584  
1544 0 0 39 1472 3842 3347 0 0 2 4 this 3 3843  6 scalar 1 3584  
1545 0 0 4 1473 3727 0 0 10 /**
 *
 */ 2 4 this 3 3842  5 other 1 3843  
1546 0 0 6 1474 3584 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3843  
1547 0 0 4 1475 3727 0 0 10 /**
 *
 */ 2 4 this 3 3842  5 other 1 3843  
1548 0 0 4 1476 3727 0 0 10 /**
 *
 */ 1 4 this 3 3842  
1549 0 0 6 1477 3732 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3842  5 other 1 3843  
1550 0 0 6 1478 3732 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3842  
1551 0 0 6 1479 3732 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3842  5 other 1 3843  
1552 0 0 6 1479 3732 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3842  5 other 1 3847  
1553 0 0 6 1480 3843 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1554 0 0 4 1481 3727 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3842  5 trans 1 3747  
1555 0 0 4 1482 3727 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3842  5 angle 1 3584  
1556 0 0 4 1482 3727 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3842  5 angle 1 3584  4 axis 1 3774  2 cs 5 3600  
1557 0 0 4 1483 3727 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3842  5 scale 1 3747  
1558 0 0 4 1483 3727 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3842  5 scale 1 3774  
1559 0 0 7 1484 3842 3347 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3747  
1560 0 0 7 1484 3842 3347 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3584  2 ty 1 3584  
1561 0 0 7 1485 3842 3347 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3584  
1562 0 0 7 1485 3842 3347 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3584  4 axis 1 3774  2 cs 5 3600  
1563 0 0 7 1486 3842 3347 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3747  
1564 0 0 7 1486 3842 3347 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3774  
1565 0 0 7 1486 3842 3347 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3584  2 sy 1 3584  
1566 0 0 7 1486 3842 3347 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3584  2 sy 1 3584  2 sz 1 3584  
1567 0 0 4 1487 3727 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3842  5 angle 1 3584  4 axis 1 3774  2 cs 5 3600  
1568 0 0 7 1488 3842 3347 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3584  4 axis 1 3774  2 cs 5 3600  
1569 0 0 4 1489 3727 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3842  5 shear 1 3774  2 cs 5 3600  
1570 0 0 7 1490 3842 3347 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3774  2 cs 5 3600  
1571 0 0 7 1490 3842 3347 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3584  4 shxz 1 3584  4 shyz 1 3584  2 cs 5 3600  
1572 0 0 4 1491 3727 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3842  5 scale 1 3774  5 shear 1 3774  2 cs 5 3600  
1573 0 0 7 1492 3842 3347 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3774  5 shear 1 3774  2 cs 5 3600  
1574 0 0 7 1492 3842 3347 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3584  2 sy 1 3584  2 sz 1 3584  4 shxy 1 3584  4 shxz 1 3584  4 shyz 1 3584  2 cs 5 3600  
1575 0 0 6 1493 3843 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3600  2 to 1 3600  
1576 0 0 6 1494 3732 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3843  5 other 1 3843  
1577 0 0 6 1494 3732 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3843  5 other 1 3843  9 threshold 1 3584  
1578 0 0 4 1495 3727 0 0 10 /**
 *
 */ 2 4 this 3 3843  3 out 1 3735  
1579 0 0 4 1496 3727 0 0 10 /**
 *
 */ 3 4 this 3 3843  3 out 1 3735  12 indent_level 5 3587  
1580 0 0 38 1497 3731 0 0 0 1 4 this 3 3843  
1581 0 0 4 1498 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3843  7 hashgen 1 3733  
1582 0 0 4 1498 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3843  7 hashgen 1 3733  9 threshold 1 3584  
1583 0 0 4 1499 3727 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3843  11 destination 1 3737  
1584 0 0 4 1500 3727 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3842  4 scan 1 3739  
1585 0 0 4 1501 3727 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3843  11 destination 1 3737  
1586 0 0 4 1502 3727 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3842  6 source 1 3739  
1587 0 0 7 1503 3745 0 0 0 0 
1588 0 0 15 1414 3845 3265 0 0 1 6 param0 0 3849  
1589 0 0 4 1410 3727 0 0 10 /**
 *
 */ 2 4 this 3 3845  1 i 1 3587  
1590 0 0 6 1410 3584 0 0 0 2 4 this 3 3849  1 i 1 3587  
1591 0 0 4 1411 3727 0 0 0 3 4 this 3 3845  1 i 1 3587  10 assign_val 1 3584  
1592 0 0 6 1412 3587 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1593 0 0 6 1413 3774 0 0 0 1 4 this 3 3849  
1594 0 0 15 1420 3846 3270 0 0 1 6 param0 0 3851  
1595 0 0 6 1417 3584 0 0 0 2 4 this 3 3851  1 i 1 3587  
1596 0 0 6 1418 3587 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1597 0 0 6 1419 3774 0 0 0 1 4 this 3 3851  
1598 0 0 7 1520 3853 3445 0 0 0 
1599 0 0 23 1520 3853 3445 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3843  
1600 0 0 7 1520 3853 3445 0 10 /**
 *
 */ 2 6 upper3 1 3843  5 trans 1 3774  
1601 0 0 15 1520 3853 3445 0 0 1 5 other 1 3847  
1602 0 0 23 1520 3853 3445 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3801  6 param1 0 3801  6 param2 0 3801  6 param3 0 3801  
1603 0 0 23 1520 3853 3445 0 10 /**
 *
 */ 16 6 param0 0 3584  6 param1 0 3584  6 param2 0 3584  6 param3 0 3584  6 param4 0 3584  6 param5 0 3584  6 param6 0 3584  6 param7 0 3584  6 param8 0 3584  6 param9 0 3584  7 param10 0 3584  7 param11 0 3584  7 param12 0 3584  7 param13 0 3584  7 param14 0 3584  7 param15 0 3584  
1604 0 0 6 1521 3853 0 0 0 2 4 this 3 3853  5 other 1 3847  
1605 0 0 6 1521 3853 0 0 10 /**
 *
 */ 2 4 this 3 3853  10 fill_value 1 3584  
1606 0 0 4 1522 3727 0 0 0 2 4 this 3 3853  4 size 1 3725  
1607 0 0 38 1525 3728 0 0 0 1 4 this 3 3847  
1608 0 0 4 1526 3727 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3853  10 fill_value 1 3584  
1609 0 0 4 1527 3727 0 0 10 /**
 *
 */ 17 4 this 3 3853  3 e00 1 3584  3 e01 1 3584  3 e02 1 3584  3 e03 1 3584  3 e10 1 3584  3 e11 1 3584  3 e12 1 3584  3 e13 1 3584  3 e20 1 3584  3 e21 1 3584  3 e22 1 3584  3 e23 1 3584  3 e30 1 3584  3 e31 1 3584  3 e32 1 3584  3 e33 1 3584  
1610 0 0 4 1528 3727 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3853  6 upper3 1 3843  
1611 0 0 7 1529 3842 3347 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3847  
1612 0 0 7 1530 3854 3353 0 0 2 4 this 3 3853  1 i 1 3587  
1613 0 0 7 1530 3855 3358 0 0 2 4 this 3 3847  1 i 1 3587  
1614 0 0 6 1531 3587 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1615 0 0 4 1532 3727 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3853  3 row 1 3587  1 v 1 3774  
1616 0 0 4 1532 3727 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3853  3 row 1 3587  1 v 1 3801  
1617 0 0 4 1533 3727 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3853  3 col 1 3587  1 v 1 3774  
1618 0 0 4 1533 3727 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3853  3 col 1 3587  1 v 1 3801  
1619 0 0 4 1534 3727 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3847  10 result_vec 1 3800  3 row 1 3587  
1620 0 0 7 1534 3800 2871 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3847  3 row 1 3587  
1621 0 0 7 1535 3800 2871 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3847  3 col 1 3587  
1622 0 0 4 1536 3727 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3847  10 result_vec 1 3773  3 row 1 3587  
1623 0 0 7 1536 3773 2460 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3847  3 row 1 3587  
1624 0 0 7 1542 3773 2460 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3847  3 col 1 3587  
1625 0 0 4 1543 3727 0 0 10 /**
 *
 */ 3 4 this 3 3853  3 row 1 3587  3 col 1 3587  
1626 0 0 6 1543 3584 0 0 0 3 4 this 3 3847  3 row 1 3587  3 col 1 3587  
1627 0 0 6 1544 3732 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3847  
1628 0 0 6 1545 3732 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3847  
1629 0 0 6 1546 3584 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3847  3 row 1 3587  3 col 1 3587  
1630 0 0 4 1547 3727 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3853  3 row 1 3587  3 col 1 3587  5 value 1 3584  
1631 0 0 4 1548 3727 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3847  
1632 0 0 6 1549 3587 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3847  
1633 0 0 4 1550 3727 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3853  
1634 0 0 4 1550 3727 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3847  
1635 0 0 4 1551 3727 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3853  
1636 0 0 4 1551 3727 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3847  
1637 0 0 6 1552 3732 0 0 0 2 4 this 3 3847  5 other 1 3847  
1638 0 0 6 1553 3732 0 0 0 2 4 this 3 3847  5 other 1 3847  
1639 0 0 6 1554 3732 0 0 0 2 4 this 3 3847  5 other 1 3847  
1640 0 0 6 1555 3587 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3847  5 other 1 3847  
1641 0 0 6 1555 3587 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3847  5 other 1 3847  9 threshold 1 3584  
1642 0 0 6 1556 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3847  
1643 0 0 6 1556 3725 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3847  9 threshold 1 3584  
1644 0 0 6 1557 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3847  4 hash 1 3725  
1645 0 0 6 1557 3725 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3847  4 hash 1 3725  9 threshold 1 3584  
1646 0 0 7 1558 3800 2871 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3847  1 v 1 3801  
1647 0 0 7 1559 3773 2460 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3847  1 v 1 3774  
1648 0 0 7 1560 3773 2460 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3847  1 v 1 3774  
1649 0 0 7 1561 3773 2460 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3847  1 v 1 3774  
1650 0 0 7 1562 3773 2460 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3847  1 v 1 3774  
1651 0 0 4 1563 3727 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3847  1 v 1 3800  
1652 0 0 4 1564 3727 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3847  1 v 1 3773  
1653 0 0 4 1565 3727 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3847  1 v 1 3773  
1654 0 0 4 1566 3727 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3847  1 v 1 3773  
1655 0 0 4 1567 3727 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3847  1 v 1 3773  
1656 0 0 4 1568 3727 0 0 25 // this = other1 * other2 3 4 this 3 3853  6 other1 1 3847  6 other2 1 3847  
1657 0 0 7 1569 3853 3445 0 0 2 4 this 3 3847  5 other 1 3847  
1658 0 0 7 1569 3853 3445 0 0 2 4 this 3 3847  6 scalar 1 3584  
1659 0 0 7 1570 3853 3445 0 0 2 4 this 3 3847  6 scalar 1 3584  
1660 0 0 6 1571 3853 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3853  5 other 1 3847  
1661 0 0 6 1572 3853 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3853  5 other 1 3847  
1662 0 0 6 1573 3853 0 0 10 /**
 *
 */ 2 4 this 3 3853  5 other 1 3847  
1663 0 0 6 1573 3853 0 0 10 /**
 *
 */ 2 4 this 3 3853  6 scalar 1 3584  
1664 0 0 6 1574 3853 0 0 10 /**
 *
 */ 2 4 this 3 3853  6 scalar 1 3584  
1665 0 0 39 1575 3853 3445 0 0 2 4 this 3 3847  6 scalar 1 3584  
1666 0 0 4 1576 3727 0 0 10 /**
 *
 */ 2 4 this 3 3853  5 other 1 3847  
1667 0 0 4 1577 3727 0 0 10 /**
 *
 */ 2 4 this 3 3853  5 other 1 3847  
1668 0 0 4 1578 3727 0 0 10 /**
 *
 */ 1 4 this 3 3853  
1669 0 0 6 1579 3732 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3853  5 other 1 3847  
1670 0 0 6 1580 3732 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3853  5 other 1 3847  
1671 0 0 6 1581 3732 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3853  
1672 0 0 4 1582 3727 0 0 48 /**
 * Computes `(*this) += other * weight`.
 */ 3 4 this 3 3853  5 other 1 3847  6 weight 1 3584  
1673 0 0 6 1583 3847 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1674 0 0 6 1584 3847 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1675 0 0 6 1585 3847 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1676 0 0 4 1586 3727 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3853  5 trans 1 3774  
1677 0 0 4 1587 3727 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3853  5 angle 1 3584  4 axis 1 3774  2 cs 5 3600  
1678 0 0 4 1588 3727 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3853  5 angle 1 3584  4 axis 1 3774  2 cs 5 3600  
1679 0 0 4 1589 3727 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3853  5 scale 1 3774  
1680 0 0 4 1590 3727 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3853  5 shear 1 3774  2 cs 5 3600  
1681 0 0 4 1591 3727 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3853  5 scale 1 3774  5 shear 1 3774  2 cs 5 3600  
1682 0 0 7 1592 3853 3445 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3774  
1683 0 0 7 1592 3853 3445 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3584  2 ty 1 3584  2 tz 1 3584  
1684 0 0 7 1593 3853 3445 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3584  4 axis 1 3774  2 cs 5 3600  
1685 0 0 7 1594 3853 3445 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3584  4 axis 1 3774  2 cs 5 3600  
1686 0 0 7 1595 3853 3445 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3774  
1687 0 0 7 1595 3853 3445 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3584  
1688 0 0 7 1595 3853 3445 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3584  2 sy 1 3584  2 sz 1 3584  
1689 0 0 7 1596 3853 3445 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3774  2 cs 5 3600  
1690 0 0 7 1596 3853 3445 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3584  4 shxz 1 3584  4 shyz 1 3584  2 cs 5 3600  
1691 0 0 7 1597 3853 3445 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3774  5 shear 1 3774  2 cs 5 3600  
1692 0 0 7 1597 3853 3445 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3584  2 sy 1 3584  2 sz 1 3584  4 shxy 1 3584  4 shxz 1 3584  4 shyz 1 3584  2 cs 5 3600  
1693 0 0 6 1598 3847 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1694 0 0 6 1599 3847 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1695 0 0 6 1600 3847 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3600  2 to 1 3600  
1696 0 0 6 1601 3732 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3847  5 other 1 3847  
1697 0 0 6 1601 3732 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3847  5 other 1 3847  9 threshold 1 3584  
1698 0 0 4 1602 3727 0 0 10 /**
 *
 */ 2 4 this 3 3847  3 out 1 3735  
1699 0 0 4 1603 3727 0 0 10 /**
 *
 */ 3 4 this 3 3847  3 out 1 3735  12 indent_level 5 3587  
1700 0 0 38 1604 3731 0 0 0 1 4 this 3 3847  
1701 0 0 4 1605 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3847  7 hashgen 1 3733  
1702 0 0 4 1605 3727 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3847  7 hashgen 1 3733  5 scale 1 3584  
1703 0 0 4 1606 3727 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3847  11 destination 1 3737  
1704 0 0 4 1607 3727 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3853  4 scan 1 3739  
1705 0 0 4 1608 3727 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3847  11 destination 1 3737  
1706 0 0 4 1609 3727 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3853  6 source 1 3739  
1707 0 0 7 1610 3745 0 0 0 0 
1708 0 0 15 1512 3854 3353 0 0 1 6 param0 0 3856  
1709 0 0 4 1508 3727 0 0 10 /**
 *
 */ 2 4 this 3 3854  1 i 1 3587  
1710 0 0 6 1508 3584 0 0 0 2 4 this 3 3856  1 i 1 3587  
1711 0 0 4 1509 3727 0 0 0 3 4 this 3 3854  1 i 1 3587  10 assign_val 1 3584  
1712 0 0 6 1510 3587 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1713 0 0 6 1511 3801 0 0 0 1 4 this 3 3856  
1714 0 0 15 1518 3855 3358 0 0 1 6 param0 0 3858  
1715 0 0 6 1515 3584 0 0 0 2 4 this 3 3858  1 i 1 3587  
1716 0 0 6 1516 3587 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1717 0 0 6 1517 3801 0 0 0 1 4 this 3 3858  
1718 0 0 7 1621 3860 3502 0 10 /**
 *
 */ 0 
1719 0 0 15 1621 3860 3502 0 0 1 6 param0 0 3861  
1720 0 0 23 1621 3860 3502 0 10 /**
 *
 */ 1 4 copy 1 3798  
1721 0 0 7 1621 3860 3502 0 10 /**
 *
 */ 2 1 r 1 3581  4 copy 1 3771  
1722 0 0 23 1621 3860 3502 0 10 /**
 *
 */ 4 1 r 1 3581  1 i 1 3581  1 j 1 3581  1 k 1 3581  
1723 0 0 7 1622 3860 3502 0 10 /**
 *
 */ 1 1 v 1 3780  
1724 0 0 7 1623 3860 3502 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3861  
1725 0 0 7 1624 3770 2379 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3861  1 v 1 3771  
1726 0 0 7 1624 3797 2789 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3861  1 v 1 3798  
1727 0 0 7 1625 3860 3502 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3861  3 rhs 1 3861  
1728 0 0 7 1626 3860 3502 0 0 1 4 this 3 3861  
1729 0 0 7 1627 3860 3502 0 0 2 4 this 3 3861  5 other 1 3861  
1730 0 0 7 1628 3860 3502 0 0 2 4 this 3 3861  5 other 1 3861  
1731 0 0 6 1629 3581 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3861  5 other 1 3861  
1732 0 0 6 1630 3581 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3861  5 other 1 3861  
1733 0 0 7 1631 3824 3159 0 0 2 4 this 3 3860  6 param0 0 3825  
1734 0 0 7 1631 3835 3259 0 0 2 4 this 3 3860  6 param0 0 3829  
1735 0 0 7 1631 3860 3502 0 0 2 4 this 3 3861  6 param0 0 3861  
1736 0 0 7 1631 3860 3502 0 0 2 4 this 3 3861  6 scalar 1 3581  
1737 0 0 7 1632 3860 3502 0 0 2 4 this 3 3861  6 scalar 1 3581  
1738 0 0 6 1633 3860 0 0 10 /**
 *
 */ 2 4 this 3 3860  6 param0 0 3861  
1739 0 0 7 1634 3860 3502 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3861  6 param0 0 3581  
1740 0 0 6 1635 3732 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3861  5 other 1 3861  
1741 0 0 6 1635 3732 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3861  5 other 1 3861  9 threshold 1 3581  
1742 0 0 6 1636 3732 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3861  5 other 1 3861  
1743 0 0 6 1637 3732 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3861  5 other 1 3861  9 threshold 1 3581  
1744 0 0 4 1638 3727 0 0 10 /**
 *
 */ 2 4 this 3 3861  6 param0 0 3735  
1745 0 0 4 1639 3727 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3861  1 m 1 3824  
1746 0 0 4 1639 3727 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3861  1 m 1 3835  
1747 0 0 4 1640 3727 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3860  1 m 1 3825  
1748 0 0 4 1640 3727 0 0 10 /**
 *
 */ 2 4 this 3 3860  1 m 1 3829  
1749 0 0 4 1641 3727 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3860  3 hpr 1 3771  2 cs 5 3600  
1750 0 0 7 1642 3770 2379 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3861  2 cs 5 3600  
1751 0 0 7 1643 3779 2575 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3861  
1752 0 0 7 1644 3779 2575 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3861  
1753 0 0 6 1645 3581 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3861  
1754 0 0 6 1646 3581 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3861  
1755 0 0 4 1647 3727 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3860  9 angle_rad 1 3581  4 axis 1 3780  
1756 0 0 4 1648 3727 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3860  9 angle_deg 1 3581  4 axis 1 3780  
1757 0 0 7 1649 3779 2575 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3861  2 cs 5 3600  
1758 0 0 7 1650 3779 2575 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3861  2 cs 5 3600  
1759 0 0 7 1651 3779 2575 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3861  2 cs 5 3600  
1760 0 0 6 1652 3581 0 0 10 /**
 *
 */ 1 4 this 3 3861  
1761 0 0 6 1653 3581 0 0 10 /**
 *
 */ 1 4 this 3 3861  
1762 0 0 6 1654 3581 0 0 10 /**
 *
 */ 1 4 this 3 3861  
1763 0 0 6 1655 3581 0 0 10 /**
 *
 */ 1 4 this 3 3861  
1764 0 0 4 1656 3727 0 0 10 /**
 *
 */ 2 4 this 3 3860  1 r 1 3581  
1765 0 0 4 1657 3727 0 0 10 /**
 *
 */ 2 4 this 3 3860  1 i 1 3581  
1766 0 0 4 1658 3727 0 0 10 /**
 *
 */ 2 4 this 3 3860  1 j 1 3581  
1767 0 0 4 1659 3727 0 0 10 /**
 *
 */ 2 4 this 3 3860  1 k 1 3581  
1768 0 0 6 1660 3732 0 0 10 /**
 *
 */ 1 4 this 3 3860  
1769 0 0 6 1661 3732 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3860  5 other 1 3861  
1770 0 0 6 1662 3732 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3860  
1771 0 0 6 1663 3732 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3860  5 other 1 3861  
1772 0 0 6 1664 3732 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3860  
1773 0 0 6 1665 3732 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3861  
1774 0 0 6 1666 3732 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3861  9 tolerance 1 3581  
1775 0 0 6 1667 3861 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1776 0 0 7 1668 3745 0 0 0 0 
1777 0 0 7 1671 3863 3551 0 10 /**
 *
 */ 0 
1778 0 0 15 1671 3863 3551 0 0 1 6 param0 0 3864  
1779 0 0 23 1671 3863 3551 0 10 /**
 *
 */ 1 4 copy 1 3801  
1780 0 0 7 1671 3863 3551 0 10 /**
 *
 */ 2 1 r 1 3584  4 copy 1 3774  
1781 0 0 23 1671 3863 3551 0 10 /**
 *
 */ 4 1 r 1 3584  1 i 1 3584  1 j 1 3584  1 k 1 3584  
1782 0 0 7 1672 3863 3551 0 10 /**
 *
 */ 1 1 v 1 3783  
1783 0 0 7 1673 3863 3551 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3864  
1784 0 0 7 1674 3773 2460 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3864  1 v 1 3774  
1785 0 0 7 1674 3800 2871 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3864  1 v 1 3801  
1786 0 0 7 1675 3863 3551 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3864  3 rhs 1 3864  
1787 0 0 7 1676 3863 3551 0 0 1 4 this 3 3864  
1788 0 0 7 1677 3863 3551 0 0 2 4 this 3 3864  5 other 1 3864  
1789 0 0 7 1678 3863 3551 0 0 2 4 this 3 3864  5 other 1 3864  
1790 0 0 6 1679 3584 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3864  5 other 1 3864  
1791 0 0 6 1680 3584 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3864  5 other 1 3864  
1792 0 0 7 1681 3842 3347 0 0 2 4 this 3 3863  6 param0 0 3843  
1793 0 0 7 1681 3853 3445 0 0 2 4 this 3 3863  6 param0 0 3847  
1794 0 0 7 1681 3863 3551 0 0 2 4 this 3 3864  6 param0 0 3864  
1795 0 0 7 1681 3863 3551 0 0 2 4 this 3 3864  6 scalar 1 3584  
1796 0 0 7 1682 3863 3551 0 0 2 4 this 3 3864  6 scalar 1 3584  
1797 0 0 6 1683 3863 0 0 10 /**
 *
 */ 2 4 this 3 3863  6 param0 0 3864  
1798 0 0 7 1684 3863 3551 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3864  6 param0 0 3584  
1799 0 0 6 1685 3732 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3864  5 other 1 3864  
1800 0 0 6 1685 3732 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3864  5 other 1 3864  9 threshold 1 3584  
1801 0 0 6 1686 3732 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3864  5 other 1 3864  
1802 0 0 6 1687 3732 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3864  5 other 1 3864  9 threshold 1 3584  
1803 0 0 4 1688 3727 0 0 10 /**
 *
 */ 2 4 this 3 3864  6 param0 0 3735  
1804 0 0 4 1689 3727 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3864  1 m 1 3842  
1805 0 0 4 1689 3727 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3864  1 m 1 3853  
1806 0 0 4 1690 3727 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3863  1 m 1 3843  
1807 0 0 4 1690 3727 0 0 10 /**
 *
 */ 2 4 this 3 3863  1 m 1 3847  
1808 0 0 4 1691 3727 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3863  3 hpr 1 3774  2 cs 5 3600  
1809 0 0 7 1692 3773 2460 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3864  2 cs 5 3600  
1810 0 0 7 1693 3782 2610 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3864  
1811 0 0 7 1694 3782 2610 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3864  
1812 0 0 6 1695 3584 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3864  
1813 0 0 6 1696 3584 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3864  
1814 0 0 4 1697 3727 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3863  9 angle_rad 1 3584  4 axis 1 3783  
1815 0 0 4 1698 3727 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3863  9 angle_deg 1 3584  4 axis 1 3783  
1816 0 0 7 1699 3782 2610 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3864  2 cs 5 3600  
1817 0 0 7 1700 3782 2610 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3864  2 cs 5 3600  
1818 0 0 7 1701 3782 2610 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3864  2 cs 5 3600  
1819 0 0 6 1702 3584 0 0 10 /**
 *
 */ 1 4 this 3 3864  
1820 0 0 6 1703 3584 0 0 10 /**
 *
 */ 1 4 this 3 3864  
1821 0 0 6 1704 3584 0 0 10 /**
 *
 */ 1 4 this 3 3864  
1822 0 0 6 1705 3584 0 0 10 /**
 *
 */ 1 4 this 3 3864  
1823 0 0 4 1706 3727 0 0 10 /**
 *
 */ 2 4 this 3 3863  1 r 1 3584  
1824 0 0 4 1707 3727 0 0 10 /**
 *
 */ 2 4 this 3 3863  1 i 1 3584  
1825 0 0 4 1708 3727 0 0 10 /**
 *
 */ 2 4 this 3 3863  1 j 1 3584  
1826 0 0 4 1709 3727 0 0 10 /**
 *
 */ 2 4 this 3 3863  1 k 1 3584  
1827 0 0 6 1710 3732 0 0 10 /**
 *
 */ 1 4 this 3 3863  
1828 0 0 6 1711 3732 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3863  5 other 1 3864  
1829 0 0 6 1712 3732 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3863  
1830 0 0 6 1713 3732 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3863  5 other 1 3864  
1831 0 0 6 1714 3732 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3863  
1832 0 0 6 1715 3732 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3864  
1833 0 0 6 1716 3732 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3864  9 tolerance 1 3584  
1834 0 0 6 1717 3864 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1835 0 0 7 1718 3745 0 0 0 0 
1836 0 0 7 1721 3866 3556 0 10 /**
 *
 */ 0 
1837 0 0 7 1721 3866 3556 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3825  
1838 0 0 7 1721 3866 3556 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3829  
1839 0 0 23 1721 3866 3556 0 10 /**
 *
 */ 1 1 c 1 3861  
1840 0 0 15 1721 3866 3556 0 0 1 6 param0 0 3867  
1841 0 0 23 1721 3866 3556 0 10 /**
 *
 */ 1 4 copy 1 3798  
1842 0 0 7 1721 3866 3556 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3780  5 angle 1 3581  
1843 0 0 7 1721 3866 3556 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3581  1 p 1 3581  1 r 1 3581  
1844 0 0 23 1721 3866 3556 0 10 /**
 *
 */ 4 1 r 1 3581  1 i 1 3581  1 j 1 3581  1 k 1 3581  
1845 0 0 7 1722 3860 3502 0 0 2 4 this 3 3867  5 other 1 3861  
1846 0 0 7 1722 3866 3556 0 0 2 4 this 3 3867  5 other 1 3867  
1847 0 0 7 1722 3866 3556 0 0 2 4 this 3 3867  6 scalar 1 3581  
1848 0 0 7 1723 3866 3556 0 0 2 4 this 3 3867  6 scalar 1 3581  
1849 0 0 7 1724 3745 0 0 0 0 
1850 0 0 7 1727 3869 3561 0 10 /**
 *
 */ 0 
1851 0 0 7 1727 3869 3561 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3843  
1852 0 0 7 1727 3869 3561 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3847  
1853 0 0 23 1727 3869 3561 0 10 /**
 *
 */ 1 1 c 1 3864  
1854 0 0 15 1727 3869 3561 0 0 1 6 param0 0 3870  
1855 0 0 23 1727 3869 3561 0 10 /**
 *
 */ 1 4 copy 1 3801  
1856 0 0 7 1727 3869 3561 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3783  5 angle 1 3584  
1857 0 0 7 1727 3869 3561 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3584  1 p 1 3584  1 r 1 3584  
1858 0 0 23 1727 3869 3561 0 10 /**
 *
 */ 4 1 r 1 3584  1 i 1 3584  1 j 1 3584  1 k 1 3584  
1859 0 0 7 1728 3863 3551 0 0 2 4 this 3 3870  5 other 1 3864  
1860 0 0 7 1728 3869 3561 0 0 2 4 this 3 3870  5 other 1 3870  
1861 0 0 7 1728 3869 3561 0 0 2 4 this 3 3870  6 scalar 1 3584  
1862 0 0 7 1729 3869 3561 0 0 2 4 this 3 3870  6 scalar 1 3584  
1863 0 0 7 1730 3745 0 0 0 0 
1864 0 0 7 1733 3872 3565 0 10 /**
 *
 */ 0 
1865 0 0 7 1733 3872 3565 0 18 /**
 * matrix3
 */ 1 1 m 1 3825  
1866 0 0 7 1733 3872 3565 0 18 /**
 * matrix4
 */ 1 1 m 1 3829  
1867 0 0 15 1733 3872 3565 0 0 1 6 param0 0 3873  
1868 0 0 23 1733 3872 3565 0 10 /**
 *
 */ 1 1 c 1 3861  
1869 0 0 7 1733 3872 3565 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3780  5 twist 1 3581  
1870 0 0 23 1733 3872 3565 0 10 /**
 *
 */ 4 1 r 1 3581  1 i 1 3581  1 j 1 3581  1 k 1 3581  
1871 0 0 7 1734 3872 3565 0 0 2 4 this 3 3873  5 other 1 3861  
1872 0 0 7 1734 3872 3565 0 0 2 4 this 3 3873  5 other 1 3867  
1873 0 0 7 1735 3745 0 0 0 0 
1874 0 0 7 1738 3875 3569 0 10 /**
 *
 */ 0 
1875 0 0 7 1738 3875 3569 0 18 /**
 * matrix3
 */ 1 1 m 1 3843  
1876 0 0 7 1738 3875 3569 0 18 /**
 * matrix4
 */ 1 1 m 1 3847  
1877 0 0 15 1738 3875 3569 0 0 1 6 param0 0 3876  
1878 0 0 23 1738 3875 3569 0 10 /**
 *
 */ 1 1 c 1 3864  
1879 0 0 7 1738 3875 3569 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3783  5 twist 1 3584  
1880 0 0 23 1738 3875 3569 0 10 /**
 *
 */ 4 1 r 1 3584  1 i 1 3584  1 j 1 3584  1 k 1 3584  
1881 0 0 7 1739 3875 3569 0 0 2 4 this 3 3876  5 other 1 3864  
1882 0 0 7 1739 3875 3569 0 0 2 4 this 3 3876  5 other 1 3870  
1883 0 0 7 1740 3745 0 0 0 0 
1884 0 0 15 1819 3880 3577 0 0 1 6 param0 0 3878  
1885 0 0 7 1819 3880 3577 0 10 /**
 *
 */ 1 4 name 1 3731  
1886 0 0 7 1819 3880 3577 0 10 /**
 *
 */ 4 4 name 1 3731  13 default_value 1 3881  11 description 5 3731  5 flags 5 3587  
1887 0 0 7 1819 3880 3577 0 10 /**
 *
 */ 4 4 name 1 3731  13 default_value 1 3731  11 description 5 3731  5 flags 5 3587  
1888 0 0 6 1820 3880 0 0 0 2 4 this 3 3880  5 value 1 3881  
1889 0 0 6 1822 3883 0 0 0 2 4 this 3 3878  1 n 1 3587  
1890 0 0 4 1823 3727 0 0 48 /**
 * Reassigns the variable's local value.
 */ 2 4 this 3 3880  5 value 1 3881  
1891 0 0 6 1824 3881 0 0 40 /**
 * Returns the variable's value.
 */ 1 4 this 3 3878  
1892 0 0 7 1825 3884 0 0 48 /**
 * Returns the variable's default value.
 */ 1 4 this 3 3878  
1893 0 0 6 1821 3881 0 0 0 1 4 this 3 3878  
1894 0 0 6 4 3584 0 0 0 1 1 f 1 3584  
1895 0 0 6 4 3581 0 0 0 1 1 f 1 3581  
1896 0 0 6 5 3584 0 0 0 1 1 f 1 3584  
1897 0 0 6 5 3581 0 0 0 1 1 f 1 3581  
1898 0 0 6 601 3600 0 0 0 0 
1899 0 0 6 602 3600 0 0 0 1 3 str 1 3731  
1900 0 0 6 603 3731 0 0 0 1 2 cs 1 3600  
1901 0 0 6 604 3732 0 0 0 1 2 cs 5 3600  
1902 0 0 7 1298 3842 3347 0 0 1 1 a 1 3843  
1903 0 0 7 1298 3824 3159 0 0 1 1 a 1 3825  
1904 0 0 7 1298 3853 3445 0 0 1 1 a 1 3847  
1905 0 0 7 1298 3835 3259 0 0 1 1 a 1 3829  
1906 0 0 7 1299 3842 3347 0 0 1 1 a 1 3843  
1907 0 0 7 1299 3824 3159 0 0 1 1 a 1 3825  
1908 0 0 7 1299 3853 3445 0 0 1 1 a 1 3847  
1909 0 0 7 1299 3835 3259 0 0 1 1 a 1 3829  
1910 0 0 7 1299 3863 3551 0 0 1 1 a 1 3864  
1911 0 0 7 1299 3860 3502 0 0 1 1 a 1 3861  
1912 0 0 7 1612 3842 3347 0 0 2 1 m 1 3843  1 q 1 3864  
1913 0 0 7 1612 3824 3159 0 0 2 1 m 1 3825  1 q 1 3861  
1914 0 0 7 1612 3853 3445 0 0 2 1 m 1 3847  1 q 1 3864  
1915 0 0 7 1612 3835 3259 0 0 2 1 m 1 3829  1 q 1 3861  
1916 0 0 7 1612 3764 2283 0 0 2 1 v 1 3765  1 m 1 3843  
1917 0 0 7 1612 3761 2266 0 0 2 1 v 1 3762  1 m 1 3825  
1918 0 0 7 1612 3791 2685 0 0 2 1 v 1 3792  1 m 1 3843  
1919 0 0 7 1612 3791 2685 0 0 2 1 v 1 3792  1 m 1 3847  
1920 0 0 7 1612 3788 2661 0 0 2 1 v 1 3789  1 m 1 3825  
1921 0 0 7 1612 3788 2661 0 0 2 1 v 1 3789  1 m 1 3829  
1922 0 0 7 1612 3818 3052 0 0 2 1 v 1 3819  1 m 1 3847  
1923 0 0 7 1612 3815 3031 0 0 2 1 v 1 3816  1 m 1 3829  
1924 0 0 7 1612 3773 2460 0 0 2 1 v 1 3774  1 m 1 3843  
1925 0 0 7 1612 3770 2379 0 0 2 1 v 1 3771  1 m 1 3825  
1926 0 0 7 1612 3800 2871 0 0 2 1 v 1 3801  1 m 1 3847  
1927 0 0 7 1612 3797 2789 0 0 2 1 v 1 3798  1 m 1 3829  
1928 0 0 7 1612 3755 2234 0 0 2 1 v 1 3756  1 m 1 3843  
1929 0 0 7 1612 3752 2215 0 0 2 1 v 1 3753  1 m 1 3825  
1930 0 0 7 1612 3782 2610 0 0 2 1 v 1 3783  1 m 1 3843  
1931 0 0 7 1612 3782 2610 0 0 2 1 v 1 3783  1 m 1 3847  
1932 0 0 7 1612 3779 2575 0 0 2 1 v 1 3780  1 m 1 3825  
1933 0 0 7 1612 3779 2575 0 0 2 1 v 1 3780  1 m 1 3829  
1934 0 0 7 1612 3809 2991 0 0 2 1 v 1 3810  1 m 1 3847  
1935 0 0 7 1612 3806 2970 0 0 2 1 v 1 3807  1 m 1 3829  
1936 0 0 4 1613 3727 0 0 0 2 1 v 1 3764  1 m 1 3843  
1937 0 0 4 1613 3727 0 0 0 2 1 v 1 3761  1 m 1 3825  
1938 0 0 4 1613 3727 0 0 0 2 1 v 1 3791  1 m 1 3843  
1939 0 0 4 1613 3727 0 0 0 2 1 v 1 3791  1 m 1 3847  
1940 0 0 4 1613 3727 0 0 0 2 1 v 1 3788  1 m 1 3825  
1941 0 0 4 1613 3727 0 0 0 2 1 v 1 3788  1 m 1 3829  
1942 0 0 4 1613 3727 0 0 0 2 1 v 1 3773  1 m 1 3843  
1943 0 0 4 1613 3727 0 0 0 2 1 v 1 3770  1 m 1 3825  
1944 0 0 4 1613 3727 0 0 0 2 1 v 1 3800  1 m 1 3847  
1945 0 0 4 1613 3727 0 0 0 2 1 v 1 3797  1 m 1 3829  
1946 0 0 4 1613 3727 0 0 0 2 1 v 1 3755  1 m 1 3843  
1947 0 0 4 1613 3727 0 0 0 2 1 v 1 3752  1 m 1 3825  
1948 0 0 4 1613 3727 0 0 0 2 1 v 1 3782  1 m 1 3843  
1949 0 0 4 1613 3727 0 0 0 2 1 v 1 3782  1 m 1 3847  
1950 0 0 4 1613 3727 0 0 0 2 1 v 1 3779  1 m 1 3825  
1951 0 0 4 1613 3727 0 0 0 2 1 v 1 3779  1 m 1 3829  
1952 0 0 4 1614 3727 0 0 0 2 4 dest 1 3737  5 value 1 3843  
1953 0 0 4 1614 3727 0 0 0 2 4 dest 1 3737  5 value 1 3825  
1954 0 0 4 1614 3727 0 0 0 2 4 dest 1 3737  5 value 1 3847  
1955 0 0 4 1614 3727 0 0 0 2 4 dest 1 3737  5 value 1 3829  
1956 0 0 4 1615 3727 0 0 0 2 6 result 1 3842  6 source 1 3739  
1957 0 0 4 1615 3727 0 0 0 2 6 result 1 3824  6 source 1 3739  
1958 0 0 4 1615 3727 0 0 0 2 6 result 1 3853  6 source 1 3739  
1959 0 0 4 1615 3727 0 0 0 2 6 result 1 3835  6 source 1 3739  
1960 0 0 4 1616 3727 0 0 0 4 3 mat 1 3842  5 scale 1 3774  3 hpr 1 3774  2 cs 5 3600  
1961 0 0 4 1616 3727 0 0 0 5 3 mat 1 3842  5 scale 1 3774  5 shear 1 3774  3 hpr 1 3774  2 cs 5 3600  
1962 0 0 4 1616 3727 0 0 0 4 3 mat 1 3824  5 scale 1 3771  3 hpr 1 3771  2 cs 5 3600  
1963 0 0 4 1616 3727 0 0 0 5 3 mat 1 3824  5 scale 1 3771  5 shear 1 3771  3 hpr 1 3771  2 cs 5 3600  
1964 0 0 4 1616 3727 0 0 0 5 3 mat 1 3853  5 scale 1 3774  3 hpr 1 3774  9 translate 1 3774  2 cs 5 3600  
1965 0 0 4 1616 3727 0 0 0 6 3 mat 1 3853  5 scale 1 3774  5 shear 1 3774  3 hpr 1 3774  9 translate 1 3774  2 cs 5 3600  
1966 0 0 4 1616 3727 0 0 0 3 3 mat 1 3853  10 components 1 3885  2 cs 5 3600  
1967 0 0 4 1616 3727 0 0 0 5 3 mat 1 3835  5 scale 1 3771  3 hpr 1 3771  9 translate 1 3771  2 cs 5 3600  
1968 0 0 4 1616 3727 0 0 0 6 3 mat 1 3835  5 scale 1 3771  5 shear 1 3771  3 hpr 1 3771  9 translate 1 3771  2 cs 5 3600  
1969 0 0 4 1616 3727 0 0 0 3 3 mat 1 3835  10 components 1 3887  2 cs 5 3600  
1970 0 0 6 1617 3732 0 0 0 4 3 mat 1 3843  5 scale 1 3773  3 hpr 1 3773  2 cs 5 3600  
1971 0 0 6 1617 3732 0 0 0 5 3 mat 1 3843  5 scale 1 3773  5 shear 1 3773  3 hpr 1 3773  2 cs 5 3600  
1972 0 0 6 1617 3732 0 0 0 4 3 mat 1 3825  5 scale 1 3770  3 hpr 1 3770  2 cs 5 3600  
1973 0 0 6 1617 3732 0 0 0 5 3 mat 1 3825  5 scale 1 3770  5 shear 1 3770  3 hpr 1 3770  2 cs 5 3600  
1974 0 0 6 1617 3732 0 0 0 5 3 mat 1 3847  5 scale 1 3773  3 hpr 1 3773  9 translate 1 3773  2 cs 5 3600  
1975 0 0 6 1617 3732 0 0 0 6 3 mat 1 3847  5 scale 1 3773  5 shear 1 3773  3 hpr 1 3773  9 translate 1 3773  2 cs 5 3600  
1976 0 0 6 1617 3732 0 0 0 3 3 mat 1 3847  10 components 1 3889  2 CS 5 3600  
1977 0 0 6 1617 3732 0 0 0 5 3 mat 1 3829  5 scale 1 3770  3 hpr 1 3770  9 translate 1 3770  2 cs 5 3600  
1978 0 0 6 1617 3732 0 0 0 6 3 mat 1 3829  5 scale 1 3770  5 shear 1 3770  3 hpr 1 3770  9 translate 1 3770  2 cs 5 3600  
1979 0 0 6 1617 3732 0 0 0 3 3 mat 1 3829  10 components 1 3890  2 CS 5 3600  
1980 0 0 6 1618 3732 0 0 0 5 3 mat 1 3843  5 scale 1 3773  5 shear 1 3773  3 hpr 1 3773  2 cs 5 3600  
1981 0 0 6 1618 3732 0 0 0 5 3 mat 1 3825  5 scale 1 3770  5 shear 1 3770  3 hpr 1 3770  2 cs 5 3600  
1982 0 0 7 1619 3773 2460 0 0 1 7 old_hpr 1 3774  
1983 0 0 7 1619 3770 2379 0 0 1 7 old_hpr 1 3771  
313
3578 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 1984 1985 0 0 0 0 0 0 0 0

3579 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 1988 2058 2 3891 3892 69 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 0 0 0 0 1 3580 75
/**
 * This is the base class for all two-component vectors and points.
 */

3580 0 0 794624 12 LVecBase2f:: 0 3579 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0
2 6 is_int 18 LVecBase2f::is_int 0
0 0 0

3581 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3582 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 2059 2129 2 3893 3894 69 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 0 0 0 0 1 3583 75
/**
 * This is the base class for all two-component vectors and points.
 */

3583 0 0 794624 12 LVecBase2d:: 0 3582 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0
2 6 is_int 18 LVecBase2d::is_int 0
0 0 0

3584 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3585 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2130 2196 2 3895 3896 65 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 0 0 0 0 1 3586 75
/**
 * This is the base class for all two-component vectors and points.
 */

3586 0 0 794624 12 LVecBase2i:: 0 3585 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0
2 6 is_int 18 LVecBase2i::is_int 0
1 0 0

3587 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3588 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2197 2215 0 17 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 0 0 1 0 3579 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3589 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2216 2234 0 17 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 0 0 1 0 3582 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3590 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2235 2249 0 13 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 0 0 1 0 3585 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3591 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2250 2266 0 15 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 0 0 1 0 3579 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3592 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2267 2283 0 15 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 0 0 1 0 3582 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3593 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2284 2298 0 13 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 0 0 1 0 3585 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3594 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2299 2379 6 3897 3898 3899 3900 3901 3902 79 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 0 0 0 0 1 3595 77
/**
 * This is the base class for all three-component vectors and points.
 */

3595 0 0 794624 12 LVecBase3f:: 0 3594 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0
3 6 is_int 18 LVecBase3f::is_int 0
0 0 0

3596 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2380 2460 6 3903 3904 3905 3906 3907 3908 79 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 0 0 0 0 1 3597 77
/**
 * This is the base class for all three-component vectors and points.
 */

3597 0 0 794624 12 LVecBase3d:: 0 3596 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0
3 6 is_int 18 LVecBase3d::is_int 0
0 0 0

3598 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2461 2536 6 3909 3910 3911 3912 3913 3914 74 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 0 0 0 0 1 3599 77
/**
 * This is the base class for all three-component vectors and points.
 */

3599 0 0 794624 12 LVecBase3i:: 0 3598 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0
3 6 is_int 18 LVecBase3i::is_int 0
1 0 0

3600 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 21
// Z-Up, Right-handed
1 12 CS_yup_right 12 CS_yup_right 21
// Y-Up, Right-handed
2 11 CS_zup_left 11 CS_zup_left 20
// Z-Up, Left-handed
3 11 CS_yup_left 11 CS_yup_left 20
// Y-Up, Left-handed
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

3601 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2541 2575 3 3915 3916 3917 33 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 0 0 1 0 3594 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3602 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2576 2610 3 3918 3919 3920 33 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 0 0 1 0 3596 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3603 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2611 2637 3 3921 3922 3923 25 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 0 0 1 0 3598 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3604 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2638 2661 3 3924 3925 3926 22 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 0 0 1 0 3594 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3605 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2662 2685 3 3927 3928 3929 22 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 0 0 1 0 3596 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3606 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2686 2707 3 3930 3931 3932 20 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 0 0 1 0 3598 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3607 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2708 2789 5 3933 3934 3935 3936 3937 80 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 0 0 1 0 3608 0 0 0 1 3609 77
/**
 * This is the base class for all three-component vectors and points.
 */

3608 10 MemoryBase 0 2048 10 MemoryBase 10 MemoryBase 0 0 0 0 0 0 0 0 0 0 0 0 428
/**
 * This class is intended to be the base class of all objects in Panda that
 * might be allocated and deleted via the new and delete operators.  It
 * redefines these operators to provide some memory tracking support.
 *
 * We used to try to override the global operator new and delete methods, but
 * that seems to cause problems when including header files for C++-based
 * system libraries (such as are found on OSX).
 */

3609 0 0 794624 12 LVecBase4f:: 0 3607 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0
4 6 is_int 18 LVecBase4f::is_int 0
0 0 0

3610 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2790 2871 5 3938 3939 3940 3941 3942 80 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 0 0 1 0 3608 0 0 0 1 3611 77
/**
 * This is the base class for all three-component vectors and points.
 */

3611 0 0 794624 12 LVecBase4d:: 0 3610 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0
4 6 is_int 18 LVecBase4d::is_int 0
0 0 0

3612 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2872 2949 5 3943 3944 3945 3946 3947 76 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 0 0 1 0 3608 0 0 0 1 3613 77
/**
 * This is the base class for all three-component vectors and points.
 */

3613 0 0 794624 12 LVecBase4i:: 0 3612 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0
4 6 is_int 18 LVecBase4i::is_int 0
1 0 0

3614 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 2950 2970 2 3948 3949 19 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 0 0 1 0 3607 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3615 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 2971 2991 2 3950 3951 19 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 0 0 1 0 3610 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3616 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 2992 3010 2 3952 3953 17 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 0 0 1 0 3612 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3617 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 3011 3031 2 3954 3955 19 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 0 0 1 0 3607 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3618 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 3032 3052 2 3956 3957 19 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 0 0 1 0 3610 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3619 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 3053 3071 2 3958 3959 17 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 0 0 1 0 3612 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3620 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 3083 3159 2 3960 3961 75 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 4 3968 3969 3970 3971 0 0 0 3 3621 3622 3623 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3621 0 0 794624 11 LMatrix3f:: 0 3620 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0
9 6 is_int 17 LMatrix3f::is_int 0
0 0 0

3622 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3620 0 0 1 3076 3077 0 3 3072 3073 3074 0 1 3075 0 0 0 66
// These helper classes are used to support two-level operator [].

3623 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3620 0 0 1 3081 3082 0 2 3078 3079 0 1 3080 0 0 0 0

3624 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3173 3259 2 3962 3963 85 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3 3972 3973 3974 0 1 0 3608 0 0 0 3 3625 3626 3627 45
/**
 * This is a 4-by-4 transform matrix.
 */

3625 0 0 794624 11 LMatrix4f:: 0 3624 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0
16 6 is_int 17 LMatrix4f::is_int 0
0 0 0

3626 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3624 0 0 1 3166 3167 0 3 3162 3163 3164 0 1 3165 0 0 0 66
// These helper classes are used to support two-level operator [].

3627 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3624 0 0 1 3171 3172 0 2 3168 3169 0 1 3170 0 0 0 0

3628 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3271 3347 2 3964 3965 75 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 4 3975 3976 3977 3978 0 0 0 3 3629 3630 3631 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3629 0 0 794624 11 LMatrix3d:: 0 3628 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0
9 6 is_int 17 LMatrix3d::is_int 0
0 0 0

3630 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3628 0 0 1 3264 3265 0 3 3260 3261 3262 0 1 3263 0 0 0 66
// These helper classes are used to support two-level operator [].

3631 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3628 0 0 1 3269 3270 0 2 3266 3267 0 1 3268 0 0 0 0

3632 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3359 3445 2 3966 3967 85 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3 3979 3980 3981 0 1 0 3608 0 0 0 3 3633 3634 3635 45
/**
 * This is a 4-by-4 transform matrix.
 */

3633 0 0 794624 11 LMatrix4d:: 0 3632 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0
16 6 is_int 17 LMatrix4d::is_int 0
0 0 0

3634 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3632 0 0 1 3352 3353 0 3 3348 3349 3350 0 1 3351 0 0 0 66
// These helper classes are used to support two-level operator [].

3635 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3632 0 0 1 3357 3358 0 2 3354 3355 0 1 3356 0 0 0 0

3636 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3454 3502 0 47 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 0 0 1 0 3607 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3637 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3503 3551 0 47 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 0 0 1 0 3610 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3638 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3552 3556 0 3 3553 3554 3555 0 0 1 0 3636 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3639 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3557 3561 0 3 3558 3559 3560 0 0 1 0 3637 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3640 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3562 3565 0 2 3563 3564 0 0 1 0 3636 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3641 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3566 3569 0 2 3567 3568 0 0 1 0 3637 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3642 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3604 0 0 0 0 0 0 0 0 0 0

3643 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3601 0 0 0 0 0 0 0 0 0 0

3644 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3591 0 0 0 0 0 0 0 0 0 0

3645 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3604 0 0 0 0 0 0 0 0 0 0

3646 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3607 0 0 0 0 0 0 0 0 0 0

3647 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3594 0 0 0 0 0 0 0 0 0 0

3648 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3605 0 0 0 0 0 0 0 0 0 0

3649 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3602 0 0 0 0 0 0 0 0 0 0

3650 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3592 0 0 0 0 0 0 0 0 0 0

3651 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3605 0 0 0 0 0 0 0 0 0 0

3652 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3610 0 0 0 0 0 0 0 0 0 0

3653 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3596 0 0 0 0 0 0 0 0 0 0

3654 19 UnalignedLVecBase4f 0 2105345 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 3607 0 0 0 0 0 0 0 0 0 0

3655 19 UnalignedLVecBase4d 0 2105345 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 3610 0 0 0 0 0 0 0 0 0 0

3656 19 UnalignedLVecBase4i 0 2105345 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 3612 0 0 0 0 0 0 0 0 0 0

3657 18 UnalignedLMatrix4f 0 2105345 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 3624 0 0 0 0 0 0 0 0 0 0

3658 18 UnalignedLMatrix4d 0 2105345 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 3632 0 0 0 0 0 0 0 0 0 0

3659 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3624 0 0 0 0 0 0 0 0 0 0

3660 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3620 0 0 0 0 0 0 0 0 0 0

3661 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3607 0 0 0 0 0 0 0 0 0 0

3662 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3614 0 0 0 0 0 0 0 0 0 0

3663 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3617 0 0 0 0 0 0 0 0 0 0

3664 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3594 0 0 0 0 0 0 0 0 0 0

3665 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3601 0 0 0 0 0 0 0 0 0 0

3666 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3604 0 0 0 0 0 0 0 0 0 0

3667 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3579 0 0 0 0 0 0 0 0 0 0

3668 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3588 0 0 0 0 0 0 0 0 0 0

3669 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3591 0 0 0 0 0 0 0 0 0 0

3670 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3636 0 0 0 0 0 0 0 0 0 0

3671 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3632 0 0 0 0 0 0 0 0 0 0

3672 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3628 0 0 0 0 0 0 0 0 0 0

3673 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3610 0 0 0 0 0 0 0 0 0 0

3674 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3615 0 0 0 0 0 0 0 0 0 0

3675 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3618 0 0 0 0 0 0 0 0 0 0

3676 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3596 0 0 0 0 0 0 0 0 0 0

3677 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3602 0 0 0 0 0 0 0 0 0 0

3678 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3605 0 0 0 0 0 0 0 0 0 0

3679 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3582 0 0 0 0 0 0 0 0 0 0

3680 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3589 0 0 0 0 0 0 0 0 0 0

3681 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3592 0 0 0 0 0 0 0 0 0 0

3682 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3637 0 0 0 0 0 0 0 0 0 0

3683 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3579 0 0 0 0 0 0 0 0 0 0

3684 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3591 0 0 0 0 0 0 0 0 0 0

3685 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3588 0 0 0 0 0 0 0 0 0 0

3686 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3594 0 0 0 0 0 0 0 0 0 0

3687 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3604 0 0 0 0 0 0 0 0 0 0

3688 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3601 0 0 0 0 0 0 0 0 0 0

3689 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3607 0 0 0 0 0 0 0 0 0 0

3690 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3617 0 0 0 0 0 0 0 0 0 0

3691 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3614 0 0 0 0 0 0 0 0 0 0

3692 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3636 0 0 0 0 0 0 0 0 0 0

3693 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3638 0 0 0 0 0 0 0 0 0 0

3694 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3640 0 0 0 0 0 0 0 0 0 0

3695 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3620 0 0 0 0 0 0 0 0 0 0

3696 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3624 0 0 0 0 0 0 0 0 0 0

3697 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3642 0 0 0 0 0 0 0 0 0 0

3698 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3643 0 0 0 0 0 0 0 0 0 0

3699 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3644 0 0 0 0 0 0 0 0 0 0

3700 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3645 0 0 0 0 0 0 0 0 0 0

3701 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3646 0 0 0 0 0 0 0 0 0 0

3702 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3647 0 0 0 0 0 0 0 0 0 0

3703 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3654 0 0 0 0 0 0 0 0 0 0

3704 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3657 0 0 0 0 0 0 0 0 0 0

3705 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3624 0 0 0 0 0 0 0 0 0 0

3706 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3620 0 0 0 0 0 0 0 0 0 0

3707 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3607 0 0 0 0 0 0 0 0 0 0

3708 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3614 0 0 0 0 0 0 0 0 0 0

3709 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3617 0 0 0 0 0 0 0 0 0 0

3710 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3594 0 0 0 0 0 0 0 0 0 0

3711 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3601 0 0 0 0 0 0 0 0 0 0

3712 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3604 0 0 0 0 0 0 0 0 0 0

3713 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3579 0 0 0 0 0 0 0 0 0 0

3714 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3588 0 0 0 0 0 0 0 0 0 0

3715 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3591 0 0 0 0 0 0 0 0 0 0

3716 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3636 0 0 0 0 0 0 0 0 0 0

3717 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3570 3577 0 5 3571 3573 3574 3575 3576 0 1 3572 1 0 3718 0 0 0 0 538
/**
 * This is a convenience class to specialize ConfigVariable as a set of
 * floating-point types representing a color value.
 *
 * It interprets the color differently depending on how many words were
 * specified: if only one, it is interpreted as a shade of gray with alpha 1.
 * If two values were specified, a grayscale and alpha pair.  If three, a set
 * of R, G, B values with alpha 1, and if four, a complete RGBA color.
 *
 * This isn't defined in dtool because it relies on the LColor class, which is
 * defined in linmath.
 */

3718 14 ConfigVariable 0 2048 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415
/**
 * This is a generic, untyped ConfigVariable.  It is also the base class for
 * the typed ConfigVariables, and contains all of the code common to
 * ConfigVariables of all types (except ConfigVariableList, which is a bit of
 * a special case).
 *
 * Mostly, this class serves as a thin wrapper around ConfigVariableCore
 * and/or ConfigDeclaration, more or less duplicating the interface presented
 * there.
 */

3719 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3578 0 0 0 0 0 0 0 0 0 0

3720 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3721 0 0 0 0 0 0 0 0 0 0

3721 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3578 0 0 0 0 0 0 0 0 0 0

3722 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3579 0 0 0 0 0 0 0 0 0 0

3723 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3724 0 0 0 0 0 0 0 0 0 0

3724 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3579 0 0 0 0 0 0 0 0 0 0

3725 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3726 0 0 0 0 0 0 0 0 0 0

3726 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

3727 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3728 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3729 0 0 0 0 0 0 0 0 0 0

3729 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3730 0 0 0 0 0 0 0 0 0 0

3730 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3731 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3732 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3733 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3734 0 0 0 0 0 0 0 0 0 0

3734 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This is a specific kind of HashGenerator that simply adds up all of the
 * ints.  Nothing fancy, and pretty quick.
 */

3735 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 3736 0 0 0 0 0 0 0 0 0 0

3736 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3737 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3738 0 0 0 0 0 0 0 0 0 0

3738 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

3739 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3740 0 0 0 0 0 0 0 0 0 0

3740 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 365
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 *
 * Note that it is the responsibility of the caller to ensure that the datagram
 * object is not destructed while this DatagramIterator is in use.
 */

3741 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 3742 0 0 0 0 0 0 0 0 0 0

3742 9 Py_buffer 0 2105344 9 Py_buffer 9 Py_buffer 0 0 3743 0 0 0 0 0 0 0 0 0 0

3743 10 bufferinfo 0 1024 10 bufferinfo 10 bufferinfo 0 0 0 0 0 0 0 0 0 0 0 0 0

3744 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3745 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3744 0 0 0 0 0 0 0 0 0 0

3746 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3582 0 0 0 0 0 0 0 0 0 0

3747 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3748 0 0 0 0 0 0 0 0 0 0

3748 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3582 0 0 0 0 0 0 0 0 0 0

3749 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3585 0 0 0 0 0 0 0 0 0 0

3750 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3751 0 0 0 0 0 0 0 0 0 0

3751 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3585 0 0 0 0 0 0 0 0 0 0

3752 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3588 0 0 0 0 0 0 0 0 0 0

3753 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3754 0 0 0 0 0 0 0 0 0 0

3754 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3588 0 0 0 0 0 0 0 0 0 0

3755 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3589 0 0 0 0 0 0 0 0 0 0

3756 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3757 0 0 0 0 0 0 0 0 0 0

3757 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3589 0 0 0 0 0 0 0 0 0 0

3758 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3590 0 0 0 0 0 0 0 0 0 0

3759 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3760 0 0 0 0 0 0 0 0 0 0

3760 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3590 0 0 0 0 0 0 0 0 0 0

3761 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3591 0 0 0 0 0 0 0 0 0 0

3762 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3763 0 0 0 0 0 0 0 0 0 0

3763 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3591 0 0 0 0 0 0 0 0 0 0

3764 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3592 0 0 0 0 0 0 0 0 0 0

3765 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3766 0 0 0 0 0 0 0 0 0 0

3766 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3592 0 0 0 0 0 0 0 0 0 0

3767 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3593 0 0 0 0 0 0 0 0 0 0

3768 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3769 0 0 0 0 0 0 0 0 0 0

3769 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3593 0 0 0 0 0 0 0 0 0 0

3770 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3594 0 0 0 0 0 0 0 0 0 0

3771 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3772 0 0 0 0 0 0 0 0 0 0

3772 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3594 0 0 0 0 0 0 0 0 0 0

3773 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3596 0 0 0 0 0 0 0 0 0 0

3774 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3775 0 0 0 0 0 0 0 0 0 0

3775 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3596 0 0 0 0 0 0 0 0 0 0

3776 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3598 0 0 0 0 0 0 0 0 0 0

3777 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3778 0 0 0 0 0 0 0 0 0 0

3778 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3598 0 0 0 0 0 0 0 0 0 0

3779 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3601 0 0 0 0 0 0 0 0 0 0

3780 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3781 0 0 0 0 0 0 0 0 0 0

3781 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3601 0 0 0 0 0 0 0 0 0 0

3782 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3602 0 0 0 0 0 0 0 0 0 0

3783 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3784 0 0 0 0 0 0 0 0 0 0

3784 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3602 0 0 0 0 0 0 0 0 0 0

3785 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3603 0 0 0 0 0 0 0 0 0 0

3786 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3787 0 0 0 0 0 0 0 0 0 0

3787 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3603 0 0 0 0 0 0 0 0 0 0

3788 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3604 0 0 0 0 0 0 0 0 0 0

3789 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3790 0 0 0 0 0 0 0 0 0 0

3790 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3604 0 0 0 0 0 0 0 0 0 0

3791 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3605 0 0 0 0 0 0 0 0 0 0

3792 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3793 0 0 0 0 0 0 0 0 0 0

3793 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3605 0 0 0 0 0 0 0 0 0 0

3794 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3606 0 0 0 0 0 0 0 0 0 0

3795 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3796 0 0 0 0 0 0 0 0 0 0

3796 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3606 0 0 0 0 0 0 0 0 0 0

3797 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3607 0 0 0 0 0 0 0 0 0 0

3798 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3799 0 0 0 0 0 0 0 0 0 0

3799 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3607 0 0 0 0 0 0 0 0 0 0

3800 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3610 0 0 0 0 0 0 0 0 0 0

3801 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3802 0 0 0 0 0 0 0 0 0 0

3802 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3610 0 0 0 0 0 0 0 0 0 0

3803 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3612 0 0 0 0 0 0 0 0 0 0

3804 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3805 0 0 0 0 0 0 0 0 0 0

3805 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3612 0 0 0 0 0 0 0 0 0 0

3806 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3614 0 0 0 0 0 0 0 0 0 0

3807 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3808 0 0 0 0 0 0 0 0 0 0

3808 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3614 0 0 0 0 0 0 0 0 0 0

3809 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3615 0 0 0 0 0 0 0 0 0 0

3810 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3811 0 0 0 0 0 0 0 0 0 0

3811 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3615 0 0 0 0 0 0 0 0 0 0

3812 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3616 0 0 0 0 0 0 0 0 0 0

3813 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3814 0 0 0 0 0 0 0 0 0 0

3814 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3616 0 0 0 0 0 0 0 0 0 0

3815 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3617 0 0 0 0 0 0 0 0 0 0

3816 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3817 0 0 0 0 0 0 0 0 0 0

3817 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3617 0 0 0 0 0 0 0 0 0 0

3818 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3618 0 0 0 0 0 0 0 0 0 0

3819 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3820 0 0 0 0 0 0 0 0 0 0

3820 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3618 0 0 0 0 0 0 0 0 0 0

3821 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3619 0 0 0 0 0 0 0 0 0 0

3822 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3823 0 0 0 0 0 0 0 0 0 0

3823 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3619 0 0 0 0 0 0 0 0 0 0

3824 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3620 0 0 0 0 0 0 0 0 0 0

3825 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3826 0 0 0 0 0 0 0 0 0 0

3826 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3620 0 0 0 0 0 0 0 0 0 0

3827 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3622 0 0 0 0 0 0 0 0 0 0

3828 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3623 0 0 0 0 0 0 0 0 0 0

3829 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3830 0 0 0 0 0 0 0 0 0 0

3830 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3624 0 0 0 0 0 0 0 0 0 0

3831 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3832 0 0 0 0 0 0 0 0 0 0

3832 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3622 0 0 0 0 0 0 0 0 0 0

3833 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3834 0 0 0 0 0 0 0 0 0 0

3834 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3623 0 0 0 0 0 0 0 0 0 0

3835 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3624 0 0 0 0 0 0 0 0 0 0

3836 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3626 0 0 0 0 0 0 0 0 0 0

3837 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3627 0 0 0 0 0 0 0 0 0 0

3838 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3839 0 0 0 0 0 0 0 0 0 0

3839 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3626 0 0 0 0 0 0 0 0 0 0

3840 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3841 0 0 0 0 0 0 0 0 0 0

3841 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3627 0 0 0 0 0 0 0 0 0 0

3842 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3628 0 0 0 0 0 0 0 0 0 0

3843 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3844 0 0 0 0 0 0 0 0 0 0

3844 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3628 0 0 0 0 0 0 0 0 0 0

3845 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3630 0 0 0 0 0 0 0 0 0 0

3846 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3631 0 0 0 0 0 0 0 0 0 0

3847 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3848 0 0 0 0 0 0 0 0 0 0

3848 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3632 0 0 0 0 0 0 0 0 0 0

3849 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 3850 0 0 0 0 0 0 0 0 0 0

3850 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3630 0 0 0 0 0 0 0 0 0 0

3851 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 3852 0 0 0 0 0 0 0 0 0 0

3852 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3631 0 0 0 0 0 0 0 0 0 0

3853 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3632 0 0 0 0 0 0 0 0 0 0

3854 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3634 0 0 0 0 0 0 0 0 0 0

3855 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3635 0 0 0 0 0 0 0 0 0 0

3856 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 3857 0 0 0 0 0 0 0 0 0 0

3857 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3634 0 0 0 0 0 0 0 0 0 0

3858 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 3859 0 0 0 0 0 0 0 0 0 0

3859 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3635 0 0 0 0 0 0 0 0 0 0

3860 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3636 0 0 0 0 0 0 0 0 0 0

3861 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3862 0 0 0 0 0 0 0 0 0 0

3862 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3636 0 0 0 0 0 0 0 0 0 0

3863 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3637 0 0 0 0 0 0 0 0 0 0

3864 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 3865 0 0 0 0 0 0 0 0 0 0

3865 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3637 0 0 0 0 0 0 0 0 0 0

3866 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3638 0 0 0 0 0 0 0 0 0 0

3867 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 3868 0 0 0 0 0 0 0 0 0 0

3868 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3638 0 0 0 0 0 0 0 0 0 0

3869 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3639 0 0 0 0 0 0 0 0 0 0

3870 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 3871 0 0 0 0 0 0 0 0 0 0

3871 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3639 0 0 0 0 0 0 0 0 0 0

3872 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3640 0 0 0 0 0 0 0 0 0 0

3873 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 3874 0 0 0 0 0 0 0 0 0 0

3874 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3640 0 0 0 0 0 0 0 0 0 0

3875 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3641 0 0 0 0 0 0 0 0 0 0

3876 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 3877 0 0 0 0 0 0 0 0 0 0

3877 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3641 0 0 0 0 0 0 0 0 0 0

3878 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 3879 0 0 0 0 0 0 0 0 0 0

3879 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3717 0 0 0 0 0 0 0 0 0 0

3880 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3717 0 0 0 0 0 0 0 0 0 0

3881 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3882 0 0 0 0 0 0 0 0 0 0

3882 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3701 0 0 0 0 0 0 0 0 0 0

3883 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3581 0 0 0 0 0 0 0 0 0 0

3884 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3701 0 0 0 0 0 0 0 0 0 0

3885 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 3886 12 0 0 0 0 0 0 0 0 0 0

3886 12 double const 0 8832 12 double const 12 double const 0 0 3584 0 0 0 0 0 0 0 0 0 0

3887 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 3888 12 0 0 0 0 0 0 0 0 0 0

3888 11 float const 0 8832 11 float const 11 float const 0 0 3581 0 0 0 0 0 0 0 0 0 0

3889 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3584 12 0 0 0 0 0 0 0 0 0 0

3890 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3581 12 0 0 0 0 0 0 0 0 0 0

0
77
3891 1 x 0 6 3581 2005 2007 0 0 0 0 0 0 13 LVecBase2f::x 0

3892 1 y 0 6 3581 2006 2008 0 0 0 0 0 0 13 LVecBase2f::y 0

3893 1 x 0 6 3584 2076 2078 0 0 0 0 0 0 13 LVecBase2d::x 0

3894 1 y 0 6 3584 2077 2079 0 0 0 0 0 0 13 LVecBase2d::y 0

3895 1 x 0 6 3587 2147 2149 0 0 0 0 0 0 13 LVecBase2i::x 0

3896 1 y 0 6 3587 2148 2150 0 0 0 0 0 0 13 LVecBase2i::y 0

3897 1 x 0 6 3581 2316 2320 0 0 0 0 0 0 13 LVecBase3f::x 0

3898 1 y 0 6 3581 2317 2321 0 0 0 0 0 0 13 LVecBase3f::y 0

3899 1 z 0 6 3581 2318 2322 0 0 0 0 0 0 13 LVecBase3f::z 0

3900 2 xy 0 2 3579 2323 0 0 0 0 0 0 0 14 LVecBase3f::xy 0

3901 2 xz 0 2 3579 2324 0 0 0 0 0 0 0 14 LVecBase3f::xz 0

3902 2 yz 0 2 3579 2325 0 0 0 0 0 0 0 14 LVecBase3f::yz 0

3903 1 x 0 6 3584 2397 2401 0 0 0 0 0 0 13 LVecBase3d::x 0

3904 1 y 0 6 3584 2398 2402 0 0 0 0 0 0 13 LVecBase3d::y 0

3905 1 z 0 6 3584 2399 2403 0 0 0 0 0 0 13 LVecBase3d::z 0

3906 2 xy 0 2 3582 2404 0 0 0 0 0 0 0 14 LVecBase3d::xy 0

3907 2 xz 0 2 3582 2405 0 0 0 0 0 0 0 14 LVecBase3d::xz 0

3908 2 yz 0 2 3582 2406 0 0 0 0 0 0 0 14 LVecBase3d::yz 0

3909 1 x 0 6 3587 2478 2482 0 0 0 0 0 0 13 LVecBase3i::x 0

3910 1 y 0 6 3587 2479 2483 0 0 0 0 0 0 13 LVecBase3i::y 0

3911 1 z 0 6 3587 2480 2484 0 0 0 0 0 0 13 LVecBase3i::z 0

3912 2 xy 0 2 3585 2485 0 0 0 0 0 0 0 14 LVecBase3i::xy 0

3913 2 xz 0 2 3585 2486 0 0 0 0 0 0 0 14 LVecBase3i::xz 0

3914 2 yz 0 2 3585 2487 0 0 0 0 0 0 0 14 LVecBase3i::yz 0

3915 2 xy 0 2 3588 2548 0 0 0 0 0 0 0 13 LVector3f::xy 0

3916 2 xz 0 2 3588 2549 0 0 0 0 0 0 0 13 LVector3f::xz 0

3917 2 yz 0 2 3588 2550 0 0 0 0 0 0 0 13 LVector3f::yz 0

3918 2 xy 0 2 3589 2583 0 0 0 0 0 0 0 13 LVector3d::xy 0

3919 2 xz 0 2 3589 2584 0 0 0 0 0 0 0 13 LVector3d::xz 0

3920 2 yz 0 2 3589 2585 0 0 0 0 0 0 0 13 LVector3d::yz 0

3921 2 xy 0 2 3590 2618 0 0 0 0 0 0 0 13 LVector3i::xy 0

3922 2 xz 0 2 3590 2619 0 0 0 0 0 0 0 13 LVector3i::xz 0

3923 2 yz 0 2 3590 2620 0 0 0 0 0 0 0 13 LVector3i::yz 0

3924 2 xy 0 2 3591 2645 0 0 0 0 0 0 0 12 LPoint3f::xy 0

3925 2 xz 0 2 3591 2646 0 0 0 0 0 0 0 12 LPoint3f::xz 0

3926 2 yz 0 2 3591 2647 0 0 0 0 0 0 0 12 LPoint3f::yz 0

3927 2 xy 0 2 3592 2669 0 0 0 0 0 0 0 12 LPoint3d::xy 0

3928 2 xz 0 2 3592 2670 0 0 0 0 0 0 0 12 LPoint3d::xz 0

3929 2 yz 0 2 3592 2671 0 0 0 0 0 0 0 12 LPoint3d::yz 0

3930 2 xy 0 2 3593 2693 0 0 0 0 0 0 0 12 LPoint3i::xy 0

3931 2 xz 0 2 3593 2694 0 0 0 0 0 0 0 12 LPoint3i::xz 0

3932 2 yz 0 2 3593 2695 0 0 0 0 0 0 0 12 LPoint3i::yz 0

3933 1 x 0 6 3581 2727 2733 0 0 0 0 0 0 13 LVecBase4f::x 0

3934 1 y 0 6 3581 2728 2734 0 0 0 0 0 0 13 LVecBase4f::y 0

3935 1 z 0 6 3581 2729 2735 0 0 0 0 0 0 13 LVecBase4f::z 0

3936 3 xyz 0 2 3594 2731 0 0 0 0 0 0 0 15 LVecBase4f::xyz 0

3937 2 xy 0 2 3579 2732 0 0 0 0 0 0 0 14 LVecBase4f::xy 0

3938 1 x 0 6 3584 2809 2815 0 0 0 0 0 0 13 LVecBase4d::x 0

3939 1 y 0 6 3584 2810 2816 0 0 0 0 0 0 13 LVecBase4d::y 0

3940 1 z 0 6 3584 2811 2817 0 0 0 0 0 0 13 LVecBase4d::z 0

3941 3 xyz 0 2 3596 2813 0 0 0 0 0 0 0 15 LVecBase4d::xyz 0

3942 2 xy 0 2 3582 2814 0 0 0 0 0 0 0 14 LVecBase4d::xy 0

3943 1 x 0 6 3587 2891 2897 0 0 0 0 0 0 13 LVecBase4i::x 0

3944 1 y 0 6 3587 2892 2898 0 0 0 0 0 0 13 LVecBase4i::y 0

3945 1 z 0 6 3587 2893 2899 0 0 0 0 0 0 13 LVecBase4i::z 0

3946 3 xyz 0 2 3598 2895 0 0 0 0 0 0 0 15 LVecBase4i::xyz 0

3947 2 xy 0 2 3585 2896 0 0 0 0 0 0 0 14 LVecBase4i::xy 0

3948 3 xyz 0 2 3601 2958 0 0 0 0 0 0 0 14 LVector4f::xyz 0

3949 2 xy 0 2 3588 2959 0 0 0 0 0 0 0 13 LVector4f::xy 0

3950 3 xyz 0 2 3602 2979 0 0 0 0 0 0 0 14 LVector4d::xyz 0

3951 2 xy 0 2 3589 2980 0 0 0 0 0 0 0 13 LVector4d::xy 0

3952 3 xyz 0 2 3603 3000 0 0 0 0 0 0 0 14 LVector4i::xyz 0

3953 2 xy 0 2 3590 3001 0 0 0 0 0 0 0 13 LVector4i::xy 0

3954 3 xyz 0 2 3604 3019 0 0 0 0 0 0 0 13 LPoint4f::xyz 0

3955 2 xy 0 2 3591 3020 0 0 0 0 0 0 0 12 LPoint4f::xy 0

3956 3 xyz 0 2 3605 3040 0 0 0 0 0 0 0 13 LPoint4d::xyz 0

3957 2 xy 0 2 3592 3041 0 0 0 0 0 0 0 12 LPoint4d::xy 0

3958 3 xyz 0 2 3606 3061 0 0 0 0 0 0 0 13 LPoint4i::xyz 0

3959 2 xy 0 2 3593 3062 0 0 0 0 0 0 0 12 LPoint4i::xy 0

3960 4 rows 0 70 3594 3095 3093 0 0 0 3092 0 0 15 LMatrix3f::rows 0

3961 4 cols 0 70 3594 3096 3094 0 0 0 3092 0 0 15 LMatrix3f::cols 0

3962 4 rows 0 70 3607 3187 3185 0 0 0 3184 0 0 15 LMatrix4f::rows 0

3963 4 cols 0 70 3607 3188 3186 0 0 0 3184 0 0 15 LMatrix4f::cols 0

3964 4 rows 0 70 3596 3283 3281 0 0 0 3280 0 0 15 LMatrix3d::rows 0

3965 4 cols 0 70 3596 3284 3282 0 0 0 3280 0 0 15 LMatrix3d::cols 0

3966 4 rows 0 70 3610 3373 3371 0 0 0 3370 0 0 15 LMatrix4d::rows 0

3967 4 cols 0 70 3610 3374 3372 0 0 0 3370 0 0 15 LMatrix4d::cols 0

14
3968 8 get_rows 0 3092 3095 19 LMatrix3f::get_rows 0

3969 8 get_cols 0 3092 3096 19 LMatrix3f::get_cols 0

3970 9 get_col2s 0 3092 3098 20 LMatrix3f::get_col2s 0

3971 9 get_row2s 0 3092 3097 20 LMatrix3f::get_row2s 0

3972 8 get_rows 0 3184 3187 19 LMatrix4f::get_rows 0

3973 8 get_cols 0 3184 3188 19 LMatrix4f::get_cols 0

3974 9 get_row3s 0 3184 3189 20 LMatrix4f::get_row3s 0

3975 8 get_rows 0 3280 3283 19 LMatrix3d::get_rows 0

3976 8 get_cols 0 3280 3284 19 LMatrix3d::get_cols 0

3977 9 get_col2s 0 3280 3286 20 LMatrix3d::get_col2s 0

3978 9 get_row2s 0 3280 3285 20 LMatrix3d::get_row2s 0

3979 8 get_rows 0 3370 3373 19 LMatrix4d::get_rows 0

3980 8 get_cols 0 3370 3374 19 LMatrix4d::get_cols 0

3981 9 get_row3s 0 3370 3375 20 LMatrix4d::get_row3s 0

