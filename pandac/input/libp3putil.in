1713074420
3 3
10 libp3putil 4 xqRv 12 panda3d.core 
976
988 5 clear 0 4 1966 68 PointerToBase< ReferenceCountedVector< unsigned short int > >::clear 0 1 18 0
87
inline void PointerToBase< ReferenceCountedVector< unsigned short int > >::clear(void);

989 6 output 0 4 1966 69 PointerToBase< ReferenceCountedVector< unsigned short int > >::output 0 1 19 0
100
void PointerToBase< ReferenceCountedVector< unsigned short int > >::output(std::ostream &out) const;

990 19 ~PointerToArrayBase 0 516 1965 61 PointerToArrayBase< unsigned short int >::~PointerToArrayBase 0 0 0
75
inline PointerToArrayBase< unsigned short int >::~PointerToArrayBase(void);

991 11 operator == 0 4 1965 53 PointerToArrayBase< unsigned short int >::operator == 0 1 16 64
// These are implemented in PointerToVoid, but expose them here.
127
inline bool PointerToArrayBase< unsigned short int >::operator ==(PointerToArrayBase< unsigned short int > const &other) const;

992 11 operator != 0 4 1965 53 PointerToArrayBase< unsigned short int >::operator != 0 1 17 0
127
inline bool PointerToArrayBase< unsigned short int >::operator !=(PointerToArrayBase< unsigned short int > const &other) const;

993 19 ConstPointerToArray 0 260 1964 62 ConstPointerToArray< unsigned short int >::ConstPointerToArray 0 2 1 2 0
246
inline ConstPointerToArray< unsigned short int >::ConstPointerToArray(PointerToArray< unsigned short int > const &copy);
inline ConstPointerToArray< unsigned short int >::ConstPointerToArray(ConstPointerToArray< unsigned short int > const &copy);

994 5 clear 0 4 1964 48 ConstPointerToArray< unsigned short int >::clear 0 1 3 0
67
inline void ConstPointerToArray< unsigned short int >::clear(void);

995 4 size 0 4 1964 47 ConstPointerToArray< unsigned short int >::size 0 1 4 0
90
inline unsigned long long int ConstPointerToArray< unsigned short int >::size(void) const;

996 11 get_element 0 4 1964 54 ConstPointerToArray< unsigned short int >::get_element 0 1 5 0
120
inline unsigned short int const &ConstPointerToArray< unsigned short int >::get_element(unsigned long long int n) const;

997 11 __getitem__ 0 4 1964 54 ConstPointerToArray< unsigned short int >::__getitem__ 0 1 6 0
113
unsigned short int const &ConstPointerToArray< unsigned short int >::__getitem__(unsigned long long int n) const;

998 8 get_data 0 4 1964 51 ConstPointerToArray< unsigned short int >::get_data 0 1 7 0
74
PyObject *ConstPointerToArray< unsigned short int >::get_data(void) const;

999 11 get_subdata 0 4 1964 54 ConstPointerToArray< unsigned short int >::get_subdata 0 1 8 0
127
PyObject *ConstPointerToArray< unsigned short int >::get_subdata(unsigned long long int n, unsigned long long int count) const;

1000 13 get_ref_count 0 4 1964 56 ConstPointerToArray< unsigned short int >::get_ref_count 0 1 9 0
80
inline int ConstPointerToArray< unsigned short int >::get_ref_count(void) const;

1001 18 get_node_ref_count 0 4 1964 61 ConstPointerToArray< unsigned short int >::get_node_ref_count 0 1 10 0
85
inline int ConstPointerToArray< unsigned short int >::get_node_ref_count(void) const;

1002 5 count 0 4 1964 48 ConstPointerToArray< unsigned short int >::count 0 1 11 0
113
inline unsigned long long int ConstPointerToArray< unsigned short int >::count(unsigned short int const &) const;

1003 10 __reduce__ 0 4 1964 53 ConstPointerToArray< unsigned short int >::__reduce__ 0 1 12 0
86
PyObject *ConstPointerToArray< unsigned short int >::__reduce__(PyObject *self) const;

1004 13 __getbuffer__ 0 4 1964 56 ConstPointerToArray< unsigned short int >::__getbuffer__ 0 1 13 0
111
int ConstPointerToArray< unsigned short int >::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

1005 17 __releasebuffer__ 0 4 1964 60 ConstPointerToArray< unsigned short int >::__releasebuffer__ 0 1 14 0
105
void ConstPointerToArray< unsigned short int >::__releasebuffer__(PyObject *self, Py_buffer *view) const;

1006 12 __deepcopy__ 0 4 1964 55 ConstPointerToArray< unsigned short int >::__deepcopy__ 0 1 15 0
120
ConstPointerToArray< unsigned short int > ConstPointerToArray< unsigned short int >::__deepcopy__(PyObject *memo) const;

1007 20 ~ConstPointerToArray 0 516 1964 63 ConstPointerToArray< unsigned short int >::~ConstPointerToArray 0 0 0
70
ConstPointerToArray< unsigned short int >::~ConstPointerToArray(void);

1008 14 PointerToArray 0 260 1968 52 PointerToArray< unsigned short int >::PointerToArray 0 3 20 21 22 0
339
inline PointerToArray< unsigned short int >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((unsigned short int const *)(0))));
inline PointerToArray< unsigned short int >::PointerToArray(PointerToArray< unsigned short int > const &copy);
PointerToArray< unsigned short int >::PointerToArray(PyObject *self, PyObject *source);

1009 11 empty_array 0 4 1968 49 PointerToArray< unsigned short int >::empty_array 0 1 23 0
207
static inline PointerToArray< unsigned short int > PointerToArray< unsigned short int >::empty_array(unsigned long long int n, TypeHandle type_handle = (::_get_type_handle((unsigned short int const *)(0))));

1010 5 clear 0 4 1968 43 PointerToArray< unsigned short int >::clear 0 1 24 0
62
inline void PointerToArray< unsigned short int >::clear(void);

1011 4 size 0 4 1968 42 PointerToArray< unsigned short int >::size 0 1 25 0
85
inline unsigned long long int PointerToArray< unsigned short int >::size(void) const;

1012 9 push_back 0 4 1968 47 PointerToArray< unsigned short int >::push_back 0 1 26 0
89
inline void PointerToArray< unsigned short int >::push_back(unsigned short int const &x);

1013 8 pop_back 0 4 1968 46 PointerToArray< unsigned short int >::pop_back 0 1 27 0
65
inline void PointerToArray< unsigned short int >::pop_back(void);

1014 11 get_element 0 4 1968 49 PointerToArray< unsigned short int >::get_element 0 1 28 0
115
inline unsigned short int const &PointerToArray< unsigned short int >::get_element(unsigned long long int n) const;

1015 11 set_element 0 4 1968 49 PointerToArray< unsigned short int >::set_element 0 1 29 0
121
inline void PointerToArray< unsigned short int >::set_element(unsigned long long int n, unsigned short int const &value);

1016 11 __getitem__ 0 4 1968 49 PointerToArray< unsigned short int >::__getitem__ 0 1 30 0
108
unsigned short int const &PointerToArray< unsigned short int >::__getitem__(unsigned long long int n) const;

1017 11 __setitem__ 0 4 1968 49 PointerToArray< unsigned short int >::__setitem__ 0 1 31 0
114
void PointerToArray< unsigned short int >::__setitem__(unsigned long long int n, unsigned short int const &value);

1018 8 get_data 0 4 1968 46 PointerToArray< unsigned short int >::get_data 0 1 32 0
69
PyObject *PointerToArray< unsigned short int >::get_data(void) const;

1019 8 set_data 0 4 1968 46 PointerToArray< unsigned short int >::set_data 0 1 33 0
68
void PointerToArray< unsigned short int >::set_data(PyObject *data);

1020 11 get_subdata 0 4 1968 49 PointerToArray< unsigned short int >::get_subdata 0 1 34 0
122
PyObject *PointerToArray< unsigned short int >::get_subdata(unsigned long long int n, unsigned long long int count) const;

1021 11 set_subdata 0 4 1968 49 PointerToArray< unsigned short int >::set_subdata 0 1 35 0
157
inline void PointerToArray< unsigned short int >::set_subdata(unsigned long long int n, unsigned long long int count, std::basic_string< char > const &data);

1022 13 get_ref_count 0 4 1968 51 PointerToArray< unsigned short int >::get_ref_count 0 1 36 0
75
inline int PointerToArray< unsigned short int >::get_ref_count(void) const;

1023 18 get_node_ref_count 0 4 1968 56 PointerToArray< unsigned short int >::get_node_ref_count 0 1 37 0
80
inline int PointerToArray< unsigned short int >::get_node_ref_count(void) const;

1024 5 count 0 4 1968 43 PointerToArray< unsigned short int >::count 0 1 38 0
108
inline unsigned long long int PointerToArray< unsigned short int >::count(unsigned short int const &) const;

1025 10 __reduce__ 0 4 1968 48 PointerToArray< unsigned short int >::__reduce__ 0 1 39 0
81
PyObject *PointerToArray< unsigned short int >::__reduce__(PyObject *self) const;

1026 13 __getbuffer__ 0 4 1968 51 PointerToArray< unsigned short int >::__getbuffer__ 0 1 40 0
100
int PointerToArray< unsigned short int >::__getbuffer__(PyObject *self, Py_buffer *view, int flags);

1027 17 __releasebuffer__ 0 4 1968 55 PointerToArray< unsigned short int >::__releasebuffer__ 0 1 41 0
100
void PointerToArray< unsigned short int >::__releasebuffer__(PyObject *self, Py_buffer *view) const;

1028 12 __deepcopy__ 0 4 1968 50 PointerToArray< unsigned short int >::__deepcopy__ 0 1 42 0
110
PointerToArray< unsigned short int > PointerToArray< unsigned short int >::__deepcopy__(PyObject *memo) const;

1029 15 ~PointerToArray 0 516 1968 53 PointerToArray< unsigned short int >::~PointerToArray 0 0 0
60
PointerToArray< unsigned short int >::~PointerToArray(void);

1030 14 ~AnimInterface 0 518 1969 29 AnimInterface::~AnimInterface 0 0 10
/**
 *
 */
44
virtual AnimInterface::~AnimInterface(void);

1031 4 play 0 4 1969 19 AnimInterface::play 0 2 43 44 477
/**
 * Runs the entire animation from beginning to end and stops.
 */

/**
 * Runs the animation from the frame "from" to and including the frame "to",
 * at which point the animation is stopped.  Both "from" and "to" frame
 * numbers may be outside the range (0, get_num_frames()) and the animation
 * will follow the range correctly, reporting numbers modulo get_num_frames().
 * For instance, play(0, get_num_frames() * 2) will play the animation twice
 * and then stop.
 */
95
inline void AnimInterface::play(void);
inline void AnimInterface::play(double from, double to);

1032 4 loop 0 4 1969 19 AnimInterface::loop 0 2 45 46 392
/**
 * Starts the entire animation looping.  If restart is true, the animation is
 * restarted from the beginning; otherwise, it continues from the current
 * frame.
 */

/**
 * Loops the animation from the frame "from" to and including the frame "to",
 * indefinitely.  If restart is true, the animation is restarted from the
 * beginning; otherwise, it continues from the current frame.
 */
117
inline void AnimInterface::loop(bool restart);
inline void AnimInterface::loop(bool restart, double from, double to);

1033 8 pingpong 0 4 1969 23 AnimInterface::pingpong 0 2 47 48 369
/**
 * Starts the entire animation bouncing back and forth between its first frame
 * and last frame.  If restart is true, the animation is restarted from the
 * beginning; otherwise, it continues from the current frame.
 */

/**
 * Loops the animation from the frame "from" to and including the frame "to",
 * and then back in the opposite direction, indefinitely.
 */
125
inline void AnimInterface::pingpong(bool restart);
inline void AnimInterface::pingpong(bool restart, double from, double to);

1034 4 stop 0 4 1969 19 AnimInterface::stop 0 1 49 130
/**
 * Stops a currently playing or looping animation right where it is.  The
 * animation remains posed at the current frame.
 */
38
inline void AnimInterface::stop(void);

1035 4 pose 0 4 1969 19 AnimInterface::pose 0 1 50 72
/**
 * Sets the animation to the indicated frame and holds it there.
 */
46
inline void AnimInterface::pose(double frame);

1036 13 set_play_rate 0 4 1969 28 AnimInterface::set_play_rate 0 1 51 243
/**
 * Changes the rate at which the animation plays.  1.0 is the normal speed,
 * 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to
 * pause the animation, and a negative value will play the animation
 * backwards.
 */
59
inline void AnimInterface::set_play_rate(double play_rate);

1037 13 get_play_rate 0 4 1969 28 AnimInterface::get_play_rate 0 1 52 79
/**
 * Returns the rate at which the animation plays.  See set_play_rate().
 */
55
inline double AnimInterface::get_play_rate(void) const;

1038 14 get_frame_rate 0 4 1969 29 AnimInterface::get_frame_rate 0 1 53 234
/**
 * Returns the native frame rate of the animation.  This is the number of
 * frames per second that will elapse when the play_rate is set to 1.0.  It is
 * a fixed property of the animation and may not be adjusted by the user.
 */
56
inline double AnimInterface::get_frame_rate(void) const;

1039 14 get_num_frames 0 6 1969 29 AnimInterface::get_num_frames 0 1 54 278
/**
 * Returns the number of frames in the animation.  This is a property of the
 * animation and may not be directly adjusted by the user (although it may
 * change without warning with certain kinds of animations, since this is a
 * virtual method that may be overridden).
 */
54
virtual int AnimInterface::get_num_frames(void) const;

1040 9 get_frame 0 4 1969 24 AnimInterface::get_frame 0 1 55 116
/**
 * Returns the current integer frame number.  This number will be in the range
 * 0 <= f < get_num_frames().
 */
48
inline int AnimInterface::get_frame(void) const;

1041 14 get_next_frame 0 4 1969 29 AnimInterface::get_next_frame 0 1 56 330
/**
 * Returns the current integer frame number + 1, constrained to the range 0 <=
 * f < get_num_frames().
 *
 * If the play mode is PM_play, this will clamp to the same value as
 * get_frame() at the end of the animation.  If the play mode is any other
 * value, this will wrap around to frame 0 at the end of the animation.
 */
53
inline int AnimInterface::get_next_frame(void) const;

1042 8 get_frac 0 4 1969 23 AnimInterface::get_frac 0 1 57 314
/**
 * Returns the fractional part of the current frame.  Normally, this is in the
 * range 0.0 <= f < 1.0, but in the one special case of an animation playing
 * to its end frame and stopping, it might exactly equal 1.0.
 *
 * It will always be true that get_full_frame() + get_frac() ==
 * get_full_fframe().
 */
50
inline double AnimInterface::get_frac(void) const;

1043 14 get_full_frame 0 4 1969 29 AnimInterface::get_full_frame 0 1 58 372
/**
 * Returns the current integer frame number.
 *
 * Unlike the value returned by get_frame(), this frame number may extend
 * beyond the range of get_num_frames() if the frame range passed to play(),
 * loop(), etc.  did.
 *
 * Unlike the value returned by get_full_fframe(), this return value will
 * never exceed the value passed to to_frame in the play() method.
 */
53
inline int AnimInterface::get_full_frame(void) const;

1044 15 get_full_fframe 0 4 1969 30 AnimInterface::get_full_fframe 0 1 59 490
/**
 * Returns the current floating-point frame number.
 *
 * Unlike the value returned by get_frame(), this frame number may extend
 * beyond the range of get_num_frames() if the frame range passed to play(),
 * loop(), etc.  did.
 *
 * Unlike the value returned by get_full_frame(), this return value may equal
 * (to_frame + 1.0), when the animation has played to its natural end.
 * However, in this case the return value of get_full_frame() will be
 * to_frame, not (to_frame + 1).
 */
57
inline double AnimInterface::get_full_fframe(void) const;

1045 10 is_playing 0 4 1969 25 AnimInterface::is_playing 0 1 60 208
/**
 * Returns true if the animation is currently playing, false if it is stopped
 * (e.g.  because stop() or pose() was called, or because it reached the end
 * of the animation after play() was called).
 */
50
inline bool AnimInterface::is_playing(void) const;

1046 6 output 0 6 1969 21 AnimInterface::output 0 1 61 10
/**
 *
 */
60
virtual void AnimInterface::output(std::ostream &out) const;

1047 14 get_class_type 0 4 1969 29 AnimInterface::get_class_type 0 1 62 0
54
static TypeHandle AnimInterface::get_class_type(void);

1048 9 UpdateSeq 0 260 1974 20 UpdateSeq::UpdateSeq 0 2 63 64 132
/**
 * Creates an UpdateSeq in the given state.
 */

/**
 * Creates an UpdateSeq in the 'initial' state.
 */

/**
 *
 */

/**
 *
 */
89
constexpr UpdateSeq::UpdateSeq(void);
inline UpdateSeq::UpdateSeq(UpdateSeq const &copy);

1049 7 initial 0 4 1974 18 UpdateSeq::initial 0 1 65 0
52
static constexpr UpdateSeq UpdateSeq::initial(void);

1050 3 old 0 4 1974 14 UpdateSeq::old 0 1 66 0
48
static constexpr UpdateSeq UpdateSeq::old(void);

1051 5 fresh 0 4 1974 16 UpdateSeq::fresh 0 1 67 0
50
static constexpr UpdateSeq UpdateSeq::fresh(void);

1052 10 operator = 0 4 1974 21 UpdateSeq::operator = 0 1 68 10
/**
 *
 */
57
inline void UpdateSeq::operator =(UpdateSeq const &copy);

1053 5 clear 0 4 1974 16 UpdateSeq::clear 0 1 69 55
/**
 * Resets the UpdateSeq to the 'initial' state.
 */
35
inline void UpdateSeq::clear(void);

1054 10 is_initial 0 4 1974 21 UpdateSeq::is_initial 0 1 70 67
/**
 * Returns true if the UpdateSeq is in the 'initial' state.
 */
46
inline bool UpdateSeq::is_initial(void) const;

1055 6 is_old 0 4 1974 17 UpdateSeq::is_old 0 1 71 63
/**
 * Returns true if the UpdateSeq is in the 'old' state.
 */
42
inline bool UpdateSeq::is_old(void) const;

1056 8 is_fresh 0 4 1974 19 UpdateSeq::is_fresh 0 1 72 65
/**
 * Returns true if the UpdateSeq is in the 'fresh' state.
 */
44
inline bool UpdateSeq::is_fresh(void) const;

1057 10 is_special 0 4 1974 21 UpdateSeq::is_special 0 1 73 105
/**
 * Returns true if the UpdateSeq is in any special states, i.e.  'initial',
 * 'old', or 'fresh'.
 */
46
inline bool UpdateSeq::is_special(void) const;

1058 11 operator == 0 4 1974 22 UpdateSeq::operator == 0 1 74 0
65
inline bool UpdateSeq::operator ==(UpdateSeq const &other) const;

1059 11 operator != 0 4 1974 22 UpdateSeq::operator != 0 1 75 0
65
inline bool UpdateSeq::operator !=(UpdateSeq const &other) const;

1060 10 operator < 0 4 1974 21 UpdateSeq::operator < 0 1 76 0
64
inline bool UpdateSeq::operator <(UpdateSeq const &other) const;

1061 11 operator <= 0 4 1974 22 UpdateSeq::operator <= 0 1 77 0
65
inline bool UpdateSeq::operator <=(UpdateSeq const &other) const;

1062 10 operator > 0 4 1974 21 UpdateSeq::operator > 0 1 78 0
64
inline bool UpdateSeq::operator >(UpdateSeq const &other) const;

1063 11 operator >= 0 4 1974 22 UpdateSeq::operator >= 0 1 79 0
65
inline bool UpdateSeq::operator >=(UpdateSeq const &other) const;

1064 11 operator ++ 0 68 1974 22 UpdateSeq::operator ++ 0 1 80 0
46
inline UpdateSeq UpdateSeq::operator ++(void);

1065 11 operator ++ 0 4 1974 22 UpdateSeq::operator ++ 0 1 81 0
46
inline UpdateSeq UpdateSeq::operator ++(int );

1066 7 get_seq 0 4 1974 18 UpdateSeq::get_seq 0 1 82 107
/**
 * Returns the internal integer value associated with the UpdateSeq.  Useful
 * for debugging only.
 */
60
inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const;

1067 6 output 0 4 1974 17 UpdateSeq::output 0 1 83 10
/**
 *
 */
55
inline void UpdateSeq::output(std::ostream &out) const;

1068 10 ~UpdateSeq 0 516 1974 21 UpdateSeq::~UpdateSeq 0 0 0
28
UpdateSeq::~UpdateSeq(void);

1069 7 __new__ 0 4 1978 22 TypedWritable::__new__ 0 1 84 0
59
static PyObject *TypedWritable::__new__(PyTypeObject *cls);

1070 14 write_datagram 0 6 1978 29 TypedWritable::write_datagram 0 1 85 96
/**
 * Writes the contents of this object to the datagram for shipping out to a
 * Bam file.
 */
77
virtual void TypedWritable::write_datagram(BamWriter *manager, Datagram &dg);

1071 6 fillin 0 6 1978 21 TypedWritable::fillin 0 1 86 308
/**
 * This internal function is intended to be called by each class's
 * make_from_bam() method to read in all of the relevant data from the BamFile
 * for the new object.  It is also called directly by the BamReader to re-read
 * the data for an object that has been placed on the stream for an update.
 */
79
virtual void TypedWritable::fillin(DatagramIterator &scan, BamReader *manager);

1072 17 mark_bam_modified 0 4 1978 32 TypedWritable::mark_bam_modified 0 1 87 345
/**
 * Increments the bam_modified counter, so that this object will be
 * invalidated and retransmitted on any open bam streams.  This should
 * normally not need to be called by user code; it should be called internally
 * when the object has been changed in a way that legitimately requires its
 * retransmission to any connected clients.
 */
51
inline void TypedWritable::mark_bam_modified(void);

1073 16 get_bam_modified 0 4 1978 31 TypedWritable::get_bam_modified 0 1 88 140
/**
 * Returns the current bam_modified counter.  This counter is normally
 * incremented automatically whenever the object is modified.
 */
61
inline UpdateSeq TypedWritable::get_bam_modified(void) const;

1074 10 __reduce__ 0 4 1978 25 TypedWritable::__reduce__ 0 1 89 0
58
PyObject *TypedWritable::__reduce__(PyObject *self) const;

1075 18 __reduce_persist__ 0 4 1978 33 TypedWritable::__reduce_persist__ 0 1 90 0
85
PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const;

1076 20 encode_to_bam_stream 0 4 1978 35 TypedWritable::encode_to_bam_stream 0 2 91 92 854
/**
 * Converts the TypedWritable object into a single stream of data using a
 * BamWriter, and returns that data as a bytes object.  Returns an empty bytes
 * object on failure.
 *
 * This is a convenience method particularly useful for cases when you are
 * only serializing a single object.  If you have many objects to process, it
 * is more efficient to use the same BamWriter to serialize all of them
 * together.
 */

/**
 * Converts the TypedWritable object into a single stream of data using a
 * BamWriter, and stores that data in the indicated string.  Returns true on
 * success, false on failure.
 *
 * This is a convenience method particularly useful for cases when you are
 * only serializing a single object.  If you have many objects to process, it
 * is more efficient to use the same BamWriter to serialize all of them
 * together.
 */
165
inline vector_uchar TypedWritable::encode_to_bam_stream(void) const;
bool TypedWritable::encode_to_bam_stream(vector_uchar &data, BamWriter *writer = nullptr) const;

1077 26 decode_raw_from_bam_stream 0 4 1978 41 TypedWritable::decode_raw_from_bam_stream 0 0 953
/**
 * Reads the bytes created by a previous call to encode_to_bam_stream(), and
 * extracts the single object on those bytes.  Returns true on success, false
 * on error.
 *
 * This variant sets the TypedWritable and ReferenceCount pointers separately;
 * both are pointers to the same object.  The reference count is not
 * incremented; it is the caller's responsibility to manage the reference
 * count.
 *
 * Note that this method cannot be used to retrieve objects that do not
 * inherit from ReferenceCount, because these objects cannot persist beyond
 * the lifetime of the BamReader that reads them.  To retrieve these objects
 * from a bam stream, you must construct a BamReader directly.
 *
 * If you happen to know that the particular object in question inherits from
 * TypedWritableReferenceCount or PandaNode, consider calling the variant of
 * decode_from_bam_stream() defined for those methods, which presents a
 * simpler interface.
 */
149
static bool TypedWritable::decode_raw_from_bam_stream(TypedWritable *&ptr, ReferenceCount *&ref_ptr, vector_uchar data, BamReader *reader = nullptr);

1078 14 get_class_type 0 4 1978 29 TypedWritable::get_class_type 0 1 93 0
54
static TypeHandle TypedWritable::get_class_type(void);

1079 23 upcast_to_TypedWritable 0 12 1980 52 TypedWritableReferenceCount::upcast_to_TypedWritable 0 1 96 56
upcast from TypedWritableReferenceCount to TypedWritable
74
TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void);

1080 39 downcast_to_TypedWritableReferenceCount 0 12 1978 54 TypedWritable::downcast_to_TypedWritableReferenceCount 0 0 58
downcast from TypedWritable to TypedWritableReferenceCount
90
TypedWritableReferenceCount *TypedWritable::downcast_to_TypedWritableReferenceCount(void);

1081 24 upcast_to_ReferenceCount 0 12 1980 53 TypedWritableReferenceCount::upcast_to_ReferenceCount 0 1 97 57
upcast from TypedWritableReferenceCount to ReferenceCount
76
ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void);

1082 39 downcast_to_TypedWritableReferenceCount 0 12 1981 55 ReferenceCount::downcast_to_TypedWritableReferenceCount 0 0 59
downcast from ReferenceCount to TypedWritableReferenceCount
91
TypedWritableReferenceCount *ReferenceCount::downcast_to_TypedWritableReferenceCount(void);

1083 22 decode_from_bam_stream 0 4 1980 51 TypedWritableReferenceCount::decode_from_bam_stream 0 1 94 491
/**
 * Reads the bytes created by a previous call to encode_to_bam_stream(), and
 * extracts and returns the single object on those bytes.  Returns NULL on
 * error.
 *
 * This method is intended to replace decode_raw_from_bam_stream() when you
 * know the stream in question returns an object of type
 * TypedWritableReferenceCount, allowing for easier reference count
 * management.  Note that the caller is still responsible for maintaining the
 * reference count on the return value.
 */
148
static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr);

1084 14 get_class_type 0 4 1980 43 TypedWritableReferenceCount::get_class_type 0 1 95 0
68
static TypeHandle TypedWritableReferenceCount::get_class_type(void);

1085 28 ~TypedWritableReferenceCount 0 516 1980 57 TypedWritableReferenceCount::~TypedWritableReferenceCount 0 0 0
64
TypedWritableReferenceCount::~TypedWritableReferenceCount(void);

1086 37 upcast_to_TypedWritableReferenceCount 0 12 1982 53 BamCacheRecord::upcast_to_TypedWritableReferenceCount 0 1 120 57
upcast from BamCacheRecord to TypedWritableReferenceCount
89
TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void);

1087 26 downcast_to_BamCacheRecord 0 12 1980 55 TypedWritableReferenceCount::downcast_to_BamCacheRecord 0 0 59
downcast from TypedWritableReferenceCount to BamCacheRecord
78
BamCacheRecord *TypedWritableReferenceCount::downcast_to_BamCacheRecord(void);

1088 24 upcast_to_LinkedListNode 0 12 1982 40 BamCacheRecord::upcast_to_LinkedListNode 0 0 44
upcast from BamCacheRecord to LinkedListNode
63
LinkedListNode *BamCacheRecord::upcast_to_LinkedListNode(void);

1089 26 downcast_to_BamCacheRecord 0 12 1983 42 LinkedListNode::downcast_to_BamCacheRecord 0 0 46
downcast from LinkedListNode to BamCacheRecord
65
BamCacheRecord *LinkedListNode::downcast_to_BamCacheRecord(void);

1090 15 ~BamCacheRecord 0 518 1982 31 BamCacheRecord::~BamCacheRecord 0 0 10
/**
 *
 */
46
virtual BamCacheRecord::~BamCacheRecord(void);

1091 9 make_copy 0 4 1982 25 BamCacheRecord::make_copy 0 1 98 179
/**
 * Returns a duplicate of the BamCacheRecord.  The duplicate will not have a
 * data pointer set, even though one may have been assigned to the original
 * via set_data().
 */
73
inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const;

1092 11 operator == 0 4 1982 27 BamCacheRecord::operator == 0 1 99 0
75
inline bool BamCacheRecord::operator ==(BamCacheRecord const &other) const;

1093 19 get_source_pathname 0 4 1982 35 BamCacheRecord::get_source_pathname 0 1 100 237
/**
 * Returns the full pathname to the source file that originally generated this
 * cache request.  In some cases, for instance in the case of a of a multipage
 * texture like "cube_#.png", this may not not a true filename on disk.
 */
71
inline Filename const &BamCacheRecord::get_source_pathname(void) const;

1094 18 get_cache_filename 0 4 1982 34 BamCacheRecord::get_cache_filename 0 1 101 230
/**
 * Returns the name of the cache file as hashed from the source_pathname.
 * This will be relative to the root of the cache directory, and it will not
 * include any suffixes that may be appended to resolve hash conflicts.
 */
70
inline Filename const &BamCacheRecord::get_cache_filename(void) const;

1095 20 get_source_timestamp 0 4 1982 36 BamCacheRecord::get_source_timestamp 0 1 102 204
/**
 * Returns the file timestamp of the original source file that generated this
 * cache record, if available.  In some cases the original file timestamp is
 * not available, and this will return 0.
 */
63
inline time_t BamCacheRecord::get_source_timestamp(void) const;

1096 17 get_recorded_time 0 4 1982 33 BamCacheRecord::get_recorded_time 0 1 103 84
/**
 * Returns the time at which this particular record was recorded or updated.
 */
60
inline time_t BamCacheRecord::get_recorded_time(void) const;

1097 23 get_num_dependent_files 0 4 1982 39 BamCacheRecord::get_num_dependent_files 0 1 104 75
/**
 * Returns the number of source files that contribute to the cache.
 */
63
inline int BamCacheRecord::get_num_dependent_files(void) const;

1098 22 get_dependent_pathname 0 4 1982 38 BamCacheRecord::get_dependent_pathname 0 1 105 94
/**
 * Returns the full pathname of the nth source files that contributes to the
 * cache.
 */
75
inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const;

1099 20 dependents_unchanged 0 4 1982 36 BamCacheRecord::dependents_unchanged 0 1 106 124
/**
 * Returns true if all of the dependent files are still the same as when the
 * cache was recorded, false otherwise.
 */
54
bool BamCacheRecord::dependents_unchanged(void) const;

1100 21 clear_dependent_files 0 4 1982 37 BamCacheRecord::clear_dependent_files 0 1 107 80
/**
 * Empties the list of files that contribute to the data in this record.
 */
49
void BamCacheRecord::clear_dependent_files(void);

1101 18 add_dependent_file 0 4 1982 34 BamCacheRecord::add_dependent_file 0 2 108 109 309
/**
 * Adds the indicated file to the list of files that will be loaded to
 * generate the data in this record.  This should be called once for the
 * primary source file, and again for each secondary source file, if any.
 */

/**
 * Variant of add_dependent_file that takes an already opened VirtualFile.
 */
132
void BamCacheRecord::add_dependent_file(Filename const &pathname);
void BamCacheRecord::add_dependent_file(VirtualFile const *file);

1102 8 has_data 0 4 1982 24 BamCacheRecord::has_data 0 1 110 130
/**
 * Returns true if this cache record has an in-memory data object associated--
 * that is, the object stored in the cache.
 */
49
inline bool BamCacheRecord::has_data(void) const;

1103 10 clear_data 0 4 1982 26 BamCacheRecord::clear_data 0 1 111 147
/**
 * Removes the in-memory data object associated with this record, if any.
 * This does not affect the on-disk representation of the record.
 */
45
inline void BamCacheRecord::clear_data(void);

1104 8 get_data 0 4 1982 24 BamCacheRecord::get_data 0 1 112 139
/**
 * Returns a pointer to the data stored in the record, or NULL if there is no
 * data.  The pointer is not removed from the record.
 */
59
inline TypedWritable *BamCacheRecord::get_data(void) const;

1105 12 extract_data 0 4 1982 28 BamCacheRecord::extract_data 0 0 416
/**
 * Fills ptr and ref_ptr with the two different-typed pointers to the same
 * object, the data stored within this record.  This transfers ownership of
 * the data pointer; the caller will be responsible for managing the reference
 * counts on this object subsequently.
 *
 * Returns true if the record contained any data (and the pointers have been
 * filled), false if it didn't (and the pointers are NULL).
 */
88
inline bool BamCacheRecord::extract_data(TypedWritable *&ptr, ReferenceCount *&ref_ptr);

1106 8 set_data 0 4 1982 24 BamCacheRecord::set_data 0 4 113 114 115 116 916
/**
 * Stores a new data object on the record.  You should pass the same pointer
 * twice, to both parameters; this allows the C++ typecasting to automatically
 * convert the pointer into both a TypedWritable and a ReferenceCount pointer,
 * so that the BamCacheRecord object can reliably manage the reference counts.
 *
 * You may pass 0 or NULL as the second parameter.  If you do this, the
 * BamCacheRecord will not manage the object's reference count; it will be up
 * to you to ensure the object is not deleted during the lifetime of the
 * BamCacheRecord object.
 */

/**
 * This variant on set_data() is provided to easily pass objects deriving from
 * TypedWritable.
 */

/**
 * This variant on set_data() is provided to easily pass objects deriving from
 * TypedWritableReferenceCount.
 */

/**
 * This variant on set_data() is provided just to allow Python code to pass a
 * 0 as the second parameter.
 */
281
inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr);
inline void BamCacheRecord::set_data(TypedWritable *ptr);
inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr);
inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy);

1107 6 output 0 4 1982 22 BamCacheRecord::output 0 1 117 10
/**
 *
 */
53
void BamCacheRecord::output(std::ostream &out) const;

1108 5 write 0 4 1982 21 BamCacheRecord::write 0 1 118 10
/**
 *
 */
74
void BamCacheRecord::write(std::ostream &out, int indent_level = 0) const;

1109 14 get_class_type 0 4 1982 30 BamCacheRecord::get_class_type 0 1 119 0
55
static TypeHandle BamCacheRecord::get_class_type(void);

1110 8 BamCache 0 260 1988 18 BamCache::BamCache 0 1 121 10
/**
 *
 */
25
BamCache::BamCache(void);

1111 9 ~BamCache 0 516 1988 19 BamCache::~BamCache 0 0 10
/**
 *
 */
26
BamCache::~BamCache(void);

1112 10 set_active 0 4 1988 20 BamCache::set_active 0 1 122 347
/**
 * Changes the state of the active flag.  "active" means that the cache should
 * be consulted automatically on loads, "not active" means that objects should
 * be loaded directly without consulting the cache.
 *
 * This represents the global flag.  Also see the individual cache_models,
 * cache_textures, cache_compressed_textures flags.
 */
44
inline void BamCache::set_active(bool flag);

1113 10 get_active 0 4 1988 20 BamCache::get_active 0 1 123 381
/**
 * Returns true if the BamCache is currently active, false if it is not.
 * "active" means that the cache should be consulted automatically on loads,
 * "not active" means that objects should be loaded directly without
 * consulting the cache.
 *
 * This represents the global flag.  Also see the individual cache_models,
 * cache_textures, cache_compressed_textures flags.
 */
45
inline bool BamCache::get_active(void) const;

1114 16 set_cache_models 0 4 1988 26 BamCache::set_cache_models 0 1 124 118
/**
 * Indicates whether model files (e.g.  egg files and bam files) will be
 * stored in the cache, as bam files.
 */
50
inline void BamCache::set_cache_models(bool flag);

1115 16 get_cache_models 0 4 1988 26 BamCache::get_cache_models 0 1 125 172
/**
 * Returns whether model files (e.g.  egg files and bam files) will be stored
 * in the cache, as bam files.
 *
 * This also returns false if get_active() is false.
 */
51
inline bool BamCache::get_cache_models(void) const;

1116 18 set_cache_textures 0 4 1988 28 BamCache::set_cache_textures 0 1 126 101
/**
 * Indicates whether texture files will be stored in the cache, as
 * uncompressed txo files.
 */
52
inline void BamCache::set_cache_textures(bool flag);

1117 18 get_cache_textures 0 4 1988 28 BamCache::get_cache_textures 0 1 127 174
/**
 * Returns whether texture files (e.g.  egg files and bam files) will be
 * stored in the cache, as txo files.
 *
 * This also returns false if get_active() is false.
 */
53
inline bool BamCache::get_cache_textures(void) const;

1118 29 set_cache_compressed_textures 0 4 1988 39 BamCache::set_cache_compressed_textures 0 1 128 722
/**
 * Indicates whether compressed texture files will be stored in the cache, as
 * compressed txo files.  The compressed data may either be generated in-CPU,
 * via the squish library, or it may be extracted from the GSG after the
 * texture has been loaded.
 *
 * This may be set in conjunction with set_cache_textures(), or independently
 * of it.  If set_cache_textures() is true and this is false, all textures
 * will be cached in their uncompressed form.  If set_cache_textures() is
 * false and this is true, only compressed textures will be cached, and they
 * will be cached in their compressed form.  If both are true, all textures
 * will be cached, in their uncompressed or compressed form appropriately.
 */
63
inline void BamCache::set_cache_compressed_textures(bool flag);

1119 29 get_cache_compressed_textures 0 4 1988 39 BamCache::get_cache_compressed_textures 0 1 129 202
/**
 * Returns whether compressed texture files will be stored in the cache, as
 * compressed txo files.  See set_cache_compressed_textures().
 *
 * This also returns false if get_active() is false.
 */
64
inline bool BamCache::get_cache_compressed_textures(void) const;

1120 26 set_cache_compiled_shaders 0 4 1988 36 BamCache::set_cache_compiled_shaders 0 1 130 184
/**
 * Indicates whether compiled shader programs will be stored in the cache, as
 * binary .sho files.  This may not be supported by all shader languages or
 * graphics renderers.
 */
60
inline void BamCache::set_cache_compiled_shaders(bool flag);

1121 26 get_cache_compiled_shaders 0 4 1988 36 BamCache::get_cache_compiled_shaders 0 1 131 196
/**
 * Returns whether compiled shader programs will be stored in the cache, as
 * binary .txo files.  See set_cache_compiled_shaders().
 *
 * This also returns false if get_active() is false.
 */
61
inline bool BamCache::get_cache_compiled_shaders(void) const;

1122 8 set_root 0 4 1988 18 BamCache::set_root 0 1 132 372
/**
 * Changes the current root pathname of the cache.  This specifies where the
 * cache files are stored on disk.  This should name a directory that is on a
 * disk local to the machine (not on a network-mounted disk), for instance,
 * /tmp/panda-cache or /c/panda-cache.
 *
 * If the directory does not already exist, it will be created as a result of
 * this call.
 */
46
void BamCache::set_root(Filename const &root);

1123 8 get_root 0 4 1988 18 BamCache::get_root 0 1 133 75
/**
 * Returns the current root pathname of the cache.  See set_root().
 */
47
inline Filename BamCache::get_root(void) const;

1124 14 set_flush_time 0 4 1988 24 BamCache::set_flush_time 0 1 134 86
/**
 * Specifies the time in seconds between automatic flushes of the cache index.
 */
53
inline void BamCache::set_flush_time(int flush_time);

1125 14 get_flush_time 0 4 1988 24 BamCache::get_flush_time 0 1 135 84
/**
 * Returns the time in seconds between automatic flushes of the cache index.
 */
48
inline int BamCache::get_flush_time(void) const;

1126 20 set_cache_max_kbytes 0 4 1988 30 BamCache::set_cache_max_kbytes 0 1 136 430
/**
 * Specifies the maximum size, in kilobytes, which the cache is allowed to
 * grow to.  If a newly cached file would exceed this size, an older file is
 * removed from the cache.
 *
 * Note that in the case of multiple different processes simultaneously
 * operating on the same cache directory, the actual cache size may slightly
 * exceed this value from time to time due to latency in checking between the
 * processes.
 */
59
inline void BamCache::set_cache_max_kbytes(int max_kbytes);

1127 20 get_cache_max_kbytes 0 4 1988 30 BamCache::get_cache_max_kbytes 0 1 137 121
/**
 * Returns the maximum size, in kilobytes, which the cache is allowed to grow
 * to.  See set_cache_max_kbytes().
 */
54
inline int BamCache::get_cache_max_kbytes(void) const;

1128 13 set_read_only 0 4 1988 23 BamCache::set_read_only 0 1 138 252
/**
 * Can be used to put the cache in read-only mode, or take it out of read-only
 * mode.  Note that if you put it into read-write mode, and it discovers that
 * it does not have write access, it will put itself right back into read-only
 * mode.
 */
45
inline void BamCache::set_read_only(bool ro);

1129 13 get_read_only 0 4 1988 23 BamCache::get_read_only 0 1 139 230
/**
 * Returns true if the cache is in read-only mode.  Normally, the cache starts
 * in read-write mode.  It can put itself into read-only mode automatically if
 * it discovers that it does not have write access to the cache.
 */
48
inline bool BamCache::get_read_only(void) const;

1130 6 lookup 0 4 1988 16 BamCache::lookup 0 1 140 782
/**
 * Looks up a file in the cache.
 *
 * If the file is cacheable, then regardless of whether the file is found in
 * the cache or not, this returns a BamCacheRecord.  On the other hand, if the
 * file cannot be cached, returns NULL.
 *
 * If record->has_data() returns true, then the file was found in the cache,
 * and you may call record->extract_data() to get the object.  If
 * record->has_data() returns false, then the file was not found in the cache
 * or the cache was stale; and you should reload the source file (calling
 * record->add_dependent_file() for each file loaded, including the original
 * source file), and then call record->set_data() to record the resulting
 * loaded object; and finally, you should call store() to write the cached
 * record to disk.
 */
114
PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, std::string const &cache_extension);

1131 5 store 0 4 1988 15 BamCache::store 0 1 141 212
/**
 * Flushes a cache entry to disk.  You must have retrieved the cache record
 * via a prior call to lookup(), and then stored the data via
 * record->set_data().  Returns true on success, false on failure.
 */
45
bool BamCache::store(BamCacheRecord *record);

1132 20 consider_flush_index 0 4 1988 30 BamCache::consider_flush_index 0 1 142 92
/**
 * Flushes the index if enough time has elapsed since the index was last
 * flushed.
 */
42
void BamCache::consider_flush_index(void);

1133 11 flush_index 0 4 1988 21 BamCache::flush_index 0 1 143 48
/**
 * Ensures the index is written to disk.
 */
33
void BamCache::flush_index(void);

1134 10 list_index 0 4 1988 20 BamCache::list_index 0 1 144 63
/**
 * Writes the contents of the index to standard output.
 */
73
void BamCache::list_index(std::ostream &out, int indent_level = 0) const;

1135 14 get_global_ptr 0 4 1988 24 BamCache::get_global_ptr 0 1 145 124
/**
 * Returns a pointer to the global BamCache object, which is used
 * automatically by the ModelPool and TexturePool.
 */
55
static inline BamCache *BamCache::get_global_ptr(void);

1136 27 consider_flush_global_index 0 4 1988 37 BamCache::consider_flush_global_index 0 1 146 84
/**
 * If there is a global BamCache object, calls consider_flush_index() on it.
 */
63
static inline void BamCache::consider_flush_global_index(void);

1137 18 flush_global_index 0 4 1988 28 BamCache::flush_global_index 0 1 147 75
/**
 * If there is a global BamCache object, calls flush_index() on it.
 */
54
static inline void BamCache::flush_global_index(void);

1138 8 BamEnums 0 260 1989 18 BamEnums::BamEnums 0 2 148 149 0
97
inline BamEnums::BamEnums(void) = default;
inline BamEnums::BamEnums(BamEnums const &) = default;

1139 9 ~BamEnums 0 516 1989 19 BamEnums::~BamEnums 0 0 0
26
BamEnums::~BamEnums(void);

1140 13 LoaderOptions 0 260 1993 28 LoaderOptions::LoaderOptions 0 3 150 151 152 22
/**
 *
 */

/**
 *
 */
265
explicit LoaderOptions::LoaderOptions(int flags = (::LoaderOptions::LF_search | ::LoaderOptions::LF_report_errors));
explicit constexpr LoaderOptions::LoaderOptions(int flags, int texture_flags);
inline LoaderOptions::LoaderOptions(LoaderOptions const &) = default;

1141 9 set_flags 0 4 1993 24 LoaderOptions::set_flags 0 1 153 10
/**
 *
 */
48
inline void LoaderOptions::set_flags(int flags);

1142 9 get_flags 0 4 1993 24 LoaderOptions::get_flags 0 1 154 10
/**
 *
 */
48
inline int LoaderOptions::get_flags(void) const;

1143 17 set_texture_flags 0 4 1993 32 LoaderOptions::set_texture_flags 0 1 155 10
/**
 *
 */
56
inline void LoaderOptions::set_texture_flags(int flags);

1144 17 get_texture_flags 0 4 1993 32 LoaderOptions::get_texture_flags 0 1 156 10
/**
 *
 */
56
inline int LoaderOptions::get_texture_flags(void) const;

1145 18 set_texture_format 0 4 1993 33 LoaderOptions::set_texture_format 0 1 157 0
58
inline void LoaderOptions::set_texture_format(int format);

1146 18 get_texture_format 0 4 1993 33 LoaderOptions::get_texture_format 0 1 158 34
/**
 *  Get the texture format
 */
57
inline int LoaderOptions::get_texture_format(void) const;

1147 23 set_texture_compression 0 4 1993 38 LoaderOptions::set_texture_compression 0 1 159 39
/**
 *  Set the texture compression
 */
65
inline void LoaderOptions::set_texture_compression(int compress);

1148 23 get_texture_compression 0 4 1993 38 LoaderOptions::get_texture_compression 0 1 160 39
/**
 *  Get the texture compression
 */
62
inline int LoaderOptions::get_texture_compression(void) const;

1149 19 set_texture_quality 0 4 1993 34 LoaderOptions::set_texture_quality 0 1 161 35
/**
 *  Set the texture quality
 */
60
inline void LoaderOptions::set_texture_quality(int quality);

1150 19 get_texture_quality 0 4 1993 34 LoaderOptions::get_texture_quality 0 1 162 35
/**
 *  Get the texture quality
 */
58
inline int LoaderOptions::get_texture_quality(void) const;

1151 21 set_texture_num_views 0 4 1993 36 LoaderOptions::set_texture_num_views 0 1 163 459
/**
 * Specifies the expected number of views to load for the texture.  This is
 * ignored unless TF_multiview is included in texture_flags.  This must be
 * specified when loading a 3-d multiview texture or 2-d texture array, in
 * which case it is used to differentiate z levels from separate views; it
 * may be zero in the case of 2-d textures or cube maps, in which case the
 * number of views can be inferred from the number of images found on disk.
 */
64
inline void LoaderOptions::set_texture_num_views(int num_views);

1152 21 get_texture_num_views 0 4 1993 36 LoaderOptions::get_texture_num_views 0 1 164 39
/**
 * See set_texture_num_views().
 */
60
inline int LoaderOptions::get_texture_num_views(void) const;

1153 22 set_auto_texture_scale 0 4 1993 37 LoaderOptions::set_auto_texture_scale 0 1 165 209
/**
 * Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a
 * texture is scaled from disk when it is subsequently loaded.  Set it to
 * ATS_unspecified to restore the default behavior.
 */
74
inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale);

1154 22 get_auto_texture_scale 0 4 1993 37 LoaderOptions::get_auto_texture_scale 0 1 166 40
/**
 * See set_auto_texture_scale().
 */
74
inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const;

1155 6 output 0 4 1993 21 LoaderOptions::output 0 1 167 10
/**
 *
 */
52
void LoaderOptions::output(std::ostream &out) const;

1156 14 ~LoaderOptions 0 516 1993 29 LoaderOptions::~LoaderOptions 0 0 0
36
LoaderOptions::~LoaderOptions(void);

1157 9 BamReader 0 260 1996 20 BamReader::BamReader 0 1 168 50
// The primary interface for a caller.

/**
 *
 */
67
explicit BamReader::BamReader(DatagramGenerator *source = nullptr);

1158 10 ~BamReader 0 516 1996 21 BamReader::~BamReader 0 0 10
/**
 *
 */
28
BamReader::~BamReader(void);

1159 10 set_source 0 4 1996 21 BamReader::set_source 0 1 169 142
/**
 * Changes the source of future datagrams for this BamReader.  This also
 * implicitly calls init() if it has not already been called.
 */
54
void BamReader::set_source(DatagramGenerator *source);

1160 10 get_source 0 4 1996 21 BamReader::get_source 0 1 170 100
/**
 * Returns the current source of the BamReader as set by set_source() or the
 * constructor.
 */
54
inline DatagramGenerator *BamReader::get_source(void);

1161 4 init 0 4 1996 15 BamReader::init 0 1 171 210
/**
 * Initializes the BamReader prior to reading any objects from its source.
 * This includes reading the Bam header.
 *
 * This returns true if the BamReader successfully initialized, false
 * otherwise.
 */
27
bool BamReader::init(void);

1162 12 set_aux_data 0 4 1996 23 BamReader::set_aux_data 0 1 172 1007
/**
 * Associates an arbitrary block of data with the indicated object (or NULL),
 * and the indicated name.
 *
 * This is intended to provide a place for temporary storage for objects
 * reading themselves from the bam file.  To use it, inherit from
 * BamReader::AuxData and store whatever data you like there.  Then associate
 * your AuxData with the object as it is being read with set_aux_data().  You
 * may later set the aux data to NULL to remove it; or it will automatically
 * be removed (and deleted) after finalize() is called for the object in
 * question.
 *
 * If the TypedWritable pointer is NULL, the the aux data is stored globally
 * for the BamReader in general.  This pointer is available to any bam
 * objects, and will not be automatically removed until the BamReader itself
 * destructs.
 *
 * In either case, the name is just an arbitrary user-defined key.  If there
 * is already a data pointer stored for the obj/name pair, that data pointer
 * will be replaced (and deleted).
 */
100
void BamReader::set_aux_data(TypedWritable *obj, std::string const &name, BamReader::AuxData *data);

1163 12 get_aux_data 0 4 1996 23 BamReader::get_aux_data 0 1 173 173
/**
 * Returns the pointer previously associated with the bam reader by a previous
 * call to set_aux_data(), or NULL if data with the indicated key has not been
 * set.
 */
95
BamReader::AuxData *BamReader::get_aux_data(TypedWritable *obj, std::string const &name) const;

1164 12 get_filename 0 4 1996 23 BamReader::get_filename 0 1 174 199
/**
 * If a BAM is a file, then the BamReader should contain the name of the file.
 * This enables the reader to interpret pathnames in the BAM as relative to
 * the directory containing the BAM.
 */
59
inline Filename const &BamReader::get_filename(void) const;

1165 18 get_loader_options 0 4 1996 29 BamReader::get_loader_options 0 1 175 98
/**
 * Returns the LoaderOptions passed to the loader when the model was
 * requested, if any.
 */
70
inline LoaderOptions const &BamReader::get_loader_options(void) const;

1166 18 set_loader_options 0 4 1996 29 BamReader::set_loader_options 0 1 176 58
/**
 * Specifies the LoaderOptions for this BamReader.
 */
72
inline void BamReader::set_loader_options(LoaderOptions const &options);

1167 11 read_object 0 4 1996 22 BamReader::read_object 0 1 177 1393
/**
 * Reads a single object from the Bam file.  If the object type is known, a
 * new object of the appropriate type is created and returned; otherwise, NULL
 * is returned.  NULL is also returned when the end of the file is reached.
 * is_eof() may be called to differentiate between these two cases.
 *
 * This may be called repeatedly to extract out all the objects in the Bam
 * file, but typically (especially for scene graph files, indicated with the
 * .bam extension), only one object is retrieved directly from the Bam file:
 * the root of the scene graph.  The remaining objects will all be retrieved
 * recursively by the first object.
 *
 * Note that the object returned may not yet be complete.  In particular, some
 * of its pointers may not be filled in; you must call resolve() to fill in
 * all the available pointers before you can safely use any objects returned
 * by read_object().
 *
 * This flavor of read_object() requires the caller to know what type of
 * object it has received in order to properly manage the reference counts.
 */

/**
 * Reads a single object from the Bam file.
 *
 * This flavor of read_object() returns both a TypedWritable and a
 * ReferenceCount pointer to the same object, so the reference count may be
 * tracked reliably, without having to know precisely what type of object we
 * have.
 * @return true on success, or false on failure.
 */
39
PyObject *BamReader::read_object(void);

1168 6 is_eof 0 4 1996 17 BamReader::is_eof 0 1 178 138
/**
 * Returns true if the reader has reached end-of-file, false otherwise.  This
 * call is only valid after a call to read_object().
 */
42
inline bool BamReader::is_eof(void) const;

1169 7 resolve 0 4 1996 18 BamReader::resolve 0 1 179 566
/**
 * This may be called at any time during processing of the Bam file to resolve
 * all the known pointers so far.  It is usually called at the end of the
 * processing, after all objects have been read, which is generally the best
 * time to call it.
 *
 * This must be called at least once after reading a particular object via
 * read_object() in order to validate that object.
 *
 * The return value is true if all objects have been resolved, or false if
 * some objects are still outstanding (in which case you will need to call
 * resolve() again later).
 */
30
bool BamReader::resolve(void);

1170 14 change_pointer 0 4 1996 25 BamReader::change_pointer 0 1 180 406
/**
 * Indicates that an object recently read from the bam stream should be
 * replaced with a new object.  Any future occurrences of the original object
 * in the stream will henceforth return the new object instead.
 *
 * The return value is true if the replacement was successfully made, or false
 * if the object was not read from the stream (or if change_pointer had
 * already been called on it).
 */
100
bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer);

1171 18 get_file_major_ver 0 4 1996 29 BamReader::get_file_major_ver 0 1 181 81
/**
 * Returns the major version number of the Bam file currently being read.
 */
53
inline int BamReader::get_file_major_ver(void) const;

1172 18 get_file_minor_ver 0 4 1996 29 BamReader::get_file_minor_ver 0 1 182 81
/**
 * Returns the minor version number of the Bam file currently being read.
 */
53
inline int BamReader::get_file_minor_ver(void) const;

1173 15 get_file_endian 0 4 1996 26 BamReader::get_file_endian 0 1 183 254
/**
 * Returns the endian preference indicated by the Bam file currently being
 * read.  This does not imply that every number is stored using the indicated
 * convention, but individual objects may choose to respect this flag when
 * recording data.
 */
66
inline BamEnums::BamEndian BamReader::get_file_endian(void) const;

1174 24 get_file_stdfloat_double 0 4 1996 35 BamReader::get_file_stdfloat_double 0 1 184 220
/**
 * Returns true if the file stores all "standard" floats as 64-bit doubles, or
 * false if they are 32-bit floats.  This is determined by the compilation
 * flags of the version of Panda that generated this file.
 */
60
inline bool BamReader::get_file_stdfloat_double(void) const;

1175 21 get_current_major_ver 0 4 1996 32 BamReader::get_current_major_ver 0 1 185 174
/**
 * Returns the major version number of Bam files supported by the current code
 * base.  This must match get_file_major_ver() in order to successfully read a
 * file.
 */
56
inline int BamReader::get_current_major_ver(void) const;

1176 21 get_current_minor_ver 0 4 1996 32 BamReader::get_current_minor_ver 0 1 186 184
/**
 * Returns the minor version number of Bam files supported by the current code
 * base.  This must match or exceed get_file_minor_ver() in order to
 * successfully read a file.
 */
56
inline int BamReader::get_current_minor_ver(void) const;

1177 16 get_file_version 0 4 1996 27 BamReader::get_file_version 0 1 187 0
50
PyObject *BamReader::get_file_version(void) const;

1178 16 register_factory 0 4 1996 27 BamReader::register_factory 0 1 188 208
/**
 * Registers a factory function that is called when an object of the given
 * type is encountered within the .bam stream.
 *
 * @param user_data an optional pointer to be passed along to the function.
 */
75
static void BamReader::register_factory(TypeHandle handle, PyObject *func);

1179 9 BamWriter 0 260 2003 20 BamWriter::BamWriter 0 2 189 190 10
/**
 *
 */
120
explicit BamWriter::BamWriter(DatagramSink *target = nullptr);
inline BamWriter::BamWriter(BamWriter const &) = default;

1180 10 ~BamWriter 0 516 2003 21 BamWriter::~BamWriter 0 0 10
/**
 *
 */
28
BamWriter::~BamWriter(void);

1181 10 set_target 0 4 2003 21 BamWriter::set_target 0 1 191 153
/**
 * Changes the destination of future datagrams written by the BamWriter.  This
 * also implicitly calls init() if it has not already been called.
 */
49
void BamWriter::set_target(DatagramSink *target);

1182 10 get_target 0 4 2003 21 BamWriter::get_target 0 1 192 100
/**
 * Returns the current target of the BamWriter as set by set_target() or the
 * constructor.
 */
49
inline DatagramSink *BamWriter::get_target(void);

1183 4 init 0 4 2003 15 BamWriter::init 0 1 193 220
/**
 * Initializes the BamWriter prior to writing any objects to its output
 * stream.  This includes writing out the Bam header.
 *
 * This returns true if the BamWriter successfully initialized, false
 * otherwise.
 */
27
bool BamWriter::init(void);

1184 12 get_filename 0 4 2003 23 BamWriter::get_filename 0 1 194 197
/**
 * If a BAM is a file, then the BamWriter should contain the name of the file.
 * This enables the writer to convert pathnames in the BAM to relative to the
 * directory containing the BAM.
 */
59
inline Filename const &BamWriter::get_filename(void) const;

1185 12 write_object 0 4 2003 23 BamWriter::write_object 0 1 195 736
/**
 * Writes a single object to the Bam file, so that the
 * BamReader::read_object() can later correctly restore the object and all its
 * pointers.
 *
 * This implicitly also writes any additional objects this object references
 * (if they haven't already been written), so that pointers may be fully
 * resolved.
 *
 * This may be called repeatedly to write a sequence of objects to the Bam
 * file, but typically (especially for scene graph files, indicated with the
 * .bam extension), only one object is written directly from the Bam file: the
 * root of the scene graph.  The remaining objects will all be written
 * recursively by the first object.
 *
 * Returns true if the object is successfully written, false otherwise.
 */
55
bool BamWriter::write_object(TypedWritable const *obj);

1186 10 has_object 0 4 2003 21 BamWriter::has_object 0 1 196 170
/**
 * Returns true if the object has previously been written (or at least
 * requested to be written) to the bam file, or false if we've never heard of
 * it before.
 */
59
bool BamWriter::has_object(TypedWritable const *obj) const;

1187 5 flush 0 4 2003 16 BamWriter::flush 0 1 197 85
/**
 * Ensures that all data written thus far is manifested on the output stream.
 */
28
void BamWriter::flush(void);

1188 18 get_file_major_ver 0 4 2003 29 BamWriter::get_file_major_ver 0 1 198 84
/**
 * Returns the major version number of the Bam file currently being written.
 */
53
inline int BamWriter::get_file_major_ver(void) const;

1189 18 get_file_minor_ver 0 4 2003 29 BamWriter::get_file_minor_ver 0 1 199 84
/**
 * Returns the minor version number of the Bam file currently being written.
 */
53
inline int BamWriter::get_file_minor_ver(void) const;

1190 18 set_file_minor_ver 0 4 2003 29 BamWriter::set_file_minor_ver 0 1 200 232
/**
 * Changes the minor .bam version to write.  This should be called before
 * init().  Each Panda version has only a fairly narrow range of versions it
 * is able to write; consult the .bam documentation for more information.
 */
57
inline void BamWriter::set_file_minor_ver(int minor_ver);

1191 15 get_file_endian 0 4 2003 26 BamWriter::get_file_endian 0 1 201 257
/**
 * Returns the endian preference indicated by the Bam file currently being
 * written.  This does not imply that every number is stored using the
 * indicated convention, but individual objects may choose to respect this
 * flag when recording data.
 */
66
inline BamEnums::BamEndian BamWriter::get_file_endian(void) const;

1192 24 get_file_stdfloat_double 0 4 2003 35 BamWriter::get_file_stdfloat_double 0 1 202 248
/**
 * Returns true if the file will store all "standard" floats as 64-bit
 * doubles, or false if they are 32-bit floats.  This isn't runtime settable;
 * it's based on the compilation flags of the version of Panda that generated
 * this file.
 */
60
inline bool BamWriter::get_file_stdfloat_double(void) const;

1193 21 get_file_texture_mode 0 4 2003 32 BamWriter::get_file_texture_mode 0 1 203 196
/**
 * Returns the BamTextureMode preference indicated by the Bam file currently
 * being written.  Texture objects written to this Bam file will be encoded
 * according to the specified mode.
 */
77
inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const;

1194 21 set_file_texture_mode 0 4 2003 32 BamWriter::set_file_texture_mode 0 1 204 187
/**
 * Changes the BamTextureMode preference for the Bam file currently being
 * written.  Texture objects written to this Bam file will be encoded
 * according to the specified mode.
 */
89
inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode);

1195 13 get_root_node 0 4 2003 24 BamWriter::get_root_node 0 1 205 165
/**
 * Returns the root node of the part of the scene graph we are currently
 * writing out.  This is used for determining what to make NodePaths relative
 * to.
 */
59
inline TypedWritable *BamWriter::get_root_node(void) const;

1196 13 set_root_node 0 4 2003 24 BamWriter::set_root_node 0 1 206 160
/**
 * Sets the root node of the part of the scene graph we are currently writing
 * out.  NodePaths written to this bam file will be relative to this node.
 */
63
inline void BamWriter::set_root_node(TypedWritable *root_node);

1197 16 get_file_version 0 4 2003 27 BamWriter::get_file_version 0 0 0
50
PyObject *BamWriter::get_file_version(void) const;

1198 7 BitMask 0 260 2006 32 BitMask< uint16_t, 16 >::BitMask 0 3 207 208 209 0
215
constexpr BitMask< uint16_t, 16 >::BitMask(void) = default;
inline constexpr BitMask< uint16_t, 16 >::BitMask(uint16_t init_value);
inline BitMask< uint16_t, 16 >::BitMask(BitMask< uint16_t, 16 > const &) = default;

1199 6 all_on 0 4 2006 31 BitMask< uint16_t, 16 >::all_on 0 1 210 0
76
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_on(void);

1200 7 all_off 0 4 2006 32 BitMask< uint16_t, 16 >::all_off 0 1 211 0
77
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_off(void);

1201 8 lower_on 0 4 2006 33 BitMask< uint16_t, 16 >::lower_on 0 1 212 0
85
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::lower_on(int on_bits);

1202 3 bit 0 4 2006 28 BitMask< uint16_t, 16 >::bit 0 1 213 0
78
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::bit(int index);

1203 5 range 0 4 2006 30 BitMask< uint16_t, 16 >::range 0 1 214 0
92
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::range(int low_bit, int size);

1204 16 has_max_num_bits 0 4 2006 41 BitMask< uint16_t, 16 >::has_max_num_bits 0 1 215 0
70
static constexpr bool BitMask< uint16_t, 16 >::has_max_num_bits(void);

1205 16 get_max_num_bits 0 4 2006 41 BitMask< uint16_t, 16 >::get_max_num_bits 0 1 216 0
69
static constexpr int BitMask< uint16_t, 16 >::get_max_num_bits(void);

1206 12 get_num_bits 0 4 2006 37 BitMask< uint16_t, 16 >::get_num_bits 0 1 217 0
64
constexpr int BitMask< uint16_t, 16 >::get_num_bits(void) const;

1207 7 get_bit 0 4 2006 32 BitMask< uint16_t, 16 >::get_bit 0 1 218 0
62
inline bool BitMask< uint16_t, 16 >::get_bit(int index) const;

1208 7 set_bit 0 4 2006 32 BitMask< uint16_t, 16 >::set_bit 0 1 219 0
56
inline void BitMask< uint16_t, 16 >::set_bit(int index);

1209 9 clear_bit 0 4 2006 34 BitMask< uint16_t, 16 >::clear_bit 0 1 220 0
58
inline void BitMask< uint16_t, 16 >::clear_bit(int index);

1210 10 set_bit_to 0 4 2006 35 BitMask< uint16_t, 16 >::set_bit_to 0 1 221 0
71
inline void BitMask< uint16_t, 16 >::set_bit_to(int index, bool value);

1211 7 is_zero 0 4 2006 32 BitMask< uint16_t, 16 >::is_zero 0 1 222 0
57
inline bool BitMask< uint16_t, 16 >::is_zero(void) const;

1212 9 is_all_on 0 4 2006 34 BitMask< uint16_t, 16 >::is_all_on 0 1 223 0
59
inline bool BitMask< uint16_t, 16 >::is_all_on(void) const;

1213 7 extract 0 4 2006 32 BitMask< uint16_t, 16 >::extract 0 1 224 0
78
inline uint16_t BitMask< uint16_t, 16 >::extract(int low_bit, int size) const;

1214 5 store 0 4 2006 30 BitMask< uint16_t, 16 >::store 0 1 225 0
82
inline void BitMask< uint16_t, 16 >::store(uint16_t value, int low_bit, int size);

1215 10 has_any_of 0 4 2006 35 BitMask< uint16_t, 16 >::has_any_of 0 1 226 0
77
inline bool BitMask< uint16_t, 16 >::has_any_of(int low_bit, int size) const;

1216 10 has_all_of 0 4 2006 35 BitMask< uint16_t, 16 >::has_all_of 0 1 227 0
77
inline bool BitMask< uint16_t, 16 >::has_all_of(int low_bit, int size) const;

1217 9 set_range 0 4 2006 34 BitMask< uint16_t, 16 >::set_range 0 1 228 0
70
inline void BitMask< uint16_t, 16 >::set_range(int low_bit, int size);

1218 11 clear_range 0 4 2006 36 BitMask< uint16_t, 16 >::clear_range 0 1 229 0
72
inline void BitMask< uint16_t, 16 >::clear_range(int low_bit, int size);

1219 12 set_range_to 0 4 2006 37 BitMask< uint16_t, 16 >::set_range_to 0 1 230 0
85
inline void BitMask< uint16_t, 16 >::set_range_to(bool value, int low_bit, int size);

1220 8 get_word 0 4 2006 33 BitMask< uint16_t, 16 >::get_word 0 1 231 0
62
inline uint16_t BitMask< uint16_t, 16 >::get_word(void) const;

1221 8 set_word 0 4 2006 33 BitMask< uint16_t, 16 >::set_word 0 1 232 0
62
inline void BitMask< uint16_t, 16 >::set_word(uint16_t value);

1222 15 get_num_on_bits 0 4 2006 40 BitMask< uint16_t, 16 >::get_num_on_bits 0 1 233 0
64
inline int BitMask< uint16_t, 16 >::get_num_on_bits(void) const;

1223 16 get_num_off_bits 0 4 2006 41 BitMask< uint16_t, 16 >::get_num_off_bits 0 1 234 0
65
inline int BitMask< uint16_t, 16 >::get_num_off_bits(void) const;

1224 17 get_lowest_on_bit 0 4 2006 42 BitMask< uint16_t, 16 >::get_lowest_on_bit 0 1 235 0
66
inline int BitMask< uint16_t, 16 >::get_lowest_on_bit(void) const;

1225 18 get_lowest_off_bit 0 4 2006 43 BitMask< uint16_t, 16 >::get_lowest_off_bit 0 1 236 0
67
inline int BitMask< uint16_t, 16 >::get_lowest_off_bit(void) const;

1226 18 get_highest_on_bit 0 4 2006 43 BitMask< uint16_t, 16 >::get_highest_on_bit 0 1 237 0
67
inline int BitMask< uint16_t, 16 >::get_highest_on_bit(void) const;

1227 19 get_highest_off_bit 0 4 2006 44 BitMask< uint16_t, 16 >::get_highest_off_bit 0 1 238 0
68
inline int BitMask< uint16_t, 16 >::get_highest_off_bit(void) const;

1228 29 get_next_higher_different_bit 0 4 2006 54 BitMask< uint16_t, 16 >::get_next_higher_different_bit 0 1 239 0
85
inline int BitMask< uint16_t, 16 >::get_next_higher_different_bit(int low_bit) const;

1229 15 invert_in_place 0 4 2006 40 BitMask< uint16_t, 16 >::invert_in_place 0 1 240 0
59
inline void BitMask< uint16_t, 16 >::invert_in_place(void);

1230 18 has_bits_in_common 0 4 2006 43 BitMask< uint16_t, 16 >::has_bits_in_common 0 1 241 0
100
inline bool BitMask< uint16_t, 16 >::has_bits_in_common(BitMask< uint16_t, 16 > const &other) const;

1231 5 clear 0 4 2006 30 BitMask< uint16_t, 16 >::clear 0 1 242 0
49
inline void BitMask< uint16_t, 16 >::clear(void);

1232 6 output 0 4 2006 31 BitMask< uint16_t, 16 >::output 0 1 243 0
62
void BitMask< uint16_t, 16 >::output(std::ostream &out) const;

1233 13 output_binary 0 4 2006 38 BitMask< uint16_t, 16 >::output_binary 0 1 244 0
91
void BitMask< uint16_t, 16 >::output_binary(std::ostream &out, int spaces_every = 4) const;

1234 10 output_hex 0 4 2006 35 BitMask< uint16_t, 16 >::output_hex 0 1 245 0
88
void BitMask< uint16_t, 16 >::output_hex(std::ostream &out, int spaces_every = 4) const;

1235 5 write 0 4 2006 30 BitMask< uint16_t, 16 >::write 0 1 246 0
83
void BitMask< uint16_t, 16 >::write(std::ostream &out, int indent_level = 0) const;

1236 11 operator == 0 4 2006 36 BitMask< uint16_t, 16 >::operator == 0 1 247 0
93
inline bool BitMask< uint16_t, 16 >::operator ==(BitMask< uint16_t, 16 > const &other) const;

1237 11 operator != 0 4 2006 36 BitMask< uint16_t, 16 >::operator != 0 1 248 0
93
inline bool BitMask< uint16_t, 16 >::operator !=(BitMask< uint16_t, 16 > const &other) const;

1238 10 operator < 0 4 2006 35 BitMask< uint16_t, 16 >::operator < 0 1 249 0
92
inline bool BitMask< uint16_t, 16 >::operator <(BitMask< uint16_t, 16 > const &other) const;

1239 10 compare_to 0 4 2006 35 BitMask< uint16_t, 16 >::compare_to 0 1 250 0
91
inline int BitMask< uint16_t, 16 >::compare_to(BitMask< uint16_t, 16 > const &other) const;

1240 10 operator & 0 4 2006 35 BitMask< uint16_t, 16 >::operator & 0 1 251 0
111
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator &(BitMask< uint16_t, 16 > const &other) const;

1241 10 operator | 0 4 2006 35 BitMask< uint16_t, 16 >::operator | 0 1 252 0
111
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator |(BitMask< uint16_t, 16 > const &other) const;

1242 10 operator ^ 0 4 2006 35 BitMask< uint16_t, 16 >::operator ^ 0 1 253 0
111
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator ^(BitMask< uint16_t, 16 > const &other) const;

1243 10 operator ~ 0 68 2006 35 BitMask< uint16_t, 16 >::operator ~ 0 1 254 0
79
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator ~(void) const;

1244 11 operator << 0 4 2006 36 BitMask< uint16_t, 16 >::operator << 0 1 255 0
85
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator <<(int shift) const;

1245 11 operator >> 0 4 2006 36 BitMask< uint16_t, 16 >::operator >> 0 1 256 0
85
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator >>(int shift) const;

1246 11 operator &= 0 4 2006 36 BitMask< uint16_t, 16 >::operator &= 0 1 257 0
87
inline void BitMask< uint16_t, 16 >::operator &=(BitMask< uint16_t, 16 > const &other);

1247 11 operator |= 0 4 2006 36 BitMask< uint16_t, 16 >::operator |= 0 1 258 0
87
inline void BitMask< uint16_t, 16 >::operator |=(BitMask< uint16_t, 16 > const &other);

1248 11 operator ^= 0 4 2006 36 BitMask< uint16_t, 16 >::operator ^= 0 1 259 0
87
inline void BitMask< uint16_t, 16 >::operator ^=(BitMask< uint16_t, 16 > const &other);

1249 12 operator <<= 0 4 2006 37 BitMask< uint16_t, 16 >::operator <<= 0 1 260 0
61
inline void BitMask< uint16_t, 16 >::operator <<=(int shift);

1250 12 operator >>= 0 4 2006 37 BitMask< uint16_t, 16 >::operator >>= 0 1 261 0
61
inline void BitMask< uint16_t, 16 >::operator >>=(int shift);

1251 19 flood_down_in_place 0 4 2006 44 BitMask< uint16_t, 16 >::flood_down_in_place 0 1 262 0
63
inline void BitMask< uint16_t, 16 >::flood_down_in_place(void);

1252 17 flood_up_in_place 0 4 2006 42 BitMask< uint16_t, 16 >::flood_up_in_place 0 1 263 0
61
inline void BitMask< uint16_t, 16 >::flood_up_in_place(void);

1253 15 flood_bits_down 0 4 2006 40 BitMask< uint16_t, 16 >::flood_bits_down 0 1 264 0
84
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_down(void) const;

1254 13 flood_bits_up 0 4 2006 38 BitMask< uint16_t, 16 >::flood_bits_up 0 1 265 0
82
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_up(void) const;

1255 21 keep_next_highest_bit 0 4 2006 46 BitMask< uint16_t, 16 >::keep_next_highest_bit 0 3 266 267 268 0
309
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(void) const;
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(int index) const;
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(BitMask< uint16_t, 16 > const &other) const;

1256 20 keep_next_lowest_bit 0 4 2006 45 BitMask< uint16_t, 16 >::keep_next_lowest_bit 0 3 269 270 271 0
306
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(void) const;
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(int index) const;
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(BitMask< uint16_t, 16 > const &other) const;

1257 7 get_key 0 4 2006 32 BitMask< uint16_t, 16 >::get_key 0 1 272 0
56
inline int BitMask< uint16_t, 16 >::get_key(void) const;

1258 8 __bool__ 0 4 2006 33 BitMask< uint16_t, 16 >::__bool__ 0 1 273 0
51
bool BitMask< uint16_t, 16 >::__bool__(void) const;

1259 7 __int__ 0 4 2006 32 BitMask< uint16_t, 16 >::__int__ 0 1 274 0
55
PyObject *BitMask< uint16_t, 16 >::__int__(void) const;

1260 10 __reduce__ 0 4 2006 35 BitMask< uint16_t, 16 >::__reduce__ 0 1 275 0
68
PyObject *BitMask< uint16_t, 16 >::__reduce__(PyObject *self) const;

1261 14 get_class_type 0 4 2006 39 BitMask< uint16_t, 16 >::get_class_type 0 1 276 0
64
static TypeHandle BitMask< uint16_t, 16 >::get_class_type(void);

1262 8 ~BitMask 0 516 2006 33 BitMask< uint16_t, 16 >::~BitMask 0 0 0
40
BitMask< uint16_t, 16 >::~BitMask(void);

1263 7 BitMask 0 260 2008 32 BitMask< uint32_t, 32 >::BitMask 0 3 277 278 279 0
215
constexpr BitMask< uint32_t, 32 >::BitMask(void) = default;
inline constexpr BitMask< uint32_t, 32 >::BitMask(uint32_t init_value);
inline BitMask< uint32_t, 32 >::BitMask(BitMask< uint32_t, 32 > const &) = default;

1264 6 all_on 0 4 2008 31 BitMask< uint32_t, 32 >::all_on 0 1 280 0
76
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_on(void);

1265 7 all_off 0 4 2008 32 BitMask< uint32_t, 32 >::all_off 0 1 281 0
77
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_off(void);

1266 8 lower_on 0 4 2008 33 BitMask< uint32_t, 32 >::lower_on 0 1 282 0
85
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::lower_on(int on_bits);

1267 3 bit 0 4 2008 28 BitMask< uint32_t, 32 >::bit 0 1 283 0
78
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::bit(int index);

1268 5 range 0 4 2008 30 BitMask< uint32_t, 32 >::range 0 1 284 0
92
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::range(int low_bit, int size);

1269 16 has_max_num_bits 0 4 2008 41 BitMask< uint32_t, 32 >::has_max_num_bits 0 1 285 0
70
static constexpr bool BitMask< uint32_t, 32 >::has_max_num_bits(void);

1270 16 get_max_num_bits 0 4 2008 41 BitMask< uint32_t, 32 >::get_max_num_bits 0 1 286 0
69
static constexpr int BitMask< uint32_t, 32 >::get_max_num_bits(void);

1271 12 get_num_bits 0 4 2008 37 BitMask< uint32_t, 32 >::get_num_bits 0 1 287 0
64
constexpr int BitMask< uint32_t, 32 >::get_num_bits(void) const;

1272 7 get_bit 0 4 2008 32 BitMask< uint32_t, 32 >::get_bit 0 1 288 0
62
inline bool BitMask< uint32_t, 32 >::get_bit(int index) const;

1273 7 set_bit 0 4 2008 32 BitMask< uint32_t, 32 >::set_bit 0 1 289 0
56
inline void BitMask< uint32_t, 32 >::set_bit(int index);

1274 9 clear_bit 0 4 2008 34 BitMask< uint32_t, 32 >::clear_bit 0 1 290 0
58
inline void BitMask< uint32_t, 32 >::clear_bit(int index);

1275 10 set_bit_to 0 4 2008 35 BitMask< uint32_t, 32 >::set_bit_to 0 1 291 0
71
inline void BitMask< uint32_t, 32 >::set_bit_to(int index, bool value);

1276 7 is_zero 0 4 2008 32 BitMask< uint32_t, 32 >::is_zero 0 1 292 0
57
inline bool BitMask< uint32_t, 32 >::is_zero(void) const;

1277 9 is_all_on 0 4 2008 34 BitMask< uint32_t, 32 >::is_all_on 0 1 293 0
59
inline bool BitMask< uint32_t, 32 >::is_all_on(void) const;

1278 7 extract 0 4 2008 32 BitMask< uint32_t, 32 >::extract 0 1 294 0
78
inline uint32_t BitMask< uint32_t, 32 >::extract(int low_bit, int size) const;

1279 5 store 0 4 2008 30 BitMask< uint32_t, 32 >::store 0 1 295 0
82
inline void BitMask< uint32_t, 32 >::store(uint32_t value, int low_bit, int size);

1280 10 has_any_of 0 4 2008 35 BitMask< uint32_t, 32 >::has_any_of 0 1 296 0
77
inline bool BitMask< uint32_t, 32 >::has_any_of(int low_bit, int size) const;

1281 10 has_all_of 0 4 2008 35 BitMask< uint32_t, 32 >::has_all_of 0 1 297 0
77
inline bool BitMask< uint32_t, 32 >::has_all_of(int low_bit, int size) const;

1282 9 set_range 0 4 2008 34 BitMask< uint32_t, 32 >::set_range 0 1 298 0
70
inline void BitMask< uint32_t, 32 >::set_range(int low_bit, int size);

1283 11 clear_range 0 4 2008 36 BitMask< uint32_t, 32 >::clear_range 0 1 299 0
72
inline void BitMask< uint32_t, 32 >::clear_range(int low_bit, int size);

1284 12 set_range_to 0 4 2008 37 BitMask< uint32_t, 32 >::set_range_to 0 1 300 0
85
inline void BitMask< uint32_t, 32 >::set_range_to(bool value, int low_bit, int size);

1285 8 get_word 0 4 2008 33 BitMask< uint32_t, 32 >::get_word 0 1 301 0
62
inline uint32_t BitMask< uint32_t, 32 >::get_word(void) const;

1286 8 set_word 0 4 2008 33 BitMask< uint32_t, 32 >::set_word 0 1 302 0
62
inline void BitMask< uint32_t, 32 >::set_word(uint32_t value);

1287 15 get_num_on_bits 0 4 2008 40 BitMask< uint32_t, 32 >::get_num_on_bits 0 1 303 0
64
inline int BitMask< uint32_t, 32 >::get_num_on_bits(void) const;

1288 16 get_num_off_bits 0 4 2008 41 BitMask< uint32_t, 32 >::get_num_off_bits 0 1 304 0
65
inline int BitMask< uint32_t, 32 >::get_num_off_bits(void) const;

1289 17 get_lowest_on_bit 0 4 2008 42 BitMask< uint32_t, 32 >::get_lowest_on_bit 0 1 305 0
66
inline int BitMask< uint32_t, 32 >::get_lowest_on_bit(void) const;

1290 18 get_lowest_off_bit 0 4 2008 43 BitMask< uint32_t, 32 >::get_lowest_off_bit 0 1 306 0
67
inline int BitMask< uint32_t, 32 >::get_lowest_off_bit(void) const;

1291 18 get_highest_on_bit 0 4 2008 43 BitMask< uint32_t, 32 >::get_highest_on_bit 0 1 307 0
67
inline int BitMask< uint32_t, 32 >::get_highest_on_bit(void) const;

1292 19 get_highest_off_bit 0 4 2008 44 BitMask< uint32_t, 32 >::get_highest_off_bit 0 1 308 0
68
inline int BitMask< uint32_t, 32 >::get_highest_off_bit(void) const;

1293 29 get_next_higher_different_bit 0 4 2008 54 BitMask< uint32_t, 32 >::get_next_higher_different_bit 0 1 309 0
85
inline int BitMask< uint32_t, 32 >::get_next_higher_different_bit(int low_bit) const;

1294 15 invert_in_place 0 4 2008 40 BitMask< uint32_t, 32 >::invert_in_place 0 1 310 0
59
inline void BitMask< uint32_t, 32 >::invert_in_place(void);

1295 18 has_bits_in_common 0 4 2008 43 BitMask< uint32_t, 32 >::has_bits_in_common 0 1 311 0
100
inline bool BitMask< uint32_t, 32 >::has_bits_in_common(BitMask< uint32_t, 32 > const &other) const;

1296 5 clear 0 4 2008 30 BitMask< uint32_t, 32 >::clear 0 1 312 0
49
inline void BitMask< uint32_t, 32 >::clear(void);

1297 6 output 0 4 2008 31 BitMask< uint32_t, 32 >::output 0 1 313 0
62
void BitMask< uint32_t, 32 >::output(std::ostream &out) const;

1298 13 output_binary 0 4 2008 38 BitMask< uint32_t, 32 >::output_binary 0 1 314 0
91
void BitMask< uint32_t, 32 >::output_binary(std::ostream &out, int spaces_every = 4) const;

1299 10 output_hex 0 4 2008 35 BitMask< uint32_t, 32 >::output_hex 0 1 315 0
88
void BitMask< uint32_t, 32 >::output_hex(std::ostream &out, int spaces_every = 4) const;

1300 5 write 0 4 2008 30 BitMask< uint32_t, 32 >::write 0 1 316 0
83
void BitMask< uint32_t, 32 >::write(std::ostream &out, int indent_level = 0) const;

1301 11 operator == 0 4 2008 36 BitMask< uint32_t, 32 >::operator == 0 1 317 0
93
inline bool BitMask< uint32_t, 32 >::operator ==(BitMask< uint32_t, 32 > const &other) const;

1302 11 operator != 0 4 2008 36 BitMask< uint32_t, 32 >::operator != 0 1 318 0
93
inline bool BitMask< uint32_t, 32 >::operator !=(BitMask< uint32_t, 32 > const &other) const;

1303 10 operator < 0 4 2008 35 BitMask< uint32_t, 32 >::operator < 0 1 319 0
92
inline bool BitMask< uint32_t, 32 >::operator <(BitMask< uint32_t, 32 > const &other) const;

1304 10 compare_to 0 4 2008 35 BitMask< uint32_t, 32 >::compare_to 0 1 320 0
91
inline int BitMask< uint32_t, 32 >::compare_to(BitMask< uint32_t, 32 > const &other) const;

1305 10 operator & 0 4 2008 35 BitMask< uint32_t, 32 >::operator & 0 1 321 0
111
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator &(BitMask< uint32_t, 32 > const &other) const;

1306 10 operator | 0 4 2008 35 BitMask< uint32_t, 32 >::operator | 0 1 322 0
111
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator |(BitMask< uint32_t, 32 > const &other) const;

1307 10 operator ^ 0 4 2008 35 BitMask< uint32_t, 32 >::operator ^ 0 1 323 0
111
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator ^(BitMask< uint32_t, 32 > const &other) const;

1308 10 operator ~ 0 68 2008 35 BitMask< uint32_t, 32 >::operator ~ 0 1 324 0
79
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator ~(void) const;

1309 11 operator << 0 4 2008 36 BitMask< uint32_t, 32 >::operator << 0 1 325 0
85
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator <<(int shift) const;

1310 11 operator >> 0 4 2008 36 BitMask< uint32_t, 32 >::operator >> 0 1 326 0
85
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator >>(int shift) const;

1311 11 operator &= 0 4 2008 36 BitMask< uint32_t, 32 >::operator &= 0 1 327 0
87
inline void BitMask< uint32_t, 32 >::operator &=(BitMask< uint32_t, 32 > const &other);

1312 11 operator |= 0 4 2008 36 BitMask< uint32_t, 32 >::operator |= 0 1 328 0
87
inline void BitMask< uint32_t, 32 >::operator |=(BitMask< uint32_t, 32 > const &other);

1313 11 operator ^= 0 4 2008 36 BitMask< uint32_t, 32 >::operator ^= 0 1 329 0
87
inline void BitMask< uint32_t, 32 >::operator ^=(BitMask< uint32_t, 32 > const &other);

1314 12 operator <<= 0 4 2008 37 BitMask< uint32_t, 32 >::operator <<= 0 1 330 0
61
inline void BitMask< uint32_t, 32 >::operator <<=(int shift);

1315 12 operator >>= 0 4 2008 37 BitMask< uint32_t, 32 >::operator >>= 0 1 331 0
61
inline void BitMask< uint32_t, 32 >::operator >>=(int shift);

1316 19 flood_down_in_place 0 4 2008 44 BitMask< uint32_t, 32 >::flood_down_in_place 0 1 332 0
63
inline void BitMask< uint32_t, 32 >::flood_down_in_place(void);

1317 17 flood_up_in_place 0 4 2008 42 BitMask< uint32_t, 32 >::flood_up_in_place 0 1 333 0
61
inline void BitMask< uint32_t, 32 >::flood_up_in_place(void);

1318 15 flood_bits_down 0 4 2008 40 BitMask< uint32_t, 32 >::flood_bits_down 0 1 334 0
84
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_down(void) const;

1319 13 flood_bits_up 0 4 2008 38 BitMask< uint32_t, 32 >::flood_bits_up 0 1 335 0
82
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_up(void) const;

1320 21 keep_next_highest_bit 0 4 2008 46 BitMask< uint32_t, 32 >::keep_next_highest_bit 0 3 336 337 338 0
309
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(void) const;
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(int index) const;
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(BitMask< uint32_t, 32 > const &other) const;

1321 20 keep_next_lowest_bit 0 4 2008 45 BitMask< uint32_t, 32 >::keep_next_lowest_bit 0 3 339 340 341 0
306
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(void) const;
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(int index) const;
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(BitMask< uint32_t, 32 > const &other) const;

1322 7 get_key 0 4 2008 32 BitMask< uint32_t, 32 >::get_key 0 1 342 0
56
inline int BitMask< uint32_t, 32 >::get_key(void) const;

1323 8 __bool__ 0 4 2008 33 BitMask< uint32_t, 32 >::__bool__ 0 1 343 0
51
bool BitMask< uint32_t, 32 >::__bool__(void) const;

1324 7 __int__ 0 4 2008 32 BitMask< uint32_t, 32 >::__int__ 0 1 344 0
55
PyObject *BitMask< uint32_t, 32 >::__int__(void) const;

1325 10 __reduce__ 0 4 2008 35 BitMask< uint32_t, 32 >::__reduce__ 0 1 345 0
68
PyObject *BitMask< uint32_t, 32 >::__reduce__(PyObject *self) const;

1326 14 get_class_type 0 4 2008 39 BitMask< uint32_t, 32 >::get_class_type 0 1 346 0
64
static TypeHandle BitMask< uint32_t, 32 >::get_class_type(void);

1327 8 ~BitMask 0 516 2008 33 BitMask< uint32_t, 32 >::~BitMask 0 0 0
40
BitMask< uint32_t, 32 >::~BitMask(void);

1328 7 BitMask 0 260 2010 32 BitMask< uint64_t, 64 >::BitMask 0 3 347 348 349 0
215
constexpr BitMask< uint64_t, 64 >::BitMask(void) = default;
inline constexpr BitMask< uint64_t, 64 >::BitMask(uint64_t init_value);
inline BitMask< uint64_t, 64 >::BitMask(BitMask< uint64_t, 64 > const &) = default;

1329 6 all_on 0 4 2010 31 BitMask< uint64_t, 64 >::all_on 0 1 350 0
76
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_on(void);

1330 7 all_off 0 4 2010 32 BitMask< uint64_t, 64 >::all_off 0 1 351 0
77
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_off(void);

1331 8 lower_on 0 4 2010 33 BitMask< uint64_t, 64 >::lower_on 0 1 352 0
85
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::lower_on(int on_bits);

1332 3 bit 0 4 2010 28 BitMask< uint64_t, 64 >::bit 0 1 353 0
78
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::bit(int index);

1333 5 range 0 4 2010 30 BitMask< uint64_t, 64 >::range 0 1 354 0
92
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::range(int low_bit, int size);

1334 16 has_max_num_bits 0 4 2010 41 BitMask< uint64_t, 64 >::has_max_num_bits 0 1 355 0
70
static constexpr bool BitMask< uint64_t, 64 >::has_max_num_bits(void);

1335 16 get_max_num_bits 0 4 2010 41 BitMask< uint64_t, 64 >::get_max_num_bits 0 1 356 0
69
static constexpr int BitMask< uint64_t, 64 >::get_max_num_bits(void);

1336 12 get_num_bits 0 4 2010 37 BitMask< uint64_t, 64 >::get_num_bits 0 1 357 0
64
constexpr int BitMask< uint64_t, 64 >::get_num_bits(void) const;

1337 7 get_bit 0 4 2010 32 BitMask< uint64_t, 64 >::get_bit 0 1 358 0
62
inline bool BitMask< uint64_t, 64 >::get_bit(int index) const;

1338 7 set_bit 0 4 2010 32 BitMask< uint64_t, 64 >::set_bit 0 1 359 0
56
inline void BitMask< uint64_t, 64 >::set_bit(int index);

1339 9 clear_bit 0 4 2010 34 BitMask< uint64_t, 64 >::clear_bit 0 1 360 0
58
inline void BitMask< uint64_t, 64 >::clear_bit(int index);

1340 10 set_bit_to 0 4 2010 35 BitMask< uint64_t, 64 >::set_bit_to 0 1 361 0
71
inline void BitMask< uint64_t, 64 >::set_bit_to(int index, bool value);

1341 7 is_zero 0 4 2010 32 BitMask< uint64_t, 64 >::is_zero 0 1 362 0
57
inline bool BitMask< uint64_t, 64 >::is_zero(void) const;

1342 9 is_all_on 0 4 2010 34 BitMask< uint64_t, 64 >::is_all_on 0 1 363 0
59
inline bool BitMask< uint64_t, 64 >::is_all_on(void) const;

1343 7 extract 0 4 2010 32 BitMask< uint64_t, 64 >::extract 0 1 364 0
78
inline uint64_t BitMask< uint64_t, 64 >::extract(int low_bit, int size) const;

1344 5 store 0 4 2010 30 BitMask< uint64_t, 64 >::store 0 1 365 0
82
inline void BitMask< uint64_t, 64 >::store(uint64_t value, int low_bit, int size);

1345 10 has_any_of 0 4 2010 35 BitMask< uint64_t, 64 >::has_any_of 0 1 366 0
77
inline bool BitMask< uint64_t, 64 >::has_any_of(int low_bit, int size) const;

1346 10 has_all_of 0 4 2010 35 BitMask< uint64_t, 64 >::has_all_of 0 1 367 0
77
inline bool BitMask< uint64_t, 64 >::has_all_of(int low_bit, int size) const;

1347 9 set_range 0 4 2010 34 BitMask< uint64_t, 64 >::set_range 0 1 368 0
70
inline void BitMask< uint64_t, 64 >::set_range(int low_bit, int size);

1348 11 clear_range 0 4 2010 36 BitMask< uint64_t, 64 >::clear_range 0 1 369 0
72
inline void BitMask< uint64_t, 64 >::clear_range(int low_bit, int size);

1349 12 set_range_to 0 4 2010 37 BitMask< uint64_t, 64 >::set_range_to 0 1 370 0
85
inline void BitMask< uint64_t, 64 >::set_range_to(bool value, int low_bit, int size);

1350 8 get_word 0 4 2010 33 BitMask< uint64_t, 64 >::get_word 0 1 371 0
62
inline uint64_t BitMask< uint64_t, 64 >::get_word(void) const;

1351 8 set_word 0 4 2010 33 BitMask< uint64_t, 64 >::set_word 0 1 372 0
62
inline void BitMask< uint64_t, 64 >::set_word(uint64_t value);

1352 15 get_num_on_bits 0 4 2010 40 BitMask< uint64_t, 64 >::get_num_on_bits 0 1 373 0
64
inline int BitMask< uint64_t, 64 >::get_num_on_bits(void) const;

1353 16 get_num_off_bits 0 4 2010 41 BitMask< uint64_t, 64 >::get_num_off_bits 0 1 374 0
65
inline int BitMask< uint64_t, 64 >::get_num_off_bits(void) const;

1354 17 get_lowest_on_bit 0 4 2010 42 BitMask< uint64_t, 64 >::get_lowest_on_bit 0 1 375 0
66
inline int BitMask< uint64_t, 64 >::get_lowest_on_bit(void) const;

1355 18 get_lowest_off_bit 0 4 2010 43 BitMask< uint64_t, 64 >::get_lowest_off_bit 0 1 376 0
67
inline int BitMask< uint64_t, 64 >::get_lowest_off_bit(void) const;

1356 18 get_highest_on_bit 0 4 2010 43 BitMask< uint64_t, 64 >::get_highest_on_bit 0 1 377 0
67
inline int BitMask< uint64_t, 64 >::get_highest_on_bit(void) const;

1357 19 get_highest_off_bit 0 4 2010 44 BitMask< uint64_t, 64 >::get_highest_off_bit 0 1 378 0
68
inline int BitMask< uint64_t, 64 >::get_highest_off_bit(void) const;

1358 29 get_next_higher_different_bit 0 4 2010 54 BitMask< uint64_t, 64 >::get_next_higher_different_bit 0 1 379 0
85
inline int BitMask< uint64_t, 64 >::get_next_higher_different_bit(int low_bit) const;

1359 15 invert_in_place 0 4 2010 40 BitMask< uint64_t, 64 >::invert_in_place 0 1 380 0
59
inline void BitMask< uint64_t, 64 >::invert_in_place(void);

1360 18 has_bits_in_common 0 4 2010 43 BitMask< uint64_t, 64 >::has_bits_in_common 0 1 381 0
100
inline bool BitMask< uint64_t, 64 >::has_bits_in_common(BitMask< uint64_t, 64 > const &other) const;

1361 5 clear 0 4 2010 30 BitMask< uint64_t, 64 >::clear 0 1 382 0
49
inline void BitMask< uint64_t, 64 >::clear(void);

1362 6 output 0 4 2010 31 BitMask< uint64_t, 64 >::output 0 1 383 0
62
void BitMask< uint64_t, 64 >::output(std::ostream &out) const;

1363 13 output_binary 0 4 2010 38 BitMask< uint64_t, 64 >::output_binary 0 1 384 0
91
void BitMask< uint64_t, 64 >::output_binary(std::ostream &out, int spaces_every = 4) const;

1364 10 output_hex 0 4 2010 35 BitMask< uint64_t, 64 >::output_hex 0 1 385 0
88
void BitMask< uint64_t, 64 >::output_hex(std::ostream &out, int spaces_every = 4) const;

1365 5 write 0 4 2010 30 BitMask< uint64_t, 64 >::write 0 1 386 0
83
void BitMask< uint64_t, 64 >::write(std::ostream &out, int indent_level = 0) const;

1366 11 operator == 0 4 2010 36 BitMask< uint64_t, 64 >::operator == 0 1 387 0
93
inline bool BitMask< uint64_t, 64 >::operator ==(BitMask< uint64_t, 64 > const &other) const;

1367 11 operator != 0 4 2010 36 BitMask< uint64_t, 64 >::operator != 0 1 388 0
93
inline bool BitMask< uint64_t, 64 >::operator !=(BitMask< uint64_t, 64 > const &other) const;

1368 10 operator < 0 4 2010 35 BitMask< uint64_t, 64 >::operator < 0 1 389 0
92
inline bool BitMask< uint64_t, 64 >::operator <(BitMask< uint64_t, 64 > const &other) const;

1369 10 compare_to 0 4 2010 35 BitMask< uint64_t, 64 >::compare_to 0 1 390 0
91
inline int BitMask< uint64_t, 64 >::compare_to(BitMask< uint64_t, 64 > const &other) const;

1370 10 operator & 0 4 2010 35 BitMask< uint64_t, 64 >::operator & 0 1 391 0
111
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator &(BitMask< uint64_t, 64 > const &other) const;

1371 10 operator | 0 4 2010 35 BitMask< uint64_t, 64 >::operator | 0 1 392 0
111
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator |(BitMask< uint64_t, 64 > const &other) const;

1372 10 operator ^ 0 4 2010 35 BitMask< uint64_t, 64 >::operator ^ 0 1 393 0
111
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator ^(BitMask< uint64_t, 64 > const &other) const;

1373 10 operator ~ 0 68 2010 35 BitMask< uint64_t, 64 >::operator ~ 0 1 394 0
79
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator ~(void) const;

1374 11 operator << 0 4 2010 36 BitMask< uint64_t, 64 >::operator << 0 1 395 0
85
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator <<(int shift) const;

1375 11 operator >> 0 4 2010 36 BitMask< uint64_t, 64 >::operator >> 0 1 396 0
85
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator >>(int shift) const;

1376 11 operator &= 0 4 2010 36 BitMask< uint64_t, 64 >::operator &= 0 1 397 0
87
inline void BitMask< uint64_t, 64 >::operator &=(BitMask< uint64_t, 64 > const &other);

1377 11 operator |= 0 4 2010 36 BitMask< uint64_t, 64 >::operator |= 0 1 398 0
87
inline void BitMask< uint64_t, 64 >::operator |=(BitMask< uint64_t, 64 > const &other);

1378 11 operator ^= 0 4 2010 36 BitMask< uint64_t, 64 >::operator ^= 0 1 399 0
87
inline void BitMask< uint64_t, 64 >::operator ^=(BitMask< uint64_t, 64 > const &other);

1379 12 operator <<= 0 4 2010 37 BitMask< uint64_t, 64 >::operator <<= 0 1 400 0
61
inline void BitMask< uint64_t, 64 >::operator <<=(int shift);

1380 12 operator >>= 0 4 2010 37 BitMask< uint64_t, 64 >::operator >>= 0 1 401 0
61
inline void BitMask< uint64_t, 64 >::operator >>=(int shift);

1381 19 flood_down_in_place 0 4 2010 44 BitMask< uint64_t, 64 >::flood_down_in_place 0 1 402 0
63
inline void BitMask< uint64_t, 64 >::flood_down_in_place(void);

1382 17 flood_up_in_place 0 4 2010 42 BitMask< uint64_t, 64 >::flood_up_in_place 0 1 403 0
61
inline void BitMask< uint64_t, 64 >::flood_up_in_place(void);

1383 15 flood_bits_down 0 4 2010 40 BitMask< uint64_t, 64 >::flood_bits_down 0 1 404 0
84
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_down(void) const;

1384 13 flood_bits_up 0 4 2010 38 BitMask< uint64_t, 64 >::flood_bits_up 0 1 405 0
82
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_up(void) const;

1385 21 keep_next_highest_bit 0 4 2010 46 BitMask< uint64_t, 64 >::keep_next_highest_bit 0 3 406 407 408 0
309
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(void) const;
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(int index) const;
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(BitMask< uint64_t, 64 > const &other) const;

1386 20 keep_next_lowest_bit 0 4 2010 45 BitMask< uint64_t, 64 >::keep_next_lowest_bit 0 3 409 410 411 0
306
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(void) const;
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(int index) const;
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(BitMask< uint64_t, 64 > const &other) const;

1387 7 get_key 0 4 2010 32 BitMask< uint64_t, 64 >::get_key 0 1 412 0
56
inline int BitMask< uint64_t, 64 >::get_key(void) const;

1388 8 __bool__ 0 4 2010 33 BitMask< uint64_t, 64 >::__bool__ 0 1 413 0
51
bool BitMask< uint64_t, 64 >::__bool__(void) const;

1389 7 __int__ 0 4 2010 32 BitMask< uint64_t, 64 >::__int__ 0 1 414 0
55
PyObject *BitMask< uint64_t, 64 >::__int__(void) const;

1390 10 __reduce__ 0 4 2010 35 BitMask< uint64_t, 64 >::__reduce__ 0 1 415 0
68
PyObject *BitMask< uint64_t, 64 >::__reduce__(PyObject *self) const;

1391 14 get_class_type 0 4 2010 39 BitMask< uint64_t, 64 >::get_class_type 0 1 416 0
64
static TypeHandle BitMask< uint64_t, 64 >::get_class_type(void);

1392 8 ~BitMask 0 516 2010 33 BitMask< uint64_t, 64 >::~BitMask 0 0 0
40
BitMask< uint64_t, 64 >::~BitMask(void);

1393 8 BitArray 0 260 2013 18 BitArray::BitArray 0 4 417 418 419 420 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
174
inline BitArray::BitArray(void);
BitArray::BitArray(SparseArray const &from);
BitArray::BitArray(PyObject *init_value);
inline BitArray::BitArray(BitArray const &) = default;

1394 6 all_on 0 4 2013 16 BitArray::all_on 0 1 421 69
/**
 * Returns a BitArray with an infinite array of bits, all on.
 */
46
static inline BitArray BitArray::all_on(void);

1395 7 all_off 0 4 2013 17 BitArray::all_off 0 1 422 53
/**
 * Returns a BitArray whose bits are all off.
 */
47
static inline BitArray BitArray::all_off(void);

1396 8 lower_on 0 4 2013 18 BitArray::lower_on 0 1 423 62
/**
 * Returns a BitArray whose lower on_bits bits are on.
 */
55
static inline BitArray BitArray::lower_on(int on_bits);

1397 3 bit 0 4 2013 13 BitArray::bit 0 1 424 61
/**
 * Returns a BitArray with only the indicated bit on.
 */
48
static inline BitArray BitArray::bit(int index);

1398 5 range 0 4 2013 15 BitArray::range 0 1 425 76
/**
 * Returns a BitArray whose size bits, beginning at low_bit, are on.
 */
62
static inline BitArray BitArray::range(int low_bit, int size);

1399 16 has_max_num_bits 0 4 2013 26 BitArray::has_max_num_bits 0 1 426 0
55
static constexpr bool BitArray::has_max_num_bits(void);

1400 16 get_max_num_bits 0 4 2013 26 BitArray::get_max_num_bits 0 1 427 0
54
static constexpr int BitArray::get_max_num_bits(void);

1401 21 get_num_bits_per_word 0 4 2013 31 BitArray::get_num_bits_per_word 0 1 428 0
59
static constexpr int BitArray::get_num_bits_per_word(void);

1402 12 get_num_bits 0 4 2013 22 BitArray::get_num_bits 0 1 429 300
/**
 * Returns the current number of possibly different bits in this array.  There
 * are actually an infinite number of bits, but every bit higher than this bit
 * will have the same value, either 0 or 1 (see get_highest_bits()).
 *
 * This number may grow and/or shrink automatically as needed.
 */
54
inline std::size_t BitArray::get_num_bits(void) const;

1403 7 get_bit 0 4 2013 17 BitArray::get_bit 0 1 430 191
/**
 * Returns true if the nth bit is set, false if it is cleared.  It is valid
 * for n to increase beyond get_num_bits(), but the return value
 * get_num_bits() will always be the same.
 */
47
inline bool BitArray::get_bit(int index) const;

1404 7 set_bit 0 4 2013 17 BitArray::set_bit 0 1 431 97
/**
 * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
 * the array.
 */
41
inline void BitArray::set_bit(int index);

1405 9 clear_bit 0 4 2013 19 BitArray::clear_bit 0 1 432 98
/**
 * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
 * the array.
 */
43
inline void BitArray::clear_bit(int index);

1406 10 set_bit_to 0 4 2013 20 BitArray::set_bit_to 0 1 433 84
/**
 * Sets the nth bit either on or off, according to the indicated bool value.
 */
56
inline void BitArray::set_bit_to(int index, bool value);

1407 16 get_highest_bits 0 4 2013 26 BitArray::get_highest_bits 0 1 434 118
/**
 * Returns true if the infinite set of bits beyond get_num_bits() are all on,
 * or false of they are all off.
 */
51
inline bool BitArray::get_highest_bits(void) const;

1408 7 is_zero 0 4 2013 17 BitArray::is_zero 0 1 435 71
/**
 * Returns true if the entire bitmask is zero, false otherwise.
 */
35
bool BitArray::is_zero(void) const;

1409 9 is_all_on 0 4 2013 19 BitArray::is_all_on 0 1 436 70
/**
 * Returns true if the entire bitmask is one, false otherwise.
 */
37
bool BitArray::is_all_on(void) const;

1410 7 extract 0 4 2013 17 BitArray::extract 0 1 437 187
/**
 * Returns a word that represents only the indicated range of bits within this
 * BitArray, shifted to the least-significant position.  size must be <=
 * get_num_bits_per_word().
 */
73
inline BitArray::WordType BitArray::extract(int low_bit, int size) const;

1411 5 store 0 4 2013 15 BitArray::store 0 1 438 92
/**
 * Stores the indicated word into the indicated range of bits with this
 * BitArray.
 */
77
inline void BitArray::store(BitArray::WordType value, int low_bit, int size);

1412 10 has_any_of 0 4 2013 20 BitArray::has_any_of 0 1 439 82
/**
 * Returns true if any bit in the indicated range is set, false otherwise.
 */
55
bool BitArray::has_any_of(int low_bit, int size) const;

1413 10 has_all_of 0 4 2013 20 BitArray::has_all_of 0 1 440 84
/**
 * Returns true if all bits in the indicated range are set, false otherwise.
 */
55
bool BitArray::has_all_of(int low_bit, int size) const;

1414 9 set_range 0 4 2013 19 BitArray::set_range 0 1 441 47
/**
 * Sets the indicated range of bits on.
 */
48
void BitArray::set_range(int low_bit, int size);

1415 11 clear_range 0 4 2013 21 BitArray::clear_range 0 1 442 48
/**
 * Sets the indicated range of bits off.
 */
50
void BitArray::clear_range(int low_bit, int size);

1416 12 set_range_to 0 4 2013 22 BitArray::set_range_to 0 1 443 64
/**
 * Sets the indicated range of bits to either on or off.
 */
70
inline void BitArray::set_range_to(bool value, int low_bit, int size);

1417 15 get_num_on_bits 0 4 2013 25 BitArray::get_num_on_bits 0 1 444 127
/**
 * Returns the number of bits that are set to 1 in the array.  Returns -1 if
 * there are an infinite number of 1 bits.
 */
42
int BitArray::get_num_on_bits(void) const;

1418 16 get_num_off_bits 0 4 2013 26 BitArray::get_num_off_bits 0 1 445 127
/**
 * Returns the number of bits that are set to 0 in the array.  Returns -1 if
 * there are an infinite number of 0 bits.
 */
43
int BitArray::get_num_off_bits(void) const;

1419 17 get_lowest_on_bit 0 4 2013 27 BitArray::get_lowest_on_bit 0 1 446 101
/**
 * Returns the index of the lowest 1 bit in the array.  Returns -1 if there
 * are no 1 bits.
 */
44
int BitArray::get_lowest_on_bit(void) const;

1420 18 get_lowest_off_bit 0 4 2013 28 BitArray::get_lowest_off_bit 0 1 447 101
/**
 * Returns the index of the lowest 0 bit in the array.  Returns -1 if there
 * are no 0 bits.
 */
45
int BitArray::get_lowest_off_bit(void) const;

1421 18 get_highest_on_bit 0 4 2013 28 BitArray::get_highest_on_bit 0 1 448 143
/**
 * Returns the index of the highest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there an infinite number of 1 bits.
 */
45
int BitArray::get_highest_on_bit(void) const;

1422 19 get_highest_off_bit 0 4 2013 29 BitArray::get_highest_off_bit 0 1 449 143
/**
 * Returns the index of the highest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there an infinite number of 1 bits.
 */
46
int BitArray::get_highest_off_bit(void) const;

1423 29 get_next_higher_different_bit 0 4 2013 39 BitArray::get_next_higher_different_bit 0 1 450 287
/**
 * Returns the index of the next bit in the array, above low_bit, whose value
 * is different that the value of low_bit.  Returns low_bit again if all bits
 * higher than low_bit have the same value.
 *
 * This can be used to quickly iterate through all of the bits in the array.
 */
63
int BitArray::get_next_higher_different_bit(int low_bit) const;

1424 13 get_num_words 0 4 2013 23 BitArray::get_num_words 0 1 451 75
/**
 * Returns the number of possibly-unique words stored in the array.
 */
55
inline std::size_t BitArray::get_num_words(void) const;

1425 8 get_word 0 4 2013 18 BitArray::get_word 0 1 452 175
/**
 * Returns the nth word in the array.  It is valid for n to be greater than
 * get_num_words(), but the return value beyond get_num_words() will always be
 * the same.
 */
66
inline BitArray::WordType BitArray::get_word(std::size_t n) const;

1426 8 set_word 0 4 2013 18 BitArray::set_word 0 1 453 113
/**
 * Replaces the nth word in the array.  If n >= get_num_words(), this
 * automatically extends the array.
 */
72
inline void BitArray::set_word(std::size_t n, BitArray::WordType value);

1427 15 invert_in_place 0 4 2013 25 BitArray::invert_in_place 0 1 454 90
/**
 * Inverts all the bits in the BitArray.  This is equivalent to array =
 * ~array.
 */
37
void BitArray::invert_in_place(void);

1428 18 has_bits_in_common 0 4 2013 28 BitArray::has_bits_in_common 0 1 455 178
/**
 * Returns true if this BitArray has any "one" bits in common with the other
 * one, false otherwise.
 *
 * This is equivalent to (array & other) != 0, but may be faster.
 */
63
bool BitArray::has_bits_in_common(BitArray const &other) const;

1429 5 clear 0 4 2013 15 BitArray::clear 0 1 456 49
/**
 * Sets all the bits in the BitArray off.
 */
34
inline void BitArray::clear(void);

1430 6 output 0 4 2013 16 BitArray::output 0 1 457 193
/**
 * Writes the BitArray out as a hex number.  For a BitArray, this is always
 * the same as output_hex(); it's too confusing for the output format to
 * change back and forth at runtime.
 */
47
void BitArray::output(std::ostream &out) const;

1431 13 output_binary 0 4 2013 23 BitArray::output_binary 0 1 458 83
/**
 * Writes the BitArray out as a binary number, with spaces every four bits.
 */
76
void BitArray::output_binary(std::ostream &out, int spaces_every = 4) const;

1432 10 output_hex 0 4 2013 20 BitArray::output_hex 0 1 459 93
/**
 * Writes the BitArray out as a hexadecimal number, with spaces every four
 * digits.
 */
73
void BitArray::output_hex(std::ostream &out, int spaces_every = 4) const;

1433 5 write 0 4 2013 15 BitArray::write 0 1 460 99
/**
 * Writes the BitArray out as a binary or a hex number, according to the
 * number of bits.
 */
68
void BitArray::write(std::ostream &out, int indent_level = 0) const;

1434 11 operator == 0 4 2013 21 BitArray::operator == 0 1 461 0
63
inline bool BitArray::operator ==(BitArray const &other) const;

1435 11 operator != 0 4 2013 21 BitArray::operator != 0 1 462 0
63
inline bool BitArray::operator !=(BitArray const &other) const;

1436 10 operator < 0 4 2013 20 BitArray::operator < 0 1 463 0
62
inline bool BitArray::operator <(BitArray const &other) const;

1437 10 compare_to 0 4 2013 20 BitArray::compare_to 0 1 464 233
/**
 * Returns a number less than zero if this BitArray sorts before the indicated
 * other BitArray, greater than zero if it sorts after, or 0 if they are
 * equivalent.  This is based on the same ordering defined by operator <.
 */
54
int BitArray::compare_to(BitArray const &other) const;

1438 10 operator & 0 4 2013 20 BitArray::operator & 0 1 465 0
66
inline BitArray BitArray::operator &(BitArray const &other) const;

1439 10 operator | 0 4 2013 20 BitArray::operator | 0 1 466 0
66
inline BitArray BitArray::operator |(BitArray const &other) const;

1440 10 operator ^ 0 4 2013 20 BitArray::operator ^ 0 1 467 0
66
inline BitArray BitArray::operator ^(BitArray const &other) const;

1441 10 operator ~ 0 68 2013 20 BitArray::operator ~ 0 1 468 0
49
inline BitArray BitArray::operator ~(void) const;

1442 11 operator << 0 4 2013 21 BitArray::operator << 0 1 469 0
55
inline BitArray BitArray::operator <<(int shift) const;

1443 11 operator >> 0 4 2013 21 BitArray::operator >> 0 1 470 0
55
inline BitArray BitArray::operator >>(int shift) const;

1444 11 operator &= 0 4 2013 21 BitArray::operator &= 0 1 471 0
50
void BitArray::operator &=(BitArray const &other);

1445 11 operator |= 0 4 2013 21 BitArray::operator |= 0 1 472 0
50
void BitArray::operator |=(BitArray const &other);

1446 11 operator ^= 0 4 2013 21 BitArray::operator ^= 0 1 473 0
50
void BitArray::operator ^=(BitArray const &other);

1447 12 operator <<= 0 4 2013 22 BitArray::operator <<= 0 1 474 0
39
void BitArray::operator <<=(int shift);

1448 12 operator >>= 0 4 2013 22 BitArray::operator >>= 0 1 475 0
39
void BitArray::operator >>=(int shift);

1449 8 __bool__ 0 4 2013 18 BitArray::__bool__ 0 1 476 0
36
bool BitArray::__bool__(void) const;

1450 12 __getstate__ 0 4 2013 22 BitArray::__getstate__ 0 1 477 0
45
PyObject *BitArray::__getstate__(void) const;

1451 12 __setstate__ 0 4 2013 22 BitArray::__setstate__ 0 1 478 0
45
void BitArray::__setstate__(PyObject *state);

1452 14 get_class_type 0 4 2013 24 BitArray::get_class_type 0 1 479 0
49
static TypeHandle BitArray::get_class_type(void);

1453 9 ~BitArray 0 516 2013 19 BitArray::~BitArray 0 0 0
26
BitArray::~BitArray(void);

1454 12 ButtonHandle 0 260 2015 26 ButtonHandle::ButtonHandle 0 4 480 481 482 483 758
// The default constructor must do nothing, because we can't guarantee
// ordering of static initializers.  If the constructor tried to initialize
// its value, it  might happen after the value had already been set
// previously by another static initializer!

/**
 * Constructs a ButtonHandle with the corresponding index number, which may
 * have been returned by an earlier call to ButtonHandle::get_index().
 */

/**
 * Constructs a ButtonHandle with the corresponding name, which is looked up
 * in the ButtonRegistry.  This exists for the purpose of being able to
 * automatically coerce a string into a ButtonHandle; for most purposes, you
 * should use either the static KeyboardButton/MouseButton getters or
 * ButtonRegistry::register_button().
 */
228
inline ButtonHandle::ButtonHandle(void) = default;
explicit constexpr ButtonHandle::ButtonHandle(int index);
ButtonHandle::ButtonHandle(std::string const &name);
inline ButtonHandle::ButtonHandle(ButtonHandle const &) = default;

1455 11 operator == 0 4 2015 25 ButtonHandle::operator == 0 1 484 0
71
inline bool ButtonHandle::operator ==(ButtonHandle const &other) const;

1456 11 operator != 0 4 2015 25 ButtonHandle::operator != 0 1 485 0
71
inline bool ButtonHandle::operator !=(ButtonHandle const &other) const;

1457 10 operator < 0 4 2015 24 ButtonHandle::operator < 0 1 486 0
70
inline bool ButtonHandle::operator <(ButtonHandle const &other) const;

1458 11 operator <= 0 4 2015 25 ButtonHandle::operator <= 0 1 487 0
71
inline bool ButtonHandle::operator <=(ButtonHandle const &other) const;

1459 10 operator > 0 4 2015 24 ButtonHandle::operator > 0 1 488 0
70
inline bool ButtonHandle::operator >(ButtonHandle const &other) const;

1460 11 operator >= 0 4 2015 25 ButtonHandle::operator >= 0 1 489 0
71
inline bool ButtonHandle::operator >=(ButtonHandle const &other) const;

1461 10 compare_to 0 4 2015 24 ButtonHandle::compare_to 0 1 490 209
/**
 * Sorts ButtonHandles arbitrarily (according to <, >, etc.).  Returns a
 * number less than 0 if this type sorts before the other one, greater than
 * zero if it sorts after, 0 if they are equivalent.
 */
69
inline int ButtonHandle::compare_to(ButtonHandle const &other) const;

1462 8 get_hash 0 4 2015 22 ButtonHandle::get_hash 0 1 491 54
/**
 * Returns a hash code suitable for phash_map.
 */
54
inline std::size_t ButtonHandle::get_hash(void) const;

1463 8 get_name 0 4 2015 22 ButtonHandle::get_name 0 1 492 42
/**
 * Returns the name of the button.
 */
47
std::string ButtonHandle::get_name(void) const;

1464 20 has_ascii_equivalent 0 4 2015 34 ButtonHandle::has_ascii_equivalent 0 1 493 121
/**
 * Returns true if the button was created with an ASCII equivalent code (e.g.
 * for a standard keyboard button).
 */
59
inline bool ButtonHandle::has_ascii_equivalent(void) const;

1465 20 get_ascii_equivalent 0 4 2015 34 ButtonHandle::get_ascii_equivalent 0 1 494 109
/**
 * Returns the character code associated with the button, or '\0' if no ASCII
 * code was associated.
 */
59
inline char ButtonHandle::get_ascii_equivalent(void) const;

1466 9 get_alias 0 4 2015 23 ButtonHandle::get_alias 0 1 495 373
/**
 * Returns the alias (alternate name) associated with the button, if any, or
 * ButtonHandle::none() if the button has no alias.
 *
 * Each button is allowed to have one alias, and multiple different buttons
 * can refer to the same alias.  The alias should be the more general name for
 * the button, for instance, shift is an alias for lshift, but not vice-versa.
 */
49
ButtonHandle ButtonHandle::get_alias(void) const;

1467 7 matches 0 4 2015 21 ButtonHandle::matches 0 1 496 263
/**
 * Returns true if this ButtonHandle is the same as the other one, or if the
 * other one is an alias for this one.  (Does not return true if this button
 * is an alias for the other one, however.)
 *
 * This is a more general comparison than operator ==.
 */
67
inline bool ButtonHandle::matches(ButtonHandle const &other) const;

1468 9 get_index 0 4 2015 23 ButtonHandle::get_index 0 1 497 363
/**
 * Returns the integer index associated with this ButtonHandle.  Each
 * different ButtonHandle will have a different index.  However, you probably
 * shouldn't be using this method; you should just treat the ButtonHandles as
 * opaque classes.  This is provided for the convenience of non-C++ scripting
 * languages to build a hashtable of ButtonHandles.
 */
50
constexpr int ButtonHandle::get_index(void) const;

1469 6 output 0 4 2015 20 ButtonHandle::output 0 1 498 10
/**
 *
 */
58
inline void ButtonHandle::output(std::ostream &out) const;

1470 4 none 0 4 2015 18 ButtonHandle::none 0 1 499 0
55
static constexpr ButtonHandle ButtonHandle::none(void);

1471 22 operator typecast bool 0 132 2015 36 ButtonHandle::operator typecast bool 0 1 501 0
34
inline operator bool (void) const;

1472 14 get_class_type 0 4 2015 28 ButtonHandle::get_class_type 0 1 500 0
53
static TypeHandle ButtonHandle::get_class_type(void);

1473 13 ~ButtonHandle 0 516 2015 27 ButtonHandle::~ButtonHandle 0 0 0
34
ButtonHandle::~ButtonHandle(void);

1474 10 get_button 0 4 2019 26 ButtonRegistry::get_button 0 1 503 150
/**
 * Finds a ButtonHandle in the registry matching the indicated name.  If there
 * is no such ButtonHandle, registers a new one and returns it.
 */
65
ButtonHandle ButtonRegistry::get_button(std::string const &name);

1475 11 find_button 0 4 2019 27 ButtonRegistry::find_button 0 1 504 144
/**
 * Finds a ButtonHandle in the registry matching the indicated name.  If there
 * is no such ButtonHandle, returns ButtonHandle::none().
 */
66
ButtonHandle ButtonRegistry::find_button(std::string const &name);

1476 17 find_ascii_button 0 4 2019 33 ButtonRegistry::find_ascii_button 0 1 505 169
/**
 * Finds a ButtonHandle in the registry matching the indicated ASCII
 * equivalent character.  If there is no such ButtonHandle, returns
 * ButtonHandle::none().
 */
76
ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const;

1477 5 write 0 4 2019 21 ButtonRegistry::write 0 1 506 10
/**
 *
 */
52
void ButtonRegistry::write(std::ostream &out) const;

1478 3 ptr 0 4 2019 19 ButtonRegistry::ptr 0 1 507 134
// ptr() returns the pointer to the global ButtonRegistry object.

/**
 * Returns the pointer to the global ButtonRegistry object.
 */
56
static inline ButtonRegistry *ButtonRegistry::ptr(void);

1479 14 ButtonRegistry 0 260 2019 30 ButtonRegistry::ButtonRegistry 0 1 502 10
/**
 *
 */
72
inline ButtonRegistry::ButtonRegistry(ButtonRegistry const &) = default;

1480 15 ~ButtonRegistry 0 516 2019 31 ButtonRegistry::~ButtonRegistry 0 0 0
38
ButtonRegistry::~ButtonRegistry(void);

1481 15 get_num_buttons 0 4 2020 26 ButtonMap::get_num_buttons 0 1 510 76
/**
 * Returns the number of buttons that this button mapping specifies.
 */
58
inline std::size_t ButtonMap::get_num_buttons(void) const;

1482 14 get_raw_button 0 4 2020 25 ButtonMap::get_raw_button 0 1 511 76
/**
 * Returns the underlying raw button associated with the nth button.
 */
67
inline ButtonHandle ButtonMap::get_raw_button(std::size_t i) const;

1483 17 get_mapped_button 0 4 2020 28 ButtonMap::get_mapped_button 0 3 512 513 514 437
/**
 * Returns the nth mapped button, meaning the button that the nth raw button
 * is mapped to.
 */

/**
 * Returns the button that the given button is mapped to, or
 * ButtonHandle::none() if this map does not specify a mapped button for the
 * given raw button.
 */

/**
 * Returns the button that the given button is mapped to, or
 * ButtonHandle::none() if this map does not specify a mapped button for the
 * given raw button.
 */
229
inline ButtonHandle ButtonMap::get_mapped_button(std::size_t i) const;
inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const;
inline ButtonHandle ButtonMap::get_mapped_button(std::string const &raw_name) const;

1484 23 get_mapped_button_label 0 4 2020 34 ButtonMap::get_mapped_button_label 0 3 515 516 517 837
/**
 * Returns the label associated with the nth mapped button, meaning the button
 * that the nth raw button is mapped to.
 */

/**
 * If the button map specifies a special name for the button (eg.  if the
 * operating system or keyboard device has a localized name describing the
 * key), returns it, or the empty string otherwise.
 *
 * Note that this is not the same as get_mapped_button().get_name(), which
 * returns the name of the Panda event associated with the button.
 */

/**
 * If the button map specifies a special name for the button (eg.  if the
 * operating system or keyboard device has a localized name describing the
 * key), returns it, or the empty string otherwise.
 *
 * Note that this is not the same as get_mapped_button().get_name(), which
 * returns the name of the Panda event associated with the button.
 */
265
inline std::string const &ButtonMap::get_mapped_button_label(std::size_t i) const;
inline std::string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const;
inline std::string const &ButtonMap::get_mapped_button_label(std::string const &raw_name) const;

1485 6 output 0 4 2020 17 ButtonMap::output 0 1 518 10
/**
 *
 */
48
void ButtonMap::output(std::ostream &out) const;

1486 5 write 0 4 2020 16 ButtonMap::write 0 1 519 10
/**
 *
 */
69
void ButtonMap::write(std::ostream &out, int indent_level = 0) const;

1487 14 get_class_type 0 4 2020 25 ButtonMap::get_class_type 0 1 520 0
50
static TypeHandle ButtonMap::get_class_type(void);

1488 9 ButtonMap 0 260 2020 20 ButtonMap::ButtonMap 0 2 508 509 0
102
inline ButtonMap::ButtonMap(void) = default;
inline ButtonMap::ButtonMap(ButtonMap const &) = default;

1489 10 ~ButtonMap 0 516 2020 21 ButtonMap::~ButtonMap 0 0 0
28
ButtonMap::~ButtonMap(void);

1490 6 output 0 6 2022 22 CallbackObject::output 0 1 522 10
/**
 *
 */
61
virtual void CallbackObject::output(std::ostream &out) const;

1491 4 make 0 4 2022 20 CallbackObject::make 0 1 523 0
76
static PointerTo< CallbackObject > CallbackObject::make(PyObject *function);

1492 14 get_class_type 0 4 2022 30 CallbackObject::get_class_type 0 1 524 0
55
static TypeHandle CallbackObject::get_class_type(void);

1493 14 CallbackObject 0 260 2022 30 CallbackObject::CallbackObject 0 1 521 10
/**
 *
 */
72
inline CallbackObject::CallbackObject(CallbackObject const &) = default;

1494 15 ~CallbackObject 0 516 2022 31 CallbackObject::~CallbackObject 0 0 0
38
CallbackObject::~CallbackObject(void);

1495 19 get_cache_ref_count 0 4 2023 54 CachedTypedWritableReferenceCount::get_cache_ref_count 0 1 525 47
/**
 * Returns the current reference count.
 */
78
inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const;

1496 9 cache_ref 0 4 2023 44 CachedTypedWritableReferenceCount::cache_ref 0 1 526 108
/**
 * Explicitly increments the cache reference count and the normal reference
 * count simultaneously.
 */
69
inline void CachedTypedWritableReferenceCount::cache_ref(void) const;

1497 11 cache_unref 0 4 2023 46 CachedTypedWritableReferenceCount::cache_unref 0 1 527 202
/**
 * Explicitly decrements the cache reference count and the normal reference
 * count simultaneously.
 *
 * The return value is true if the new reference count is nonzero, false if it
 * is zero.
 */
71
inline bool CachedTypedWritableReferenceCount::cache_unref(void) const;

1498 24 test_ref_count_integrity 0 4 2023 59 CachedTypedWritableReferenceCount::test_ref_count_integrity 0 1 528 97
/**
 * Does some easy checks to make sure that the reference count isn't
 * completely bogus.
 */
84
inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const;

1499 14 get_class_type 0 4 2023 49 CachedTypedWritableReferenceCount::get_class_type 0 1 529 0
74
static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void);

1500 6 output 0 6 2024 20 CallbackData::output 0 1 530 10
/**
 *
 */
59
virtual void CallbackData::output(std::ostream &out) const;

1501 6 upcall 0 6 2024 20 CallbackData::upcall 0 1 531 159
/**
 * You should make this call during the callback if you want to continue the
 * normal function that would have been done in the absence of a callback.
 */
40
virtual void CallbackData::upcall(void);

1502 14 get_class_type 0 4 2024 28 CallbackData::get_class_type 0 1 532 0
53
static TypeHandle CallbackData::get_class_type(void);

1503 13 ~CallbackData 0 516 2024 27 CallbackData::~CallbackData 0 0 0
34
CallbackData::~CallbackData(void);

1504 20 PythonCallbackObject 0 260 2025 42 PythonCallbackObject::PythonCallbackObject 0 2 533 534 10
/**
 *
 */
177
PythonCallbackObject::PythonCallbackObject(PyObject *function = (& ::_Py_NoneStruct));
inline PythonCallbackObject::PythonCallbackObject(PythonCallbackObject const &) = default;

1505 12 operator new 0 4 2025 34 PythonCallbackObject::operator new 0 1 535 0
144
inline void *PythonCallbackObject::operator new(std::size_t size);
inline void *PythonCallbackObject::operator new(std::size_t size, void *ptr);

1506 15 operator delete 0 4 2025 37 PythonCallbackObject::operator delete 0 0 0
128
inline void PythonCallbackObject::operator delete(void *ptr);
inline void PythonCallbackObject::operator delete(void *, void *);

1507 12 validate_ptr 0 4 2025 34 PythonCallbackObject::validate_ptr 0 0 0
71
static inline bool PythonCallbackObject::validate_ptr(void const *ptr);

1508 12 set_function 0 4 2025 34 PythonCallbackObject::set_function 0 1 536 126
/**
 * Replaces the function that is called for the callback.  runs.  The
 * parameter should be a Python callable object.
 */
60
void PythonCallbackObject::set_function(PyObject *function);

1509 12 get_function 0 4 2025 34 PythonCallbackObject::get_function 0 1 537 64
/**
 * Returns the function that is called for the callback.
 */
51
PyObject *PythonCallbackObject::get_function(void);

1510 10 __reduce__ 0 4 2025 32 PythonCallbackObject::__reduce__ 0 1 538 37
/**
 * Implements pickle support.
 */
55
PyObject *PythonCallbackObject::__reduce__(void) const;

1511 14 get_class_type 0 4 2025 36 PythonCallbackObject::get_class_type 0 1 539 0
61
static TypeHandle PythonCallbackObject::get_class_type(void);

1512 7 TimeVal 0 260 2026 16 TimeVal::TimeVal 0 2 540 541 10
/**
 *
 */
82
inline TimeVal::TimeVal(void);
inline TimeVal::TimeVal(TimeVal const &) = default;

1513 7 get_sec 0 4 2026 16 TimeVal::get_sec 0 1 542 10
/**
 *
 */
54
inline unsigned long int TimeVal::get_sec(void) const;

1514 8 get_usec 0 4 2026 17 TimeVal::get_usec 0 1 543 10
/**
 *
 */
55
inline unsigned long int TimeVal::get_usec(void) const;

1515 6 get_tv 0 20 2026 15 TimeVal::get_tv 0 0 44
getter for unsigned long int TimeVal::tv[2];
47
unsigned long int *TimeVal::get_tv(void) const;

1516 6 set_tv 0 36 2026 15 TimeVal::set_tv 0 0 44
setter for unsigned long int TimeVal::tv[2];
49
void TimeVal::set_tv(unsigned long int value[2]);

1517 8 ~TimeVal 0 516 2026 17 TimeVal::~TimeVal 0 0 0
24
TimeVal::~TimeVal(void);

1518 11 ClockObject 0 260 2029 24 ClockObject::ClockObject 0 2 544 545 22
/**
 *
 */

/**
 *
 */
126
ClockObject::ClockObject(ClockObject::Mode mode = ::ClockObject::M_normal);
ClockObject::ClockObject(ClockObject const &copy);

1519 8 set_mode 0 4 2029 21 ClockObject::set_mode 0 1 546 1841
/**
 * Changes the mode of the clock.  Normally, the clock is in mode M_normal.
 * In this mode, each call to tick() will set the value returned by
 * get_frame_time() to the current real time; thus, the clock simply reports
 * time advancing.
 *
 * Other possible modes:
 *
 * M_non_real_time - the clock ignores real time completely; at each call to
 * tick(), it pretends that exactly dt seconds have elapsed since the last
 * call to tick().  You may set the value of dt with set_dt() or
 * set_frame_rate().
 *
 * M_limited - the clock will run as fast as it can, as in M_normal, but will
 * not run faster than the rate specified by set_frame_rate().  If the
 * application would run faster than this rate, the clock will slow down the
 * application.
 *
 * M_integer - the clock will run as fast as it can, but the rate will be
 * constrained to be an integer multiple or divisor of the rate specified by
 * set_frame_rate().  The clock will slow down the application a bit to
 * guarantee this.
 *
 * M_integer_limited - a combination of M_limited and M_integer; the clock
 * will not run faster than set_frame_rate(), and if it runs slower, it will
 * run at a integer divisor of that rate.
 *
 * M_forced - the clock forces the application to run at the rate specified by
 * set_frame_rate().  If the application would run faster than this rate, the
 * clock will slow down the application; if the application would run slower
 * than this rate, the clock slows down time so that the application believes
 * it is running at the given rate.
 *
 * M_degrade - the clock runs at real time, but the application is slowed down
 * by a set factor of its frame rate, specified by set_degrade_factor().
 *
 * M_slave - the clock does not advance, but relies on the user to call
 * set_frame_time() and/or set_frame_count() each frame.
 */
51
void ClockObject::set_mode(ClockObject::Mode mode);

1520 8 get_mode 0 4 2029 21 ClockObject::get_mode 0 1 547 66
/**
 * Returns the current mode of the clock.  See set_mode().
 */
59
inline ClockObject::Mode ClockObject::get_mode(void) const;

1521 14 get_frame_time 0 4 2029 27 ClockObject::get_frame_time 0 1 548 350
/**
 * Returns the time in seconds as of the last time tick() was called
 * (typically, this will be as of the start of the current frame).
 *
 * This is generally the kind of time you want to ask for in most rendering
 * and animation contexts, since it's important that all of the animation for
 * a given frame remains in sync with each other.
 */
103
inline double ClockObject::get_frame_time(Thread *current_thread = Thread::get_current_thread()) const;

1522 13 get_real_time 0 4 2029 26 ClockObject::get_real_time 0 1 549 434
/**
 * Returns the actual number of seconds elapsed since the ClockObject was
 * created, or since it was last reset.  This is useful for doing real timing
 * measurements, e.g.  for performance statistics.
 *
 * This returns the most precise timer we have for short time intervals, but
 * it may tend to drift over the long haul.  If more accurate timekeeping is
 * needed over a long period of time, use get_long_time() instead.
 */
53
inline double ClockObject::get_real_time(void) const;

1523 13 get_long_time 0 4 2029 26 ClockObject::get_long_time 0 1 550 440
/**
 * Returns the actual number of seconds elapsed since the ClockObject was
 * created, or since it was last reset.
 *
 * This is similar to get_real_time(), except that it uses the most accurate
 * counter we have over a long period of time, and so it is less likely to
 * drift.  However, it may not be very precise for measuring short intervals.
 * On Windows, for instace, this is only accurate to within about 55
 * milliseconds.
 */
53
inline double ClockObject::get_long_time(void) const;

1524 5 reset 0 4 2029 18 ClockObject::reset 0 1 551 75
/**
 * Simultaneously resets both the time and the frame count to zero.
 */
37
inline void ClockObject::reset(void);

1525 13 set_real_time 0 4 2029 26 ClockObject::set_real_time 0 1 552 316
/**
 * Resets the clock to the indicated time.  This changes only the real time of
 * the clock as reported by get_real_time(), but does not immediately change
 * the time reported by get_frame_time()--that will change after the next call
 * to tick().  Also see reset(), set_frame_time(), and set_frame_count().
 */
45
void ClockObject::set_real_time(double time);

1526 14 set_frame_time 0 4 2029 27 ClockObject::set_frame_time 0 1 553 215
/**
 * Changes the time as reported for the current frame to the indicated time.
 * Normally, the way to adjust the frame time is via tick(); this function is
 * provided only for occasional special adjustments.
 */
101
void ClockObject::set_frame_time(double time, Thread *current_thread = Thread::get_current_thread());

1527 15 set_frame_count 0 4 2029 28 ClockObject::set_frame_count 0 1 554 132
/**
 * Resets the number of frames counted to the indicated number.  Also see
 * reset(), set_real_time(), and set_frame_time().
 */
106
void ClockObject::set_frame_count(int frame_count, Thread *current_thread = Thread::get_current_thread());

1528 15 get_frame_count 0 4 2029 28 ClockObject::get_frame_count 0 1 555 195
/**
 * Returns the number of times tick() has been called since the ClockObject
 * was created, or since it was last reset.  This is generally the number of
 * frames that have been rendered.
 */
101
inline int ClockObject::get_frame_count(Thread *current_thread = Thread::get_current_thread()) const;

1529 18 get_net_frame_rate 0 4 2029 31 ClockObject::get_net_frame_rate 0 1 556 245
/**
 * Returns the average frame rate since the last reset.  This is simply the
 * total number of frames divided by the total elapsed time.  This reports the
 * virtual frame rate if the clock is in (or has been in) M_non_real_time
 * mode.
 */
107
inline double ClockObject::get_net_frame_rate(Thread *current_thread = Thread::get_current_thread()) const;

1530 6 get_dt 0 4 2029 19 ClockObject::get_dt 0 1 557 130
/**
 * Returns the elapsed time for the previous frame: the number of seconds
 * elapsed between the last two calls to tick().
 */
95
inline double ClockObject::get_dt(Thread *current_thread = Thread::get_current_thread()) const;

1531 6 set_dt 0 4 2029 19 ClockObject::set_dt 0 1 558 291
/**
 * In non-real-time mode, sets the number of seconds that should appear to
 * elapse between frames.  In forced mode or limited mode, sets our target dt.
 * In normal mode, this has no effect.
 *
 * Also see set_frame_rate(), which is a different way to specify the same
 * quantity.
 */
36
void ClockObject::set_dt(double dt);

1532 14 set_frame_rate 0 4 2029 27 ClockObject::set_frame_rate 0 1 559 291
/**
 * In non-real-time mode, sets the number of frames per second that we should
 * appear to be running.  In forced mode or limited mode, sets our target
 * frame rate.  In normal mode, this has no effect.
 *
 * Also see set_dt(), which is a different way to specify the same quantity.
 */
52
void ClockObject::set_frame_rate(double frame_rate);

1533 10 get_max_dt 0 4 2029 23 ClockObject::get_max_dt 0 1 560 106
/**
 * Returns the current maximum allowable time elapsed between any two frames.
 * See set_max_dt().
 */
50
inline double ClockObject::get_max_dt(void) const;

1534 10 set_max_dt 0 4 2029 23 ClockObject::set_max_dt 0 1 561 511
/**
 * Sets a limit on the value returned by get_dt().  If this value is less than
 * zero, no limit is imposed; otherwise, this is the maximum value that will
 * ever be returned by get_dt(), regardless of how much time has actually
 * elapsed between frames.
 *
 * This limit is only imposed in real-time mode; in non-real-time mode, the dt
 * is fixed anyway and max_dt is ignored.
 *
 * This is generally used to guarantee reasonable behavior even in the
 * presence of a very slow or chuggy frame rame.
 */
51
inline void ClockObject::set_max_dt(double max_dt);

1535 18 get_degrade_factor 0 4 2029 31 ClockObject::get_degrade_factor 0 1 562 265
/**
 * In degrade mode, returns the ratio by which the performance is degraded.  A
 * value of 2.0 causes the clock to be slowed down by a factor of two
 * (reducing performance to 1/2 what would be otherwise).
 *
 * This has no effect if mode is not M_degrade.
 */
58
inline double ClockObject::get_degrade_factor(void) const;

1536 18 set_degrade_factor 0 4 2029 31 ClockObject::set_degrade_factor 0 1 563 262
/**
 * In degrade mode, sets the ratio by which the performance is degraded.  A
 * value of 2.0 causes the clock to be slowed down by a factor of two
 * (reducing performance to 1/2 what would be otherwise).
 *
 * This has no effect if mode is not M_degrade.
 */
67
inline void ClockObject::set_degrade_factor(double degrade_factor);

1537 31 set_average_frame_rate_interval 0 4 2029 44 ClockObject::set_average_frame_rate_interval 0 1 564 393
/**
 * Specifies the interval of time (in seconds) over which
 * get_average_frame_rate() averages the number of frames per second to
 * compute the frame rate.  Changing this does not necessarily immediately
 * change the result of get_average_frame_rate(), until this interval of time
 * has elapsed again.
 *
 * Setting this to zero disables the computation of get_average_frame_rate().
 */
70
inline void ClockObject::set_average_frame_rate_interval(double time);

1538 31 get_average_frame_rate_interval 0 4 2029 44 ClockObject::get_average_frame_rate_interval 0 1 565 162
/**
 * Returns the interval of time (in seconds) over which
 * get_average_frame_rate() averages the number of frames per second to
 * compute the frame rate.
 */
71
inline double ClockObject::get_average_frame_rate_interval(void) const;

1539 22 get_average_frame_rate 0 4 2029 35 ClockObject::get_average_frame_rate 0 1 566 214
/**
 * Returns the average frame rate in number of frames per second over the last
 * get_average_frame_rate_interval() seconds.  This measures the virtual frame
 * rate if the clock is in M_non_real_time mode.
 */
104
double ClockObject::get_average_frame_rate(Thread *current_thread = Thread::get_current_thread()) const;

1540 22 get_max_frame_duration 0 4 2029 35 ClockObject::get_max_frame_duration 0 1 567 105
/**
 * Returns the maximum frame duration over the last
 * get_average_frame_rate_interval() seconds.
 */
104
double ClockObject::get_max_frame_duration(Thread *current_thread = Thread::get_current_thread()) const;

1541 25 calc_frame_rate_deviation 0 4 2029 38 ClockObject::calc_frame_rate_deviation 0 1 568 539
/**
 * Returns the standard deviation of the frame times of the frames rendered
 * over the past get_average_frame_rate_interval() seconds.  This number gives
 * an estimate of the chugginess of the frame rate; if it is large, there is a
 * large variation in the frame rate; if is small, all of the frames are
 * consistent in length.
 *
 * A large value might also represent just a recent change in frame rate, for
 * instance, because the camera has just rotated from looking at a simple
 * scene to looking at a more complex scene.
 */
107
double ClockObject::calc_frame_rate_deviation(Thread *current_thread = Thread::get_current_thread()) const;

1542 4 tick 0 4 2029 17 ClockObject::tick 0 1 569 285
/**
 * Instructs the clock that a new frame has just begun.  In normal, real-time
 * mode, get_frame_time() will henceforth report the time as of this instant
 * as the current start-of-frame time.  In non-real-time mode,
 * get_frame_time() will be incremented by the value of dt.
 */
78
void ClockObject::tick(Thread *current_thread = Thread::get_current_thread());

1543 15 sync_frame_time 0 4 2029 28 ClockObject::sync_frame_time 0 1 570 417
/**
 * Resets the frame time to the current real time.  This is similar to tick(),
 * except that it does not advance the frame counter and does not affect dt.
 * This is intended to be used in the middle of a particularly long frame to
 * compensate for the time that has already elapsed.
 *
 * In non-real-time mode, this function has no effect (because in this mode
 * all frames take the same length of time).
 */
89
void ClockObject::sync_frame_time(Thread *current_thread = Thread::get_current_thread());

1544 12 check_errors 0 4 2029 25 ClockObject::check_errors 0 1 571 322
/**
 * Returns true if a clock error was detected since the last time
 * check_errors() was called.  A clock error means that something happened, an
 * OS or BIOS bug, for instance, that makes the current value of the clock
 * somewhat suspect, and an application may wish to resynchronize with any
 * external clocks.
 */
62
inline bool ClockObject::check_errors(Thread *current_thread);

1545 16 get_global_clock 0 4 2029 29 ClockObject::get_global_clock 0 1 572 159
/**
 * Returns a pointer to the global ClockObject.  This is the ClockObject that
 * most code should use for handling scene graph rendering and animation.
 */
63
static inline ClockObject *ClockObject::get_global_clock(void);

1546 14 get_class_type 0 4 2029 27 ClockObject::get_class_type 0 1 573 0
52
static TypeHandle ClockObject::get_class_type(void);

1547 24 parse_color_space_string 0 1 0 24 parse_color_space_string 0 1 978 0
60
ColorSpace parse_color_space_string(std::string const &str);

1548 18 format_color_space 0 1 0 18 format_color_space 0 1 979 0
46
std::string format_color_space(ColorSpace cs);

1549 14 get_model_path 0 1 0 14 get_model_path 0 1 980 0
47
ConfigVariableSearchPath &get_model_path(void);

1550 15 get_plugin_path 0 1 0 15 get_plugin_path 0 1 981 0
48
ConfigVariableSearchPath &get_plugin_path(void);

1551 9 cache_ref 0 4 2033 28 CopyOnWriteObject::cache_ref 0 1 574 62
/**
 * @see CachedTypedWritableReferenceCount::cache_ref()
 */
53
inline void CopyOnWriteObject::cache_ref(void) const;

1552 11 cache_unref 0 4 2033 30 CopyOnWriteObject::cache_unref 0 1 575 64
/**
 * @see CachedTypedWritableReferenceCount::cache_unref()
 */
55
inline bool CopyOnWriteObject::cache_unref(void) const;

1553 14 get_class_type 0 4 2033 33 CopyOnWriteObject::get_class_type 0 1 576 0
58
static TypeHandle CopyOnWriteObject::get_class_type(void);

1554 18 ~CopyOnWriteObject 0 516 2033 37 CopyOnWriteObject::~CopyOnWriteObject 0 0 0
44
CopyOnWriteObject::~CopyOnWriteObject(void);

1555 22 upcast_to_DatagramSink 0 12 2034 38 DatagramBuffer::upcast_to_DatagramSink 0 1 580 42
upcast from DatagramBuffer to DatagramSink
59
DatagramSink *DatagramBuffer::upcast_to_DatagramSink(void);

1556 26 downcast_to_DatagramBuffer 0 12 2005 40 DatagramSink::downcast_to_DatagramBuffer 0 0 44
downcast from DatagramSink to DatagramBuffer
63
DatagramBuffer *DatagramSink::downcast_to_DatagramBuffer(void);

1557 27 upcast_to_DatagramGenerator 0 12 2034 43 DatagramBuffer::upcast_to_DatagramGenerator 0 1 581 47
upcast from DatagramBuffer to DatagramGenerator
69
DatagramGenerator *DatagramBuffer::upcast_to_DatagramGenerator(void);

1558 26 downcast_to_DatagramBuffer 0 12 1998 45 DatagramGenerator::downcast_to_DatagramBuffer 0 0 49
downcast from DatagramGenerator to DatagramBuffer
68
DatagramBuffer *DatagramGenerator::downcast_to_DatagramBuffer(void);

1559 14 DatagramBuffer 0 260 2034 30 DatagramBuffer::DatagramBuffer 0 2 577 578 104
/**
 * Initializes an empty datagram buffer.
 */

/**
 * Initializes the buffer with the given data.
 */
111
inline DatagramBuffer::DatagramBuffer(void);
inline explicit DatagramBuffer::DatagramBuffer(vector_uchar data);

1560 5 clear 0 4 2034 21 DatagramBuffer::clear 0 1 579 38
/**
 * Clears the internal buffer.
 */
40
inline void DatagramBuffer::clear(void);

1561 8 get_data 0 4 2034 24 DatagramBuffer::get_data 0 0 39
/**
 * Returns the internal buffer.
 */
64
inline vector_uchar const &DatagramBuffer::get_data(void) const;

1562 8 set_data 0 4 2034 24 DatagramBuffer::set_data 0 0 52
/**
 * Replaces the data in the internal buffer.
 */
56
inline void DatagramBuffer::set_data(vector_uchar data);

1563 15 ~DatagramBuffer 0 516 2034 31 DatagramBuffer::~DatagramBuffer 0 0 0
38
DatagramBuffer::~DatagramBuffer(void);

1564 17 DatagramInputFile 0 260 2038 36 DatagramInputFile::DatagramInputFile 0 1 582 10
/**
 *
 */
50
inline DatagramInputFile::DatagramInputFile(void);

1565 4 open 0 4 2038 23 DatagramInputFile::open 0 3 583 584 585 432
/**
 * Opens the indicated filename for reading.  Returns true on success, false
 * on failure.
 */

/**
 * Opens the indicated filename for reading.  Returns true on success, false
 * on failure.
 */

/**
 * Starts reading from the indicated stream.  Returns true on success, false
 * on failure.  The DatagramInputFile does not take ownership of the stream;
 * you are responsible for closing or deleting it when you are done.
 */
206
bool DatagramInputFile::open(FileReference const *file);
inline bool DatagramInputFile::open(Filename const &filename);
bool DatagramInputFile::open(std::istream &in, Filename const &filename = Filename());

1566 10 get_stream 0 4 2038 29 DatagramInputFile::get_stream 0 1 586 61
/**
 * Returns the istream represented by the input file.
 */
57
inline std::istream &DatagramInputFile::get_stream(void);

1567 5 close 0 4 2038 24 DatagramInputFile::close 0 1 587 98
/**
 * Closes the file.  This is also implicitly done when the DatagramInputFile
 * destructs.
 */
36
void DatagramInputFile::close(void);

1568 11 read_header 0 4 2038 30 DatagramInputFile::read_header 0 0 257
/**
 * Reads a sequence of bytes from the beginning of the datagram file.  This
 * may be called any number of times after the file has been opened and before
 * the first datagram is read.  It may not be called once the first datagram
 * has been read.
 */
80
bool DatagramInputFile::read_header(std::string &header, std::size_t num_bytes);

1569 18 DatagramOutputFile 0 260 2039 38 DatagramOutputFile::DatagramOutputFile 0 1 588 10
/**
 *
 */
52
inline DatagramOutputFile::DatagramOutputFile(void);

1570 4 open 0 4 2039 24 DatagramOutputFile::open 0 3 589 590 591 434
/**
 * Opens the indicated filename for writing.  Returns true on success, false
 * on failure.
 */

/**
 * Opens the indicated filename for writing.  Returns true if successful,
 * false on failure.
 */

/**
 * Starts writing to the indicated stream.  Returns true on success, false on
 * failure.  The DatagramOutputFile does not take ownership of the stream; you
 * are responsible for closing or deleting it when you are done.
 */
210
bool DatagramOutputFile::open(FileReference const *file);
inline bool DatagramOutputFile::open(Filename const &filename);
bool DatagramOutputFile::open(std::ostream &out, Filename const &filename = Filename());

1571 5 close 0 4 2039 25 DatagramOutputFile::close 0 1 592 99
/**
 * Closes the file.  This is also implicitly done when the DatagramOutputFile
 * destructs.
 */
37
void DatagramOutputFile::close(void);

1572 12 write_header 0 4 2039 32 DatagramOutputFile::write_header 0 2 593 594 514
/**
 * Writes a sequence of bytes to the beginning of the datagram file.  This may
 * be called any number of times after the file has been opened and before the
 * first datagram is written.  It may not be called once the first datagram is
 * written.
 */

/**
 * Writes a sequence of bytes to the beginning of the datagram file.  This may
 * be called any number of times after the file has been opened and before the
 * first datagram is written.  It may not be called once the first datagram is
 * written.
 */
132
bool DatagramOutputFile::write_header(vector_uchar const &header);
bool DatagramOutputFile::write_header(std::string const &header);

1573 10 get_stream 0 4 2039 30 DatagramOutputFile::get_stream 0 0 62
/**
 * Returns the ostream represented by the output file.
 */
58
inline std::ostream &DatagramOutputFile::get_stream(void);

1574 13 DoubleBitMask 0 260 2041 45 DoubleBitMask< BitMaskNative >::DoubleBitMask 0 3 595 596 597 0
245
constexpr DoubleBitMask< BitMaskNative >::DoubleBitMask(void) = default;
DoubleBitMask< BitMaskNative >::DoubleBitMask(PyObject *init_value);
inline DoubleBitMask< BitMaskNative >::DoubleBitMask(DoubleBitMask< BitMaskNative > const &) = default;

1575 6 all_on 0 4 2041 38 DoubleBitMask< BitMaskNative >::all_on 0 1 598 0
90
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_on(void);

1576 7 all_off 0 4 2041 39 DoubleBitMask< BitMaskNative >::all_off 0 1 599 0
91
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_off(void);

1577 8 lower_on 0 4 2041 40 DoubleBitMask< BitMaskNative >::lower_on 0 1 600 0
99
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::lower_on(int on_bits);

1578 3 bit 0 4 2041 35 DoubleBitMask< BitMaskNative >::bit 0 1 601 0
92
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::bit(int index);

1579 5 range 0 4 2041 37 DoubleBitMask< BitMaskNative >::range 0 1 602 0
106
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::range(int low_bit, int size);

1580 16 has_max_num_bits 0 4 2041 48 DoubleBitMask< BitMaskNative >::has_max_num_bits 0 1 603 0
77
static constexpr bool DoubleBitMask< BitMaskNative >::has_max_num_bits(void);

1581 16 get_max_num_bits 0 4 2041 48 DoubleBitMask< BitMaskNative >::get_max_num_bits 0 1 604 0
76
static constexpr int DoubleBitMask< BitMaskNative >::get_max_num_bits(void);

1582 12 get_num_bits 0 4 2041 44 DoubleBitMask< BitMaskNative >::get_num_bits 0 1 605 0
71
constexpr int DoubleBitMask< BitMaskNative >::get_num_bits(void) const;

1583 7 get_bit 0 4 2041 39 DoubleBitMask< BitMaskNative >::get_bit 0 1 606 0
69
inline bool DoubleBitMask< BitMaskNative >::get_bit(int index) const;

1584 7 set_bit 0 4 2041 39 DoubleBitMask< BitMaskNative >::set_bit 0 1 607 0
63
inline void DoubleBitMask< BitMaskNative >::set_bit(int index);

1585 9 clear_bit 0 4 2041 41 DoubleBitMask< BitMaskNative >::clear_bit 0 1 608 0
65
inline void DoubleBitMask< BitMaskNative >::clear_bit(int index);

1586 10 set_bit_to 0 4 2041 42 DoubleBitMask< BitMaskNative >::set_bit_to 0 1 609 0
78
inline void DoubleBitMask< BitMaskNative >::set_bit_to(int index, bool value);

1587 7 is_zero 0 4 2041 39 DoubleBitMask< BitMaskNative >::is_zero 0 1 610 0
64
inline bool DoubleBitMask< BitMaskNative >::is_zero(void) const;

1588 9 is_all_on 0 4 2041 41 DoubleBitMask< BitMaskNative >::is_all_on 0 1 611 0
66
inline bool DoubleBitMask< BitMaskNative >::is_all_on(void) const;

1589 7 extract 0 4 2041 39 DoubleBitMask< BitMaskNative >::extract 0 1 612 0
85
inline uint64_t DoubleBitMask< BitMaskNative >::extract(int low_bit, int size) const;

1590 5 store 0 4 2041 37 DoubleBitMask< BitMaskNative >::store 0 1 613 0
89
inline void DoubleBitMask< BitMaskNative >::store(uint64_t value, int low_bit, int size);

1591 10 has_any_of 0 4 2041 42 DoubleBitMask< BitMaskNative >::has_any_of 0 1 614 0
84
inline bool DoubleBitMask< BitMaskNative >::has_any_of(int low_bit, int size) const;

1592 10 has_all_of 0 4 2041 42 DoubleBitMask< BitMaskNative >::has_all_of 0 1 615 0
84
inline bool DoubleBitMask< BitMaskNative >::has_all_of(int low_bit, int size) const;

1593 9 set_range 0 4 2041 41 DoubleBitMask< BitMaskNative >::set_range 0 1 616 0
77
inline void DoubleBitMask< BitMaskNative >::set_range(int low_bit, int size);

1594 11 clear_range 0 4 2041 43 DoubleBitMask< BitMaskNative >::clear_range 0 1 617 0
79
inline void DoubleBitMask< BitMaskNative >::clear_range(int low_bit, int size);

1595 12 set_range_to 0 4 2041 44 DoubleBitMask< BitMaskNative >::set_range_to 0 1 618 0
92
inline void DoubleBitMask< BitMaskNative >::set_range_to(bool value, int low_bit, int size);

1596 15 get_num_on_bits 0 4 2041 47 DoubleBitMask< BitMaskNative >::get_num_on_bits 0 1 619 0
71
inline int DoubleBitMask< BitMaskNative >::get_num_on_bits(void) const;

1597 16 get_num_off_bits 0 4 2041 48 DoubleBitMask< BitMaskNative >::get_num_off_bits 0 1 620 0
72
inline int DoubleBitMask< BitMaskNative >::get_num_off_bits(void) const;

1598 17 get_lowest_on_bit 0 4 2041 49 DoubleBitMask< BitMaskNative >::get_lowest_on_bit 0 1 621 0
73
inline int DoubleBitMask< BitMaskNative >::get_lowest_on_bit(void) const;

1599 18 get_lowest_off_bit 0 4 2041 50 DoubleBitMask< BitMaskNative >::get_lowest_off_bit 0 1 622 0
74
inline int DoubleBitMask< BitMaskNative >::get_lowest_off_bit(void) const;

1600 18 get_highest_on_bit 0 4 2041 50 DoubleBitMask< BitMaskNative >::get_highest_on_bit 0 1 623 0
74
inline int DoubleBitMask< BitMaskNative >::get_highest_on_bit(void) const;

1601 19 get_highest_off_bit 0 4 2041 51 DoubleBitMask< BitMaskNative >::get_highest_off_bit 0 1 624 0
75
inline int DoubleBitMask< BitMaskNative >::get_highest_off_bit(void) const;

1602 29 get_next_higher_different_bit 0 4 2041 61 DoubleBitMask< BitMaskNative >::get_next_higher_different_bit 0 1 625 0
92
inline int DoubleBitMask< BitMaskNative >::get_next_higher_different_bit(int low_bit) const;

1603 15 invert_in_place 0 4 2041 47 DoubleBitMask< BitMaskNative >::invert_in_place 0 1 626 0
66
inline void DoubleBitMask< BitMaskNative >::invert_in_place(void);

1604 18 has_bits_in_common 0 4 2041 50 DoubleBitMask< BitMaskNative >::has_bits_in_common 0 1 627 0
114
inline bool DoubleBitMask< BitMaskNative >::has_bits_in_common(DoubleBitMask< BitMaskNative > const &other) const;

1605 5 clear 0 4 2041 37 DoubleBitMask< BitMaskNative >::clear 0 1 628 0
56
inline void DoubleBitMask< BitMaskNative >::clear(void);

1606 6 output 0 4 2041 38 DoubleBitMask< BitMaskNative >::output 0 1 629 0
69
void DoubleBitMask< BitMaskNative >::output(std::ostream &out) const;

1607 13 output_binary 0 4 2041 45 DoubleBitMask< BitMaskNative >::output_binary 0 1 630 0
98
void DoubleBitMask< BitMaskNative >::output_binary(std::ostream &out, int spaces_every = 4) const;

1608 10 output_hex 0 4 2041 42 DoubleBitMask< BitMaskNative >::output_hex 0 1 631 0
95
void DoubleBitMask< BitMaskNative >::output_hex(std::ostream &out, int spaces_every = 4) const;

1609 5 write 0 4 2041 37 DoubleBitMask< BitMaskNative >::write 0 1 632 0
90
void DoubleBitMask< BitMaskNative >::write(std::ostream &out, int indent_level = 0) const;

1610 11 operator == 0 4 2041 43 DoubleBitMask< BitMaskNative >::operator == 0 1 633 0
107
inline bool DoubleBitMask< BitMaskNative >::operator ==(DoubleBitMask< BitMaskNative > const &other) const;

1611 11 operator != 0 4 2041 43 DoubleBitMask< BitMaskNative >::operator != 0 1 634 0
107
inline bool DoubleBitMask< BitMaskNative >::operator !=(DoubleBitMask< BitMaskNative > const &other) const;

1612 10 operator < 0 4 2041 42 DoubleBitMask< BitMaskNative >::operator < 0 1 635 0
106
inline bool DoubleBitMask< BitMaskNative >::operator <(DoubleBitMask< BitMaskNative > const &other) const;

1613 10 compare_to 0 4 2041 42 DoubleBitMask< BitMaskNative >::compare_to 0 1 636 0
105
inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const;

1614 10 operator & 0 4 2041 42 DoubleBitMask< BitMaskNative >::operator & 0 1 637 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator &(DoubleBitMask< BitMaskNative > const &other) const;

1615 10 operator | 0 4 2041 42 DoubleBitMask< BitMaskNative >::operator | 0 1 638 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator |(DoubleBitMask< BitMaskNative > const &other) const;

1616 10 operator ^ 0 4 2041 42 DoubleBitMask< BitMaskNative >::operator ^ 0 1 639 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ^(DoubleBitMask< BitMaskNative > const &other) const;

1617 10 operator ~ 0 68 2041 42 DoubleBitMask< BitMaskNative >::operator ~ 0 1 640 0
93
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ~(void) const;

1618 11 operator << 0 4 2041 43 DoubleBitMask< BitMaskNative >::operator << 0 1 641 0
99
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator <<(int shift) const;

1619 11 operator >> 0 4 2041 43 DoubleBitMask< BitMaskNative >::operator >> 0 1 642 0
99
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator >>(int shift) const;

1620 11 operator &= 0 4 2041 43 DoubleBitMask< BitMaskNative >::operator &= 0 1 643 0
101
inline void DoubleBitMask< BitMaskNative >::operator &=(DoubleBitMask< BitMaskNative > const &other);

1621 11 operator |= 0 4 2041 43 DoubleBitMask< BitMaskNative >::operator |= 0 1 644 0
101
inline void DoubleBitMask< BitMaskNative >::operator |=(DoubleBitMask< BitMaskNative > const &other);

1622 11 operator ^= 0 4 2041 43 DoubleBitMask< BitMaskNative >::operator ^= 0 1 645 0
101
inline void DoubleBitMask< BitMaskNative >::operator ^=(DoubleBitMask< BitMaskNative > const &other);

1623 12 operator <<= 0 4 2041 44 DoubleBitMask< BitMaskNative >::operator <<= 0 1 646 0
68
inline void DoubleBitMask< BitMaskNative >::operator <<=(int shift);

1624 12 operator >>= 0 4 2041 44 DoubleBitMask< BitMaskNative >::operator >>= 0 1 647 0
68
inline void DoubleBitMask< BitMaskNative >::operator >>=(int shift);

1625 8 __bool__ 0 4 2041 40 DoubleBitMask< BitMaskNative >::__bool__ 0 1 648 0
58
bool DoubleBitMask< BitMaskNative >::__bool__(void) const;

1626 7 __int__ 0 4 2041 39 DoubleBitMask< BitMaskNative >::__int__ 0 1 649 0
62
PyObject *DoubleBitMask< BitMaskNative >::__int__(void) const;

1627 10 __reduce__ 0 4 2041 42 DoubleBitMask< BitMaskNative >::__reduce__ 0 1 650 0
75
PyObject *DoubleBitMask< BitMaskNative >::__reduce__(PyObject *self) const;

1628 14 get_class_type 0 4 2041 46 DoubleBitMask< BitMaskNative >::get_class_type 0 1 651 0
71
static TypeHandle DoubleBitMask< BitMaskNative >::get_class_type(void);

1629 14 ~DoubleBitMask 0 516 2041 46 DoubleBitMask< BitMaskNative >::~DoubleBitMask 0 0 0
53
DoubleBitMask< BitMaskNative >::~DoubleBitMask(void);

1630 13 DoubleBitMask 0 260 2043 51 DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask 0 3 652 653 654 0
269
constexpr DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(void) = default;
DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(PyObject *init_value);
inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(DoubleBitMask< DoubleBitMaskNative > const &) = default;

1631 6 all_on 0 4 2043 44 DoubleBitMask< DoubleBitMaskNative >::all_on 0 1 655 0
102
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_on(void);

1632 7 all_off 0 4 2043 45 DoubleBitMask< DoubleBitMaskNative >::all_off 0 1 656 0
103
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_off(void);

1633 8 lower_on 0 4 2043 46 DoubleBitMask< DoubleBitMaskNative >::lower_on 0 1 657 0
111
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::lower_on(int on_bits);

1634 3 bit 0 4 2043 41 DoubleBitMask< DoubleBitMaskNative >::bit 0 1 658 0
104
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::bit(int index);

1635 5 range 0 4 2043 43 DoubleBitMask< DoubleBitMaskNative >::range 0 1 659 0
118
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::range(int low_bit, int size);

1636 16 has_max_num_bits 0 4 2043 54 DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits 0 1 660 0
83
static constexpr bool DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits(void);

1637 16 get_max_num_bits 0 4 2043 54 DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits 0 1 661 0
82
static constexpr int DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits(void);

1638 12 get_num_bits 0 4 2043 50 DoubleBitMask< DoubleBitMaskNative >::get_num_bits 0 1 662 0
77
constexpr int DoubleBitMask< DoubleBitMaskNative >::get_num_bits(void) const;

1639 7 get_bit 0 4 2043 45 DoubleBitMask< DoubleBitMaskNative >::get_bit 0 1 663 0
75
inline bool DoubleBitMask< DoubleBitMaskNative >::get_bit(int index) const;

1640 7 set_bit 0 4 2043 45 DoubleBitMask< DoubleBitMaskNative >::set_bit 0 1 664 0
69
inline void DoubleBitMask< DoubleBitMaskNative >::set_bit(int index);

1641 9 clear_bit 0 4 2043 47 DoubleBitMask< DoubleBitMaskNative >::clear_bit 0 1 665 0
71
inline void DoubleBitMask< DoubleBitMaskNative >::clear_bit(int index);

1642 10 set_bit_to 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::set_bit_to 0 1 666 0
84
inline void DoubleBitMask< DoubleBitMaskNative >::set_bit_to(int index, bool value);

1643 7 is_zero 0 4 2043 45 DoubleBitMask< DoubleBitMaskNative >::is_zero 0 1 667 0
70
inline bool DoubleBitMask< DoubleBitMaskNative >::is_zero(void) const;

1644 9 is_all_on 0 4 2043 47 DoubleBitMask< DoubleBitMaskNative >::is_all_on 0 1 668 0
72
inline bool DoubleBitMask< DoubleBitMaskNative >::is_all_on(void) const;

1645 7 extract 0 4 2043 45 DoubleBitMask< DoubleBitMaskNative >::extract 0 1 669 0
91
inline uint64_t DoubleBitMask< DoubleBitMaskNative >::extract(int low_bit, int size) const;

1646 5 store 0 4 2043 43 DoubleBitMask< DoubleBitMaskNative >::store 0 1 670 0
95
inline void DoubleBitMask< DoubleBitMaskNative >::store(uint64_t value, int low_bit, int size);

1647 10 has_any_of 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::has_any_of 0 1 671 0
90
inline bool DoubleBitMask< DoubleBitMaskNative >::has_any_of(int low_bit, int size) const;

1648 10 has_all_of 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::has_all_of 0 1 672 0
90
inline bool DoubleBitMask< DoubleBitMaskNative >::has_all_of(int low_bit, int size) const;

1649 9 set_range 0 4 2043 47 DoubleBitMask< DoubleBitMaskNative >::set_range 0 1 673 0
83
inline void DoubleBitMask< DoubleBitMaskNative >::set_range(int low_bit, int size);

1650 11 clear_range 0 4 2043 49 DoubleBitMask< DoubleBitMaskNative >::clear_range 0 1 674 0
85
inline void DoubleBitMask< DoubleBitMaskNative >::clear_range(int low_bit, int size);

1651 12 set_range_to 0 4 2043 50 DoubleBitMask< DoubleBitMaskNative >::set_range_to 0 1 675 0
98
inline void DoubleBitMask< DoubleBitMaskNative >::set_range_to(bool value, int low_bit, int size);

1652 15 get_num_on_bits 0 4 2043 53 DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits 0 1 676 0
77
inline int DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits(void) const;

1653 16 get_num_off_bits 0 4 2043 54 DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits 0 1 677 0
78
inline int DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits(void) const;

1654 17 get_lowest_on_bit 0 4 2043 55 DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit 0 1 678 0
79
inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit(void) const;

1655 18 get_lowest_off_bit 0 4 2043 56 DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit 0 1 679 0
80
inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit(void) const;

1656 18 get_highest_on_bit 0 4 2043 56 DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit 0 1 680 0
80
inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit(void) const;

1657 19 get_highest_off_bit 0 4 2043 57 DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit 0 1 681 0
81
inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit(void) const;

1658 29 get_next_higher_different_bit 0 4 2043 67 DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit 0 1 682 0
98
inline int DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit(int low_bit) const;

1659 15 invert_in_place 0 4 2043 53 DoubleBitMask< DoubleBitMaskNative >::invert_in_place 0 1 683 0
72
inline void DoubleBitMask< DoubleBitMaskNative >::invert_in_place(void);

1660 18 has_bits_in_common 0 4 2043 56 DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common 0 1 684 0
126
inline bool DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1661 5 clear 0 4 2043 43 DoubleBitMask< DoubleBitMaskNative >::clear 0 1 685 0
62
inline void DoubleBitMask< DoubleBitMaskNative >::clear(void);

1662 6 output 0 4 2043 44 DoubleBitMask< DoubleBitMaskNative >::output 0 1 686 0
75
void DoubleBitMask< DoubleBitMaskNative >::output(std::ostream &out) const;

1663 13 output_binary 0 4 2043 51 DoubleBitMask< DoubleBitMaskNative >::output_binary 0 1 687 0
104
void DoubleBitMask< DoubleBitMaskNative >::output_binary(std::ostream &out, int spaces_every = 4) const;

1664 10 output_hex 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::output_hex 0 1 688 0
101
void DoubleBitMask< DoubleBitMaskNative >::output_hex(std::ostream &out, int spaces_every = 4) const;

1665 5 write 0 4 2043 43 DoubleBitMask< DoubleBitMaskNative >::write 0 1 689 0
96
void DoubleBitMask< DoubleBitMaskNative >::write(std::ostream &out, int indent_level = 0) const;

1666 11 operator == 0 4 2043 49 DoubleBitMask< DoubleBitMaskNative >::operator == 0 1 690 0
119
inline bool DoubleBitMask< DoubleBitMaskNative >::operator ==(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1667 11 operator != 0 4 2043 49 DoubleBitMask< DoubleBitMaskNative >::operator != 0 1 691 0
119
inline bool DoubleBitMask< DoubleBitMaskNative >::operator !=(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1668 10 operator < 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::operator < 0 1 692 0
118
inline bool DoubleBitMask< DoubleBitMaskNative >::operator <(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1669 10 compare_to 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::compare_to 0 1 693 0
117
inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1670 10 operator & 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::operator & 0 1 694 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator &(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1671 10 operator | 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::operator | 0 1 695 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator |(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1672 10 operator ^ 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::operator ^ 0 1 696 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ^(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1673 10 operator ~ 0 68 2043 48 DoubleBitMask< DoubleBitMaskNative >::operator ~ 0 1 697 0
105
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ~(void) const;

1674 11 operator << 0 4 2043 49 DoubleBitMask< DoubleBitMaskNative >::operator << 0 1 698 0
111
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator <<(int shift) const;

1675 11 operator >> 0 4 2043 49 DoubleBitMask< DoubleBitMaskNative >::operator >> 0 1 699 0
111
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator >>(int shift) const;

1676 11 operator &= 0 4 2043 49 DoubleBitMask< DoubleBitMaskNative >::operator &= 0 1 700 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator &=(DoubleBitMask< DoubleBitMaskNative > const &other);

1677 11 operator |= 0 4 2043 49 DoubleBitMask< DoubleBitMaskNative >::operator |= 0 1 701 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator |=(DoubleBitMask< DoubleBitMaskNative > const &other);

1678 11 operator ^= 0 4 2043 49 DoubleBitMask< DoubleBitMaskNative >::operator ^= 0 1 702 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator ^=(DoubleBitMask< DoubleBitMaskNative > const &other);

1679 12 operator <<= 0 4 2043 50 DoubleBitMask< DoubleBitMaskNative >::operator <<= 0 1 703 0
74
inline void DoubleBitMask< DoubleBitMaskNative >::operator <<=(int shift);

1680 12 operator >>= 0 4 2043 50 DoubleBitMask< DoubleBitMaskNative >::operator >>= 0 1 704 0
74
inline void DoubleBitMask< DoubleBitMaskNative >::operator >>=(int shift);

1681 8 __bool__ 0 4 2043 46 DoubleBitMask< DoubleBitMaskNative >::__bool__ 0 1 705 0
64
bool DoubleBitMask< DoubleBitMaskNative >::__bool__(void) const;

1682 7 __int__ 0 4 2043 45 DoubleBitMask< DoubleBitMaskNative >::__int__ 0 1 706 0
68
PyObject *DoubleBitMask< DoubleBitMaskNative >::__int__(void) const;

1683 10 __reduce__ 0 4 2043 48 DoubleBitMask< DoubleBitMaskNative >::__reduce__ 0 1 707 0
81
PyObject *DoubleBitMask< DoubleBitMaskNative >::__reduce__(PyObject *self) const;

1684 14 get_class_type 0 4 2043 52 DoubleBitMask< DoubleBitMaskNative >::get_class_type 0 1 708 0
77
static TypeHandle DoubleBitMask< DoubleBitMaskNative >::get_class_type(void);

1685 14 ~DoubleBitMask 0 516 2043 52 DoubleBitMask< DoubleBitMaskNative >::~DoubleBitMask 0 0 0
59
DoubleBitMask< DoubleBitMaskNative >::~DoubleBitMask(void);

1686 6 lstick 0 4 2046 21 GamepadButton::lstick 0 1 711 0
48
static ButtonHandle GamepadButton::lstick(void);

1687 6 rstick 0 4 2046 21 GamepadButton::rstick 0 1 712 0
48
static ButtonHandle GamepadButton::rstick(void);

1688 9 lshoulder 0 4 2046 24 GamepadButton::lshoulder 0 1 713 0
51
static ButtonHandle GamepadButton::lshoulder(void);

1689 9 rshoulder 0 4 2046 24 GamepadButton::rshoulder 0 1 714 0
51
static ButtonHandle GamepadButton::rshoulder(void);

1690 8 ltrigger 0 4 2046 23 GamepadButton::ltrigger 0 1 715 0
50
static ButtonHandle GamepadButton::ltrigger(void);

1691 8 rtrigger 0 4 2046 23 GamepadButton::rtrigger 0 1 716 0
50
static ButtonHandle GamepadButton::rtrigger(void);

1692 5 lgrip 0 4 2046 20 GamepadButton::lgrip 0 1 717 0
47
static ButtonHandle GamepadButton::lgrip(void);

1693 5 rgrip 0 4 2046 20 GamepadButton::rgrip 0 1 718 0
47
static ButtonHandle GamepadButton::rgrip(void);

1694 9 dpad_left 0 4 2046 24 GamepadButton::dpad_left 0 1 719 0
51
static ButtonHandle GamepadButton::dpad_left(void);

1695 10 dpad_right 0 4 2046 25 GamepadButton::dpad_right 0 1 720 0
52
static ButtonHandle GamepadButton::dpad_right(void);

1696 7 dpad_up 0 4 2046 22 GamepadButton::dpad_up 0 1 721 0
49
static ButtonHandle GamepadButton::dpad_up(void);

1697 9 dpad_down 0 4 2046 24 GamepadButton::dpad_down 0 1 722 0
51
static ButtonHandle GamepadButton::dpad_down(void);

1698 4 back 0 4 2046 19 GamepadButton::back 0 1 723 0
46
static ButtonHandle GamepadButton::back(void);

1699 5 guide 0 4 2046 20 GamepadButton::guide 0 1 724 0
47
static ButtonHandle GamepadButton::guide(void);

1700 5 start 0 4 2046 20 GamepadButton::start 0 1 725 0
47
static ButtonHandle GamepadButton::start(void);

1701 4 next 0 4 2046 19 GamepadButton::next 0 1 726 0
46
static ButtonHandle GamepadButton::next(void);

1702 8 previous 0 4 2046 23 GamepadButton::previous 0 1 727 0
50
static ButtonHandle GamepadButton::previous(void);

1703 6 face_a 0 4 2046 21 GamepadButton::face_a 0 1 728 0
48
static ButtonHandle GamepadButton::face_a(void);

1704 6 face_b 0 4 2046 21 GamepadButton::face_b 0 1 729 0
48
static ButtonHandle GamepadButton::face_b(void);

1705 6 face_c 0 4 2046 21 GamepadButton::face_c 0 1 730 0
48
static ButtonHandle GamepadButton::face_c(void);

1706 6 face_x 0 4 2046 21 GamepadButton::face_x 0 1 731 0
48
static ButtonHandle GamepadButton::face_x(void);

1707 6 face_y 0 4 2046 21 GamepadButton::face_y 0 1 732 0
48
static ButtonHandle GamepadButton::face_y(void);

1708 6 face_z 0 4 2046 21 GamepadButton::face_z 0 1 733 0
48
static ButtonHandle GamepadButton::face_z(void);

1709 6 face_1 0 4 2046 21 GamepadButton::face_1 0 1 734 0
48
static ButtonHandle GamepadButton::face_1(void);

1710 6 face_2 0 4 2046 21 GamepadButton::face_2 0 1 735 0
48
static ButtonHandle GamepadButton::face_2(void);

1711 7 trigger 0 4 2046 22 GamepadButton::trigger 0 1 736 74
// Flight stick buttons, takes zero-based index.  First is always trigger.
49
static ButtonHandle GamepadButton::trigger(void);

1712 8 joystick 0 4 2046 23 GamepadButton::joystick 0 1 737 169
/**
 * Returns the ButtonHandle associated with the particular numbered joystick
 * button (zero-based), if there is one, or ButtonHandle::none() if there is
 * not.
 */
63
static ButtonHandle GamepadButton::joystick(int button_number);

1713 6 hat_up 0 4 2046 21 GamepadButton::hat_up 0 1 738 0
48
static ButtonHandle GamepadButton::hat_up(void);

1714 8 hat_down 0 4 2046 23 GamepadButton::hat_down 0 1 739 0
50
static ButtonHandle GamepadButton::hat_down(void);

1715 8 hat_left 0 4 2046 23 GamepadButton::hat_left 0 1 740 0
50
static ButtonHandle GamepadButton::hat_left(void);

1716 9 hat_right 0 4 2046 24 GamepadButton::hat_right 0 1 741 0
51
static ButtonHandle GamepadButton::hat_right(void);

1717 13 GamepadButton 0 260 2046 28 GamepadButton::GamepadButton 0 2 709 710 0
122
inline GamepadButton::GamepadButton(void) = default;
inline GamepadButton::GamepadButton(GamepadButton const &) = default;

1718 14 ~GamepadButton 0 516 2046 29 GamepadButton::~GamepadButton 0 0 0
36
GamepadButton::~GamepadButton(void);

1719 9 ascii_key 0 4 2049 25 KeyboardButton::ascii_key 0 1 744 144
/**
 * Returns the ButtonHandle associated with the particular ASCII character, if
 * there is one, or ButtonHandle::none() if there is not.
 */
69
static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent);

1720 5 space 0 4 2049 21 KeyboardButton::space 0 1 745 0
48
static ButtonHandle KeyboardButton::space(void);

1721 9 backspace 0 4 2049 25 KeyboardButton::backspace 0 1 746 0
52
static ButtonHandle KeyboardButton::backspace(void);

1722 3 tab 0 4 2049 19 KeyboardButton::tab 0 1 747 0
46
static ButtonHandle KeyboardButton::tab(void);

1723 5 enter 0 4 2049 21 KeyboardButton::enter 0 1 748 0
48
static ButtonHandle KeyboardButton::enter(void);

1724 6 escape 0 4 2049 22 KeyboardButton::escape 0 1 749 0
49
static ButtonHandle KeyboardButton::escape(void);

1725 2 f1 0 4 2049 18 KeyboardButton::f1 0 1 750 0
45
static ButtonHandle KeyboardButton::f1(void);

1726 2 f2 0 4 2049 18 KeyboardButton::f2 0 1 751 0
45
static ButtonHandle KeyboardButton::f2(void);

1727 2 f3 0 4 2049 18 KeyboardButton::f3 0 1 752 0
45
static ButtonHandle KeyboardButton::f3(void);

1728 2 f4 0 4 2049 18 KeyboardButton::f4 0 1 753 0
45
static ButtonHandle KeyboardButton::f4(void);

1729 2 f5 0 4 2049 18 KeyboardButton::f5 0 1 754 0
45
static ButtonHandle KeyboardButton::f5(void);

1730 2 f6 0 4 2049 18 KeyboardButton::f6 0 1 755 0
45
static ButtonHandle KeyboardButton::f6(void);

1731 2 f7 0 4 2049 18 KeyboardButton::f7 0 1 756 0
45
static ButtonHandle KeyboardButton::f7(void);

1732 2 f8 0 4 2049 18 KeyboardButton::f8 0 1 757 0
45
static ButtonHandle KeyboardButton::f8(void);

1733 2 f9 0 4 2049 18 KeyboardButton::f9 0 1 758 0
45
static ButtonHandle KeyboardButton::f9(void);

1734 3 f10 0 4 2049 19 KeyboardButton::f10 0 1 759 0
46
static ButtonHandle KeyboardButton::f10(void);

1735 3 f11 0 4 2049 19 KeyboardButton::f11 0 1 760 0
46
static ButtonHandle KeyboardButton::f11(void);

1736 3 f12 0 4 2049 19 KeyboardButton::f12 0 1 761 0
46
static ButtonHandle KeyboardButton::f12(void);

1737 3 f13 0 4 2049 19 KeyboardButton::f13 0 1 762 59
// PC keyboards don't have these four buttons, but Macs do.
46
static ButtonHandle KeyboardButton::f13(void);

1738 3 f14 0 4 2049 19 KeyboardButton::f14 0 1 763 0
46
static ButtonHandle KeyboardButton::f14(void);

1739 3 f15 0 4 2049 19 KeyboardButton::f15 0 1 764 0
46
static ButtonHandle KeyboardButton::f15(void);

1740 3 f16 0 4 2049 19 KeyboardButton::f16 0 1 765 0
46
static ButtonHandle KeyboardButton::f16(void);

1741 4 left 0 4 2049 20 KeyboardButton::left 0 1 766 0
47
static ButtonHandle KeyboardButton::left(void);

1742 5 right 0 4 2049 21 KeyboardButton::right 0 1 767 0
48
static ButtonHandle KeyboardButton::right(void);

1743 2 up 0 4 2049 18 KeyboardButton::up 0 1 768 0
45
static ButtonHandle KeyboardButton::up(void);

1744 4 down 0 4 2049 20 KeyboardButton::down 0 1 769 0
47
static ButtonHandle KeyboardButton::down(void);

1745 7 page_up 0 4 2049 23 KeyboardButton::page_up 0 1 770 0
50
static ButtonHandle KeyboardButton::page_up(void);

1746 9 page_down 0 4 2049 25 KeyboardButton::page_down 0 1 771 0
52
static ButtonHandle KeyboardButton::page_down(void);

1747 4 home 0 4 2049 20 KeyboardButton::home 0 1 772 0
47
static ButtonHandle KeyboardButton::home(void);

1748 3 end 0 4 2049 19 KeyboardButton::end 0 1 773 0
46
static ButtonHandle KeyboardButton::end(void);

1749 6 insert 0 4 2049 22 KeyboardButton::insert 0 1 774 0
49
static ButtonHandle KeyboardButton::insert(void);

1750 3 del 0 4 2049 19 KeyboardButton::del 0 1 775 27
// delete is a C++ keyword.
46
static ButtonHandle KeyboardButton::del(void);

1751 4 help 0 4 2049 20 KeyboardButton::help 0 1 776 27
// delete is a C++ keyword.
47
static ButtonHandle KeyboardButton::help(void);

1752 4 menu 0 4 2049 20 KeyboardButton::menu 0 1 777 0
47
static ButtonHandle KeyboardButton::menu(void);

1753 5 shift 0 4 2049 21 KeyboardButton::shift 0 1 778 0
48
static ButtonHandle KeyboardButton::shift(void);

1754 7 control 0 4 2049 23 KeyboardButton::control 0 1 779 0
50
static ButtonHandle KeyboardButton::control(void);

1755 3 alt 0 4 2049 19 KeyboardButton::alt 0 1 780 0
46
static ButtonHandle KeyboardButton::alt(void);

1756 4 meta 0 4 2049 20 KeyboardButton::meta 0 1 781 0
47
static ButtonHandle KeyboardButton::meta(void);

1757 9 caps_lock 0 4 2049 25 KeyboardButton::caps_lock 0 1 782 0
52
static ButtonHandle KeyboardButton::caps_lock(void);

1758 10 shift_lock 0 4 2049 26 KeyboardButton::shift_lock 0 1 783 0
53
static ButtonHandle KeyboardButton::shift_lock(void);

1759 8 num_lock 0 4 2049 24 KeyboardButton::num_lock 0 1 784 0
51
static ButtonHandle KeyboardButton::num_lock(void);

1760 11 scroll_lock 0 4 2049 27 KeyboardButton::scroll_lock 0 1 785 0
54
static ButtonHandle KeyboardButton::scroll_lock(void);

1761 12 print_screen 0 4 2049 28 KeyboardButton::print_screen 0 1 786 0
55
static ButtonHandle KeyboardButton::print_screen(void);

1762 5 pause 0 4 2049 21 KeyboardButton::pause 0 1 787 0
48
static ButtonHandle KeyboardButton::pause(void);

1763 6 lshift 0 4 2049 22 KeyboardButton::lshift 0 1 788 0
49
static ButtonHandle KeyboardButton::lshift(void);

1764 6 rshift 0 4 2049 22 KeyboardButton::rshift 0 1 789 0
49
static ButtonHandle KeyboardButton::rshift(void);

1765 8 lcontrol 0 4 2049 24 KeyboardButton::lcontrol 0 1 790 0
51
static ButtonHandle KeyboardButton::lcontrol(void);

1766 8 rcontrol 0 4 2049 24 KeyboardButton::rcontrol 0 1 791 0
51
static ButtonHandle KeyboardButton::rcontrol(void);

1767 4 lalt 0 4 2049 20 KeyboardButton::lalt 0 1 792 0
47
static ButtonHandle KeyboardButton::lalt(void);

1768 4 ralt 0 4 2049 20 KeyboardButton::ralt 0 1 793 0
47
static ButtonHandle KeyboardButton::ralt(void);

1769 5 lmeta 0 4 2049 21 KeyboardButton::lmeta 0 1 794 0
48
static ButtonHandle KeyboardButton::lmeta(void);

1770 5 rmeta 0 4 2049 21 KeyboardButton::rmeta 0 1 795 0
48
static ButtonHandle KeyboardButton::rmeta(void);

1771 14 KeyboardButton 0 260 2049 30 KeyboardButton::KeyboardButton 0 2 742 743 0
127
inline KeyboardButton::KeyboardButton(void) = default;
inline KeyboardButton::KeyboardButton(KeyboardButton const &) = default;

1772 15 ~KeyboardButton 0 516 2049 31 KeyboardButton::~KeyboardButton 0 0 0
38
KeyboardButton::~KeyboardButton(void);

1773 13 load_prc_file 0 1 0 13 load_prc_file 0 1 982 1206
/**
 * A convenience function for loading explicit prc files from a disk file or
 * from within a multifile (via the virtual file system).  Save the return
 * value and pass it to unload_prc_file() if you ever want to unload this file
 * later.
 *
 * The filename is first searched along the default prc search path, and then
 * also along the model path, for convenience.
 *
 * This function is defined in putil instead of in dtool with the read of the
 * prc stuff, so that it can take advantage of the virtual file system (which
 * is defined in express), and the model path (which is in putil).
 */

/**
 * A convenience function for loading explicit prc files from a disk file or
 * from within a multifile (via the virtual file system).  Save the return
 * value and pass it to unload_prc_file() if you ever want to unload this file
 * later.
 *
 * The filename is first searched along the default prc search path, and then
 * also along the model path, for convenience.
 *
 * This function is defined in putil instead of in dtool with the read of the
 * prc stuff, so that it can take advantage of the virtual file system (which
 * is defined in express), and the model path (which is in putil).
 */
52
ConfigPage *load_prc_file(Filename const &filename);

1774 18 load_prc_file_data 0 1 0 18 load_prc_file_data 0 1 983 794
/**
 * Another convenience function to load a prc file from an explicit string,
 * which represents the contents of the prc file.
 *
 * The first parameter is an arbitrary name to assign to this in-memory prc
 * file.  Supply a filename if the data was read from a file, or use any other
 * name that is meaningful to you.  The name is only used when the set of
 * loaded prc files is listed.
 */

/**
 * Another convenience function to load a prc file from an explicit string,
 * which represents the contents of the prc file.
 *
 * The first parameter is an arbitrary name to assign to this in-memory prc
 * file.  Supply a filename if the data was read from a file, or use any other
 * name that is meaningful to you.  The name is only used when the set of
 * loaded prc files is listed.
 */
81
ConfigPage *load_prc_file_data(std::string const &name, std::string const &data);

1775 15 unload_prc_file 0 1 0 15 unload_prc_file 0 1 984 0
39
bool unload_prc_file(ConfigPage *page);

1776 18 hash_prc_variables 0 1 0 18 hash_prc_variables 0 1 985 0
39
void hash_prc_variables(HashVal &hash);

1777 15 ModifierButtons 0 260 2050 32 ModifierButtons::ModifierButtons 0 2 796 797 22
/**
 *
 */

/**
 *
 */
102
ModifierButtons::ModifierButtons(void);
ModifierButtons::ModifierButtons(ModifierButtons const &copy);

1778 16 ~ModifierButtons 0 516 2050 33 ModifierButtons::~ModifierButtons 0 0 10
/**
 *
 */
40
ModifierButtons::~ModifierButtons(void);

1779 10 operator = 0 4 2050 27 ModifierButtons::operator = 0 1 798 0
69
inline void ModifierButtons::operator =(ModifierButtons const &copy);

1780 11 operator == 0 4 2050 28 ModifierButtons::operator == 0 1 799 0
77
inline bool ModifierButtons::operator ==(ModifierButtons const &other) const;

1781 11 operator != 0 4 2050 28 ModifierButtons::operator != 0 1 800 0
77
inline bool ModifierButtons::operator !=(ModifierButtons const &other) const;

1782 10 operator < 0 4 2050 27 ModifierButtons::operator < 0 1 801 0
76
inline bool ModifierButtons::operator <(ModifierButtons const &other) const;

1783 10 operator & 0 4 2050 27 ModifierButtons::operator & 0 1 802 0
87
inline ModifierButtons ModifierButtons::operator &(ModifierButtons const &other) const;

1784 10 operator | 0 4 2050 27 ModifierButtons::operator | 0 1 803 0
87
inline ModifierButtons ModifierButtons::operator |(ModifierButtons const &other) const;

1785 11 operator &= 0 4 2050 28 ModifierButtons::operator &= 0 1 804 0
64
void ModifierButtons::operator &=(ModifierButtons const &other);

1786 11 operator |= 0 4 2050 28 ModifierButtons::operator |= 0 1 805 0
64
void ModifierButtons::operator |=(ModifierButtons const &other);

1787 15 set_button_list 0 4 2050 32 ModifierButtons::set_button_list 0 1 806 374
/**
 * Sets the list of buttons to watch to be the same as that of the other
 * ModifierButtons object.  This makes the lists pointer equivalent (until one
 * or the other is later modified).
 *
 * This will preserve the state of any button that was on the original list
 * and is also on the new lists.  Any other buttons will get reset to the
 * default state of "up".
 */
68
void ModifierButtons::set_button_list(ModifierButtons const &other);

1788 7 matches 0 4 2050 24 ModifierButtons::matches 0 1 807 232
/**
 * Returns true if the set of buttons indicated as down by this
 * ModifierButtons object is the same set of buttons indicated as down by the
 * other ModifierButtons object.  The buttons indicated as up are not
 * relevant.
 */
66
bool ModifierButtons::matches(ModifierButtons const &other) const;

1789 10 add_button 0 4 2050 27 ModifierButtons::add_button 0 1 808 248
/**
 * Adds the indicated button to the set of buttons that will be monitored for
 * upness and downness.  Returns true if the button was added, false if it was
 * already being monitored or if too many buttons are currently being
 * monitored.
 */
54
bool ModifierButtons::add_button(ButtonHandle button);

1790 10 has_button 0 4 2050 27 ModifierButtons::has_button 0 1 809 109
/**
 * Returns true if the indicated button is in the set of buttons being
 * monitored, false otherwise.
 */
60
bool ModifierButtons::has_button(ButtonHandle button) const;

1791 13 remove_button 0 4 2050 30 ModifierButtons::remove_button 0 1 810 313
/**
 * Removes the indicated button from the set of buttons being monitored.
 * Returns true if the button was removed, false if it was not being monitored
 * in the first place.
 *
 * Unlike the other methods, you cannot remove a button by removing its alias;
 * you have to remove exactly the button itself.
 */
57
bool ModifierButtons::remove_button(ButtonHandle button);

1792 15 get_num_buttons 0 4 2050 32 ModifierButtons::get_num_buttons 0 1 811 143
/**
 * Returns the number of buttons that the ModifierButtons object is monitoring
 * (e.g.  the number of buttons passed to add_button()).
 */
56
inline int ModifierButtons::get_num_buttons(void) const;

1793 10 get_button 0 4 2050 27 ModifierButtons::get_button 0 1 812 185
/**
 * Returns the nth button that the ModifierButtons object is monitoring (the
 * nth button passed to add_button()).  This must be in the range 0 <= index <
 * get_num_buttons().
 */
65
inline ButtonHandle ModifierButtons::get_button(int index) const;

1794 11 button_down 0 4 2050 28 ModifierButtons::button_down 0 1 813 305
/**
 * Records that a particular button has been pressed.  If the given button is
 * one of the buttons that is currently being monitored, this will update the
 * internal state appropriately; otherwise, it will do nothing.  Returns true
 * if the button is one that was monitored, or false otherwise.
 */
55
bool ModifierButtons::button_down(ButtonHandle button);

1795 9 button_up 0 4 2050 26 ModifierButtons::button_up 0 1 814 306
/**
 * Records that a particular button has been released.  If the given button is
 * one of the buttons that is currently being monitored, this will update the
 * internal state appropriately; otherwise, it will do nothing.  Returns true
 * if the button is one that was monitored, or false otherwise.
 */
53
bool ModifierButtons::button_up(ButtonHandle button);

1796 14 all_buttons_up 0 4 2050 31 ModifierButtons::all_buttons_up 0 1 815 66
/**
 * Marks all monitored buttons as being in the "up" state.
 */
50
inline void ModifierButtons::all_buttons_up(void);

1797 7 is_down 0 4 2050 24 ModifierButtons::is_down 0 2 816 817 264
/**
 * Returns true if the indicated button is known to be down, or false if it is
 * known to be up.
 */

/**
 * Returns true if the indicated button is known to be down, or false if it is
 * known to be up or if it is not in the set of buttons being tracked.
 */
112
bool ModifierButtons::is_down(ButtonHandle button) const;
inline bool ModifierButtons::is_down(int index) const;

1798 11 is_any_down 0 4 2050 28 ModifierButtons::is_any_down 0 1 818 109
/**
 * Returns true if any of the tracked button are known to be down, or false if
 * all of them are up.
 */
53
inline bool ModifierButtons::is_any_down(void) const;

1799 10 get_prefix 0 4 2050 27 ModifierButtons::get_prefix 0 1 819 150
/**
 * Returns a string which can be used to prefix any button name or event name
 * with the unique set of modifier buttons currently being held.
 */
52
std::string ModifierButtons::get_prefix(void) const;

1800 6 output 0 4 2050 23 ModifierButtons::output 0 1 820 69
/**
 * Writes a one-line summary of the buttons known to be down.
 */
54
void ModifierButtons::output(std::ostream &out) const;

1801 5 write 0 4 2050 22 ModifierButtons::write 0 1 821 123
/**
 * Writes a multi-line summary including all of the buttons being monitored
 * and which ones are known to be down.
 */
53
void ModifierButtons::write(std::ostream &out) const;

1802 6 button 0 4 2051 19 MouseButton::button 0 1 824 166
/**
 * Returns the ButtonHandle associated with the particular numbered mouse
 * button (zero-based), if there is one, or ButtonHandle::none() if there is
 * not.
 */
59
static ButtonHandle MouseButton::button(int button_number);

1803 3 one 0 4 2051 16 MouseButton::one 0 1 825 75
/**
 * Returns the ButtonHandle associated with the first mouse button.
 */
43
static ButtonHandle MouseButton::one(void);

1804 3 two 0 4 2051 16 MouseButton::two 0 1 826 76
/**
 * Returns the ButtonHandle associated with the second mouse button.
 */
43
static ButtonHandle MouseButton::two(void);

1805 5 three 0 4 2051 18 MouseButton::three 0 1 827 75
/**
 * Returns the ButtonHandle associated with the third mouse button.
 */
45
static ButtonHandle MouseButton::three(void);

1806 4 four 0 4 2051 17 MouseButton::four 0 1 828 76
/**
 * Returns the ButtonHandle associated with the fourth mouse button.
 */
44
static ButtonHandle MouseButton::four(void);

1807 4 five 0 4 2051 17 MouseButton::five 0 1 829 75
/**
 * Returns the ButtonHandle associated with the fifth mouse button.
 */
44
static ButtonHandle MouseButton::five(void);

1808 8 wheel_up 0 4 2051 21 MouseButton::wheel_up 0 1 830 98
/**
 * Returns the ButtonHandle generated when the mouse wheel is rolled one notch
 * upwards.
 */
48
static ButtonHandle MouseButton::wheel_up(void);

1809 10 wheel_down 0 4 2051 23 MouseButton::wheel_down 0 1 831 100
/**
 * Returns the ButtonHandle generated when the mouse wheel is rolled one notch
 * downwards.
 */
50
static ButtonHandle MouseButton::wheel_down(void);

1810 10 wheel_left 0 4 2051 23 MouseButton::wheel_left 0 1 832 148
/**
 * Returns the ButtonHandle generated when the mouse is scrolled to the left.
 * Usually, you'll only find the horizontal scroll on laptops.
 */
50
static ButtonHandle MouseButton::wheel_left(void);

1811 11 wheel_right 0 4 2051 24 MouseButton::wheel_right 0 1 833 149
/**
 * Returns the ButtonHandle generated when the mouse is scrolled to the right.
 * Usually, you'll only find the horizontal scroll on laptops.
 */
51
static ButtonHandle MouseButton::wheel_right(void);

1812 15 is_mouse_button 0 4 2051 28 MouseButton::is_mouse_button 0 1 834 117
/**
 * Returns true if the indicated ButtonHandle is a mouse button, false if it
 * is some other kind of button.
 */
62
static bool MouseButton::is_mouse_button(ButtonHandle button);

1813 11 MouseButton 0 260 2051 24 MouseButton::MouseButton 0 2 822 823 0
112
inline MouseButton::MouseButton(void) = default;
inline MouseButton::MouseButton(MouseButton const &) = default;

1814 12 ~MouseButton 0 516 2051 25 MouseButton::~MouseButton 0 0 0
32
MouseButton::~MouseButton(void);

1815 18 get_node_ref_count 0 4 2052 44 NodeCachedReferenceCount::get_node_ref_count 0 1 835 47
/**
 * Returns the current reference count.
 */
68
inline int NodeCachedReferenceCount::get_node_ref_count(void) const;

1816 8 node_ref 0 4 2052 34 NodeCachedReferenceCount::node_ref 0 1 836 349
/**
 * Explicitly increments the reference count.
 *
 * This function is const, even though it changes the object, because
 * generally fiddling with an object's reference count isn't considered part
 * of fiddling with the object.  An object might be const in other ways, but
 * we still need to accurately count the number of references to it.
 */
59
inline void NodeCachedReferenceCount::node_ref(void) const;

1817 10 node_unref 0 4 2052 36 NodeCachedReferenceCount::node_unref 0 1 837 201
/**
 * Explicitly decrements the node reference count and the normal reference
 * count simultaneously.
 *
 * The return value is true if the new reference count is nonzero, false if it
 * is zero.
 */
61
inline bool NodeCachedReferenceCount::node_unref(void) const;

1818 24 test_ref_count_integrity 0 4 2052 50 NodeCachedReferenceCount::test_ref_count_integrity 0 1 838 97
/**
 * Does some easy checks to make sure that the reference count isn't
 * completely bogus.
 */
75
inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const;

1819 19 get_referenced_bits 0 4 2052 45 NodeCachedReferenceCount::get_referenced_bits 0 1 839 293
/**
 * Returns the union of the values defined in the Referenced enum that
 * represents the various things that appear to be holding a pointer to this
 * object.
 *
 * If R_node is included, at least one node is holding a pointer; if R_cache
 * is included, at least one cache element is.
 */
69
inline int NodeCachedReferenceCount::get_referenced_bits(void) const;

1820 14 get_class_type 0 4 2052 40 NodeCachedReferenceCount::get_class_type 0 1 840 0
65
static TypeHandle NodeCachedReferenceCount::get_class_type(void);

1821 11 SparseArray 0 260 2054 24 SparseArray::SparseArray 0 3 841 842 843 22
/**
 *
 */

/**
 *
 */
150
inline SparseArray::SparseArray(void);
SparseArray::SparseArray(BitArray const &from);
inline SparseArray::SparseArray(SparseArray const &) = default;

1822 6 all_on 0 4 2054 19 SparseArray::all_on 0 1 844 72
/**
 * Returns a SparseArray with an infinite array of bits, all on.
 */
52
static inline SparseArray SparseArray::all_on(void);

1823 7 all_off 0 4 2054 20 SparseArray::all_off 0 1 845 56
/**
 * Returns a SparseArray whose bits are all off.
 */
53
static inline SparseArray SparseArray::all_off(void);

1824 8 lower_on 0 4 2054 21 SparseArray::lower_on 0 1 846 65
/**
 * Returns a SparseArray whose lower on_bits bits are on.
 */
61
static inline SparseArray SparseArray::lower_on(int on_bits);

1825 3 bit 0 4 2054 16 SparseArray::bit 0 1 847 64
/**
 * Returns a SparseArray with only the indicated bit on.
 */
54
static inline SparseArray SparseArray::bit(int index);

1826 5 range 0 4 2054 18 SparseArray::range 0 1 848 79
/**
 * Returns a SparseArray whose size bits, beginning at low_bit, are on.
 */
68
static inline SparseArray SparseArray::range(int low_bit, int size);

1827 16 has_max_num_bits 0 4 2054 29 SparseArray::has_max_num_bits 0 1 849 393
/**
 * Returns true if there is a maximum number of bits that may be stored in
 * this structure, false otherwise.  If this returns true, the number may be
 * queried in get_max_num_bits().
 *
 * This method always returns false.  The SparseArray has no maximum number of
 * bits.  This method is defined so generic programming algorithms can use
 * BitMask or SparseArray interchangeably.
 */
55
static inline bool SparseArray::has_max_num_bits(void);

1828 16 get_max_num_bits 0 4 2054 29 SparseArray::get_max_num_bits 0 1 850 428
/**
 * If get_max_num_bits() returned true, this method may be called to return
 * the maximum number of bits that may be stored in this structure.  It is an
 * error to call this if get_max_num_bits() return false.
 *
 * It is always an error to call this method.  The SparseArray has no maximum
 * number of bits.  This method is defined so generic programming algorithms
 * can use BitMask or SparseArray interchangeably.
 */
54
static inline int SparseArray::get_max_num_bits(void);

1829 12 get_num_bits 0 4 2054 25 SparseArray::get_num_bits 0 1 851 300
/**
 * Returns the current number of possibly different bits in this array.  There
 * are actually an infinite number of bits, but every bit higher than this bit
 * will have the same value, either 0 or 1 (see get_highest_bits()).
 *
 * This number may grow and/or shrink automatically as needed.
 */
49
inline int SparseArray::get_num_bits(void) const;

1830 7 get_bit 0 4 2054 20 SparseArray::get_bit 0 1 852 191
/**
 * Returns true if the nth bit is set, false if it is cleared.  It is valid
 * for n to increase beyond get_num_bits(), but the return value
 * get_num_bits() will always be the same.
 */
50
inline bool SparseArray::get_bit(int index) const;

1831 7 set_bit 0 4 2054 20 SparseArray::set_bit 0 1 853 97
/**
 * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
 * the array.
 */
44
inline void SparseArray::set_bit(int index);

1832 9 clear_bit 0 4 2054 22 SparseArray::clear_bit 0 1 854 98
/**
 * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
 * the array.
 */
46
inline void SparseArray::clear_bit(int index);

1833 10 set_bit_to 0 4 2054 23 SparseArray::set_bit_to 0 1 855 84
/**
 * Sets the nth bit either on or off, according to the indicated bool value.
 */
59
inline void SparseArray::set_bit_to(int index, bool value);

1834 16 get_highest_bits 0 4 2054 29 SparseArray::get_highest_bits 0 1 856 118
/**
 * Returns true if the infinite set of bits beyond get_num_bits() are all on,
 * or false of they are all off.
 */
54
inline bool SparseArray::get_highest_bits(void) const;

1835 7 is_zero 0 4 2054 20 SparseArray::is_zero 0 1 857 71
/**
 * Returns true if the entire bitmask is zero, false otherwise.
 */
45
inline bool SparseArray::is_zero(void) const;

1836 9 is_all_on 0 4 2054 22 SparseArray::is_all_on 0 1 858 70
/**
 * Returns true if the entire bitmask is one, false otherwise.
 */
47
inline bool SparseArray::is_all_on(void) const;

1837 10 has_any_of 0 4 2054 23 SparseArray::has_any_of 0 1 859 82
/**
 * Returns true if any bit in the indicated range is set, false otherwise.
 */
65
inline bool SparseArray::has_any_of(int low_bit, int size) const;

1838 10 has_all_of 0 4 2054 23 SparseArray::has_all_of 0 1 860 84
/**
 * Returns true if all bits in the indicated range are set, false otherwise.
 */
65
inline bool SparseArray::has_all_of(int low_bit, int size) const;

1839 9 set_range 0 4 2054 22 SparseArray::set_range 0 1 861 47
/**
 * Sets the indicated range of bits on.
 */
58
inline void SparseArray::set_range(int low_bit, int size);

1840 11 clear_range 0 4 2054 24 SparseArray::clear_range 0 1 862 48
/**
 * Sets the indicated range of bits off.
 */
60
inline void SparseArray::clear_range(int low_bit, int size);

1841 12 set_range_to 0 4 2054 25 SparseArray::set_range_to 0 1 863 64
/**
 * Sets the indicated range of bits to either on or off.
 */
73
inline void SparseArray::set_range_to(bool value, int low_bit, int size);

1842 15 get_num_on_bits 0 4 2054 28 SparseArray::get_num_on_bits 0 1 864 127
/**
 * Returns the number of bits that are set to 1 in the array.  Returns -1 if
 * there are an infinite number of 1 bits.
 */
45
int SparseArray::get_num_on_bits(void) const;

1843 16 get_num_off_bits 0 4 2054 29 SparseArray::get_num_off_bits 0 1 865 127
/**
 * Returns the number of bits that are set to 0 in the array.  Returns -1 if
 * there are an infinite number of 0 bits.
 */
46
int SparseArray::get_num_off_bits(void) const;

1844 17 get_lowest_on_bit 0 4 2054 30 SparseArray::get_lowest_on_bit 0 1 866 146
/**
 * Returns the index of the lowest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there are an infinite number of 1 bits.
 */
47
int SparseArray::get_lowest_on_bit(void) const;

1845 18 get_lowest_off_bit 0 4 2054 31 SparseArray::get_lowest_off_bit 0 1 867 146
/**
 * Returns the index of the lowest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there are an infinite number of 1 bits.
 */
48
int SparseArray::get_lowest_off_bit(void) const;

1846 18 get_highest_on_bit 0 4 2054 31 SparseArray::get_highest_on_bit 0 1 868 143
/**
 * Returns the index of the highest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there an infinite number of 1 bits.
 */
48
int SparseArray::get_highest_on_bit(void) const;

1847 19 get_highest_off_bit 0 4 2054 32 SparseArray::get_highest_off_bit 0 1 869 143
/**
 * Returns the index of the highest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there an infinite number of 1 bits.
 */
49
int SparseArray::get_highest_off_bit(void) const;

1848 29 get_next_higher_different_bit 0 4 2054 42 SparseArray::get_next_higher_different_bit 0 1 870 287
/**
 * Returns the index of the next bit in the array, above low_bit, whose value
 * is different that the value of low_bit.  Returns low_bit again if all bits
 * higher than low_bit have the same value.
 *
 * This can be used to quickly iterate through all of the bits in the array.
 */
66
int SparseArray::get_next_higher_different_bit(int low_bit) const;

1849 15 invert_in_place 0 4 2054 28 SparseArray::invert_in_place 0 1 871 93
/**
 * Inverts all the bits in the SparseArray.  This is equivalent to array =
 * ~array.
 */
47
inline void SparseArray::invert_in_place(void);

1850 18 has_bits_in_common 0 4 2054 31 SparseArray::has_bits_in_common 0 1 872 181
/**
 * Returns true if this SparseArray has any "one" bits in common with the
 * other one, false otherwise.
 *
 * This is equivalent to (array & other) != 0, but may be faster.
 */
69
bool SparseArray::has_bits_in_common(SparseArray const &other) const;

1851 5 clear 0 4 2054 18 SparseArray::clear 0 1 873 52
/**
 * Sets all the bits in the SparseArray off.
 */
37
inline void SparseArray::clear(void);

1852 6 output 0 4 2054 19 SparseArray::output 0 1 874 10
/**
 *
 */
50
void SparseArray::output(std::ostream &out) const;

1853 11 operator == 0 4 2054 24 SparseArray::operator == 0 1 875 0
69
inline bool SparseArray::operator ==(SparseArray const &other) const;

1854 11 operator != 0 4 2054 24 SparseArray::operator != 0 1 876 0
69
inline bool SparseArray::operator !=(SparseArray const &other) const;

1855 10 operator < 0 4 2054 23 SparseArray::operator < 0 1 877 0
68
inline bool SparseArray::operator <(SparseArray const &other) const;

1856 10 compare_to 0 4 2054 23 SparseArray::compare_to 0 1 878 242
/**
 * Returns a number less than zero if this SparseArray sorts before the
 * indicated other SparseArray, greater than zero if it sorts after, or 0 if
 * they are equivalent.  This is based on the same ordering defined by
 * operator <.
 */
60
int SparseArray::compare_to(SparseArray const &other) const;

1857 10 operator & 0 4 2054 23 SparseArray::operator & 0 1 879 0
75
inline SparseArray SparseArray::operator &(SparseArray const &other) const;

1858 10 operator | 0 4 2054 23 SparseArray::operator | 0 1 880 0
75
inline SparseArray SparseArray::operator |(SparseArray const &other) const;

1859 10 operator ^ 0 4 2054 23 SparseArray::operator ^ 0 1 881 0
75
inline SparseArray SparseArray::operator ^(SparseArray const &other) const;

1860 10 operator ~ 0 68 2054 23 SparseArray::operator ~ 0 1 882 0
55
inline SparseArray SparseArray::operator ~(void) const;

1861 11 operator << 0 4 2054 24 SparseArray::operator << 0 1 883 0
61
inline SparseArray SparseArray::operator <<(int shift) const;

1862 11 operator >> 0 4 2054 24 SparseArray::operator >> 0 1 884 0
61
inline SparseArray SparseArray::operator >>(int shift) const;

1863 11 operator &= 0 4 2054 24 SparseArray::operator &= 0 1 885 0
56
void SparseArray::operator &=(SparseArray const &other);

1864 11 operator |= 0 4 2054 24 SparseArray::operator |= 0 1 886 0
56
void SparseArray::operator |=(SparseArray const &other);

1865 11 operator ^= 0 4 2054 24 SparseArray::operator ^= 0 1 887 0
56
void SparseArray::operator ^=(SparseArray const &other);

1866 12 operator <<= 0 4 2054 25 SparseArray::operator <<= 0 1 888 0
49
inline void SparseArray::operator <<=(int shift);

1867 12 operator >>= 0 4 2054 25 SparseArray::operator >>= 0 1 889 0
49
inline void SparseArray::operator >>=(int shift);

1868 10 is_inverse 0 4 2054 23 SparseArray::is_inverse 0 1 890 330
/**
 * If this is true, the SparseArray is actually defined as a list of subranges
 * of integers that are *not* in the set.  If this is false (the default),
 * then the subranges define the integers that *are* in the set.  This affects
 * the interpretation of the values returned by iterating through
 * get_num_subranges().
 */
48
inline bool SparseArray::is_inverse(void) const;

1869 17 get_num_subranges 0 4 2054 30 SparseArray::get_num_subranges 0 1 891 237
/**
 * Returns the number of separate subranges stored in the SparseArray.  You
 * can use this limit to iterate through the subranges, calling
 * get_subrange_begin() and get_subrange_end() for each one.
 *
 * Also see is_inverse().
 */
62
inline std::size_t SparseArray::get_num_subranges(void) const;

1870 18 get_subrange_begin 0 4 2054 31 SparseArray::get_subrange_begin 0 1 892 94
/**
 * Returns the first numeric element in the nth subrange.
 *
 * Also see is_inverse().
 */
64
inline int SparseArray::get_subrange_begin(std::size_t n) const;

1871 16 get_subrange_end 0 4 2054 29 SparseArray::get_subrange_end 0 1 893 104
/**
 * Returns the last numeric element, plus one, in the nth subrange.
 *
 * Also see is_inverse().
 */
62
inline int SparseArray::get_subrange_end(std::size_t n) const;

1872 8 __bool__ 0 4 2054 21 SparseArray::__bool__ 0 1 894 0
39
bool SparseArray::__bool__(void) const;

1873 12 __getstate__ 0 4 2054 25 SparseArray::__getstate__ 0 1 895 0
48
PyObject *SparseArray::__getstate__(void) const;

1874 12 __setstate__ 0 4 2054 25 SparseArray::__setstate__ 0 1 896 0
48
void SparseArray::__setstate__(PyObject *state);

1875 14 get_class_type 0 4 2054 27 SparseArray::get_class_type 0 1 897 0
52
static TypeHandle SparseArray::get_class_type(void);

1876 12 ~SparseArray 0 516 2054 25 SparseArray::~SparseArray 0 0 0
32
SparseArray::~SparseArray(void);

1877 14 get_value_type 0 6 2055 30 ParamValueBase::get_value_type 0 1 898 52
/**
 * Returns the type of the underlying value.
 */
69
virtual inline TypeHandle ParamValueBase::get_value_type(void) const;

1878 6 output 0 6 2055 22 ParamValueBase::output 0 1 899 0
65
virtual void ParamValueBase::output(std::ostream &out) const = 0;

1879 14 get_class_type 0 4 2055 30 ParamValueBase::get_class_type 0 1 900 0
55
static TypeHandle ParamValueBase::get_class_type(void);

1880 18 ParamTypedRefCount 0 260 2056 38 ParamTypedRefCount::ParamTypedRefCount 0 1 901 10
/**
 *
 */
80
inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value);

1881 9 get_value 0 4 2056 29 ParamTypedRefCount::get_value 0 1 902 55
/**
 * Retrieves the value stored in the parameter.
 */
70
inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const;

1882 14 get_class_type 0 4 2056 34 ParamTypedRefCount::get_class_type 0 1 903 0
59
static TypeHandle ParamTypedRefCount::get_class_type(void);

1883 10 ParamValue 0 260 2058 32 ParamValue< string >::ParamValue 0 1 904 0
66
inline ParamValue< string >::ParamValue(std::string const &value);

1884 9 set_value 0 4 2058 31 ParamValue< string >::set_value 0 1 905 0
134
inline void ParamValue< string >::set_value(std::string const &value);
inline void ParamValue< string >::set_value(Type const &value);

1885 9 get_value 0 4 2058 31 ParamValue< string >::get_value 0 1 906 0
70
inline std::string const &ParamValue< string >::get_value(void) const;

1886 14 get_class_type 0 4 2058 36 ParamValue< string >::get_class_type 0 1 907 0
61
static TypeHandle ParamValue< string >::get_class_type(void);

1887 10 ParamValue 0 260 2061 33 ParamValue< wstring >::ParamValue 0 1 908 0
68
inline ParamValue< wstring >::ParamValue(std::wstring const &value);

1888 9 set_value 0 4 2061 32 ParamValue< wstring >::set_value 0 1 909 0
137
inline void ParamValue< wstring >::set_value(std::wstring const &value);
inline void ParamValue< wstring >::set_value(Type const &value);

1889 9 get_value 0 4 2061 32 ParamValue< wstring >::get_value 0 1 910 0
72
inline std::wstring const &ParamValue< wstring >::get_value(void) const;

1890 14 get_class_type 0 4 2061 37 ParamValue< wstring >::get_class_type 0 1 911 0
62
static TypeHandle ParamValue< wstring >::get_class_type(void);

1891 10 ParamValue 0 260 2063 36 ParamValue< LVecBase2d >::ParamValue 0 1 912 0
69
inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value);

1892 9 set_value 0 4 2063 35 ParamValue< LVecBase2d >::set_value 0 1 913 0
141
inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value);
inline void ParamValue< LVecBase2d >::set_value(Type const &value);

1893 9 get_value 0 4 2063 35 ParamValue< LVecBase2d >::get_value 0 1 914 0
73
inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const;

1894 14 get_class_type 0 4 2063 40 ParamValue< LVecBase2d >::get_class_type 0 1 915 0
65
static TypeHandle ParamValue< LVecBase2d >::get_class_type(void);

1895 10 ParamValue 0 260 2065 36 ParamValue< LVecBase2f >::ParamValue 0 1 916 0
69
inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value);

1896 9 set_value 0 4 2065 35 ParamValue< LVecBase2f >::set_value 0 1 917 0
141
inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value);
inline void ParamValue< LVecBase2f >::set_value(Type const &value);

1897 9 get_value 0 4 2065 35 ParamValue< LVecBase2f >::get_value 0 1 918 0
73
inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const;

1898 14 get_class_type 0 4 2065 40 ParamValue< LVecBase2f >::get_class_type 0 1 919 0
65
static TypeHandle ParamValue< LVecBase2f >::get_class_type(void);

1899 10 ParamValue 0 260 2067 36 ParamValue< LVecBase2i >::ParamValue 0 1 920 0
69
inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value);

1900 9 set_value 0 4 2067 35 ParamValue< LVecBase2i >::set_value 0 1 921 0
141
inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value);
inline void ParamValue< LVecBase2i >::set_value(Type const &value);

1901 9 get_value 0 4 2067 35 ParamValue< LVecBase2i >::get_value 0 1 922 0
73
inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const;

1902 14 get_class_type 0 4 2067 40 ParamValue< LVecBase2i >::get_class_type 0 1 923 0
65
static TypeHandle ParamValue< LVecBase2i >::get_class_type(void);

1903 10 ParamValue 0 260 2069 36 ParamValue< LVecBase3d >::ParamValue 0 1 924 0
69
inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value);

1904 9 set_value 0 4 2069 35 ParamValue< LVecBase3d >::set_value 0 1 925 0
141
inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value);
inline void ParamValue< LVecBase3d >::set_value(Type const &value);

1905 9 get_value 0 4 2069 35 ParamValue< LVecBase3d >::get_value 0 1 926 0
73
inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const;

1906 14 get_class_type 0 4 2069 40 ParamValue< LVecBase3d >::get_class_type 0 1 927 0
65
static TypeHandle ParamValue< LVecBase3d >::get_class_type(void);

1907 10 ParamValue 0 260 2071 36 ParamValue< LVecBase3f >::ParamValue 0 1 928 0
69
inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value);

1908 9 set_value 0 4 2071 35 ParamValue< LVecBase3f >::set_value 0 1 929 0
141
inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value);
inline void ParamValue< LVecBase3f >::set_value(Type const &value);

1909 9 get_value 0 4 2071 35 ParamValue< LVecBase3f >::get_value 0 1 930 0
73
inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const;

1910 14 get_class_type 0 4 2071 40 ParamValue< LVecBase3f >::get_class_type 0 1 931 0
65
static TypeHandle ParamValue< LVecBase3f >::get_class_type(void);

1911 10 ParamValue 0 260 2073 36 ParamValue< LVecBase3i >::ParamValue 0 1 932 0
69
inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value);

1912 9 set_value 0 4 2073 35 ParamValue< LVecBase3i >::set_value 0 1 933 0
141
inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value);
inline void ParamValue< LVecBase3i >::set_value(Type const &value);

1913 9 get_value 0 4 2073 35 ParamValue< LVecBase3i >::get_value 0 1 934 0
73
inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const;

1914 14 get_class_type 0 4 2073 40 ParamValue< LVecBase3i >::get_class_type 0 1 935 0
65
static TypeHandle ParamValue< LVecBase3i >::get_class_type(void);

1915 10 ParamValue 0 260 2075 36 ParamValue< LVecBase4d >::ParamValue 0 1 936 0
69
inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value);

1916 9 set_value 0 4 2075 35 ParamValue< LVecBase4d >::set_value 0 1 937 0
141
inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value);
inline void ParamValue< LVecBase4d >::set_value(Type const &value);

1917 9 get_value 0 4 2075 35 ParamValue< LVecBase4d >::get_value 0 1 938 0
73
inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const;

1918 14 get_class_type 0 4 2075 40 ParamValue< LVecBase4d >::get_class_type 0 1 939 0
65
static TypeHandle ParamValue< LVecBase4d >::get_class_type(void);

1919 10 ParamValue 0 260 2077 36 ParamValue< LVecBase4f >::ParamValue 0 1 940 0
69
inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value);

1920 9 set_value 0 4 2077 35 ParamValue< LVecBase4f >::set_value 0 1 941 0
141
inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value);
inline void ParamValue< LVecBase4f >::set_value(Type const &value);

1921 9 get_value 0 4 2077 35 ParamValue< LVecBase4f >::get_value 0 1 942 0
73
inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const;

1922 14 get_class_type 0 4 2077 40 ParamValue< LVecBase4f >::get_class_type 0 1 943 0
65
static TypeHandle ParamValue< LVecBase4f >::get_class_type(void);

1923 10 ParamValue 0 260 2079 36 ParamValue< LVecBase4i >::ParamValue 0 1 944 0
69
inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value);

1924 9 set_value 0 4 2079 35 ParamValue< LVecBase4i >::set_value 0 1 945 0
141
inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value);
inline void ParamValue< LVecBase4i >::set_value(Type const &value);

1925 9 get_value 0 4 2079 35 ParamValue< LVecBase4i >::get_value 0 1 946 0
73
inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const;

1926 14 get_class_type 0 4 2079 40 ParamValue< LVecBase4i >::get_class_type 0 1 947 0
65
static TypeHandle ParamValue< LVecBase4i >::get_class_type(void);

1927 10 ParamValue 0 260 2081 35 ParamValue< LMatrix3d >::ParamValue 0 1 948 0
67
inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value);

1928 9 set_value 0 4 2081 34 ParamValue< LMatrix3d >::set_value 0 1 949 0
138
inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value);
inline void ParamValue< LMatrix3d >::set_value(Type const &value);

1929 9 get_value 0 4 2081 34 ParamValue< LMatrix3d >::get_value 0 1 950 0
71
inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const;

1930 14 get_class_type 0 4 2081 39 ParamValue< LMatrix3d >::get_class_type 0 1 951 0
64
static TypeHandle ParamValue< LMatrix3d >::get_class_type(void);

1931 10 ParamValue 0 260 2083 35 ParamValue< LMatrix3f >::ParamValue 0 1 952 0
67
inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value);

1932 9 set_value 0 4 2083 34 ParamValue< LMatrix3f >::set_value 0 1 953 0
138
inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value);
inline void ParamValue< LMatrix3f >::set_value(Type const &value);

1933 9 get_value 0 4 2083 34 ParamValue< LMatrix3f >::get_value 0 1 954 0
71
inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const;

1934 14 get_class_type 0 4 2083 39 ParamValue< LMatrix3f >::get_class_type 0 1 955 0
64
static TypeHandle ParamValue< LMatrix3f >::get_class_type(void);

1935 10 ParamValue 0 260 2085 35 ParamValue< LMatrix4d >::ParamValue 0 1 956 0
67
inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value);

1936 9 set_value 0 4 2085 34 ParamValue< LMatrix4d >::set_value 0 1 957 0
138
inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value);
inline void ParamValue< LMatrix4d >::set_value(Type const &value);

1937 9 get_value 0 4 2085 34 ParamValue< LMatrix4d >::get_value 0 1 958 0
71
inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const;

1938 14 get_class_type 0 4 2085 39 ParamValue< LMatrix4d >::get_class_type 0 1 959 0
64
static TypeHandle ParamValue< LMatrix4d >::get_class_type(void);

1939 10 ParamValue 0 260 2087 35 ParamValue< LMatrix4f >::ParamValue 0 1 960 0
67
inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value);

1940 9 set_value 0 4 2087 34 ParamValue< LMatrix4f >::set_value 0 1 961 0
138
inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value);
inline void ParamValue< LMatrix4f >::set_value(Type const &value);

1941 9 get_value 0 4 2087 34 ParamValue< LMatrix4f >::get_value 0 1 962 0
71
inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const;

1942 14 get_class_type 0 4 2087 39 ParamValue< LMatrix4f >::get_class_type 0 1 963 0
64
static TypeHandle ParamValue< LMatrix4f >::get_class_type(void);

1943 14 get_class_type 0 4 2094 36 WritableConfigurable::get_class_type 0 1 964 0
61
static TypeHandle WritableConfigurable::get_class_type(void);

1944 21 ~WritableConfigurable 0 516 2094 43 WritableConfigurable::~WritableConfigurable 0 0 0
50
WritableConfigurable::~WritableConfigurable(void);

1945 5 get_x 0 4 2096 18 PointerData::get_x 0 1 967 10
/**
 *
 */
45
inline double PointerData::get_x(void) const;

1946 5 get_y 0 4 2096 18 PointerData::get_y 0 1 968 10
/**
 *
 */
45
inline double PointerData::get_y(void) const;

1947 13 get_in_window 0 4 2096 26 PointerData::get_in_window 0 1 969 157
/**
 * If this returns false, the pointer is not currently present in the window
 * and the values returned by get_x() and get_y() may not be meaningful.
 */
51
inline bool PointerData::get_in_window(void) const;

1948 8 get_type 0 4 2096 21 PointerData::get_type 0 0 47
/**
 * Returns the type of pointing device.
 */
53
inline PointerType PointerData::get_type(void) const;

1949 6 get_id 0 4 2096 19 PointerData::get_id 0 0 273
/**
 * Returns a unique identifier for this pointer.  This is for tracking
 * individual fingers.  This value should not be assumed to have a specific
 * meaning other than that there will not be two different pointers active
 * simultaneously with the same identifier.
 */
43
inline int PointerData::get_id(void) const;

1950 12 get_pressure 0 4 2096 25 PointerData::get_pressure 0 0 119
/**
 * Returns the pressure of the pointer.  For mice, this will be 1.0 if any
 * button is pressed, 0.0 otherwise.
 */
52
inline double PointerData::get_pressure(void) const;

1951 11 PointerData 0 260 2096 24 PointerData::PointerData 0 2 965 966 0
112
inline PointerData::PointerData(void) = default;
inline PointerData::PointerData(PointerData const &) = default;

1952 12 ~PointerData 0 516 2096 25 PointerData::~PointerData 0 0 0
32
PointerData::~PointerData(void);

1953 17 UniqueIdAllocator 0 260 2097 36 UniqueIdAllocator::UniqueIdAllocator 0 1 970 56
/**
 * Create a free id pool in the range [min:max].
 */
83
explicit UniqueIdAllocator::UniqueIdAllocator(uint32_t min = 0, uint32_t max = 20);

1954 18 ~UniqueIdAllocator 0 516 2097 37 UniqueIdAllocator::~UniqueIdAllocator 0 0 10
/**
 *
 */
44
UniqueIdAllocator::~UniqueIdAllocator(void);

1955 8 allocate 0 4 2097 27 UniqueIdAllocator::allocate 0 1 971 134
/**
 * Returns an id between _min and _max (that were passed to the constructor).
 * IndexEnd is returned if no ids are available.
 */
43
uint32_t UniqueIdAllocator::allocate(void);

1956 18 initial_reserve_id 0 4 2097 37 UniqueIdAllocator::initial_reserve_id 0 1 972 518
/**
 * This may be called to mark a particular id as having already been allocated
 * (for instance, by a prior pass).  The specified id is removed from the
 * available pool.
 *
 * Because of the limitations of this algorithm, this is most efficient when
 * it is called before the first call to allocate(), and when all the calls to
 * initial_reserve_id() are made in descending order by id.  However, this is
 * a performance warning only; if performance is not an issue, any id may be
 * reserved at any time.
 */
56
void UniqueIdAllocator::initial_reserve_id(uint32_t id);

1957 12 is_allocated 0 4 2097 31 UniqueIdAllocator::is_allocated 0 1 973 119
/**
 * Checks the allocated state of an index. Returns true for
 * indices that are currently allocated and in use.
 */
53
bool UniqueIdAllocator::is_allocated(uint32_t index);

1958 4 free 0 4 2097 23 UniqueIdAllocator::free 0 1 974 278
/**
 * Free an allocated index (index must be between _min and _max that were
 * passed to the constructor).
 *
 * Since 1.11.1, returns true if the index has been freed successfully
 * or false if the index has not been allocated yet, instead of
 * triggering an assertion.
 */
45
bool UniqueIdAllocator::free(uint32_t index);

1959 13 fraction_used 0 4 2097 32 UniqueIdAllocator::fraction_used 0 1 975 117
/**
 * return the decimal fraction of the pool that is used.  The range is 0 to
 * 1.0 (e.g.  75% would be 0.75).
 */
57
PN_stdfloat UniqueIdAllocator::fraction_used(void) const;

1960 6 output 0 4 2097 25 UniqueIdAllocator::output 0 1 976 42
/**
 * ...intended for debugging only.
 */
56
void UniqueIdAllocator::output(std::ostream &out) const;

1961 5 write 0 4 2097 24 UniqueIdAllocator::write 0 1 977 42
/**
 * ...intended for debugging only.
 */
55
void UniqueIdAllocator::write(std::ostream &out) const;

1962 39 py_decode_TypedWritable_from_bam_stream 0 1 0 39 py_decode_TypedWritable_from_bam_stream 0 1 986 203
/**
 * This wrapper is defined as a global function to suit pickle's needs.
 *
 * This hooks into the native pickle and cPickle modules, but it cannot
 * properly handle self-referential BAM objects.
 */
98
PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, vector_uchar const &data);

1963 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 0 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 987 398
/**
 * This wrapper is defined as a global function to suit pickle's needs.
 *
 * This is similar to py_decode_TypedWritable_from_bam_stream, but it provides
 * additional support for the missing persistent-state object needed to
 * properly support self-referential BAM objects written to the pickle stream.
 * This hooks into the pickle and cPickle modules implemented in
 * direct/src/stdpy.
 */
127
PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, vector_uchar const &data);

987
1 0 0 15 10 2101 1007 0 0 1 4 copy 1 2099  
2 0 0 23 10 2101 1007 0 0 1 4 copy 1 2102  
3 0 0 4 11 2104 0 0 0 1 4 this 3 2101  
4 0 0 6 12 2105 0 0 0 1 4 this 3 2099  
5 0 0 6 13 2106 0 0 0 2 4 this 3 2099  1 n 1 2105  
6 0 0 38 14 2106 0 0 0 2 4 this 3 2099  1 n 1 2105  
7 0 0 38 15 2000 0 0 0 1 4 this 3 2099  
8 0 0 38 16 2000 0 0 0 3 4 this 3 2099  1 n 1 2105  5 count 1 2105  
9 0 0 6 17 1971 0 0 0 1 4 this 3 2099  
10 0 0 6 18 1971 0 0 0 1 4 this 3 2099  
11 0 0 6 19 2105 0 0 0 2 4 this 3 2099  6 param0 0 2106  
12 0 0 38 20 2000 0 0 0 1 4 this 3 2099  
13 0 0 38 21 1971 0 0 0 3 4 this 3 2099  4 view 1 2107  5 flags 1 1971  
14 0 0 36 22 2104 0 0 0 2 4 this 3 2099  4 view 1 2107  
15 0 0 39 23 2101 1007 0 0 2 4 this 3 2099  4 memo 1 2000  
16 0 0 6 8 1972 0 0 64 // These are implemented in PointerToVoid, but expose them here. 2 4 this 3 2110  5 other 1 2110  
17 0 0 6 9 1972 0 0 0 2 4 this 3 2110  5 other 1 2110  
18 0 0 4 5 2104 0 0 0 1 4 this 3 2112  
19 0 0 4 6 2104 0 0 0 2 4 this 3 2113  3 out 1 2115  
20 0 0 15 26 2116 1029 0 0 1 4 copy 1 2102  
21 0 0 55 26 2116 1029 0 0 1 6 source 1 2000  
22 0 0 23 26 2116 1029 0 0 1 11 type_handle 5 2117  
23 0 0 7 27 2116 1029 0 0 2 1 n 1 2105  11 type_handle 5 2117  
24 0 0 4 28 2104 0 0 0 1 4 this 3 2116  
25 0 0 6 29 2105 0 0 0 1 4 this 3 2102  
26 0 0 4 30 2104 0 0 0 2 4 this 3 2116  1 x 1 2106  
27 0 0 4 31 2104 0 0 0 1 4 this 3 2116  
28 0 0 6 32 2106 0 0 0 2 4 this 3 2102  1 n 1 2105  
29 0 0 4 33 2104 0 0 0 3 4 this 3 2116  1 n 1 2105  5 value 1 2106  
30 0 0 38 34 2106 0 0 0 2 4 this 3 2102  1 n 1 2105  
31 0 0 36 35 2104 0 0 0 3 4 this 3 2116  1 n 1 2105  5 value 1 2106  
32 0 0 38 36 2000 0 0 0 1 4 this 3 2102  
33 0 0 36 37 2104 0 0 0 2 4 this 3 2116  4 data 1 2000  
34 0 0 38 38 2000 0 0 0 3 4 this 3 2102  1 n 1 2105  5 count 1 2105  
35 0 0 4 39 2104 0 0 0 4 4 this 3 2116  1 n 1 2105  5 count 1 2105  4 data 1 2119  
36 0 0 6 40 1971 0 0 0 1 4 this 3 2102  
37 0 0 6 41 1971 0 0 0 1 4 this 3 2102  
38 0 0 6 42 2105 0 0 0 2 4 this 3 2102  6 param0 0 2106  
39 0 0 38 43 2000 0 0 0 1 4 this 3 2102  
40 0 0 38 44 1971 0 0 0 3 4 this 3 2116  4 view 1 2107  5 flags 1 1971  
41 0 0 36 45 2104 0 0 0 2 4 this 3 2102  4 view 1 2107  
42 0 0 39 46 2116 1029 0 0 2 4 this 3 2102  4 memo 1 2000  
43 0 0 4 50 2104 0 0 69 /**
 * Runs the entire animation from beginning to end and stops.
 */ 1 4 this 3 2120  
44 0 0 4 50 2104 0 0 406 /**
 * Runs the animation from the frame "from" to and including the frame "to",
 * at which point the animation is stopped.  Both "from" and "to" frame
 * numbers may be outside the range (0, get_num_frames()) and the animation
 * will follow the range correctly, reporting numbers modulo get_num_frames().
 * For instance, play(0, get_num_frames() * 2) will play the animation twice
 * and then stop.
 */ 3 4 this 3 2120  4 from 1 1970  2 to 1 1970  
45 0 0 4 51 2104 0 0 169 /**
 * Starts the entire animation looping.  If restart is true, the animation is
 * restarted from the beginning; otherwise, it continues from the current
 * frame.
 */ 2 4 this 3 2120  7 restart 1 1972  
46 0 0 4 51 2104 0 0 221 /**
 * Loops the animation from the frame "from" to and including the frame "to",
 * indefinitely.  If restart is true, the animation is restarted from the
 * beginning; otherwise, it continues from the current frame.
 */ 4 4 this 3 2120  7 restart 1 1972  4 from 1 1970  2 to 1 1970  
47 0 0 4 52 2104 0 0 224 /**
 * Starts the entire animation bouncing back and forth between its first frame
 * and last frame.  If restart is true, the animation is restarted from the
 * beginning; otherwise, it continues from the current frame.
 */ 2 4 this 3 2120  7 restart 1 1972  
48 0 0 4 52 2104 0 0 143 /**
 * Loops the animation from the frame "from" to and including the frame "to",
 * and then back in the opposite direction, indefinitely.
 */ 4 4 this 3 2120  7 restart 1 1972  4 from 1 1970  2 to 1 1970  
49 0 0 4 53 2104 0 0 130 /**
 * Stops a currently playing or looping animation right where it is.  The
 * animation remains posed at the current frame.
 */ 1 4 this 3 2120  
50 0 0 4 54 2104 0 0 72 /**
 * Sets the animation to the indicated frame and holds it there.
 */ 2 4 this 3 2120  5 frame 1 1970  
51 0 0 4 55 2104 0 0 243 /**
 * Changes the rate at which the animation plays.  1.0 is the normal speed,
 * 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to
 * pause the animation, and a negative value will play the animation
 * backwards.
 */ 2 4 this 3 2120  9 play_rate 1 1970  
52 0 0 6 56 1970 0 0 79 /**
 * Returns the rate at which the animation plays.  See set_play_rate().
 */ 1 4 this 3 2121  
53 0 0 6 57 1970 0 0 234 /**
 * Returns the native frame rate of the animation.  This is the number of
 * frames per second that will elapse when the play_rate is set to 1.0.  It is
 * a fixed property of the animation and may not be adjusted by the user.
 */ 1 4 this 3 2121  
54 0 0 6 58 1971 0 0 278 /**
 * Returns the number of frames in the animation.  This is a property of the
 * animation and may not be directly adjusted by the user (although it may
 * change without warning with certain kinds of animations, since this is a
 * virtual method that may be overridden).
 */ 1 4 this 3 2121  
55 0 0 6 59 1971 0 0 116 /**
 * Returns the current integer frame number.  This number will be in the range
 * 0 <= f < get_num_frames().
 */ 1 4 this 3 2121  
56 0 0 6 60 1971 0 0 330 /**
 * Returns the current integer frame number + 1, constrained to the range 0 <=
 * f < get_num_frames().
 *
 * If the play mode is PM_play, this will clamp to the same value as
 * get_frame() at the end of the animation.  If the play mode is any other
 * value, this will wrap around to frame 0 at the end of the animation.
 */ 1 4 this 3 2121  
57 0 0 6 61 1970 0 0 314 /**
 * Returns the fractional part of the current frame.  Normally, this is in the
 * range 0.0 <= f < 1.0, but in the one special case of an animation playing
 * to its end frame and stopping, it might exactly equal 1.0.
 *
 * It will always be true that get_full_frame() + get_frac() ==
 * get_full_fframe().
 */ 1 4 this 3 2121  
58 0 0 6 62 1971 0 0 372 /**
 * Returns the current integer frame number.
 *
 * Unlike the value returned by get_frame(), this frame number may extend
 * beyond the range of get_num_frames() if the frame range passed to play(),
 * loop(), etc.  did.
 *
 * Unlike the value returned by get_full_fframe(), this return value will
 * never exceed the value passed to to_frame in the play() method.
 */ 1 4 this 3 2121  
59 0 0 6 63 1970 0 0 490 /**
 * Returns the current floating-point frame number.
 *
 * Unlike the value returned by get_frame(), this frame number may extend
 * beyond the range of get_num_frames() if the frame range passed to play(),
 * loop(), etc.  did.
 *
 * Unlike the value returned by get_full_frame(), this return value may equal
 * (to_frame + 1.0), when the animation has played to its natural end.
 * However, in this case the return value of get_full_frame() will be
 * to_frame, not (to_frame + 1).
 */ 1 4 this 3 2121  
60 0 0 6 64 1972 0 0 208 /**
 * Returns true if the animation is currently playing, false if it is stopped
 * (e.g.  because stop() or pose() was called, or because it reached the end
 * of the animation after play() was called).
 */ 1 4 this 3 2121  
61 0 0 4 65 2104 0 0 10 /**
 *
 */ 2 4 this 3 2121  3 out 1 2115  
62 0 0 7 78 2117 0 0 0 0 
63 0 0 7 81 2123 1068 0 55 /**
 * Creates an UpdateSeq in the 'initial' state.
 */ 0 
64 0 0 15 81 2123 1068 0 10 /**
 *
 */ 1 4 copy 1 2124  
65 0 0 7 82 2123 1068 0 0 0 
66 0 0 7 83 2123 1068 0 0 0 
67 0 0 7 84 2123 1068 0 0 0 
68 0 0 6 85 2123 0 0 10 /**
 *
 */ 2 4 this 3 2123  4 copy 1 2124  
69 0 0 4 86 2104 0 0 55 /**
 * Resets the UpdateSeq to the 'initial' state.
 */ 1 4 this 3 2123  
70 0 0 6 87 1972 0 0 67 /**
 * Returns true if the UpdateSeq is in the 'initial' state.
 */ 1 4 this 3 2124  
71 0 0 6 88 1972 0 0 63 /**
 * Returns true if the UpdateSeq is in the 'old' state.
 */ 1 4 this 3 2124  
72 0 0 6 89 1972 0 0 65 /**
 * Returns true if the UpdateSeq is in the 'fresh' state.
 */ 1 4 this 3 2124  
73 0 0 6 90 1972 0 0 105 /**
 * Returns true if the UpdateSeq is in any special states, i.e.  'initial',
 * 'old', or 'fresh'.
 */ 1 4 this 3 2124  
74 0 0 6 91 1972 0 0 0 2 4 this 3 2124  5 other 1 2124  
75 0 0 6 92 1972 0 0 0 2 4 this 3 2124  5 other 1 2124  
76 0 0 6 93 1972 0 0 0 2 4 this 3 2124  5 other 1 2124  
77 0 0 6 94 1972 0 0 0 2 4 this 3 2124  5 other 1 2124  
78 0 0 6 95 1972 0 0 0 2 4 this 3 2124  5 other 1 2124  
79 0 0 6 96 1972 0 0 0 2 4 this 3 2124  5 other 1 2124  
80 0 0 7 97 2123 1068 0 0 1 4 this 3 2123  
81 0 0 7 98 2123 1068 0 0 2 4 this 3 2123  6 param0 0 1971  
82 0 0 6 99 1975 0 0 107 /**
 * Returns the internal integer value associated with the UpdateSeq.  Useful
 * for debugging only.
 */ 1 4 this 3 2124  
83 0 0 4 104 2104 0 0 10 /**
 *
 */ 2 4 this 3 2124  3 out 1 2115  
84 0 0 38 108 2000 0 0 0 0 
85 0 0 4 109 2104 0 0 96 /**
 * Writes the contents of this object to the datagram for shipping out to a
 * Bam file.
 */ 3 4 this 3 1987  7 manager 1 2126  2 dg 1 2127  
86 0 0 4 110 2104 0 0 308 /**
 * This internal function is intended to be called by each class's
 * make_from_bam() method to read in all of the relevant data from the BamFile
 * for the new object.  It is also called directly by the BamReader to re-read
 * the data for an object that has been placed on the stream for an update.
 */ 3 4 this 3 1987  4 scan 1 2129  7 manager 1 2131  
87 0 0 4 111 2104 0 0 345 /**
 * Increments the bam_modified counter, so that this object will be
 * invalidated and retransmitted on any open bam streams.  This should
 * normally not need to be called by user code; it should be called internally
 * when the object has been changed in a way that legitimately requires its
 * retransmission to any connected clients.
 */ 1 4 this 3 1987  
88 0 0 7 112 2123 1068 0 140 /**
 * Returns the current bam_modified counter.  This counter is normally
 * incremented automatically whenever the object is modified.
 */ 1 4 this 3 2132  
89 0 0 38 113 2000 0 0 0 1 4 this 3 2132  
90 0 0 38 114 2000 0 0 0 2 4 this 3 2132  7 pickler 1 2000  
91 0 0 6 115 2036 0 0 423 /**
 * Converts the TypedWritable object into a single stream of data using a
 * BamWriter, and returns that data as a bytes object.  Returns an empty bytes
 * object on failure.
 *
 * This is a convenience method particularly useful for cases when you are
 * only serializing a single object.  If you have many objects to process, it
 * is more efficient to use the same BamWriter to serialize all of them
 * together.
 */ 1 4 this 3 2132  
92 0 0 6 115 1972 0 0 429 /**
 * Converts the TypedWritable object into a single stream of data using a
 * BamWriter, and stores that data in the indicated string.  Returns true on
 * success, false on failure.
 *
 * This is a convenience method particularly useful for cases when you are
 * only serializing a single object.  If you have many objects to process, it
 * is more efficient to use the same BamWriter to serialize all of them
 * together.
 */ 3 4 this 3 2132  4 data 1 2134  6 writer 5 2126  
93 0 0 7 117 2117 0 0 0 0 
94 0 0 7 124 2135 1085 0 491 /**
 * Reads the bytes created by a previous call to encode_to_bam_stream(), and
 * extracts and returns the single object on those bytes.  Returns NULL on
 * error.
 *
 * This method is intended to replace decode_raw_from_bam_stream() when you
 * know the stream in question returns an object of type
 * TypedWritableReferenceCount, allowing for easier reference count
 * management.  Note that the caller is still responsible for maintaining the
 * reference count on the return value.
 */ 2 4 data 1 2036  6 reader 5 2131  
95 0 0 7 125 2117 0 0 0 0 
96 0 0 6 119 1987 0 0 0 1 4 this 3 2135  
97 0 0 7 122 2136 0 0 0 1 4 this 3 2135  
98 0 0 7 134 2139 1090 0 179 /**
 * Returns a duplicate of the BamCacheRecord.  The duplicate will not have a
 * data pointer set, even though one may have been assigned to the original
 * via set_data().
 */ 1 4 this 3 2137  
99 0 0 6 135 1972 0 0 0 2 4 this 3 2137  5 other 1 2137  
100 0 0 6 136 2140 0 0 237 /**
 * Returns the full pathname to the source file that originally generated this
 * cache request.  In some cases, for instance in the case of a of a multipage
 * texture like "cube_#.png", this may not not a true filename on disk.
 */ 1 4 this 3 2137  
101 0 0 6 137 2140 0 0 230 /**
 * Returns the name of the cache file as hashed from the source_pathname.
 * This will be relative to the root of the cache directory, and it will not
 * include any suffixes that may be appended to resolve hash conflicts.
 */ 1 4 this 3 2137  
102 0 0 6 138 1986 0 0 204 /**
 * Returns the file timestamp of the original source file that generated this
 * cache record, if available.  In some cases the original file timestamp is
 * not available, and this will return 0.
 */ 1 4 this 3 2137  
103 0 0 6 139 1986 0 0 84 /**
 * Returns the time at which this particular record was recorded or updated.
 */ 1 4 this 3 2137  
104 0 0 6 147 1971 0 0 75 /**
 * Returns the number of source files that contribute to the cache.
 */ 1 4 this 3 2137  
105 0 0 6 148 2140 0 0 94 /**
 * Returns the full pathname of the nth source files that contributes to the
 * cache.
 */ 2 4 this 3 2137  1 n 1 1971  
106 0 0 6 149 1972 0 0 124 /**
 * Returns true if all of the dependent files are still the same as when the
 * cache was recorded, false otherwise.
 */ 1 4 this 3 2137  
107 0 0 4 150 2104 0 0 80 /**
 * Empties the list of files that contribute to the data in this record.
 */ 1 4 this 3 2139  
108 0 0 4 151 2104 0 0 225 /**
 * Adds the indicated file to the list of files that will be loaded to
 * generate the data in this record.  This should be called once for the
 * primary source file, and again for each secondary source file, if any.
 */ 2 4 this 3 2139  8 pathname 1 2140  
109 0 0 4 151 2104 0 0 82 /**
 * Variant of add_dependent_file that takes an already opened VirtualFile.
 */ 2 4 this 3 2139  4 file 1 2141  
110 0 0 6 152 1972 0 0 130 /**
 * Returns true if this cache record has an in-memory data object associated--
 * that is, the object stored in the cache.
 */ 1 4 this 3 2137  
111 0 0 4 153 2104 0 0 147 /**
 * Removes the in-memory data object associated with this record, if any.
 * This does not affect the on-disk representation of the record.
 */ 1 4 this 3 2139  
112 0 0 6 154 1987 0 0 139 /**
 * Returns a pointer to the data stored in the record, or NULL if there is no
 * data.  The pointer is not removed from the record.
 */ 1 4 this 3 2137  
113 0 0 4 156 2104 0 0 104 /**
 * This variant on set_data() is provided to easily pass objects deriving from
 * TypedWritable.
 */ 2 4 this 3 2139  3 ptr 1 1987  
114 0 0 4 156 2104 0 0 573 /**
 * Stores a new data object on the record.  You should pass the same pointer
 * twice, to both parameters; this allows the C++ typecasting to automatically
 * convert the pointer into both a TypedWritable and a ReferenceCount pointer,
 * so that the BamCacheRecord object can reliably manage the reference counts.
 *
 * You may pass 0 or NULL as the second parameter.  If you do this, the
 * BamCacheRecord will not manage the object's reference count; it will be up
 * to you to ensure the object is not deleted during the lifetime of the
 * BamCacheRecord object.
 */ 3 4 this 3 2139  3 ptr 1 1987  7 ref_ptr 1 2136  
115 0 0 4 156 2104 0 0 115 /**
 * This variant on set_data() is provided just to allow Python code to pass a
 * 0 as the second parameter.
 */ 3 4 this 3 2139  3 ptr 1 1987  5 dummy 1 1971  
116 0 0 4 156 2104 0 0 118 /**
 * This variant on set_data() is provided to easily pass objects deriving from
 * TypedWritableReferenceCount.
 */ 2 4 this 3 2139  3 ptr 1 2135  
117 0 0 4 159 2104 0 0 10 /**
 *
 */ 2 4 this 3 2137  3 out 1 2115  
118 0 0 4 160 2104 0 0 10 /**
 *
 */ 3 4 this 3 2137  3 out 1 2115  12 indent_level 5 1971  
119 0 0 7 161 2117 0 0 0 0 
120 0 0 7 128 2135 1085 0 0 1 4 this 3 2139  
121 0 0 7 163 2144 1111 0 10 /**
 *
 */ 0 
122 0 0 4 165 2104 0 0 347 /**
 * Changes the state of the active flag.  "active" means that the cache should
 * be consulted automatically on loads, "not active" means that objects should
 * be loaded directly without consulting the cache.
 *
 * This represents the global flag.  Also see the individual cache_models,
 * cache_textures, cache_compressed_textures flags.
 */ 2 4 this 3 2144  4 flag 1 1972  
123 0 0 6 166 1972 0 0 381 /**
 * Returns true if the BamCache is currently active, false if it is not.
 * "active" means that the cache should be consulted automatically on loads,
 * "not active" means that objects should be loaded directly without
 * consulting the cache.
 *
 * This represents the global flag.  Also see the individual cache_models,
 * cache_textures, cache_compressed_textures flags.
 */ 1 4 this 3 2145  
124 0 0 4 167 2104 0 0 118 /**
 * Indicates whether model files (e.g.  egg files and bam files) will be
 * stored in the cache, as bam files.
 */ 2 4 this 3 2144  4 flag 1 1972  
125 0 0 6 168 1972 0 0 172 /**
 * Returns whether model files (e.g.  egg files and bam files) will be stored
 * in the cache, as bam files.
 *
 * This also returns false if get_active() is false.
 */ 1 4 this 3 2145  
126 0 0 4 169 2104 0 0 101 /**
 * Indicates whether texture files will be stored in the cache, as
 * uncompressed txo files.
 */ 2 4 this 3 2144  4 flag 1 1972  
127 0 0 6 170 1972 0 0 174 /**
 * Returns whether texture files (e.g.  egg files and bam files) will be
 * stored in the cache, as txo files.
 *
 * This also returns false if get_active() is false.
 */ 1 4 this 3 2145  
128 0 0 4 171 2104 0 0 722 /**
 * Indicates whether compressed texture files will be stored in the cache, as
 * compressed txo files.  The compressed data may either be generated in-CPU,
 * via the squish library, or it may be extracted from the GSG after the
 * texture has been loaded.
 *
 * This may be set in conjunction with set_cache_textures(), or independently
 * of it.  If set_cache_textures() is true and this is false, all textures
 * will be cached in their uncompressed form.  If set_cache_textures() is
 * false and this is true, only compressed textures will be cached, and they
 * will be cached in their compressed form.  If both are true, all textures
 * will be cached, in their uncompressed or compressed form appropriately.
 */ 2 4 this 3 2144  4 flag 1 1972  
129 0 0 6 172 1972 0 0 202 /**
 * Returns whether compressed texture files will be stored in the cache, as
 * compressed txo files.  See set_cache_compressed_textures().
 *
 * This also returns false if get_active() is false.
 */ 1 4 this 3 2145  
130 0 0 4 173 2104 0 0 184 /**
 * Indicates whether compiled shader programs will be stored in the cache, as
 * binary .sho files.  This may not be supported by all shader languages or
 * graphics renderers.
 */ 2 4 this 3 2144  4 flag 1 1972  
131 0 0 6 174 1972 0 0 196 /**
 * Returns whether compiled shader programs will be stored in the cache, as
 * binary .txo files.  See set_cache_compiled_shaders().
 *
 * This also returns false if get_active() is false.
 */ 1 4 this 3 2145  
132 0 0 4 175 2104 0 0 372 /**
 * Changes the current root pathname of the cache.  This specifies where the
 * cache files are stored on disk.  This should name a directory that is on a
 * disk local to the machine (not on a network-mounted disk), for instance,
 * /tmp/panda-cache or /c/panda-cache.
 *
 * If the directory does not already exist, it will be created as a result of
 * this call.
 */ 2 4 this 3 2144  4 root 1 2140  
133 0 0 7 176 2147 0 0 75 /**
 * Returns the current root pathname of the cache.  See set_root().
 */ 1 4 this 3 2145  
134 0 0 4 177 2104 0 0 86 /**
 * Specifies the time in seconds between automatic flushes of the cache index.
 */ 2 4 this 3 2144  10 flush_time 1 1971  
135 0 0 6 178 1971 0 0 84 /**
 * Returns the time in seconds between automatic flushes of the cache index.
 */ 1 4 this 3 2145  
136 0 0 4 179 2104 0 0 430 /**
 * Specifies the maximum size, in kilobytes, which the cache is allowed to
 * grow to.  If a newly cached file would exceed this size, an older file is
 * removed from the cache.
 *
 * Note that in the case of multiple different processes simultaneously
 * operating on the same cache directory, the actual cache size may slightly
 * exceed this value from time to time due to latency in checking between the
 * processes.
 */ 2 4 this 3 2144  10 max_kbytes 1 1971  
137 0 0 6 180 1971 0 0 121 /**
 * Returns the maximum size, in kilobytes, which the cache is allowed to grow
 * to.  See set_cache_max_kbytes().
 */ 1 4 this 3 2145  
138 0 0 4 181 2104 0 0 252 /**
 * Can be used to put the cache in read-only mode, or take it out of read-only
 * mode.  Note that if you put it into read-write mode, and it discovers that
 * it does not have write access, it will put itself right back into read-only
 * mode.
 */ 2 4 this 3 2144  2 ro 1 1972  
139 0 0 6 182 1972 0 0 230 /**
 * Returns true if the cache is in read-only mode.  Normally, the cache starts
 * in read-write mode.  It can put itself into read-only mode automatically if
 * it discovers that it does not have write access to the cache.
 */ 1 4 this 3 2145  
140 0 0 7 183 2139 1090 0 782 /**
 * Looks up a file in the cache.
 *
 * If the file is cacheable, then regardless of whether the file is found in
 * the cache or not, this returns a BamCacheRecord.  On the other hand, if the
 * file cannot be cached, returns NULL.
 *
 * If record->has_data() returns true, then the file was found in the cache,
 * and you may call record->extract_data() to get the object.  If
 * record->has_data() returns false, then the file was not found in the cache
 * or the cache was stale; and you should reload the source file (calling
 * record->add_dependent_file() for each file loaded, including the original
 * source file), and then call record->set_data() to record the resulting
 * loaded object; and finally, you should call store() to write the cached
 * record to disk.
 */ 3 4 this 3 2144  15 source_filename 1 2140  15 cache_extension 1 2119  
141 0 0 6 184 1972 0 0 212 /**
 * Flushes a cache entry to disk.  You must have retrieved the cache record
 * via a prior call to lookup(), and then stored the data via
 * record->set_data().  Returns true on success, false on failure.
 */ 2 4 this 3 2144  6 record 1 2139  
142 0 0 4 185 2104 0 0 92 /**
 * Flushes the index if enough time has elapsed since the index was last
 * flushed.
 */ 1 4 this 3 2144  
143 0 0 4 186 2104 0 0 48 /**
 * Ensures the index is written to disk.
 */ 1 4 this 3 2144  
144 0 0 4 187 2104 0 0 63 /**
 * Writes the contents of the index to standard output.
 */ 3 4 this 3 2145  3 out 1 2115  12 indent_level 5 1971  
145 0 0 6 188 2144 0 0 124 /**
 * Returns a pointer to the global BamCache object, which is used
 * automatically by the ModelPool and TexturePool.
 */ 0 
146 0 0 4 189 2104 0 0 84 /**
 * If there is a global BamCache object, calls consider_flush_index() on it.
 */ 0 
147 0 0 4 190 2104 0 0 75 /**
 * If there is a global BamCache object, calls flush_index() on it.
 */ 0 
148 0 0 7 204 2148 1139 0 0 0 
149 0 0 15 204 2148 1139 0 0 1 6 param0 0 2149  
150 0 0 15 209 2152 1156 0 0 1 6 param0 0 2151  
151 0 0 7 209 2152 1156 0 10 /**
 *
 */ 1 5 flags 5 1971  
152 0 0 7 209 2152 1156 0 10 /**
 *
 */ 2 5 flags 1 1971  13 texture_flags 1 1971  
153 0 0 4 210 2104 0 0 10 /**
 *
 */ 2 4 this 3 2152  5 flags 1 1971  
154 0 0 6 211 1971 0 0 10 /**
 *
 */ 1 4 this 3 2151  
155 0 0 4 213 2104 0 0 10 /**
 *
 */ 2 4 this 3 2152  5 flags 1 1971  
156 0 0 6 214 1971 0 0 10 /**
 *
 */ 1 4 this 3 2151  
157 0 0 4 215 2104 0 0 0 2 4 this 3 2152  6 format 1 1971  
158 0 0 6 216 1971 0 0 34 /**
 *  Get the texture format
 */ 1 4 this 3 2151  
159 0 0 4 217 2104 0 0 39 /**
 *  Set the texture compression
 */ 2 4 this 3 2152  8 compress 1 1971  
160 0 0 6 218 1971 0 0 39 /**
 *  Get the texture compression
 */ 1 4 this 3 2151  
161 0 0 4 219 2104 0 0 35 /**
 *  Set the texture quality
 */ 2 4 this 3 2152  7 quality 1 1971  
162 0 0 6 220 1971 0 0 35 /**
 *  Get the texture quality
 */ 1 4 this 3 2151  
163 0 0 4 221 2104 0 0 459 /**
 * Specifies the expected number of views to load for the texture.  This is
 * ignored unless TF_multiview is included in texture_flags.  This must be
 * specified when loading a 3-d multiview texture or 2-d texture array, in
 * which case it is used to differentiate z levels from separate views; it
 * may be zero in the case of 2-d textures or cube maps, in which case the
 * number of views can be inferred from the number of images found on disk.
 */ 2 4 this 3 2152  9 num_views 1 1971  
164 0 0 6 222 1971 0 0 39 /**
 * See set_texture_num_views().
 */ 1 4 this 3 2151  
165 0 0 4 225 2104 0 0 209 /**
 * Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a
 * texture is scaled from disk when it is subsequently loaded.  Set it to
 * ATS_unspecified to restore the default behavior.
 */ 2 4 this 3 2152  5 scale 1 1973  
166 0 0 6 226 1973 0 0 40 /**
 * See set_auto_texture_scale().
 */ 1 4 this 3 2151  
167 0 0 4 228 2104 0 0 10 /**
 *
 */ 2 4 this 3 2151  3 out 1 2115  
168 0 0 7 231 2131 1158 0 38 // The primary interface for a caller. 1 6 source 5 1997  
169 0 0 4 233 2104 0 0 142 /**
 * Changes the source of future datagrams for this BamReader.  This also
 * implicitly calls init() if it has not already been called.
 */ 2 4 this 3 2131  6 source 1 1997  
170 0 0 6 234 1997 0 0 100 /**
 * Returns the current source of the BamReader as set by set_source() or the
 * constructor.
 */ 1 4 this 3 2131  
171 0 0 6 235 1972 0 0 210 /**
 * Initializes the BamReader prior to reading any objects from its source.
 * This includes reading the Bam header.
 *
 * This returns true if the BamReader successfully initialized, false
 * otherwise.
 */ 1 4 this 3 2131  
172 0 0 4 236 2104 0 0 1007 /**
 * Associates an arbitrary block of data with the indicated object (or NULL),
 * and the indicated name.
 *
 * This is intended to provide a place for temporary storage for objects
 * reading themselves from the bam file.  To use it, inherit from
 * BamReader::AuxData and store whatever data you like there.  Then associate
 * your AuxData with the object as it is being read with set_aux_data().  You
 * may later set the aux data to NULL to remove it; or it will automatically
 * be removed (and deleted) after finalize() is called for the object in
 * question.
 *
 * If the TypedWritable pointer is NULL, the the aux data is stored globally
 * for the BamReader in general.  This pointer is available to any bam
 * objects, and will not be automatically removed until the BamReader itself
 * destructs.
 *
 * In either case, the name is just an arbitrary user-defined key.  If there
 * is already a data pointer stored for the obj/name pair, that data pointer
 * will be replaced (and deleted).
 */ 4 4 this 3 2131  3 obj 1 1987  4 name 1 2119  4 data 1 2153  
173 0 0 7 237 2153 0 0 173 /**
 * Returns the pointer previously associated with the bam reader by a previous
 * call to set_aux_data(), or NULL if data with the indicated key has not been
 * set.
 */ 3 4 this 3 2155  3 obj 1 1987  4 name 1 2119  
174 0 0 6 238 2140 0 0 199 /**
 * If a BAM is a file, then the BamReader should contain the name of the file.
 * This enables the reader to interpret pathnames in the BAM as relative to
 * the directory containing the BAM.
 */ 1 4 this 3 2155  
175 0 0 6 239 2151 0 0 98 /**
 * Returns the LoaderOptions passed to the loader when the model was
 * requested, if any.
 */ 1 4 this 3 2155  
176 0 0 4 240 2104 0 0 58 /**
 * Specifies the LoaderOptions for this BamReader.
 */ 2 4 this 3 2131  7 options 1 2151  
177 0 0 38 241 2000 0 0 1059 /**
 * Reads a single object from the Bam file.  If the object type is known, a
 * new object of the appropriate type is created and returned; otherwise, NULL
 * is returned.  NULL is also returned when the end of the file is reached.
 * is_eof() may be called to differentiate between these two cases.
 *
 * This may be called repeatedly to extract out all the objects in the Bam
 * file, but typically (especially for scene graph files, indicated with the
 * .bam extension), only one object is retrieved directly from the Bam file:
 * the root of the scene graph.  The remaining objects will all be retrieved
 * recursively by the first object.
 *
 * Note that the object returned may not yet be complete.  In particular, some
 * of its pointers may not be filled in; you must call resolve() to fill in
 * all the available pointers before you can safely use any objects returned
 * by read_object().
 *
 * This flavor of read_object() requires the caller to know what type of
 * object it has received in order to properly manage the reference counts.
 */ 1 4 this 3 2131  
178 0 0 6 242 1972 0 0 138 /**
 * Returns true if the reader has reached end-of-file, false otherwise.  This
 * call is only valid after a call to read_object().
 */ 1 4 this 3 2155  
179 0 0 6 243 1972 0 0 566 /**
 * This may be called at any time during processing of the Bam file to resolve
 * all the known pointers so far.  It is usually called at the end of the
 * processing, after all objects have been read, which is generally the best
 * time to call it.
 *
 * This must be called at least once after reading a particular object via
 * read_object() in order to validate that object.
 *
 * The return value is true if all objects have been resolved, or false if
 * some objects are still outstanding (in which case you will need to call
 * resolve() again later).
 */ 1 4 this 3 2131  
180 0 0 6 244 1972 0 0 406 /**
 * Indicates that an object recently read from the bam stream should be
 * replaced with a new object.  Any future occurrences of the original object
 * in the stream will henceforth return the new object instead.
 *
 * The return value is true if the replacement was successfully made, or false
 * if the object was not read from the stream (or if change_pointer had
 * already been called on it).
 */ 3 4 this 3 2131  12 orig_pointer 1 2132  11 new_pointer 1 2132  
181 0 0 6 245 1971 0 0 81 /**
 * Returns the major version number of the Bam file currently being read.
 */ 1 4 this 3 2155  
182 0 0 6 246 1971 0 0 81 /**
 * Returns the minor version number of the Bam file currently being read.
 */ 1 4 this 3 2155  
183 0 0 6 247 1990 0 0 254 /**
 * Returns the endian preference indicated by the Bam file currently being
 * read.  This does not imply that every number is stored using the indicated
 * convention, but individual objects may choose to respect this flag when
 * recording data.
 */ 1 4 this 3 2155  
184 0 0 6 248 1972 0 0 220 /**
 * Returns true if the file stores all "standard" floats as 64-bit doubles, or
 * false if they are 32-bit floats.  This is determined by the compilation
 * flags of the version of Panda that generated this file.
 */ 1 4 this 3 2155  
185 0 0 6 249 1971 0 0 174 /**
 * Returns the major version number of Bam files supported by the current code
 * base.  This must match get_file_major_ver() in order to successfully read a
 * file.
 */ 1 4 this 3 2155  
186 0 0 6 250 1971 0 0 184 /**
 * Returns the minor version number of Bam files supported by the current code
 * base.  This must match or exceed get_file_minor_ver() in order to
 * successfully read a file.
 */ 1 4 this 3 2155  
187 0 0 38 251 2000 0 0 0 1 4 this 3 2155  
188 0 0 36 264 2104 0 0 0 2 6 handle 1 2117  4 func 1 2000  
189 0 0 15 266 2126 1180 0 0 1 6 param0 0 2157  
190 0 0 7 266 2126 1180 0 10 /**
 *
 */ 1 6 target 5 2004  
191 0 0 4 268 2104 0 0 153 /**
 * Changes the destination of future datagrams written by the BamWriter.  This
 * also implicitly calls init() if it has not already been called.
 */ 2 4 this 3 2126  6 target 1 2004  
192 0 0 6 269 2004 0 0 100 /**
 * Returns the current target of the BamWriter as set by set_target() or the
 * constructor.
 */ 1 4 this 3 2126  
193 0 0 6 270 1972 0 0 220 /**
 * Initializes the BamWriter prior to writing any objects to its output
 * stream.  This includes writing out the Bam header.
 *
 * This returns true if the BamWriter successfully initialized, false
 * otherwise.
 */ 1 4 this 3 2126  
194 0 0 6 271 2140 0 0 197 /**
 * If a BAM is a file, then the BamWriter should contain the name of the file.
 * This enables the writer to convert pathnames in the BAM to relative to the
 * directory containing the BAM.
 */ 1 4 this 3 2157  
195 0 0 6 272 1972 0 0 736 /**
 * Writes a single object to the Bam file, so that the
 * BamReader::read_object() can later correctly restore the object and all its
 * pointers.
 *
 * This implicitly also writes any additional objects this object references
 * (if they haven't already been written), so that pointers may be fully
 * resolved.
 *
 * This may be called repeatedly to write a sequence of objects to the Bam
 * file, but typically (especially for scene graph files, indicated with the
 * .bam extension), only one object is written directly from the Bam file: the
 * root of the scene graph.  The remaining objects will all be written
 * recursively by the first object.
 *
 * Returns true if the object is successfully written, false otherwise.
 */ 2 4 this 3 2126  3 obj 1 2132  
196 0 0 6 273 1972 0 0 170 /**
 * Returns true if the object has previously been written (or at least
 * requested to be written) to the bam file, or false if we've never heard of
 * it before.
 */ 2 4 this 3 2157  3 obj 1 2132  
197 0 0 4 274 2104 0 0 85 /**
 * Ensures that all data written thus far is manifested on the output stream.
 */ 1 4 this 3 2126  
198 0 0 6 275 1971 0 0 84 /**
 * Returns the major version number of the Bam file currently being written.
 */ 1 4 this 3 2157  
199 0 0 6 276 1971 0 0 84 /**
 * Returns the minor version number of the Bam file currently being written.
 */ 1 4 this 3 2157  
200 0 0 4 277 2104 0 0 232 /**
 * Changes the minor .bam version to write.  This should be called before
 * init().  Each Panda version has only a fairly narrow range of versions it
 * is able to write; consult the .bam documentation for more information.
 */ 2 4 this 3 2126  9 minor_ver 1 1971  
201 0 0 6 278 1990 0 0 257 /**
 * Returns the endian preference indicated by the Bam file currently being
 * written.  This does not imply that every number is stored using the
 * indicated convention, but individual objects may choose to respect this
 * flag when recording data.
 */ 1 4 this 3 2157  
202 0 0 6 279 1972 0 0 248 /**
 * Returns true if the file will store all "standard" floats as 64-bit
 * doubles, or false if they are 32-bit floats.  This isn't runtime settable;
 * it's based on the compilation flags of the version of Panda that generated
 * this file.
 */ 1 4 this 3 2157  
203 0 0 6 280 1992 0 0 196 /**
 * Returns the BamTextureMode preference indicated by the Bam file currently
 * being written.  Texture objects written to this Bam file will be encoded
 * according to the specified mode.
 */ 1 4 this 3 2157  
204 0 0 4 281 2104 0 0 187 /**
 * Changes the BamTextureMode preference for the Bam file currently being
 * written.  Texture objects written to this Bam file will be encoded
 * according to the specified mode.
 */ 2 4 this 3 2126  17 file_texture_mode 1 1992  
205 0 0 6 282 1987 0 0 165 /**
 * Returns the root node of the part of the scene graph we are currently
 * writing out.  This is used for determining what to make NodePaths relative
 * to.
 */ 1 4 this 3 2157  
206 0 0 4 283 2104 0 0 160 /**
 * Sets the root node of the part of the scene graph we are currently writing
 * out.  NodePaths written to this bam file will be relative to this node.
 */ 2 4 this 3 2126  9 root_node 1 1987  
207 0 0 7 295 2159 1262 0 0 0 
208 0 0 15 295 2159 1262 0 0 1 6 param0 0 2160  
209 0 0 23 295 2159 1262 0 0 1 10 init_value 1 2162  
210 0 0 7 296 2159 1262 0 0 0 
211 0 0 7 297 2159 1262 0 0 0 
212 0 0 7 298 2159 1262 0 0 1 7 on_bits 1 1971  
213 0 0 7 299 2159 1262 0 0 1 5 index 1 1971  
214 0 0 7 300 2159 1262 0 0 2 7 low_bit 1 1971  4 size 1 1971  
215 0 0 6 301 1972 0 0 0 0 
216 0 0 6 302 1971 0 0 0 0 
217 0 0 6 303 1971 0 0 0 1 4 this 3 2160  
218 0 0 6 304 1972 0 0 0 2 4 this 3 2160  5 index 1 1971  
219 0 0 4 305 2104 0 0 0 2 4 this 3 2159  5 index 1 1971  
220 0 0 4 306 2104 0 0 0 2 4 this 3 2159  5 index 1 1971  
221 0 0 4 307 2104 0 0 0 3 4 this 3 2159  5 index 1 1971  5 value 1 1972  
222 0 0 6 308 1972 0 0 0 1 4 this 3 2160  
223 0 0 6 309 1972 0 0 0 1 4 this 3 2160  
224 0 0 6 310 2162 0 0 0 3 4 this 3 2160  7 low_bit 1 1971  4 size 1 1971  
225 0 0 4 311 2104 0 0 0 4 4 this 3 2159  5 value 1 2162  7 low_bit 1 1971  4 size 1 1971  
226 0 0 6 312 1972 0 0 0 3 4 this 3 2160  7 low_bit 1 1971  4 size 1 1971  
227 0 0 6 313 1972 0 0 0 3 4 this 3 2160  7 low_bit 1 1971  4 size 1 1971  
228 0 0 4 314 2104 0 0 0 3 4 this 3 2159  7 low_bit 1 1971  4 size 1 1971  
229 0 0 4 315 2104 0 0 0 3 4 this 3 2159  7 low_bit 1 1971  4 size 1 1971  
230 0 0 4 316 2104 0 0 0 4 4 this 3 2159  5 value 1 1972  7 low_bit 1 1971  4 size 1 1971  
231 0 0 6 317 2162 0 0 0 1 4 this 3 2160  
232 0 0 4 318 2104 0 0 0 2 4 this 3 2159  5 value 1 2162  
233 0 0 6 319 1971 0 0 0 1 4 this 3 2160  
234 0 0 6 320 1971 0 0 0 1 4 this 3 2160  
235 0 0 6 321 1971 0 0 0 1 4 this 3 2160  
236 0 0 6 322 1971 0 0 0 1 4 this 3 2160  
237 0 0 6 323 1971 0 0 0 1 4 this 3 2160  
238 0 0 6 324 1971 0 0 0 1 4 this 3 2160  
239 0 0 6 325 1971 0 0 0 2 4 this 3 2160  7 low_bit 1 1971  
240 0 0 4 326 2104 0 0 0 1 4 this 3 2159  
241 0 0 6 327 1972 0 0 0 2 4 this 3 2160  5 other 1 2160  
242 0 0 4 328 2104 0 0 0 1 4 this 3 2159  
243 0 0 4 329 2104 0 0 0 2 4 this 3 2160  3 out 1 2115  
244 0 0 4 330 2104 0 0 0 3 4 this 3 2160  3 out 1 2115  12 spaces_every 5 1971  
245 0 0 4 331 2104 0 0 0 3 4 this 3 2160  3 out 1 2115  12 spaces_every 5 1971  
246 0 0 4 332 2104 0 0 0 3 4 this 3 2160  3 out 1 2115  12 indent_level 5 1971  
247 0 0 6 333 1972 0 0 0 2 4 this 3 2160  5 other 1 2160  
248 0 0 6 334 1972 0 0 0 2 4 this 3 2160  5 other 1 2160  
249 0 0 6 335 1972 0 0 0 2 4 this 3 2160  5 other 1 2160  
250 0 0 6 336 1971 0 0 0 2 4 this 3 2160  5 other 1 2160  
251 0 0 7 337 2159 1262 0 0 2 4 this 3 2160  5 other 1 2160  
252 0 0 7 338 2159 1262 0 0 2 4 this 3 2160  5 other 1 2160  
253 0 0 7 339 2159 1262 0 0 2 4 this 3 2160  5 other 1 2160  
254 0 0 7 340 2159 1262 0 0 1 4 this 3 2160  
255 0 0 7 341 2159 1262 0 0 2 4 this 3 2160  5 shift 1 1971  
256 0 0 7 342 2159 1262 0 0 2 4 this 3 2160  5 shift 1 1971  
257 0 0 6 343 2159 0 0 0 2 4 this 3 2159  5 other 1 2160  
258 0 0 6 344 2159 0 0 0 2 4 this 3 2159  5 other 1 2160  
259 0 0 6 345 2159 0 0 0 2 4 this 3 2159  5 other 1 2160  
260 0 0 6 346 2159 0 0 0 2 4 this 3 2159  5 shift 1 1971  
261 0 0 6 347 2159 0 0 0 2 4 this 3 2159  5 shift 1 1971  
262 0 0 4 348 2104 0 0 0 1 4 this 3 2159  
263 0 0 4 349 2104 0 0 0 1 4 this 3 2159  
264 0 0 7 350 2159 1262 0 0 1 4 this 3 2160  
265 0 0 7 351 2159 1262 0 0 1 4 this 3 2160  
266 0 0 7 352 2159 1262 0 0 1 4 this 3 2160  
267 0 0 7 352 2159 1262 0 0 2 4 this 3 2160  5 other 1 2160  
268 0 0 7 352 2159 1262 0 0 2 4 this 3 2160  5 index 1 1971  
269 0 0 7 353 2159 1262 0 0 1 4 this 3 2160  
270 0 0 7 353 2159 1262 0 0 2 4 this 3 2160  5 other 1 2160  
271 0 0 7 353 2159 1262 0 0 2 4 this 3 2160  5 index 1 1971  
272 0 0 6 354 1971 0 0 0 1 4 this 3 2160  
273 0 0 38 355 1972 0 0 0 1 4 this 3 2160  
274 0 0 38 356 2000 0 0 0 1 4 this 3 2160  
275 0 0 38 357 2000 0 0 0 1 4 this 3 2160  
276 0 0 7 358 2117 0 0 0 0 
277 0 0 7 362 2163 1327 0 0 0 
278 0 0 15 362 2163 1327 0 0 1 6 param0 0 2164  
279 0 0 23 362 2163 1327 0 0 1 10 init_value 1 2166  
280 0 0 7 363 2163 1327 0 0 0 
281 0 0 7 364 2163 1327 0 0 0 
282 0 0 7 365 2163 1327 0 0 1 7 on_bits 1 1971  
283 0 0 7 366 2163 1327 0 0 1 5 index 1 1971  
284 0 0 7 367 2163 1327 0 0 2 7 low_bit 1 1971  4 size 1 1971  
285 0 0 6 368 1972 0 0 0 0 
286 0 0 6 369 1971 0 0 0 0 
287 0 0 6 370 1971 0 0 0 1 4 this 3 2164  
288 0 0 6 371 1972 0 0 0 2 4 this 3 2164  5 index 1 1971  
289 0 0 4 372 2104 0 0 0 2 4 this 3 2163  5 index 1 1971  
290 0 0 4 373 2104 0 0 0 2 4 this 3 2163  5 index 1 1971  
291 0 0 4 374 2104 0 0 0 3 4 this 3 2163  5 index 1 1971  5 value 1 1972  
292 0 0 6 375 1972 0 0 0 1 4 this 3 2164  
293 0 0 6 376 1972 0 0 0 1 4 this 3 2164  
294 0 0 6 377 2166 0 0 0 3 4 this 3 2164  7 low_bit 1 1971  4 size 1 1971  
295 0 0 4 378 2104 0 0 0 4 4 this 3 2163  5 value 1 2166  7 low_bit 1 1971  4 size 1 1971  
296 0 0 6 379 1972 0 0 0 3 4 this 3 2164  7 low_bit 1 1971  4 size 1 1971  
297 0 0 6 380 1972 0 0 0 3 4 this 3 2164  7 low_bit 1 1971  4 size 1 1971  
298 0 0 4 381 2104 0 0 0 3 4 this 3 2163  7 low_bit 1 1971  4 size 1 1971  
299 0 0 4 382 2104 0 0 0 3 4 this 3 2163  7 low_bit 1 1971  4 size 1 1971  
300 0 0 4 383 2104 0 0 0 4 4 this 3 2163  5 value 1 1972  7 low_bit 1 1971  4 size 1 1971  
301 0 0 6 384 2166 0 0 0 1 4 this 3 2164  
302 0 0 4 385 2104 0 0 0 2 4 this 3 2163  5 value 1 2166  
303 0 0 6 386 1971 0 0 0 1 4 this 3 2164  
304 0 0 6 387 1971 0 0 0 1 4 this 3 2164  
305 0 0 6 388 1971 0 0 0 1 4 this 3 2164  
306 0 0 6 389 1971 0 0 0 1 4 this 3 2164  
307 0 0 6 390 1971 0 0 0 1 4 this 3 2164  
308 0 0 6 391 1971 0 0 0 1 4 this 3 2164  
309 0 0 6 392 1971 0 0 0 2 4 this 3 2164  7 low_bit 1 1971  
310 0 0 4 393 2104 0 0 0 1 4 this 3 2163  
311 0 0 6 394 1972 0 0 0 2 4 this 3 2164  5 other 1 2164  
312 0 0 4 395 2104 0 0 0 1 4 this 3 2163  
313 0 0 4 396 2104 0 0 0 2 4 this 3 2164  3 out 1 2115  
314 0 0 4 397 2104 0 0 0 3 4 this 3 2164  3 out 1 2115  12 spaces_every 5 1971  
315 0 0 4 398 2104 0 0 0 3 4 this 3 2164  3 out 1 2115  12 spaces_every 5 1971  
316 0 0 4 399 2104 0 0 0 3 4 this 3 2164  3 out 1 2115  12 indent_level 5 1971  
317 0 0 6 400 1972 0 0 0 2 4 this 3 2164  5 other 1 2164  
318 0 0 6 401 1972 0 0 0 2 4 this 3 2164  5 other 1 2164  
319 0 0 6 402 1972 0 0 0 2 4 this 3 2164  5 other 1 2164  
320 0 0 6 403 1971 0 0 0 2 4 this 3 2164  5 other 1 2164  
321 0 0 7 404 2163 1327 0 0 2 4 this 3 2164  5 other 1 2164  
322 0 0 7 405 2163 1327 0 0 2 4 this 3 2164  5 other 1 2164  
323 0 0 7 406 2163 1327 0 0 2 4 this 3 2164  5 other 1 2164  
324 0 0 7 407 2163 1327 0 0 1 4 this 3 2164  
325 0 0 7 408 2163 1327 0 0 2 4 this 3 2164  5 shift 1 1971  
326 0 0 7 409 2163 1327 0 0 2 4 this 3 2164  5 shift 1 1971  
327 0 0 6 410 2163 0 0 0 2 4 this 3 2163  5 other 1 2164  
328 0 0 6 411 2163 0 0 0 2 4 this 3 2163  5 other 1 2164  
329 0 0 6 412 2163 0 0 0 2 4 this 3 2163  5 other 1 2164  
330 0 0 6 413 2163 0 0 0 2 4 this 3 2163  5 shift 1 1971  
331 0 0 6 414 2163 0 0 0 2 4 this 3 2163  5 shift 1 1971  
332 0 0 4 415 2104 0 0 0 1 4 this 3 2163  
333 0 0 4 416 2104 0 0 0 1 4 this 3 2163  
334 0 0 7 417 2163 1327 0 0 1 4 this 3 2164  
335 0 0 7 418 2163 1327 0 0 1 4 this 3 2164  
336 0 0 7 419 2163 1327 0 0 1 4 this 3 2164  
337 0 0 7 419 2163 1327 0 0 2 4 this 3 2164  5 other 1 2164  
338 0 0 7 419 2163 1327 0 0 2 4 this 3 2164  5 index 1 1971  
339 0 0 7 420 2163 1327 0 0 1 4 this 3 2164  
340 0 0 7 420 2163 1327 0 0 2 4 this 3 2164  5 other 1 2164  
341 0 0 7 420 2163 1327 0 0 2 4 this 3 2164  5 index 1 1971  
342 0 0 6 421 1971 0 0 0 1 4 this 3 2164  
343 0 0 38 422 1972 0 0 0 1 4 this 3 2164  
344 0 0 38 423 2000 0 0 0 1 4 this 3 2164  
345 0 0 38 424 2000 0 0 0 1 4 this 3 2164  
346 0 0 7 425 2117 0 0 0 0 
347 0 0 7 429 2168 1392 0 0 0 
348 0 0 15 429 2168 1392 0 0 1 6 param0 0 2169  
349 0 0 23 429 2168 1392 0 0 1 10 init_value 1 2171  
350 0 0 7 430 2168 1392 0 0 0 
351 0 0 7 431 2168 1392 0 0 0 
352 0 0 7 432 2168 1392 0 0 1 7 on_bits 1 1971  
353 0 0 7 433 2168 1392 0 0 1 5 index 1 1971  
354 0 0 7 434 2168 1392 0 0 2 7 low_bit 1 1971  4 size 1 1971  
355 0 0 6 435 1972 0 0 0 0 
356 0 0 6 436 1971 0 0 0 0 
357 0 0 6 437 1971 0 0 0 1 4 this 3 2169  
358 0 0 6 438 1972 0 0 0 2 4 this 3 2169  5 index 1 1971  
359 0 0 4 439 2104 0 0 0 2 4 this 3 2168  5 index 1 1971  
360 0 0 4 440 2104 0 0 0 2 4 this 3 2168  5 index 1 1971  
361 0 0 4 441 2104 0 0 0 3 4 this 3 2168  5 index 1 1971  5 value 1 1972  
362 0 0 6 442 1972 0 0 0 1 4 this 3 2169  
363 0 0 6 443 1972 0 0 0 1 4 this 3 2169  
364 0 0 6 444 2171 0 0 0 3 4 this 3 2169  7 low_bit 1 1971  4 size 1 1971  
365 0 0 4 445 2104 0 0 0 4 4 this 3 2168  5 value 1 2171  7 low_bit 1 1971  4 size 1 1971  
366 0 0 6 446 1972 0 0 0 3 4 this 3 2169  7 low_bit 1 1971  4 size 1 1971  
367 0 0 6 447 1972 0 0 0 3 4 this 3 2169  7 low_bit 1 1971  4 size 1 1971  
368 0 0 4 448 2104 0 0 0 3 4 this 3 2168  7 low_bit 1 1971  4 size 1 1971  
369 0 0 4 449 2104 0 0 0 3 4 this 3 2168  7 low_bit 1 1971  4 size 1 1971  
370 0 0 4 450 2104 0 0 0 4 4 this 3 2168  5 value 1 1972  7 low_bit 1 1971  4 size 1 1971  
371 0 0 6 451 2171 0 0 0 1 4 this 3 2169  
372 0 0 4 452 2104 0 0 0 2 4 this 3 2168  5 value 1 2171  
373 0 0 6 453 1971 0 0 0 1 4 this 3 2169  
374 0 0 6 454 1971 0 0 0 1 4 this 3 2169  
375 0 0 6 455 1971 0 0 0 1 4 this 3 2169  
376 0 0 6 456 1971 0 0 0 1 4 this 3 2169  
377 0 0 6 457 1971 0 0 0 1 4 this 3 2169  
378 0 0 6 458 1971 0 0 0 1 4 this 3 2169  
379 0 0 6 459 1971 0 0 0 2 4 this 3 2169  7 low_bit 1 1971  
380 0 0 4 460 2104 0 0 0 1 4 this 3 2168  
381 0 0 6 461 1972 0 0 0 2 4 this 3 2169  5 other 1 2169  
382 0 0 4 462 2104 0 0 0 1 4 this 3 2168  
383 0 0 4 463 2104 0 0 0 2 4 this 3 2169  3 out 1 2115  
384 0 0 4 464 2104 0 0 0 3 4 this 3 2169  3 out 1 2115  12 spaces_every 5 1971  
385 0 0 4 465 2104 0 0 0 3 4 this 3 2169  3 out 1 2115  12 spaces_every 5 1971  
386 0 0 4 466 2104 0 0 0 3 4 this 3 2169  3 out 1 2115  12 indent_level 5 1971  
387 0 0 6 467 1972 0 0 0 2 4 this 3 2169  5 other 1 2169  
388 0 0 6 468 1972 0 0 0 2 4 this 3 2169  5 other 1 2169  
389 0 0 6 469 1972 0 0 0 2 4 this 3 2169  5 other 1 2169  
390 0 0 6 470 1971 0 0 0 2 4 this 3 2169  5 other 1 2169  
391 0 0 7 471 2168 1392 0 0 2 4 this 3 2169  5 other 1 2169  
392 0 0 7 472 2168 1392 0 0 2 4 this 3 2169  5 other 1 2169  
393 0 0 7 473 2168 1392 0 0 2 4 this 3 2169  5 other 1 2169  
394 0 0 7 474 2168 1392 0 0 1 4 this 3 2169  
395 0 0 7 475 2168 1392 0 0 2 4 this 3 2169  5 shift 1 1971  
396 0 0 7 476 2168 1392 0 0 2 4 this 3 2169  5 shift 1 1971  
397 0 0 6 477 2168 0 0 0 2 4 this 3 2168  5 other 1 2169  
398 0 0 6 478 2168 0 0 0 2 4 this 3 2168  5 other 1 2169  
399 0 0 6 479 2168 0 0 0 2 4 this 3 2168  5 other 1 2169  
400 0 0 6 480 2168 0 0 0 2 4 this 3 2168  5 shift 1 1971  
401 0 0 6 481 2168 0 0 0 2 4 this 3 2168  5 shift 1 1971  
402 0 0 4 482 2104 0 0 0 1 4 this 3 2168  
403 0 0 4 483 2104 0 0 0 1 4 this 3 2168  
404 0 0 7 484 2168 1392 0 0 1 4 this 3 2169  
405 0 0 7 485 2168 1392 0 0 1 4 this 3 2169  
406 0 0 7 486 2168 1392 0 0 1 4 this 3 2169  
407 0 0 7 486 2168 1392 0 0 2 4 this 3 2169  5 other 1 2169  
408 0 0 7 486 2168 1392 0 0 2 4 this 3 2169  5 index 1 1971  
409 0 0 7 487 2168 1392 0 0 1 4 this 3 2169  
410 0 0 7 487 2168 1392 0 0 2 4 this 3 2169  5 other 1 2169  
411 0 0 7 487 2168 1392 0 0 2 4 this 3 2169  5 index 1 1971  
412 0 0 6 488 1971 0 0 0 1 4 this 3 2169  
413 0 0 38 489 1972 0 0 0 1 4 this 3 2169  
414 0 0 38 490 2000 0 0 0 1 4 this 3 2169  
415 0 0 38 491 2000 0 0 0 1 4 this 3 2169  
416 0 0 7 492 2117 0 0 0 0 
417 0 0 7 498 2172 1453 0 10 /**
 *
 */ 0 
418 0 0 15 498 2172 1453 0 0 1 6 param0 0 2173  
419 0 0 55 498 2172 1453 0 0 1 10 init_value 1 2000  
420 0 0 23 498 2172 1453 0 10 /**
 *
 */ 1 4 from 1 2175  
421 0 0 7 499 2172 1453 0 69 /**
 * Returns a BitArray with an infinite array of bits, all on.
 */ 0 
422 0 0 7 500 2172 1453 0 53 /**
 * Returns a BitArray whose bits are all off.
 */ 0 
423 0 0 7 501 2172 1453 0 62 /**
 * Returns a BitArray whose lower on_bits bits are on.
 */ 1 7 on_bits 1 1971  
424 0 0 7 502 2172 1453 0 61 /**
 * Returns a BitArray with only the indicated bit on.
 */ 1 5 index 1 1971  
425 0 0 7 503 2172 1453 0 76 /**
 * Returns a BitArray whose size bits, beginning at low_bit, are on.
 */ 2 7 low_bit 1 1971  4 size 1 1971  
426 0 0 6 504 1972 0 0 0 0 
427 0 0 6 505 1971 0 0 0 0 
428 0 0 6 506 1971 0 0 0 0 
429 0 0 6 507 2177 0 0 300 /**
 * Returns the current number of possibly different bits in this array.  There
 * are actually an infinite number of bits, but every bit higher than this bit
 * will have the same value, either 0 or 1 (see get_highest_bits()).
 *
 * This number may grow and/or shrink automatically as needed.
 */ 1 4 this 3 2173  
430 0 0 6 508 1972 0 0 191 /**
 * Returns true if the nth bit is set, false if it is cleared.  It is valid
 * for n to increase beyond get_num_bits(), but the return value
 * get_num_bits() will always be the same.
 */ 2 4 this 3 2173  5 index 1 1971  
431 0 0 4 509 2104 0 0 97 /**
 * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
 * the array.
 */ 2 4 this 3 2172  5 index 1 1971  
432 0 0 4 510 2104 0 0 98 /**
 * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
 * the array.
 */ 2 4 this 3 2172  5 index 1 1971  
433 0 0 4 511 2104 0 0 84 /**
 * Sets the nth bit either on or off, according to the indicated bool value.
 */ 3 4 this 3 2172  5 index 1 1971  5 value 1 1972  
434 0 0 6 512 1972 0 0 118 /**
 * Returns true if the infinite set of bits beyond get_num_bits() are all on,
 * or false of they are all off.
 */ 1 4 this 3 2173  
435 0 0 6 513 1972 0 0 71 /**
 * Returns true if the entire bitmask is zero, false otherwise.
 */ 1 4 this 3 2173  
436 0 0 6 514 1972 0 0 70 /**
 * Returns true if the entire bitmask is one, false otherwise.
 */ 1 4 this 3 2173  
437 0 0 6 515 2178 0 0 187 /**
 * Returns a word that represents only the indicated range of bits within this
 * BitArray, shifted to the least-significant position.  size must be <=
 * get_num_bits_per_word().
 */ 3 4 this 3 2173  7 low_bit 1 1971  4 size 1 1971  
438 0 0 4 516 2104 0 0 92 /**
 * Stores the indicated word into the indicated range of bits with this
 * BitArray.
 */ 4 4 this 3 2172  5 value 1 2178  7 low_bit 1 1971  4 size 1 1971  
439 0 0 6 517 1972 0 0 82 /**
 * Returns true if any bit in the indicated range is set, false otherwise.
 */ 3 4 this 3 2173  7 low_bit 1 1971  4 size 1 1971  
440 0 0 6 518 1972 0 0 84 /**
 * Returns true if all bits in the indicated range are set, false otherwise.
 */ 3 4 this 3 2173  7 low_bit 1 1971  4 size 1 1971  
441 0 0 4 519 2104 0 0 47 /**
 * Sets the indicated range of bits on.
 */ 3 4 this 3 2172  7 low_bit 1 1971  4 size 1 1971  
442 0 0 4 520 2104 0 0 48 /**
 * Sets the indicated range of bits off.
 */ 3 4 this 3 2172  7 low_bit 1 1971  4 size 1 1971  
443 0 0 4 521 2104 0 0 64 /**
 * Sets the indicated range of bits to either on or off.
 */ 4 4 this 3 2172  5 value 1 1972  7 low_bit 1 1971  4 size 1 1971  
444 0 0 6 522 1971 0 0 127 /**
 * Returns the number of bits that are set to 1 in the array.  Returns -1 if
 * there are an infinite number of 1 bits.
 */ 1 4 this 3 2173  
445 0 0 6 523 1971 0 0 127 /**
 * Returns the number of bits that are set to 0 in the array.  Returns -1 if
 * there are an infinite number of 0 bits.
 */ 1 4 this 3 2173  
446 0 0 6 524 1971 0 0 101 /**
 * Returns the index of the lowest 1 bit in the array.  Returns -1 if there
 * are no 1 bits.
 */ 1 4 this 3 2173  
447 0 0 6 525 1971 0 0 101 /**
 * Returns the index of the lowest 0 bit in the array.  Returns -1 if there
 * are no 0 bits.
 */ 1 4 this 3 2173  
448 0 0 6 526 1971 0 0 143 /**
 * Returns the index of the highest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there an infinite number of 1 bits.
 */ 1 4 this 3 2173  
449 0 0 6 527 1971 0 0 143 /**
 * Returns the index of the highest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there an infinite number of 1 bits.
 */ 1 4 this 3 2173  
450 0 0 6 528 1971 0 0 287 /**
 * Returns the index of the next bit in the array, above low_bit, whose value
 * is different that the value of low_bit.  Returns low_bit again if all bits
 * higher than low_bit have the same value.
 *
 * This can be used to quickly iterate through all of the bits in the array.
 */ 2 4 this 3 2173  7 low_bit 1 1971  
451 0 0 6 529 2177 0 0 75 /**
 * Returns the number of possibly-unique words stored in the array.
 */ 1 4 this 3 2173  
452 0 0 6 530 2178 0 0 175 /**
 * Returns the nth word in the array.  It is valid for n to be greater than
 * get_num_words(), but the return value beyond get_num_words() will always be
 * the same.
 */ 2 4 this 3 2173  1 n 1 2177  
453 0 0 4 531 2104 0 0 113 /**
 * Replaces the nth word in the array.  If n >= get_num_words(), this
 * automatically extends the array.
 */ 3 4 this 3 2172  1 n 1 2177  5 value 1 2178  
454 0 0 4 532 2104 0 0 90 /**
 * Inverts all the bits in the BitArray.  This is equivalent to array =
 * ~array.
 */ 1 4 this 3 2172  
455 0 0 6 533 1972 0 0 178 /**
 * Returns true if this BitArray has any "one" bits in common with the other
 * one, false otherwise.
 *
 * This is equivalent to (array & other) != 0, but may be faster.
 */ 2 4 this 3 2173  5 other 1 2173  
456 0 0 4 534 2104 0 0 49 /**
 * Sets all the bits in the BitArray off.
 */ 1 4 this 3 2172  
457 0 0 4 535 2104 0 0 193 /**
 * Writes the BitArray out as a hex number.  For a BitArray, this is always
 * the same as output_hex(); it's too confusing for the output format to
 * change back and forth at runtime.
 */ 2 4 this 3 2173  3 out 1 2115  
458 0 0 4 536 2104 0 0 83 /**
 * Writes the BitArray out as a binary number, with spaces every four bits.
 */ 3 4 this 3 2173  3 out 1 2115  12 spaces_every 5 1971  
459 0 0 4 537 2104 0 0 93 /**
 * Writes the BitArray out as a hexadecimal number, with spaces every four
 * digits.
 */ 3 4 this 3 2173  3 out 1 2115  12 spaces_every 5 1971  
460 0 0 4 538 2104 0 0 99 /**
 * Writes the BitArray out as a binary or a hex number, according to the
 * number of bits.
 */ 3 4 this 3 2173  3 out 1 2115  12 indent_level 5 1971  
461 0 0 6 539 1972 0 0 0 2 4 this 3 2173  5 other 1 2173  
462 0 0 6 540 1972 0 0 0 2 4 this 3 2173  5 other 1 2173  
463 0 0 6 541 1972 0 0 0 2 4 this 3 2173  5 other 1 2173  
464 0 0 6 542 1971 0 0 233 /**
 * Returns a number less than zero if this BitArray sorts before the indicated
 * other BitArray, greater than zero if it sorts after, or 0 if they are
 * equivalent.  This is based on the same ordering defined by operator <.
 */ 2 4 this 3 2173  5 other 1 2173  
465 0 0 7 543 2172 1453 0 0 2 4 this 3 2173  5 other 1 2173  
466 0 0 7 544 2172 1453 0 0 2 4 this 3 2173  5 other 1 2173  
467 0 0 7 545 2172 1453 0 0 2 4 this 3 2173  5 other 1 2173  
468 0 0 7 546 2172 1453 0 0 1 4 this 3 2173  
469 0 0 7 547 2172 1453 0 0 2 4 this 3 2173  5 shift 1 1971  
470 0 0 7 548 2172 1453 0 0 2 4 this 3 2173  5 shift 1 1971  
471 0 0 6 549 2172 0 0 0 2 4 this 3 2172  5 other 1 2173  
472 0 0 6 550 2172 0 0 0 2 4 this 3 2172  5 other 1 2173  
473 0 0 6 551 2172 0 0 0 2 4 this 3 2172  5 other 1 2173  
474 0 0 6 552 2172 0 0 0 2 4 this 3 2172  5 shift 1 1971  
475 0 0 6 553 2172 0 0 0 2 4 this 3 2172  5 shift 1 1971  
476 0 0 38 554 1972 0 0 0 1 4 this 3 2173  
477 0 0 38 555 2000 0 0 0 1 4 this 3 2173  
478 0 0 36 556 2104 0 0 0 2 4 this 3 2172  5 state 1 2000  
479 0 0 7 557 2117 0 0 0 0 
480 0 0 7 560 2179 1473 0 259 // The default constructor must do nothing, because we can't guarantee
// ordering of static initializers.  If the constructor tried to initialize
// its value, it  might happen after the value had already been set
// previously by another static initializer! 0 
481 0 0 15 560 2179 1473 0 0 1 6 param0 0 2180  
482 0 0 7 560 2179 1473 0 154 /**
 * Constructs a ButtonHandle with the corresponding index number, which may
 * have been returned by an earlier call to ButtonHandle::get_index().
 */ 1 5 index 1 1971  
483 0 0 23 560 2179 1473 0 341 /**
 * Constructs a ButtonHandle with the corresponding name, which is looked up
 * in the ButtonRegistry.  This exists for the purpose of being able to
 * automatically coerce a string into a ButtonHandle; for most purposes, you
 * should use either the static KeyboardButton/MouseButton getters or
 * ButtonRegistry::register_button().
 */ 1 4 name 1 2119  
484 0 0 6 561 1972 0 0 0 2 4 this 3 2180  5 other 1 2180  
485 0 0 6 562 1972 0 0 0 2 4 this 3 2180  5 other 1 2180  
486 0 0 6 563 1972 0 0 0 2 4 this 3 2180  5 other 1 2180  
487 0 0 6 564 1972 0 0 0 2 4 this 3 2180  5 other 1 2180  
488 0 0 6 565 1972 0 0 0 2 4 this 3 2180  5 other 1 2180  
489 0 0 6 566 1972 0 0 0 2 4 this 3 2180  5 other 1 2180  
490 0 0 6 567 1971 0 0 209 /**
 * Sorts ButtonHandles arbitrarily (according to <, >, etc.).  Returns a
 * number less than 0 if this type sorts before the other one, greater than
 * zero if it sorts after, 0 if they are equivalent.
 */ 2 4 this 3 2180  5 other 1 2180  
491 0 0 6 568 2177 0 0 54 /**
 * Returns a hash code suitable for phash_map.
 */ 1 4 this 3 2180  
492 0 0 6 569 2119 0 0 42 /**
 * Returns the name of the button.
 */ 1 4 this 3 2180  
493 0 0 6 570 1972 0 0 121 /**
 * Returns true if the button was created with an ASCII equivalent code (e.g.
 * for a standard keyboard button).
 */ 1 4 this 3 2180  
494 0 0 6 571 2018 0 0 109 /**
 * Returns the character code associated with the button, or '\0' if no ASCII
 * code was associated.
 */ 1 4 this 3 2180  
495 0 0 7 572 2179 1473 0 373 /**
 * Returns the alias (alternate name) associated with the button, if any, or
 * ButtonHandle::none() if the button has no alias.
 *
 * Each button is allowed to have one alias, and multiple different buttons
 * can refer to the same alias.  The alias should be the more general name for
 * the button, for instance, shift is an alias for lshift, but not vice-versa.
 */ 1 4 this 3 2180  
496 0 0 6 573 1972 0 0 263 /**
 * Returns true if this ButtonHandle is the same as the other one, or if the
 * other one is an alias for this one.  (Does not return true if this button
 * is an alias for the other one, however.)
 *
 * This is a more general comparison than operator ==.
 */ 2 4 this 3 2180  5 other 1 2180  
497 0 0 6 574 1971 0 0 363 /**
 * Returns the integer index associated with this ButtonHandle.  Each
 * different ButtonHandle will have a different index.  However, you probably
 * shouldn't be using this method; you should just treat the ButtonHandles as
 * opaque classes.  This is provided for the convenience of non-C++ scripting
 * languages to build a hashtable of ButtonHandles.
 */ 1 4 this 3 2180  
498 0 0 4 575 2104 0 0 10 /**
 *
 */ 2 4 this 3 2180  3 out 1 2115  
499 0 0 7 576 2179 1473 0 0 0 
500 0 0 7 585 2117 0 0 0 0 
501 0 0 6 577 1972 0 0 0 1 4 this 3 2180  
502 0 0 15 593 2184 1480 0 0 1 6 param0 0 2182  
503 0 0 7 588 2179 1473 0 150 /**
 * Finds a ButtonHandle in the registry matching the indicated name.  If there
 * is no such ButtonHandle, registers a new one and returns it.
 */ 2 4 this 3 2184  4 name 1 2119  
504 0 0 7 589 2179 1473 0 144 /**
 * Finds a ButtonHandle in the registry matching the indicated name.  If there
 * is no such ButtonHandle, returns ButtonHandle::none().
 */ 2 4 this 3 2184  4 name 1 2119  
505 0 0 7 590 2179 1473 0 169 /**
 * Finds a ButtonHandle in the registry matching the indicated ASCII
 * equivalent character.  If there is no such ButtonHandle, returns
 * ButtonHandle::none().
 */ 2 4 this 3 2182  16 ascii_equivalent 1 2018  
506 0 0 4 591 2104 0 0 10 /**
 *
 */ 2 4 this 3 2182  3 out 1 2115  
507 0 0 6 592 2184 0 0 67 /**
 * Returns the pointer to the global ButtonRegistry object.
 */ 0 
508 0 0 7 604 2185 1489 0 0 0 
509 0 0 15 604 2185 1489 0 0 1 6 param0 0 2186  
510 0 0 6 597 2177 0 0 76 /**
 * Returns the number of buttons that this button mapping specifies.
 */ 1 4 this 3 2186  
511 0 0 7 598 2179 1473 0 76 /**
 * Returns the underlying raw button associated with the nth button.
 */ 2 4 this 3 2186  1 i 1 2177  
512 0 0 7 599 2179 1473 0 166 /**
 * Returns the button that the given button is mapped to, or
 * ButtonHandle::none() if this map does not specify a mapped button for the
 * given raw button.
 */ 2 4 this 3 2186  3 raw 1 2179  
513 0 0 7 599 2179 1473 0 101 /**
 * Returns the nth mapped button, meaning the button that the nth raw button
 * is mapped to.
 */ 2 4 this 3 2186  1 i 1 2177  
514 0 0 7 599 2179 1473 0 166 /**
 * Returns the button that the given button is mapped to, or
 * ButtonHandle::none() if this map does not specify a mapped button for the
 * given raw button.
 */ 2 4 this 3 2186  8 raw_name 1 2119  
515 0 0 6 600 2119 0 0 353 /**
 * If the button map specifies a special name for the button (eg.  if the
 * operating system or keyboard device has a localized name describing the
 * key), returns it, or the empty string otherwise.
 *
 * Note that this is not the same as get_mapped_button().get_name(), which
 * returns the name of the Panda event associated with the button.
 */ 2 4 this 3 2186  3 raw 1 2179  
516 0 0 6 600 2119 0 0 127 /**
 * Returns the label associated with the nth mapped button, meaning the button
 * that the nth raw button is mapped to.
 */ 2 4 this 3 2186  1 i 1 2177  
517 0 0 6 600 2119 0 0 353 /**
 * If the button map specifies a special name for the button (eg.  if the
 * operating system or keyboard device has a localized name describing the
 * key), returns it, or the empty string otherwise.
 *
 * Note that this is not the same as get_mapped_button().get_name(), which
 * returns the name of the Panda event associated with the button.
 */ 2 4 this 3 2186  8 raw_name 1 2119  
518 0 0 4 601 2104 0 0 10 /**
 *
 */ 2 4 this 3 2186  3 out 1 2115  
519 0 0 4 602 2104 0 0 10 /**
 *
 */ 3 4 this 3 2186  3 out 1 2115  12 indent_level 5 1971  
520 0 0 7 603 2117 0 0 0 0 
521 0 0 15 610 2190 1494 0 0 1 6 param0 0 2188  
522 0 0 4 607 2104 0 0 10 /**
 *
 */ 2 4 this 3 2188  3 out 1 2115  
523 0 0 55 608 2190 1494 0 0 1 8 function 1 2000  
524 0 0 7 609 2117 0 0 0 0 
525 0 0 6 613 1971 0 0 47 /**
 * Returns the current reference count.
 */ 1 4 this 3 2191  
526 0 0 4 614 2104 0 0 108 /**
 * Explicitly increments the cache reference count and the normal reference
 * count simultaneously.
 */ 1 4 this 3 2191  
527 0 0 6 615 1972 0 0 202 /**
 * Explicitly decrements the cache reference count and the normal reference
 * count simultaneously.
 *
 * The return value is true if the new reference count is nonzero, false if it
 * is zero.
 */ 1 4 this 3 2191  
528 0 0 6 616 1972 0 0 97 /**
 * Does some easy checks to make sure that the reference count isn't
 * completely bogus.
 */ 1 4 this 3 2191  
529 0 0 7 618 2117 0 0 0 0 
530 0 0 4 620 2104 0 0 10 /**
 *
 */ 2 4 this 3 2193  3 out 1 2115  
531 0 0 4 621 2104 0 0 159 /**
 * You should make this call during the callback if you want to continue the
 * normal function that would have been done in the absence of a callback.
 */ 1 4 this 3 2195  
532 0 0 7 622 2117 0 0 0 0 
533 0 0 23 625 2196 1494 0 10 /**
 *
 */ 1 8 function 5 2000  
534 0 0 15 625 2196 1494 0 0 1 6 param0 0 2197  
535 0 0 4 626 2104 0 0 0 2 4 this 3 2196  4 size 1 2177  
536 0 0 4 629 2104 0 0 126 /**
 * Replaces the function that is called for the callback.  runs.  The
 * parameter should be a Python callable object.
 */ 2 4 this 3 2196  8 function 1 2000  
537 0 0 6 630 2000 0 0 64 /**
 * Returns the function that is called for the callback.
 */ 1 4 this 3 2196  
538 0 0 6 631 2000 0 0 37 /**
 * Implements pickle support.
 */ 1 4 this 3 2197  
539 0 0 7 633 2117 0 0 0 0 
540 0 0 7 635 2199 1517 0 10 /**
 *
 */ 0 
541 0 0 15 635 2199 1517 0 0 1 6 param0 0 2200  
542 0 0 6 636 2028 0 0 10 /**
 *
 */ 1 4 this 3 2200  
543 0 0 6 637 2028 0 0 10 /**
 *
 */ 1 4 this 3 2200  
544 0 0 15 646 2204 0 0 10 /**
 *
 */ 1 4 copy 1 2202  
545 0 0 23 646 2204 0 0 10 /**
 *
 */ 1 4 mode 5 2030  
546 0 0 4 647 2104 0 0 1841 /**
 * Changes the mode of the clock.  Normally, the clock is in mode M_normal.
 * In this mode, each call to tick() will set the value returned by
 * get_frame_time() to the current real time; thus, the clock simply reports
 * time advancing.
 *
 * Other possible modes:
 *
 * M_non_real_time - the clock ignores real time completely; at each call to
 * tick(), it pretends that exactly dt seconds have elapsed since the last
 * call to tick().  You may set the value of dt with set_dt() or
 * set_frame_rate().
 *
 * M_limited - the clock will run as fast as it can, as in M_normal, but will
 * not run faster than the rate specified by set_frame_rate().  If the
 * application would run faster than this rate, the clock will slow down the
 * application.
 *
 * M_integer - the clock will run as fast as it can, but the rate will be
 * constrained to be an integer multiple or divisor of the rate specified by
 * set_frame_rate().  The clock will slow down the application a bit to
 * guarantee this.
 *
 * M_integer_limited - a combination of M_limited and M_integer; the clock
 * will not run faster than set_frame_rate(), and if it runs slower, it will
 * run at a integer divisor of that rate.
 *
 * M_forced - the clock forces the application to run at the rate specified by
 * set_frame_rate().  If the application would run faster than this rate, the
 * clock will slow down the application; if the application would run slower
 * than this rate, the clock slows down time so that the application believes
 * it is running at the given rate.
 *
 * M_degrade - the clock runs at real time, but the application is slowed down
 * by a set factor of its frame rate, specified by set_degrade_factor().
 *
 * M_slave - the clock does not advance, but relies on the user to call
 * set_frame_time() and/or set_frame_count() each frame.
 */ 2 4 this 3 2204  4 mode 1 2030  
547 0 0 6 648 2030 0 0 66 /**
 * Returns the current mode of the clock.  See set_mode().
 */ 1 4 this 3 2202  
548 0 0 6 650 1970 0 0 350 /**
 * Returns the time in seconds as of the last time tick() was called
 * (typically, this will be as of the start of the current frame).
 *
 * This is generally the kind of time you want to ask for in most rendering
 * and animation contexts, since it's important that all of the animation for
 * a given frame remains in sync with each other.
 */ 2 4 this 3 2202  14 current_thread 5 2205  
549 0 0 6 651 1970 0 0 434 /**
 * Returns the actual number of seconds elapsed since the ClockObject was
 * created, or since it was last reset.  This is useful for doing real timing
 * measurements, e.g.  for performance statistics.
 *
 * This returns the most precise timer we have for short time intervals, but
 * it may tend to drift over the long haul.  If more accurate timekeeping is
 * needed over a long period of time, use get_long_time() instead.
 */ 1 4 this 3 2202  
550 0 0 6 652 1970 0 0 440 /**
 * Returns the actual number of seconds elapsed since the ClockObject was
 * created, or since it was last reset.
 *
 * This is similar to get_real_time(), except that it uses the most accurate
 * counter we have over a long period of time, and so it is less likely to
 * drift.  However, it may not be very precise for measuring short intervals.
 * On Windows, for instace, this is only accurate to within about 55
 * milliseconds.
 */ 1 4 this 3 2202  
551 0 0 4 653 2104 0 0 75 /**
 * Simultaneously resets both the time and the frame count to zero.
 */ 1 4 this 3 2204  
552 0 0 4 654 2104 0 0 316 /**
 * Resets the clock to the indicated time.  This changes only the real time of
 * the clock as reported by get_real_time(), but does not immediately change
 * the time reported by get_frame_time()--that will change after the next call
 * to tick().  Also see reset(), set_frame_time(), and set_frame_count().
 */ 2 4 this 3 2204  4 time 1 1970  
553 0 0 4 655 2104 0 0 215 /**
 * Changes the time as reported for the current frame to the indicated time.
 * Normally, the way to adjust the frame time is via tick(); this function is
 * provided only for occasional special adjustments.
 */ 3 4 this 3 2204  4 time 1 1970  14 current_thread 5 2205  
554 0 0 4 656 2104 0 0 132 /**
 * Resets the number of frames counted to the indicated number.  Also see
 * reset(), set_real_time(), and set_frame_time().
 */ 3 4 this 3 2204  11 frame_count 1 1971  14 current_thread 5 2205  
555 0 0 6 657 1971 0 0 195 /**
 * Returns the number of times tick() has been called since the ClockObject
 * was created, or since it was last reset.  This is generally the number of
 * frames that have been rendered.
 */ 2 4 this 3 2202  14 current_thread 5 2205  
556 0 0 6 658 1970 0 0 245 /**
 * Returns the average frame rate since the last reset.  This is simply the
 * total number of frames divided by the total elapsed time.  This reports the
 * virtual frame rate if the clock is in (or has been in) M_non_real_time
 * mode.
 */ 2 4 this 3 2202  14 current_thread 5 2205  
557 0 0 6 663 1970 0 0 130 /**
 * Returns the elapsed time for the previous frame: the number of seconds
 * elapsed between the last two calls to tick().
 */ 2 4 this 3 2202  14 current_thread 5 2205  
558 0 0 4 664 2104 0 0 291 /**
 * In non-real-time mode, sets the number of seconds that should appear to
 * elapse between frames.  In forced mode or limited mode, sets our target dt.
 * In normal mode, this has no effect.
 *
 * Also see set_frame_rate(), which is a different way to specify the same
 * quantity.
 */ 2 4 this 3 2204  2 dt 1 1970  
559 0 0 4 665 2104 0 0 291 /**
 * In non-real-time mode, sets the number of frames per second that we should
 * appear to be running.  In forced mode or limited mode, sets our target
 * frame rate.  In normal mode, this has no effect.
 *
 * Also see set_dt(), which is a different way to specify the same quantity.
 */ 2 4 this 3 2204  10 frame_rate 1 1970  
560 0 0 6 667 1970 0 0 106 /**
 * Returns the current maximum allowable time elapsed between any two frames.
 * See set_max_dt().
 */ 1 4 this 3 2202  
561 0 0 4 668 2104 0 0 511 /**
 * Sets a limit on the value returned by get_dt().  If this value is less than
 * zero, no limit is imposed; otherwise, this is the maximum value that will
 * ever be returned by get_dt(), regardless of how much time has actually
 * elapsed between frames.
 *
 * This limit is only imposed in real-time mode; in non-real-time mode, the dt
 * is fixed anyway and max_dt is ignored.
 *
 * This is generally used to guarantee reasonable behavior even in the
 * presence of a very slow or chuggy frame rame.
 */ 2 4 this 3 2204  6 max_dt 1 1970  
562 0 0 6 670 1970 0 0 265 /**
 * In degrade mode, returns the ratio by which the performance is degraded.  A
 * value of 2.0 causes the clock to be slowed down by a factor of two
 * (reducing performance to 1/2 what would be otherwise).
 *
 * This has no effect if mode is not M_degrade.
 */ 1 4 this 3 2202  
563 0 0 4 671 2104 0 0 262 /**
 * In degrade mode, sets the ratio by which the performance is degraded.  A
 * value of 2.0 causes the clock to be slowed down by a factor of two
 * (reducing performance to 1/2 what would be otherwise).
 *
 * This has no effect if mode is not M_degrade.
 */ 2 4 this 3 2204  14 degrade_factor 1 1970  
564 0 0 4 673 2104 0 0 393 /**
 * Specifies the interval of time (in seconds) over which
 * get_average_frame_rate() averages the number of frames per second to
 * compute the frame rate.  Changing this does not necessarily immediately
 * change the result of get_average_frame_rate(), until this interval of time
 * has elapsed again.
 *
 * Setting this to zero disables the computation of get_average_frame_rate().
 */ 2 4 this 3 2204  4 time 1 1970  
565 0 0 6 674 1970 0 0 162 /**
 * Returns the interval of time (in seconds) over which
 * get_average_frame_rate() averages the number of frames per second to
 * compute the frame rate.
 */ 1 4 this 3 2202  
566 0 0 6 676 1970 0 0 214 /**
 * Returns the average frame rate in number of frames per second over the last
 * get_average_frame_rate_interval() seconds.  This measures the virtual frame
 * rate if the clock is in M_non_real_time mode.
 */ 2 4 this 3 2202  14 current_thread 5 2205  
567 0 0 6 677 1970 0 0 105 /**
 * Returns the maximum frame duration over the last
 * get_average_frame_rate_interval() seconds.
 */ 2 4 this 3 2202  14 current_thread 5 2205  
568 0 0 6 678 1970 0 0 539 /**
 * Returns the standard deviation of the frame times of the frames rendered
 * over the past get_average_frame_rate_interval() seconds.  This number gives
 * an estimate of the chugginess of the frame rate; if it is large, there is a
 * large variation in the frame rate; if is small, all of the frames are
 * consistent in length.
 *
 * A large value might also represent just a recent change in frame rate, for
 * instance, because the camera has just rotated from looking at a simple
 * scene to looking at a more complex scene.
 */ 2 4 this 3 2202  14 current_thread 5 2205  
569 0 0 4 681 2104 0 0 285 /**
 * Instructs the clock that a new frame has just begun.  In normal, real-time
 * mode, get_frame_time() will henceforth report the time as of this instant
 * as the current start-of-frame time.  In non-real-time mode,
 * get_frame_time() will be incremented by the value of dt.
 */ 2 4 this 3 2204  14 current_thread 5 2205  
570 0 0 4 682 2104 0 0 417 /**
 * Resets the frame time to the current real time.  This is similar to tick(),
 * except that it does not advance the frame counter and does not affect dt.
 * This is intended to be used in the middle of a particularly long frame to
 * compensate for the time that has already elapsed.
 *
 * In non-real-time mode, this function has no effect (because in this mode
 * all frames take the same length of time).
 */ 2 4 this 3 2204  14 current_thread 5 2205  
571 0 0 6 683 1972 0 0 322 /**
 * Returns true if a clock error was detected since the last time
 * check_errors() was called.  A clock error means that something happened, an
 * OS or BIOS bug, for instance, that makes the current value of the clock
 * somewhat suspect, and an application may wish to resynchronize with any
 * external clocks.
 */ 2 4 this 3 2204  14 current_thread 1 2205  
572 0 0 7 684 2204 0 0 159 /**
 * Returns a pointer to the global ClockObject.  This is the ClockObject that
 * most code should use for handling scene graph rendering and animation.
 */ 0 
573 0 0 7 685 2117 0 0 0 0 
574 0 0 4 693 2104 0 0 62 /**
 * @see CachedTypedWritableReferenceCount::cache_ref()
 */ 1 4 this 3 2207  
575 0 0 6 694 1972 0 0 64 /**
 * @see CachedTypedWritableReferenceCount::cache_unref()
 */ 1 4 this 3 2207  
576 0 0 7 695 2117 0 0 0 0 
577 0 0 7 702 2209 1563 0 48 /**
 * Initializes an empty datagram buffer.
 */ 0 
578 0 0 7 702 2209 1563 0 54 /**
 * Initializes the buffer with the given data.
 */ 1 4 data 1 2036  
579 0 0 4 703 2104 0 0 38 /**
 * Clears the internal buffer.
 */ 1 4 this 3 2209  
580 0 0 6 698 2004 0 0 0 1 4 this 3 2209  
581 0 0 6 700 1997 0 0 0 1 4 this 3 2209  
582 0 0 7 712 2210 0 0 10 /**
 *
 */ 0 
583 0 0 6 713 1972 0 0 99 /**
 * Opens the indicated filename for reading.  Returns true on success, false
 * on failure.
 */ 2 4 this 3 2210  4 file 1 2211  
584 0 0 6 713 1972 0 0 99 /**
 * Opens the indicated filename for reading.  Returns true on success, false
 * on failure.
 */ 2 4 this 3 2210  8 filename 1 2140  
585 0 0 6 713 1972 0 0 230 /**
 * Starts reading from the indicated stream.  Returns true on success, false
 * on failure.  The DatagramInputFile does not take ownership of the stream;
 * you are responsible for closing or deleting it when you are done.
 */ 3 4 this 3 2210  2 in 1 2214  8 filename 5 2140  
586 0 0 6 714 2214 0 0 61 /**
 * Returns the istream represented by the input file.
 */ 1 4 this 3 2210  
587 0 0 4 715 2104 0 0 98 /**
 * Closes the file.  This is also implicitly done when the DatagramInputFile
 * destructs.
 */ 1 4 this 3 2210  
588 0 0 7 718 2216 0 0 10 /**
 *
 */ 0 
589 0 0 6 719 1972 0 0 102 /**
 * Opens the indicated filename for writing.  Returns true if successful,
 * false on failure.
 */ 2 4 this 3 2216  4 file 1 2211  
590 0 0 6 719 1972 0 0 99 /**
 * Opens the indicated filename for writing.  Returns true on success, false
 * on failure.
 */ 2 4 this 3 2216  8 filename 1 2140  
591 0 0 6 719 1972 0 0 229 /**
 * Starts writing to the indicated stream.  Returns true on success, false on
 * failure.  The DatagramOutputFile does not take ownership of the stream; you
 * are responsible for closing or deleting it when you are done.
 */ 3 4 this 3 2216  3 out 1 2115  8 filename 5 2140  
592 0 0 4 720 2104 0 0 99 /**
 * Closes the file.  This is also implicitly done when the DatagramOutputFile
 * destructs.
 */ 1 4 this 3 2216  
593 0 0 6 721 1972 0 0 256 /**
 * Writes a sequence of bytes to the beginning of the datagram file.  This may
 * be called any number of times after the file has been opened and before the
 * first datagram is written.  It may not be called once the first datagram is
 * written.
 */ 2 4 this 3 2216  6 header 1 2119  
594 0 0 6 721 1972 0 0 256 /**
 * Writes a sequence of bytes to the beginning of the datagram file.  This may
 * be called any number of times after the file has been opened and before the
 * first datagram is written.  It may not be called once the first datagram is
 * written.
 */ 2 4 this 3 2216  6 header 1 2036  
595 0 0 7 726 2217 1629 0 0 0 
596 0 0 15 726 2217 1629 0 0 1 6 param0 0 2218  
597 0 0 55 726 2217 1629 0 0 1 10 init_value 1 2000  
598 0 0 7 727 2217 1629 0 0 0 
599 0 0 7 728 2217 1629 0 0 0 
600 0 0 7 729 2217 1629 0 0 1 7 on_bits 1 1971  
601 0 0 7 730 2217 1629 0 0 1 5 index 1 1971  
602 0 0 7 731 2217 1629 0 0 2 7 low_bit 1 1971  4 size 1 1971  
603 0 0 6 732 1972 0 0 0 0 
604 0 0 6 733 1971 0 0 0 0 
605 0 0 6 734 1971 0 0 0 1 4 this 3 2218  
606 0 0 6 735 1972 0 0 0 2 4 this 3 2218  5 index 1 1971  
607 0 0 4 736 2104 0 0 0 2 4 this 3 2217  5 index 1 1971  
608 0 0 4 737 2104 0 0 0 2 4 this 3 2217  5 index 1 1971  
609 0 0 4 738 2104 0 0 0 3 4 this 3 2217  5 index 1 1971  5 value 1 1972  
610 0 0 6 739 1972 0 0 0 1 4 this 3 2218  
611 0 0 6 740 1972 0 0 0 1 4 this 3 2218  
612 0 0 6 741 2171 0 0 0 3 4 this 3 2218  7 low_bit 1 1971  4 size 1 1971  
613 0 0 4 742 2104 0 0 0 4 4 this 3 2217  5 value 1 2171  7 low_bit 1 1971  4 size 1 1971  
614 0 0 6 743 1972 0 0 0 3 4 this 3 2218  7 low_bit 1 1971  4 size 1 1971  
615 0 0 6 744 1972 0 0 0 3 4 this 3 2218  7 low_bit 1 1971  4 size 1 1971  
616 0 0 4 745 2104 0 0 0 3 4 this 3 2217  7 low_bit 1 1971  4 size 1 1971  
617 0 0 4 746 2104 0 0 0 3 4 this 3 2217  7 low_bit 1 1971  4 size 1 1971  
618 0 0 4 747 2104 0 0 0 4 4 this 3 2217  5 value 1 1972  7 low_bit 1 1971  4 size 1 1971  
619 0 0 6 748 1971 0 0 0 1 4 this 3 2218  
620 0 0 6 749 1971 0 0 0 1 4 this 3 2218  
621 0 0 6 750 1971 0 0 0 1 4 this 3 2218  
622 0 0 6 751 1971 0 0 0 1 4 this 3 2218  
623 0 0 6 752 1971 0 0 0 1 4 this 3 2218  
624 0 0 6 753 1971 0 0 0 1 4 this 3 2218  
625 0 0 6 754 1971 0 0 0 2 4 this 3 2218  7 low_bit 1 1971  
626 0 0 4 755 2104 0 0 0 1 4 this 3 2217  
627 0 0 6 756 1972 0 0 0 2 4 this 3 2218  5 other 1 2218  
628 0 0 4 757 2104 0 0 0 1 4 this 3 2217  
629 0 0 4 758 2104 0 0 0 2 4 this 3 2218  3 out 1 2115  
630 0 0 4 759 2104 0 0 0 3 4 this 3 2218  3 out 1 2115  12 spaces_every 5 1971  
631 0 0 4 760 2104 0 0 0 3 4 this 3 2218  3 out 1 2115  12 spaces_every 5 1971  
632 0 0 4 761 2104 0 0 0 3 4 this 3 2218  3 out 1 2115  12 indent_level 5 1971  
633 0 0 6 762 1972 0 0 0 2 4 this 3 2218  5 other 1 2218  
634 0 0 6 763 1972 0 0 0 2 4 this 3 2218  5 other 1 2218  
635 0 0 6 764 1972 0 0 0 2 4 this 3 2218  5 other 1 2218  
636 0 0 6 765 1971 0 0 0 2 4 this 3 2218  5 other 1 2218  
637 0 0 7 766 2217 1629 0 0 2 4 this 3 2218  5 other 1 2218  
638 0 0 7 767 2217 1629 0 0 2 4 this 3 2218  5 other 1 2218  
639 0 0 7 768 2217 1629 0 0 2 4 this 3 2218  5 other 1 2218  
640 0 0 7 769 2217 1629 0 0 1 4 this 3 2218  
641 0 0 7 770 2217 1629 0 0 2 4 this 3 2218  5 shift 1 1971  
642 0 0 7 771 2217 1629 0 0 2 4 this 3 2218  5 shift 1 1971  
643 0 0 6 772 2217 0 0 0 2 4 this 3 2217  5 other 1 2218  
644 0 0 6 773 2217 0 0 0 2 4 this 3 2217  5 other 1 2218  
645 0 0 6 774 2217 0 0 0 2 4 this 3 2217  5 other 1 2218  
646 0 0 6 775 2217 0 0 0 2 4 this 3 2217  5 shift 1 1971  
647 0 0 6 776 2217 0 0 0 2 4 this 3 2217  5 shift 1 1971  
648 0 0 38 777 1972 0 0 0 1 4 this 3 2218  
649 0 0 38 778 2000 0 0 0 1 4 this 3 2218  
650 0 0 38 779 2000 0 0 0 1 4 this 3 2218  
651 0 0 7 780 2117 0 0 0 0 
652 0 0 7 784 2220 1685 0 0 0 
653 0 0 15 784 2220 1685 0 0 1 6 param0 0 2221  
654 0 0 55 784 2220 1685 0 0 1 10 init_value 1 2000  
655 0 0 7 785 2220 1685 0 0 0 
656 0 0 7 786 2220 1685 0 0 0 
657 0 0 7 787 2220 1685 0 0 1 7 on_bits 1 1971  
658 0 0 7 788 2220 1685 0 0 1 5 index 1 1971  
659 0 0 7 789 2220 1685 0 0 2 7 low_bit 1 1971  4 size 1 1971  
660 0 0 6 790 1972 0 0 0 0 
661 0 0 6 791 1971 0 0 0 0 
662 0 0 6 792 1971 0 0 0 1 4 this 3 2221  
663 0 0 6 793 1972 0 0 0 2 4 this 3 2221  5 index 1 1971  
664 0 0 4 794 2104 0 0 0 2 4 this 3 2220  5 index 1 1971  
665 0 0 4 795 2104 0 0 0 2 4 this 3 2220  5 index 1 1971  
666 0 0 4 796 2104 0 0 0 3 4 this 3 2220  5 index 1 1971  5 value 1 1972  
667 0 0 6 797 1972 0 0 0 1 4 this 3 2221  
668 0 0 6 798 1972 0 0 0 1 4 this 3 2221  
669 0 0 6 799 2171 0 0 0 3 4 this 3 2221  7 low_bit 1 1971  4 size 1 1971  
670 0 0 4 800 2104 0 0 0 4 4 this 3 2220  5 value 1 2171  7 low_bit 1 1971  4 size 1 1971  
671 0 0 6 801 1972 0 0 0 3 4 this 3 2221  7 low_bit 1 1971  4 size 1 1971  
672 0 0 6 802 1972 0 0 0 3 4 this 3 2221  7 low_bit 1 1971  4 size 1 1971  
673 0 0 4 803 2104 0 0 0 3 4 this 3 2220  7 low_bit 1 1971  4 size 1 1971  
674 0 0 4 804 2104 0 0 0 3 4 this 3 2220  7 low_bit 1 1971  4 size 1 1971  
675 0 0 4 805 2104 0 0 0 4 4 this 3 2220  5 value 1 1972  7 low_bit 1 1971  4 size 1 1971  
676 0 0 6 806 1971 0 0 0 1 4 this 3 2221  
677 0 0 6 807 1971 0 0 0 1 4 this 3 2221  
678 0 0 6 808 1971 0 0 0 1 4 this 3 2221  
679 0 0 6 809 1971 0 0 0 1 4 this 3 2221  
680 0 0 6 810 1971 0 0 0 1 4 this 3 2221  
681 0 0 6 811 1971 0 0 0 1 4 this 3 2221  
682 0 0 6 812 1971 0 0 0 2 4 this 3 2221  7 low_bit 1 1971  
683 0 0 4 813 2104 0 0 0 1 4 this 3 2220  
684 0 0 6 814 1972 0 0 0 2 4 this 3 2221  5 other 1 2221  
685 0 0 4 815 2104 0 0 0 1 4 this 3 2220  
686 0 0 4 816 2104 0 0 0 2 4 this 3 2221  3 out 1 2115  
687 0 0 4 817 2104 0 0 0 3 4 this 3 2221  3 out 1 2115  12 spaces_every 5 1971  
688 0 0 4 818 2104 0 0 0 3 4 this 3 2221  3 out 1 2115  12 spaces_every 5 1971  
689 0 0 4 819 2104 0 0 0 3 4 this 3 2221  3 out 1 2115  12 indent_level 5 1971  
690 0 0 6 820 1972 0 0 0 2 4 this 3 2221  5 other 1 2221  
691 0 0 6 821 1972 0 0 0 2 4 this 3 2221  5 other 1 2221  
692 0 0 6 822 1972 0 0 0 2 4 this 3 2221  5 other 1 2221  
693 0 0 6 823 1971 0 0 0 2 4 this 3 2221  5 other 1 2221  
694 0 0 7 824 2220 1685 0 0 2 4 this 3 2221  5 other 1 2221  
695 0 0 7 825 2220 1685 0 0 2 4 this 3 2221  5 other 1 2221  
696 0 0 7 826 2220 1685 0 0 2 4 this 3 2221  5 other 1 2221  
697 0 0 7 827 2220 1685 0 0 1 4 this 3 2221  
698 0 0 7 828 2220 1685 0 0 2 4 this 3 2221  5 shift 1 1971  
699 0 0 7 829 2220 1685 0 0 2 4 this 3 2221  5 shift 1 1971  
700 0 0 6 830 2220 0 0 0 2 4 this 3 2220  5 other 1 2221  
701 0 0 6 831 2220 0 0 0 2 4 this 3 2220  5 other 1 2221  
702 0 0 6 832 2220 0 0 0 2 4 this 3 2220  5 other 1 2221  
703 0 0 6 833 2220 0 0 0 2 4 this 3 2220  5 shift 1 1971  
704 0 0 6 834 2220 0 0 0 2 4 this 3 2220  5 shift 1 1971  
705 0 0 38 835 1972 0 0 0 1 4 this 3 2221  
706 0 0 38 836 2000 0 0 0 1 4 this 3 2221  
707 0 0 38 837 2000 0 0 0 1 4 this 3 2221  
708 0 0 7 838 2117 0 0 0 0 
709 0 0 7 874 2223 1718 0 0 0 
710 0 0 15 874 2223 1718 0 0 1 6 param0 0 2224  
711 0 0 7 843 2179 1473 0 0 0 
712 0 0 7 844 2179 1473 0 0 0 
713 0 0 7 845 2179 1473 0 0 0 
714 0 0 7 846 2179 1473 0 0 0 
715 0 0 7 847 2179 1473 0 0 0 
716 0 0 7 848 2179 1473 0 0 0 
717 0 0 7 849 2179 1473 0 0 0 
718 0 0 7 850 2179 1473 0 0 0 
719 0 0 7 851 2179 1473 0 0 0 
720 0 0 7 852 2179 1473 0 0 0 
721 0 0 7 853 2179 1473 0 0 0 
722 0 0 7 854 2179 1473 0 0 0 
723 0 0 7 855 2179 1473 0 0 0 
724 0 0 7 856 2179 1473 0 0 0 
725 0 0 7 857 2179 1473 0 0 0 
726 0 0 7 858 2179 1473 0 0 0 
727 0 0 7 859 2179 1473 0 0 0 
728 0 0 7 860 2179 1473 0 0 0 
729 0 0 7 861 2179 1473 0 0 0 
730 0 0 7 862 2179 1473 0 0 0 
731 0 0 7 863 2179 1473 0 0 0 
732 0 0 7 864 2179 1473 0 0 0 
733 0 0 7 865 2179 1473 0 0 0 
734 0 0 7 866 2179 1473 0 0 0 
735 0 0 7 867 2179 1473 0 0 0 
736 0 0 7 868 2179 1473 0 74 // Flight stick buttons, takes zero-based index.  First is always trigger. 0 
737 0 0 7 869 2179 1473 0 169 /**
 * Returns the ButtonHandle associated with the particular numbered joystick
 * button (zero-based), if there is one, or ButtonHandle::none() if there is
 * not.
 */ 1 13 button_number 1 1971  
738 0 0 7 870 2179 1473 0 0 0 
739 0 0 7 871 2179 1473 0 0 0 
740 0 0 7 872 2179 1473 0 0 0 
741 0 0 7 873 2179 1473 0 0 0 
742 0 0 7 931 2226 1772 0 0 0 
743 0 0 15 931 2226 1772 0 0 1 6 param0 0 2227  
744 0 0 7 879 2179 1473 0 144 /**
 * Returns the ButtonHandle associated with the particular ASCII character, if
 * there is one, or ButtonHandle::none() if there is not.
 */ 1 16 ascii_equivalent 1 2018  
745 0 0 7 880 2179 1473 0 0 0 
746 0 0 7 881 2179 1473 0 0 0 
747 0 0 7 882 2179 1473 0 0 0 
748 0 0 7 883 2179 1473 0 0 0 
749 0 0 7 884 2179 1473 0 0 0 
750 0 0 7 885 2179 1473 0 0 0 
751 0 0 7 886 2179 1473 0 0 0 
752 0 0 7 887 2179 1473 0 0 0 
753 0 0 7 888 2179 1473 0 0 0 
754 0 0 7 889 2179 1473 0 0 0 
755 0 0 7 890 2179 1473 0 0 0 
756 0 0 7 891 2179 1473 0 0 0 
757 0 0 7 892 2179 1473 0 0 0 
758 0 0 7 893 2179 1473 0 0 0 
759 0 0 7 894 2179 1473 0 0 0 
760 0 0 7 895 2179 1473 0 0 0 
761 0 0 7 896 2179 1473 0 0 0 
762 0 0 7 897 2179 1473 0 59 // PC keyboards don't have these four buttons, but Macs do. 0 
763 0 0 7 898 2179 1473 0 0 0 
764 0 0 7 899 2179 1473 0 0 0 
765 0 0 7 900 2179 1473 0 0 0 
766 0 0 7 901 2179 1473 0 0 0 
767 0 0 7 902 2179 1473 0 0 0 
768 0 0 7 903 2179 1473 0 0 0 
769 0 0 7 904 2179 1473 0 0 0 
770 0 0 7 905 2179 1473 0 0 0 
771 0 0 7 906 2179 1473 0 0 0 
772 0 0 7 907 2179 1473 0 0 0 
773 0 0 7 908 2179 1473 0 0 0 
774 0 0 7 909 2179 1473 0 0 0 
775 0 0 7 910 2179 1473 0 27 // delete is a C++ keyword. 0 
776 0 0 7 911 2179 1473 0 27 // delete is a C++ keyword. 0 
777 0 0 7 912 2179 1473 0 0 0 
778 0 0 7 913 2179 1473 0 0 0 
779 0 0 7 914 2179 1473 0 0 0 
780 0 0 7 915 2179 1473 0 0 0 
781 0 0 7 916 2179 1473 0 0 0 
782 0 0 7 917 2179 1473 0 0 0 
783 0 0 7 918 2179 1473 0 0 0 
784 0 0 7 919 2179 1473 0 0 0 
785 0 0 7 920 2179 1473 0 0 0 
786 0 0 7 921 2179 1473 0 0 0 
787 0 0 7 922 2179 1473 0 0 0 
788 0 0 7 923 2179 1473 0 0 0 
789 0 0 7 924 2179 1473 0 0 0 
790 0 0 7 925 2179 1473 0 0 0 
791 0 0 7 926 2179 1473 0 0 0 
792 0 0 7 927 2179 1473 0 0 0 
793 0 0 7 928 2179 1473 0 0 0 
794 0 0 7 929 2179 1473 0 0 0 
795 0 0 7 930 2179 1473 0 0 0 
796 0 0 7 938 2229 1778 0 10 /**
 *
 */ 0 
797 0 0 15 938 2229 1778 0 10 /**
 *
 */ 1 4 copy 1 2230  
798 0 0 6 940 2229 0 0 0 2 4 this 3 2229  4 copy 1 2230  
799 0 0 6 941 1972 0 0 0 2 4 this 3 2230  5 other 1 2230  
800 0 0 6 942 1972 0 0 0 2 4 this 3 2230  5 other 1 2230  
801 0 0 6 943 1972 0 0 0 2 4 this 3 2230  5 other 1 2230  
802 0 0 7 944 2229 1778 0 0 2 4 this 3 2230  5 other 1 2230  
803 0 0 7 945 2229 1778 0 0 2 4 this 3 2230  5 other 1 2230  
804 0 0 6 946 2229 0 0 0 2 4 this 3 2229  5 other 1 2230  
805 0 0 6 947 2229 0 0 0 2 4 this 3 2229  5 other 1 2230  
806 0 0 4 948 2104 0 0 374 /**
 * Sets the list of buttons to watch to be the same as that of the other
 * ModifierButtons object.  This makes the lists pointer equivalent (until one
 * or the other is later modified).
 *
 * This will preserve the state of any button that was on the original list
 * and is also on the new lists.  Any other buttons will get reset to the
 * default state of "up".
 */ 2 4 this 3 2229  5 other 1 2230  
807 0 0 6 949 1972 0 0 232 /**
 * Returns true if the set of buttons indicated as down by this
 * ModifierButtons object is the same set of buttons indicated as down by the
 * other ModifierButtons object.  The buttons indicated as up are not
 * relevant.
 */ 2 4 this 3 2230  5 other 1 2230  
808 0 0 6 950 1972 0 0 248 /**
 * Adds the indicated button to the set of buttons that will be monitored for
 * upness and downness.  Returns true if the button was added, false if it was
 * already being monitored or if too many buttons are currently being
 * monitored.
 */ 2 4 this 3 2229  6 button 1 2179  
809 0 0 6 951 1972 0 0 109 /**
 * Returns true if the indicated button is in the set of buttons being
 * monitored, false otherwise.
 */ 2 4 this 3 2230  6 button 1 2179  
810 0 0 6 952 1972 0 0 313 /**
 * Removes the indicated button from the set of buttons being monitored.
 * Returns true if the button was removed, false if it was not being monitored
 * in the first place.
 *
 * Unlike the other methods, you cannot remove a button by removing its alias;
 * you have to remove exactly the button itself.
 */ 2 4 this 3 2229  6 button 1 2179  
811 0 0 6 953 1971 0 0 143 /**
 * Returns the number of buttons that the ModifierButtons object is monitoring
 * (e.g.  the number of buttons passed to add_button()).
 */ 1 4 this 3 2230  
812 0 0 7 954 2179 1473 0 185 /**
 * Returns the nth button that the ModifierButtons object is monitoring (the
 * nth button passed to add_button()).  This must be in the range 0 <= index <
 * get_num_buttons().
 */ 2 4 this 3 2230  5 index 1 1971  
813 0 0 6 957 1972 0 0 305 /**
 * Records that a particular button has been pressed.  If the given button is
 * one of the buttons that is currently being monitored, this will update the
 * internal state appropriately; otherwise, it will do nothing.  Returns true
 * if the button is one that was monitored, or false otherwise.
 */ 2 4 this 3 2229  6 button 1 2179  
814 0 0 6 958 1972 0 0 306 /**
 * Records that a particular button has been released.  If the given button is
 * one of the buttons that is currently being monitored, this will update the
 * internal state appropriately; otherwise, it will do nothing.  Returns true
 * if the button is one that was monitored, or false otherwise.
 */ 2 4 this 3 2229  6 button 1 2179  
815 0 0 4 959 2104 0 0 66 /**
 * Marks all monitored buttons as being in the "up" state.
 */ 1 4 this 3 2229  
816 0 0 6 960 1972 0 0 157 /**
 * Returns true if the indicated button is known to be down, or false if it is
 * known to be up or if it is not in the set of buttons being tracked.
 */ 2 4 this 3 2230  6 button 1 2179  
817 0 0 6 960 1972 0 0 105 /**
 * Returns true if the indicated button is known to be down, or false if it is
 * known to be up.
 */ 2 4 this 3 2230  5 index 1 1971  
818 0 0 6 961 1972 0 0 109 /**
 * Returns true if any of the tracked button are known to be down, or false if
 * all of them are up.
 */ 1 4 this 3 2230  
819 0 0 6 962 2119 0 0 150 /**
 * Returns a string which can be used to prefix any button name or event name
 * with the unique set of modifier buttons currently being held.
 */ 1 4 this 3 2230  
820 0 0 4 963 2104 0 0 69 /**
 * Writes a one-line summary of the buttons known to be down.
 */ 2 4 this 3 2230  3 out 1 2115  
821 0 0 4 964 2104 0 0 123 /**
 * Writes a multi-line summary including all of the buttons being monitored
 * and which ones are known to be down.
 */ 2 4 this 3 2230  3 out 1 2115  
822 0 0 7 977 2232 1814 0 0 0 
823 0 0 15 977 2232 1814 0 0 1 6 param0 0 2233  
824 0 0 7 966 2179 1473 0 166 /**
 * Returns the ButtonHandle associated with the particular numbered mouse
 * button (zero-based), if there is one, or ButtonHandle::none() if there is
 * not.
 */ 1 13 button_number 1 1971  
825 0 0 7 967 2179 1473 0 75 /**
 * Returns the ButtonHandle associated with the first mouse button.
 */ 0 
826 0 0 7 968 2179 1473 0 76 /**
 * Returns the ButtonHandle associated with the second mouse button.
 */ 0 
827 0 0 7 969 2179 1473 0 75 /**
 * Returns the ButtonHandle associated with the third mouse button.
 */ 0 
828 0 0 7 970 2179 1473 0 76 /**
 * Returns the ButtonHandle associated with the fourth mouse button.
 */ 0 
829 0 0 7 971 2179 1473 0 75 /**
 * Returns the ButtonHandle associated with the fifth mouse button.
 */ 0 
830 0 0 7 972 2179 1473 0 98 /**
 * Returns the ButtonHandle generated when the mouse wheel is rolled one notch
 * upwards.
 */ 0 
831 0 0 7 973 2179 1473 0 100 /**
 * Returns the ButtonHandle generated when the mouse wheel is rolled one notch
 * downwards.
 */ 0 
832 0 0 7 974 2179 1473 0 148 /**
 * Returns the ButtonHandle generated when the mouse is scrolled to the left.
 * Usually, you'll only find the horizontal scroll on laptops.
 */ 0 
833 0 0 7 975 2179 1473 0 149 /**
 * Returns the ButtonHandle generated when the mouse is scrolled to the right.
 * Usually, you'll only find the horizontal scroll on laptops.
 */ 0 
834 0 0 6 976 1972 0 0 117 /**
 * Returns true if the indicated ButtonHandle is a mouse button, false if it
 * is some other kind of button.
 */ 1 6 button 1 2179  
835 0 0 6 980 1971 0 0 47 /**
 * Returns the current reference count.
 */ 1 4 this 3 2235  
836 0 0 4 981 2104 0 0 349 /**
 * Explicitly increments the reference count.
 *
 * This function is const, even though it changes the object, because
 * generally fiddling with an object's reference count isn't considered part
 * of fiddling with the object.  An object might be const in other ways, but
 * we still need to accurately count the number of references to it.
 */ 1 4 this 3 2235  
837 0 0 6 982 1972 0 0 201 /**
 * Explicitly decrements the node reference count and the normal reference
 * count simultaneously.
 *
 * The return value is true if the new reference count is nonzero, false if it
 * is zero.
 */ 1 4 this 3 2235  
838 0 0 6 983 1972 0 0 97 /**
 * Does some easy checks to make sure that the reference count isn't
 * completely bogus.
 */ 1 4 this 3 2235  
839 0 0 6 985 1971 0 0 293 /**
 * Returns the union of the values defined in the Referenced enum that
 * represents the various things that appear to be holding a pointer to this
 * object.
 *
 * If R_node is included, at least one node is holding a pointer; if R_cache
 * is included, at least one cache element is.
 */ 1 4 this 3 2235  
840 0 0 7 986 2117 0 0 0 0 
841 0 0 7 988 2237 1876 0 10 /**
 *
 */ 0 
842 0 0 23 988 2237 1876 0 10 /**
 *
 */ 1 4 from 1 2173  
843 0 0 15 988 2237 1876 0 0 1 6 param0 0 2175  
844 0 0 7 989 2237 1876 0 72 /**
 * Returns a SparseArray with an infinite array of bits, all on.
 */ 0 
845 0 0 7 990 2237 1876 0 56 /**
 * Returns a SparseArray whose bits are all off.
 */ 0 
846 0 0 7 991 2237 1876 0 65 /**
 * Returns a SparseArray whose lower on_bits bits are on.
 */ 1 7 on_bits 1 1971  
847 0 0 7 992 2237 1876 0 64 /**
 * Returns a SparseArray with only the indicated bit on.
 */ 1 5 index 1 1971  
848 0 0 7 993 2237 1876 0 79 /**
 * Returns a SparseArray whose size bits, beginning at low_bit, are on.
 */ 2 7 low_bit 1 1971  4 size 1 1971  
849 0 0 6 994 1972 0 0 393 /**
 * Returns true if there is a maximum number of bits that may be stored in
 * this structure, false otherwise.  If this returns true, the number may be
 * queried in get_max_num_bits().
 *
 * This method always returns false.  The SparseArray has no maximum number of
 * bits.  This method is defined so generic programming algorithms can use
 * BitMask or SparseArray interchangeably.
 */ 0 
850 0 0 6 995 1971 0 0 428 /**
 * If get_max_num_bits() returned true, this method may be called to return
 * the maximum number of bits that may be stored in this structure.  It is an
 * error to call this if get_max_num_bits() return false.
 *
 * It is always an error to call this method.  The SparseArray has no maximum
 * number of bits.  This method is defined so generic programming algorithms
 * can use BitMask or SparseArray interchangeably.
 */ 0 
851 0 0 6 996 1971 0 0 300 /**
 * Returns the current number of possibly different bits in this array.  There
 * are actually an infinite number of bits, but every bit higher than this bit
 * will have the same value, either 0 or 1 (see get_highest_bits()).
 *
 * This number may grow and/or shrink automatically as needed.
 */ 1 4 this 3 2175  
852 0 0 6 997 1972 0 0 191 /**
 * Returns true if the nth bit is set, false if it is cleared.  It is valid
 * for n to increase beyond get_num_bits(), but the return value
 * get_num_bits() will always be the same.
 */ 2 4 this 3 2175  5 index 1 1971  
853 0 0 4 998 2104 0 0 97 /**
 * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
 * the array.
 */ 2 4 this 3 2237  5 index 1 1971  
854 0 0 4 999 2104 0 0 98 /**
 * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
 * the array.
 */ 2 4 this 3 2237  5 index 1 1971  
855 0 0 4 1000 2104 0 0 84 /**
 * Sets the nth bit either on or off, according to the indicated bool value.
 */ 3 4 this 3 2237  5 index 1 1971  5 value 1 1972  
856 0 0 6 1001 1972 0 0 118 /**
 * Returns true if the infinite set of bits beyond get_num_bits() are all on,
 * or false of they are all off.
 */ 1 4 this 3 2175  
857 0 0 6 1002 1972 0 0 71 /**
 * Returns true if the entire bitmask is zero, false otherwise.
 */ 1 4 this 3 2175  
858 0 0 6 1003 1972 0 0 70 /**
 * Returns true if the entire bitmask is one, false otherwise.
 */ 1 4 this 3 2175  
859 0 0 6 1004 1972 0 0 82 /**
 * Returns true if any bit in the indicated range is set, false otherwise.
 */ 3 4 this 3 2175  7 low_bit 1 1971  4 size 1 1971  
860 0 0 6 1005 1972 0 0 84 /**
 * Returns true if all bits in the indicated range are set, false otherwise.
 */ 3 4 this 3 2175  7 low_bit 1 1971  4 size 1 1971  
861 0 0 4 1006 2104 0 0 47 /**
 * Sets the indicated range of bits on.
 */ 3 4 this 3 2237  7 low_bit 1 1971  4 size 1 1971  
862 0 0 4 1007 2104 0 0 48 /**
 * Sets the indicated range of bits off.
 */ 3 4 this 3 2237  7 low_bit 1 1971  4 size 1 1971  
863 0 0 4 1008 2104 0 0 64 /**
 * Sets the indicated range of bits to either on or off.
 */ 4 4 this 3 2237  5 value 1 1972  7 low_bit 1 1971  4 size 1 1971  
864 0 0 6 1009 1971 0 0 127 /**
 * Returns the number of bits that are set to 1 in the array.  Returns -1 if
 * there are an infinite number of 1 bits.
 */ 1 4 this 3 2175  
865 0 0 6 1010 1971 0 0 127 /**
 * Returns the number of bits that are set to 0 in the array.  Returns -1 if
 * there are an infinite number of 0 bits.
 */ 1 4 this 3 2175  
866 0 0 6 1011 1971 0 0 146 /**
 * Returns the index of the lowest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there are an infinite number of 1 bits.
 */ 1 4 this 3 2175  
867 0 0 6 1012 1971 0 0 146 /**
 * Returns the index of the lowest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there are an infinite number of 1 bits.
 */ 1 4 this 3 2175  
868 0 0 6 1013 1971 0 0 143 /**
 * Returns the index of the highest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there an infinite number of 1 bits.
 */ 1 4 this 3 2175  
869 0 0 6 1014 1971 0 0 143 /**
 * Returns the index of the highest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there an infinite number of 1 bits.
 */ 1 4 this 3 2175  
870 0 0 6 1015 1971 0 0 287 /**
 * Returns the index of the next bit in the array, above low_bit, whose value
 * is different that the value of low_bit.  Returns low_bit again if all bits
 * higher than low_bit have the same value.
 *
 * This can be used to quickly iterate through all of the bits in the array.
 */ 2 4 this 3 2175  7 low_bit 1 1971  
871 0 0 4 1016 2104 0 0 93 /**
 * Inverts all the bits in the SparseArray.  This is equivalent to array =
 * ~array.
 */ 1 4 this 3 2237  
872 0 0 6 1017 1972 0 0 181 /**
 * Returns true if this SparseArray has any "one" bits in common with the
 * other one, false otherwise.
 *
 * This is equivalent to (array & other) != 0, but may be faster.
 */ 2 4 this 3 2175  5 other 1 2175  
873 0 0 4 1018 2104 0 0 52 /**
 * Sets all the bits in the SparseArray off.
 */ 1 4 this 3 2237  
874 0 0 4 1019 2104 0 0 10 /**
 *
 */ 2 4 this 3 2175  3 out 1 2115  
875 0 0 6 1020 1972 0 0 0 2 4 this 3 2175  5 other 1 2175  
876 0 0 6 1021 1972 0 0 0 2 4 this 3 2175  5 other 1 2175  
877 0 0 6 1022 1972 0 0 0 2 4 this 3 2175  5 other 1 2175  
878 0 0 6 1023 1971 0 0 242 /**
 * Returns a number less than zero if this SparseArray sorts before the
 * indicated other SparseArray, greater than zero if it sorts after, or 0 if
 * they are equivalent.  This is based on the same ordering defined by
 * operator <.
 */ 2 4 this 3 2175  5 other 1 2175  
879 0 0 7 1024 2237 1876 0 0 2 4 this 3 2175  5 other 1 2175  
880 0 0 7 1025 2237 1876 0 0 2 4 this 3 2175  5 other 1 2175  
881 0 0 7 1026 2237 1876 0 0 2 4 this 3 2175  5 other 1 2175  
882 0 0 7 1027 2237 1876 0 0 1 4 this 3 2175  
883 0 0 7 1028 2237 1876 0 0 2 4 this 3 2175  5 shift 1 1971  
884 0 0 7 1029 2237 1876 0 0 2 4 this 3 2175  5 shift 1 1971  
885 0 0 6 1030 2237 0 0 0 2 4 this 3 2237  5 other 1 2175  
886 0 0 6 1031 2237 0 0 0 2 4 this 3 2237  5 other 1 2175  
887 0 0 6 1032 2237 0 0 0 2 4 this 3 2237  5 other 1 2175  
888 0 0 6 1033 2237 0 0 0 2 4 this 3 2237  5 shift 1 1971  
889 0 0 6 1034 2237 0 0 0 2 4 this 3 2237  5 shift 1 1971  
890 0 0 6 1035 1972 0 0 330 /**
 * If this is true, the SparseArray is actually defined as a list of subranges
 * of integers that are *not* in the set.  If this is false (the default),
 * then the subranges define the integers that *are* in the set.  This affects
 * the interpretation of the values returned by iterating through
 * get_num_subranges().
 */ 1 4 this 3 2175  
891 0 0 6 1036 2177 0 0 237 /**
 * Returns the number of separate subranges stored in the SparseArray.  You
 * can use this limit to iterate through the subranges, calling
 * get_subrange_begin() and get_subrange_end() for each one.
 *
 * Also see is_inverse().
 */ 1 4 this 3 2175  
892 0 0 6 1037 1971 0 0 94 /**
 * Returns the first numeric element in the nth subrange.
 *
 * Also see is_inverse().
 */ 2 4 this 3 2175  1 n 1 2177  
893 0 0 6 1038 1971 0 0 104 /**
 * Returns the last numeric element, plus one, in the nth subrange.
 *
 * Also see is_inverse().
 */ 2 4 this 3 2175  1 n 1 2177  
894 0 0 38 1039 1972 0 0 0 1 4 this 3 2175  
895 0 0 38 1040 2000 0 0 0 1 4 this 3 2175  
896 0 0 36 1041 2104 0 0 0 2 4 this 3 2237  5 state 1 2000  
897 0 0 7 1042 2117 0 0 0 0 
898 0 0 7 1045 2117 0 0 52 /**
 * Returns the type of the underlying value.
 */ 1 4 this 3 2238  
899 0 0 4 1046 2104 0 0 0 2 4 this 3 2238  3 out 1 2115  
900 0 0 7 1047 2117 0 0 0 0 
901 0 0 23 1049 2242 1085 0 10 /**
 *
 */ 1 5 value 1 2240  
902 0 0 7 1050 2057 0 0 55 /**
 * Retrieves the value stored in the parameter.
 */ 1 4 this 3 2243  
903 0 0 7 1053 2117 0 0 0 0 
904 0 0 23 1055 2245 1085 0 0 1 5 value 1 2119  
905 0 0 4 1056 2104 0 0 0 2 4 this 3 2245  5 value 1 2119  
906 0 0 6 1057 2119 0 0 0 1 4 this 3 2246  
907 0 0 7 1061 2117 0 0 0 0 
908 0 0 23 1064 2248 1085 0 0 1 5 value 1 2119  
909 0 0 4 1065 2104 0 0 0 2 4 this 3 2248  5 value 1 2119  
910 0 0 6 1066 2119 0 0 0 1 4 this 3 2249  
911 0 0 7 1068 2117 0 0 0 0 
912 0 0 23 1071 2254 1085 0 0 1 5 value 1 2251  
913 0 0 4 1072 2104 0 0 0 2 4 this 3 2254  5 value 1 2251  
914 0 0 6 1073 2251 0 0 0 1 4 this 3 2255  
915 0 0 7 1075 2117 0 0 0 0 
916 0 0 23 1078 2260 1085 0 0 1 5 value 1 2257  
917 0 0 4 1079 2104 0 0 0 2 4 this 3 2260  5 value 1 2257  
918 0 0 6 1080 2257 0 0 0 1 4 this 3 2261  
919 0 0 7 1082 2117 0 0 0 0 
920 0 0 23 1085 2266 1085 0 0 1 5 value 1 2263  
921 0 0 4 1086 2104 0 0 0 2 4 this 3 2266  5 value 1 2263  
922 0 0 6 1087 2263 0 0 0 1 4 this 3 2267  
923 0 0 7 1089 2117 0 0 0 0 
924 0 0 23 1092 2272 1085 0 0 1 5 value 1 2269  
925 0 0 4 1093 2104 0 0 0 2 4 this 3 2272  5 value 1 2269  
926 0 0 6 1094 2269 0 0 0 1 4 this 3 2273  
927 0 0 7 1096 2117 0 0 0 0 
928 0 0 23 1099 2278 1085 0 0 1 5 value 1 2275  
929 0 0 4 1100 2104 0 0 0 2 4 this 3 2278  5 value 1 2275  
930 0 0 6 1101 2275 0 0 0 1 4 this 3 2279  
931 0 0 7 1103 2117 0 0 0 0 
932 0 0 23 1106 2284 1085 0 0 1 5 value 1 2281  
933 0 0 4 1107 2104 0 0 0 2 4 this 3 2284  5 value 1 2281  
934 0 0 6 1108 2281 0 0 0 1 4 this 3 2285  
935 0 0 7 1110 2117 0 0 0 0 
936 0 0 23 1113 2290 1085 0 0 1 5 value 1 2287  
937 0 0 4 1114 2104 0 0 0 2 4 this 3 2290  5 value 1 2287  
938 0 0 6 1115 2287 0 0 0 1 4 this 3 2291  
939 0 0 7 1117 2117 0 0 0 0 
940 0 0 23 1120 2296 1085 0 0 1 5 value 1 2293  
941 0 0 4 1121 2104 0 0 0 2 4 this 3 2296  5 value 1 2293  
942 0 0 6 1122 2293 0 0 0 1 4 this 3 2297  
943 0 0 7 1124 2117 0 0 0 0 
944 0 0 23 1127 2302 1085 0 0 1 5 value 1 2299  
945 0 0 4 1128 2104 0 0 0 2 4 this 3 2302  5 value 1 2299  
946 0 0 6 1129 2299 0 0 0 1 4 this 3 2303  
947 0 0 7 1131 2117 0 0 0 0 
948 0 0 23 1134 2308 1085 0 0 1 5 value 1 2305  
949 0 0 4 1135 2104 0 0 0 2 4 this 3 2308  5 value 1 2305  
950 0 0 6 1136 2305 0 0 0 1 4 this 3 2309  
951 0 0 7 1138 2117 0 0 0 0 
952 0 0 23 1141 2314 1085 0 0 1 5 value 1 2311  
953 0 0 4 1142 2104 0 0 0 2 4 this 3 2314  5 value 1 2311  
954 0 0 6 1143 2311 0 0 0 1 4 this 3 2315  
955 0 0 7 1145 2117 0 0 0 0 
956 0 0 23 1148 2320 1085 0 0 1 5 value 1 2317  
957 0 0 4 1149 2104 0 0 0 2 4 this 3 2320  5 value 1 2317  
958 0 0 6 1150 2317 0 0 0 1 4 this 3 2321  
959 0 0 7 1152 2117 0 0 0 0 
960 0 0 23 1155 2326 1085 0 0 1 5 value 1 2323  
961 0 0 4 1156 2104 0 0 0 2 4 this 3 2326  5 value 1 2323  
962 0 0 6 1157 2323 0 0 0 1 4 this 3 2327  
963 0 0 7 1159 2117 0 0 0 0 
964 0 0 7 1167 2117 0 0 0 0 
965 0 0 7 1183 2329 1952 0 0 0 
966 0 0 15 1183 2329 1952 0 0 1 6 param0 0 2330  
967 0 0 6 1171 1970 0 0 10 /**
 *
 */ 1 4 this 3 2330  
968 0 0 6 1172 1970 0 0 10 /**
 *
 */ 1 4 this 3 2330  
969 0 0 6 1173 1972 0 0 157 /**
 * If this returns false, the pointer is not currently present in the window
 * and the values returned by get_x() and get_y() may not be meaningful.
 */ 1 4 this 3 2330  
970 0 0 7 1186 2332 1954 0 56 /**
 * Create a free id pool in the range [min:max].
 */ 2 3 min 5 2166  3 max 5 2166  
971 0 0 6 1188 2166 0 0 134 /**
 * Returns an id between _min and _max (that were passed to the constructor).
 * IndexEnd is returned if no ids are available.
 */ 1 4 this 3 2332  
972 0 0 4 1189 2104 0 0 518 /**
 * This may be called to mark a particular id as having already been allocated
 * (for instance, by a prior pass).  The specified id is removed from the
 * available pool.
 *
 * Because of the limitations of this algorithm, this is most efficient when
 * it is called before the first call to allocate(), and when all the calls to
 * initial_reserve_id() are made in descending order by id.  However, this is
 * a performance warning only; if performance is not an issue, any id may be
 * reserved at any time.
 */ 2 4 this 3 2332  2 id 1 2166  
973 0 0 6 1190 1972 0 0 119 /**
 * Checks the allocated state of an index. Returns true for
 * indices that are currently allocated and in use.
 */ 2 4 this 3 2332  5 index 1 2166  
974 0 0 6 1191 1972 0 0 278 /**
 * Free an allocated index (index must be between _min and _max that were
 * passed to the constructor).
 *
 * Since 1.11.1, returns true if the index has been freed successfully
 * or false if the index has not been allocated yet, instead of
 * triggering an assertion.
 */ 2 4 this 3 2332  5 index 1 2166  
975 0 0 6 1192 2335 0 0 117 /**
 * return the decimal fraction of the pool that is used.  The range is 0 to
 * 1.0 (e.g.  75% would be 0.75).
 */ 1 4 this 3 2333  
976 0 0 4 1193 2104 0 0 42 /**
 * ...intended for debugging only.
 */ 2 4 this 3 2333  3 out 1 2115  
977 0 0 4 1194 2104 0 0 42 /**
 * ...intended for debugging only.
 */ 2 4 this 3 2333  3 out 1 2115  
978 0 0 6 688 2032 0 0 0 1 3 str 1 2119  
979 0 0 6 689 2119 0 0 0 1 2 cs 1 2032  
980 0 0 6 690 2337 0 0 0 0 
981 0 0 6 691 2337 0 0 0 0 
982 0 0 6 933 2339 0 0 602 /**
 * A convenience function for loading explicit prc files from a disk file or
 * from within a multifile (via the virtual file system).  Save the return
 * value and pass it to unload_prc_file() if you ever want to unload this file
 * later.
 *
 * The filename is first searched along the default prc search path, and then
 * also along the model path, for convenience.
 *
 * This function is defined in putil instead of in dtool with the read of the
 * prc stuff, so that it can take advantage of the virtual file system (which
 * is defined in express), and the model path (which is in putil).
 */ 1 8 filename 1 2140  
983 0 0 6 934 2339 0 0 396 /**
 * Another convenience function to load a prc file from an explicit string,
 * which represents the contents of the prc file.
 *
 * The first parameter is an arbitrary name to assign to this in-memory prc
 * file.  Supply a filename if the data was read from a file, or use any other
 * name that is meaningful to you.  The name is only used when the set of
 * loaded prc files is listed.
 */ 2 4 name 1 2119  4 data 1 2119  
984 0 0 6 935 1972 0 0 0 1 4 page 1 2339  
985 0 0 4 936 2104 0 0 0 1 4 hash 1 2341  
986 0 0 6 1195 2000 0 0 203 /**
 * This wrapper is defined as a global function to suit pickle's needs.
 *
 * This hooks into the native pickle and cPickle modules, but it cannot
 * properly handle self-referential BAM objects.
 */ 2 10 this_class 1 2000  4 data 1 2036  
987 0 0 6 1196 2000 0 0 398 /**
 * This wrapper is defined as a global function to suit pickle's needs.
 *
 * This is similar to py_decode_TypedWritable_from_bam_stream, but it provides
 * additional support for the missing persistent-state object needed to
 * properly support self-referential BAM objects written to the pickle stream.
 * This hooks into the pickle and cPickle modules implemented in
 * direct/src/stdpy.
 */ 3 9 unpickler 1 2000  10 this_class 1 2000  4 data 1 2036  
379
1964 41 ConstPointerToArray< unsigned short int > 0 141313 41 ConstPointerToArray< unsigned short int > 41 ConstPointerToArray< unsigned short int > 0 0 0 1 993 1007 0 13 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 0 0 1 0 1965 0 0 0 0 0

1965 40 PointerToArrayBase< unsigned short int > 0 26625 40 PointerToArrayBase< unsigned short int > 40 PointerToArrayBase< unsigned short int > 0 0 0 0 990 0 2 991 992 0 0 1 0 1966 0 0 0 0 0

1966 61 PointerToBase< ReferenceCountedVector< unsigned short int > > 0 43009 61 PointerToBase< ReferenceCountedVector< unsigned short int > > 61 PointerToBase< ReferenceCountedVector< unsigned short int > > 0 0 0 0 0 0 2 988 989 0 0 1 0 1967 0 0 0 0 0

1967 13 PointerToVoid 0 2048 13 PointerToVoid 13 PointerToVoid 0 0 0 0 0 0 0 0 0 0 0 0 373
/**
 * This is the non-template part of the base class for PointerTo and
 * ConstPointerTo.  It is necessary so we can keep a pointer to a non-template
 * class within the ReferenceCount object, to implement weak reference
 * pointers--we need to have something to clean up when the ReferenceCount
 * object destructs.
 *
 * This is the base class for PointerToBase<T>.
 */

1968 36 PointerToArray< unsigned short int > 0 141313 36 PointerToArray< unsigned short int > 36 PointerToArray< unsigned short int > 0 0 0 1 1008 1029 0 20 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 0 0 1 0 1965 0 0 0 0 0

1969 13 AnimInterface 0 26625 13 AnimInterface 13 AnimInterface 0 0 0 0 1030 9 2343 2344 2345 2346 2347 2348 2349 2350 2351 17 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 0 0 0 0 0 226
/**
 * This is the fundamental interface for things that have a play/loop/stop
 * type interface for frame-based animation, such as animated characters.
 * This is the base class for AnimControl and other, similar classes.
 */

1970 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

1971 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

1972 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

1973 16 AutoTextureScale 0 532481 16 AutoTextureScale 16 AutoTextureScale 0 0 0 0 0 0 0 0 0 0 5 8 ATS_none 8 ATS_none 0
0 8 ATS_down 8 ATS_down 0
1 6 ATS_up 6 ATS_up 0
2 7 ATS_pad 7 ATS_pad 0
3 15 ATS_unspecified 15 ATS_unspecified 0
4 0 0

1974 9 UpdateSeq 0 141313 9 UpdateSeq 9 UpdateSeq 0 0 0 1 1048 1068 1 2352 19 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 0 0 0 0 0 761
/**
 * This is a sequence number that increments monotonically.  It can be used to
 * track cache updates, or serve as a kind of timestamp for any changing
 * properties.
 *
 * A special class is used instead of simply an int, so we can elegantly
 * handle such things as wraparound and special cases.  There are two special
 * cases.  Firstly, a sequence number is 'initial' when it is first created.
 * This sequence is older than any other sequence number.  Secondly, a
 * sequence number may be explicitly set to 'old'.  This is older than any
 * other sequence number except 'initial'.  Finally, we have the explicit
 * number 'fresh', which is newer than any other sequence number.  All other
 * sequences are numeric and are monotonically increasing.
 */

1975 7 Integer 0 2367488 21 AtomicAdjust::Integer 21 AtomicAdjust::Integer 1976 0 1977 0 0 0 0 0 0 0 0 0 0

1976 12 AtomicAdjust 0 1024 12 AtomicAdjust 12 AtomicAdjust 0 0 0 0 0 0 0 0 0 0 0 0 0

1977 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0

1978 13 TypedWritable 0 75777 13 TypedWritable 13 TypedWritable 0 0 0 0 0 0 10 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 0 0 1 0 1979 0 0 0 0 135
/**
 * Base class for objects that can be written to and read from Bam files.
 *
 * See also TypedObject for detailed instructions.
 */

1979 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file):
 * @code
 * public:
 *   static TypeHandle get_class_type() {
 *     return _type_handle;
 *   }
 *   static void init_type() {
 *     <<<BaseClassOne>>>::init_type();
 *     <<<BaseClassTwo>>>::init_type();
 *     <<<BaseClassN>>>::init_type();
 *     register_type(_type_handle, "<<<ThisClassStringName>>>",
 *                   <<<BaseClassOne>>>::get_class_type(),
 *                   <<<BaseClassTwo>>>::get_class_type(),
 *                   <<<BaseClassN>>>::get_class_type());
 *   }
 *   virtual TypeHandle get_type() const {
 *     return get_class_type();
 *   }
 *   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private:
 *   static TypeHandle _type_handle;
 * @endcode
 *
 * @par In the class .cxx file:
 * @code
 * TypeHandle <<<ThisClassStringName>>>::_type_handle;
 * @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file:
 * @code
 * ConfigureFn(config_<<<PackageName>>>) {
 *   <<<ClassOne>>>::init_type();
 *   <<<ClassTwo>>>::init_type();
 *   <<<ClassN>>>::init_type();
 * }
 * @endcode
 */

1980 27 TypedWritableReferenceCount 0 141313 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 1085 0 2 1083 1084 0 0 2 3 1978 1079 1080 3 1981 1081 1082 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

1981 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

1982 14 BamCacheRecord 0 26625 14 BamCacheRecord 14 BamCacheRecord 0 0 0 0 1090 5 2353 2354 2355 2356 2357 19 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 0 0 2 3 1980 1086 1087 3 1983 1088 1089 0 0 231
/**
 * An instance of this class is written to the front of a Bam or Txo file to
 * make the file a cached instance of some other loadable resource.  This
 * record contains information needed to test the validity of the cache.
 */

1983 14 LinkedListNode 0 1050624 14 LinkedListNode 14 LinkedListNode 0 0 0 0 0 0 0 0 0 0 0 0 468
/**
 * This just stores the pointers to implement a doubly-linked list of some
 * kind of object.  There are occasions when a hand-rolled linked list is more
 * appropriate than an STL container.
 *
 * Typically, each node of the linked list, as well as the root of the list,
 * will inherit from this class.
 *
 * Note that this class is not inherently thread-safe; derived classes are
 * responsible for protecting any calls into it within mutexes, if necessary.
 */

1984 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 1985 0 0 0 0 0 0 0 0 0 0

1985 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 839
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 *
 * Note that the methods of Filename that interact with the filesystem (such
 * as exists(), open_read(), etc.) directly interface with the operating system
 * and are not aware of Panda's virtual file system.  To interact with the VFS,
 * use the methods on VirtualFileSystem instead.
 */

1986 6 time_t 0 2105344 6 time_t 6 time_t 0 0 1977 0 0 0 0 0 0 0 0 0 0

1987 15 TypedWritable * 0 8576 15 TypedWritable * 15 TypedWritable * 0 0 1978 0 0 0 0 0 0 0 0 0 0

1988 8 BamCache 0 26625 8 BamCache 8 BamCache 0 0 0 1 1110 1111 9 2358 2359 2360 2361 2362 2363 2364 2365 2366 26 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 0 0 0 0 0 615
/**
 * This class maintains a cache of Bam and/or Txo objects generated from model
 * files and texture images (as well as possibly other kinds of loadable
 * objects that can be stored in bam file format).
 *
 * This class also maintains a persistent index that lists all of the cached
 * objects (see BamCacheIndex). We go through some considerable effort to make
 * sure this index gets saved correctly to disk, even in the presence of
 * multiple different processes writing to the same index, and without relying
 * too heavily on low-level os-provided file locks (which work poorly with C++
 * iostreams).
 */

1989 8 BamEnums 0 141313 8 BamEnums 8 BamEnums 0 0 0 1 1138 1139 0 0 0 0 0 0 3 1990 1991 1992 104
/**
 * This class exists just to provide scoping for the enums shared by BamReader
 * and BamWriter.
 */

1990 9 BamEndian 0 794624 19 BamEnums::BamEndian 19 BamEnums::BamEndian 1989 0 0 0 0 0 0 0 0 0 3 12 BE_bigendian 22 BamEnums::BE_bigendian 0
0 15 BE_littleendian 25 BamEnums::BE_littleendian 0
1 9 BE_native 19 BamEnums::BE_native 0
1 0 365
/**
   * This defines an enumerated type used to represent the endianness of
   * certain numeric values stored in a Bam file.  It really has only two
   * possible values, either BE_bigendian or BE_littleendian; but through a
   * preprocessor trick we also add BE_native, which is the same numerically
   * as whichever value the hardware supports natively.
   */

1991 13 BamObjectCode 0 794624 23 BamEnums::BamObjectCode 23 BamEnums::BamObjectCode 1989 0 0 0 0 0 0 0 0 0 5 8 BOC_push 18 BamEnums::BOC_push 107
// Indicates an object definition, and will always be eventually paired
// with a BOC_pop (which does not).
0 7 BOC_pop 17 BamEnums::BOC_pop 0
1 11 BOC_adjunct 21 BamEnums::BOC_adjunct 105
// Includes an object definition but does not push the level; it is
// associated with the current level.
2 10 BOC_remove 20 BamEnums::BOC_remove 65
// Lists object IDs that have been deallocated on the sender end.
3 13 BOC_file_data 23 BamEnums::BOC_file_data 137
// May appear at any level and indicates the following datagram contains
// auxiliary file data that may be referenced by a later object.
4 0 107
/**
   * This is the code written along with each object.  It is used to control
   * object scoping.
   */

1992 14 BamTextureMode 0 794624 24 BamEnums::BamTextureMode 24 BamEnums::BamTextureMode 1989 0 0 0 0 0 0 0 0 0 5 13 BTM_unchanged 23 BamEnums::BTM_unchanged 0
0 12 BTM_fullpath 22 BamEnums::BTM_fullpath 0
1 12 BTM_relative 22 BamEnums::BTM_relative 0
2 12 BTM_basename 22 BamEnums::BTM_basename 0
3 11 BTM_rawdata 21 BamEnums::BTM_rawdata 0
4 0 73
// This enum is used to control how textures are written to a bam stream.

1993 13 LoaderOptions 0 141313 13 LoaderOptions 13 LoaderOptions 0 0 0 1 1140 1156 4 2367 2368 2369 2370 15 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 0 0 0 0 2 1994 1995 65
/**
 * Specifies parameters that may be passed to the loader.
 */

1994 11 LoaderFlags 0 794624 26 LoaderOptions::LoaderFlags 26 LoaderOptions::LoaderFlags 1993 0 0 0 0 0 0 0 0 0 10 9 LF_search 24 LoaderOptions::LF_search 0
1 16 LF_report_errors 31 LoaderOptions::LF_report_errors 0
2 19 LF_convert_skeleton 34 LoaderOptions::LF_convert_skeleton 0
4 19 LF_convert_channels 34 LoaderOptions::LF_convert_channels 0
8 15 LF_convert_anim 30 LoaderOptions::LF_convert_anim 22
// skeleton + channels
12 16 LF_no_disk_cache 31 LoaderOptions::LF_no_disk_cache 20
// disallow BamCache
16 15 LF_no_ram_cache 30 LoaderOptions::LF_no_ram_cache 21
// disallow ModelPool
32 11 LF_no_cache 26 LoaderOptions::LF_no_cache 19
// no_disk + no_ram
48 13 LF_cache_only 28 LoaderOptions::LF_cache_only 23
// fail if not in cache
64 17 LF_allow_instance 32 LoaderOptions::LF_allow_instance 35
// returned pointer might be shared
128 0 33
// Flags for loading model files.

1995 12 TextureFlags 0 794624 27 LoaderOptions::TextureFlags 27 LoaderOptions::TextureFlags 1993 0 0 0 0 0 0 0 0 0 10 10 TF_preload 25 LoaderOptions::TF_preload 30
// Texture will have RAM image
4 17 TF_preload_simple 32 LoaderOptions::TF_preload_simple 37
// Texture will have simple RAM image
8 11 TF_allow_1d 26 LoaderOptions::TF_allow_1d 40
// If texture is Nx1, make a 1-d texture
16 19 TF_generate_mipmaps 34 LoaderOptions::TF_generate_mipmaps 30
// Consider generating mipmaps
32 12 TF_multiview 27 LoaderOptions::TF_multiview 36
// Load a multiview texture in pages
64 10 TF_integer 25 LoaderOptions::TF_integer 35
// Load as an integer (RGB) texture
128 8 TF_float 23 LoaderOptions::TF_float 43
// Load as a floating-point (depth) texture
256 20 TF_allow_compression 35 LoaderOptions::TF_allow_compression 33
// Consider compressing RAM image
512 13 TF_no_filters 28 LoaderOptions::TF_no_filters 38
// disallow using texture pool filters
1024 13 TF_force_srgb 28 LoaderOptions::TF_force_srgb 43
// Force the texture to have an sRGB format
2048 0 35
// Flags for loading texture files.

1996 9 BamReader 0 26625 9 BamReader 9 BamReader 0 0 0 1 1157 1158 6 2371 2372 2373 2374 2375 2376 20 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 0 0 1 0 1989 0 0 0 0 1311
/**
 * This is the fundamental interface for extracting binary objects from a Bam
 * file, as generated by a BamWriter.
 *
 * A Bam file can be thought of as a linear collection of objects.  Each
 * object is an instance of a class that inherits, directly or indirectly,
 * from TypedWritable.  The objects may include pointers to other objects
 * within the Bam file; the BamReader automatically manages these (with help
 * from code within each class) and restores the pointers correctly.
 *
 * This is the abstract interface and does not specifically deal with disk
 * files, but rather with a DatagramGenerator of some kind, which is simply a
 * linear source of Datagrams.  It is probably from a disk file, but it might
 * conceivably be streamed directly from a network or some such nonsense.
 *
 * Bam files are most often used to store scene graphs or subgraphs, and by
 * convention they are given filenames ending in the extension ".bam" when
 * they are used for this purpose.  However, a Bam file may store any
 * arbitrary list of TypedWritable objects; in this more general usage, they
 * are given filenames ending in ".boo" to differentiate them from the more
 * common scene graph files.
 *
 * See also BamFile, which defines a higher-level interface to read and write
 * Bam files on disk.
 */

1997 19 DatagramGenerator * 0 8576 19 DatagramGenerator * 19 DatagramGenerator * 0 0 1998 0 0 0 0 0 0 0 0 0 0

1998 17 DatagramGenerator 0 2048 17 DatagramGenerator 17 DatagramGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This class defines the abstract interace to any source of datagrams,
 * whether it be from a file or from the net.
 */

1999 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 1993 0 0 0 0 0 0 0 0 0 0

2000 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 2001 0 0 0 0 0 0 0 0 0 0

2001 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 2002 0 0 0 0 0 0 0 0 0 0

2002 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

2003 9 BamWriter 0 26625 9 BamWriter 9 BamWriter 0 0 0 1 1179 1180 7 2377 2378 2379 2380 2381 2382 2383 16 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 0 0 1 0 1989 0 0 0 0 1376
/**
 * This is the fundamental interface for writing binary objects to a Bam file,
 * to be extracted later by a BamReader.
 *
 * A Bam file can be thought of as a linear collection of objects.  Each
 * object is an instance of a class that inherits, directly or indirectly,
 * from TypedWritable.  The objects may include pointers to other objects; the
 * BamWriter automatically manages these (with help from code within each
 * class) and writes all referenced objects to the file in such a way that the
 * pointers may be correctly restored later.
 *
 * This is the abstract interface and does not specifically deal with disk
 * files, but rather with a DatagramSink of some kind, which simply accepts a
 * linear stream of Datagrams.  It is probably written to a disk file, but it
 * might conceivably be streamed directly to a network or some such nonsense.
 *
 * Bam files are most often used to store scene graphs or subgraphs, and by
 * convention they are given filenames ending in the extension ".bam" when
 * they are used for this purpose.  However, a Bam file may store any
 * arbitrary list of TypedWritable objects; in this more general usage, they
 * are given filenames ending in ".boo" to differentiate them from the more
 * common scene graph files.
 *
 * See also BamFile, which defines a higher-level interface to read and write
 * Bam files on disk.
 */

2004 14 DatagramSink * 0 8576 14 DatagramSink * 14 DatagramSink * 0 0 2005 0 0 0 0 0 0 0 0 0 0

2005 12 DatagramSink 0 2048 12 DatagramSink 12 DatagramSink 0 0 0 0 0 0 0 0 0 0 0 0 135
/**
 * This class defines the abstract interface to sending datagrams to any
 * target, whether it be into a file or across the net
 */

2006 23 BitMask< uint16_t, 16 > 0 141313 23 BitMask< uint16_t, 16 > 23 BitMask< uint16_t, 16 > 0 0 0 1 1198 1262 0 63 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 0 0 0 0 0 0

2007 9 BitMask16 0 2105345 9 BitMask16 9 BitMask16 0 0 2006 0 0 0 0 0 0 0 0 0 0

2008 23 BitMask< uint32_t, 32 > 0 141313 23 BitMask< uint32_t, 32 > 23 BitMask< uint32_t, 32 > 0 0 0 1 1263 1327 0 63 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 0 0 0 0 0 0

2009 9 BitMask32 0 2105345 9 BitMask32 9 BitMask32 0 0 2008 0 0 0 0 0 0 0 0 0 0

2010 23 BitMask< uint64_t, 64 > 0 141313 23 BitMask< uint64_t, 64 > 23 BitMask< uint64_t, 64 > 0 0 0 1 1328 1392 0 63 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 0 0 0 0 0 0

2011 9 BitMask64 0 2105345 9 BitMask64 9 BitMask64 0 0 2010 0 0 0 0 0 0 0 0 0 0

2012 13 BitMaskNative 0 1 13 BitMaskNative 13 BitMaskNative 0 0 0 0 0 0 0 0 0 0 0 0 0

2013 8 BitArray 0 141313 8 BitArray 8 BitArray 0 0 0 1 1393 1453 0 59 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 0 0 0 0 1 2014 210
/**
 * A dynamic array with an unlimited number of bits.
 *
 * This is similar to a BitMask, except it appears to contain an infinite
 * number of bits.  You can use it very much as you would use a BitMask.
 */

2014 0 0 794624 10 BitArray:: 0 2013 0 0 0 0 0 0 0 0 0 1 17 num_bits_per_word 27 BitArray::num_bits_per_word 0
64 0 0

2015 12 ButtonHandle 0 16918529 12 ButtonHandle 12 ButtonHandle 0 0 0 1 1454 1473 4 2384 2385 2386 2387 17 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1472 0 1 1471 0 0 0 162
/**
 * A ButtonHandle represents a single button from any device, including
 * keyboard buttons and mouse buttons (but see KeyboardButton and
 * MouseButton).
 */

2016 6 string 0 2105344 11 std::string 11 std::string 0 0 2017 0 0 0 0 0 0 0 0 0 0

2017 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

2018 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0

2019 14 ButtonRegistry 0 141313 14 ButtonRegistry 14 ButtonRegistry 0 0 0 1 1479 1480 0 5 1474 1475 1476 1477 1478 0 0 0 0 0 188
/**
 * The ButtonRegistry class maintains all the assigned ButtonHandles in a
 * given system.  There should be only one ButtonRegistry class during the
 * lifetime of the application.
 */

2020 9 ButtonMap 0 141313 9 ButtonMap 9 ButtonMap 0 0 0 1 1488 1489 0 7 1481 1482 1483 1484 1485 1486 1487 0 0 1 0 2021 0 0 0 0 328
/**
 * This class represents a map containing all of the buttons of a (keyboard)
 * device, though it can also be used as a generic mapping between
 * ButtonHandles.  It maps an underlying 'raw' button to a 'virtual' button,
 * which may optionally be associated with an appropriate platform-specific
 * name for the button.
 */

2021 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

2022 14 CallbackObject 0 141313 14 CallbackObject 14 CallbackObject 0 0 0 1 1493 1494 0 3 1490 1491 1492 0 0 1 0 2021 0 0 0 0 276
/**
 * This is a generic object that can be assigned to a callback at various
 * points in the rendering process.  This is actually a base class for a
 * handful of specialized callback object types.  You can also subclass it
 * yourself to make your own callback handler.
 */

2023 33 CachedTypedWritableReferenceCount 0 43009 33 CachedTypedWritableReferenceCount 33 CachedTypedWritableReferenceCount 0 0 0 0 0 1 2388 5 1495 1496 1497 1498 1499 0 0 1 0 1980 0 0 0 0 722
/**
 * This is a special extension to ReferenceCount that includes dual reference
 * counts: the standard reference count number, which includes all references
 * to the object, and a separate number (the cache reference count) that
 * counts the number of references to the object just within its cache alone.
 * When get_ref_count() == get_cache_ref_count(), the object is not referenced
 * outside the cache.
 *
 * The cache refs must be explicitly maintained; there is no PointerTo<> class
 * to maintain the cache reference counts automatically.  The cache reference
 * count is automatically included in the overall reference count: calling
 * cache_ref() and cache_unref() automatically calls ref() and unref().
 */

2024 12 CallbackData 0 141313 12 CallbackData 12 CallbackData 0 0 0 0 1503 0 3 1500 1501 1502 0 0 1 0 1979 0 0 0 0 348
/**
 * This is a generic data block that is passed along to a CallbackObject when
 * a callback is made.  It contains data specific to the particular callback
 * type in question.
 *
 * This is actually an abstract base class and contains no data.
 * Specializations of this class will contain the actual data relevant to each
 * callback type.
 */

2025 20 PythonCallbackObject 0 75777 20 PythonCallbackObject 20 PythonCallbackObject 0 0 0 1 1504 1494 1 2389 7 1505 1506 1507 1508 1509 1510 1511 0 0 1 0 2022 0 0 0 0 157
/**
 * This is a specialization on CallbackObject to allow a callback to directly
 * call an arbitrary Python function.  Powerful!  But use with caution.
 */

2026 7 TimeVal 0 141313 7 TimeVal 7 TimeVal 0 0 0 1 1512 1517 1 2390 2 1513 1514 0 0 0 0 0 0

2027 21 unsigned long int [2] 0 4202496 21 unsigned long int [2] 21 unsigned long int [2] 0 0 2028 2 0 0 0 0 0 0 0 0 0 0

2028 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

2029 11 ClockObject 0 75777 11 ClockObject 11 ClockObject 0 0 0 1 1518 0 11 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 28 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 0 0 1 0 1981 0 0 0 1 2030 1000
/**
 * A ClockObject keeps track of elapsed real time and discrete time.  In
 * normal mode, get_frame_time() returns the time as of the last time tick()
 * was called.  This is the "discrete" time, and is usually used to get the
 * time as of, for instance, the beginning of the current frame.
 *
 * In other modes, as set by set_mode() or the clock-mode config variable,
 * get_frame_time() may return other values to simulate different timing
 * effects, for instance to perform non-real-time animation.  See set_mode().
 *
 * In all modes, get_real_time() always returns the elapsed real time in
 * seconds since the ClockObject was constructed, or since it was last reset.
 *
 * You can create your own ClockObject whenever you want to have your own
 * local timer.  There is also a default, global ClockObject intended to
 * represent global time for the application; this is normally set up to tick
 * every frame so that its get_frame_time() will return the time for the
 * current frame.
 */

2030 4 Mode 0 794624 17 ClockObject::Mode 17 ClockObject::Mode 2029 0 0 0 0 0 0 0 0 0 8 8 M_normal 21 ClockObject::M_normal 0
0 15 M_non_real_time 28 ClockObject::M_non_real_time 0
1 8 M_forced 21 ClockObject::M_forced 0
2 9 M_degrade 22 ClockObject::M_degrade 0
3 7 M_slave 20 ClockObject::M_slave 0
4 9 M_limited 22 ClockObject::M_limited 0
5 9 M_integer 22 ClockObject::M_integer 0
6 17 M_integer_limited 30 ClockObject::M_integer_limited 0
7 0 0

2031 11 CollideMask 0 2105345 11 CollideMask 11 CollideMask 0 0 2009 0 0 0 0 0 0 0 0 0 0

2032 10 ColorSpace 0 532481 10 ColorSpace 10 ColorSpace 0 0 0 0 0 0 0 0 0 0 4 14 CS_unspecified 14 CS_unspecified 105
// This value is not a color space, but is used to indicate that a color
// space has not been specified.
0 9 CS_linear 9 CS_linear 389
// CS_linear is not a color space per se, but represents the working color
// space of graphics APIs, which is linearized.  Since the conversion from
// sRGB to linear is defined, one could posit that it has the ITU-R BT.709
// primaries, but this isn't meaningful as modern graphics APIs do not
// perform color management.  All colors in Panda3D are linear unless
// otherwise specified.
1 7 CS_sRGB 7 CS_sRGB 107
// This is the standard, gamma-2.2-corrected sRGB color space, as used by
// the majority of image formats.
2 8 CS_scRGB 8 CS_scRGB 110
// This is a 16-bit encoded linear color space capable of encoding color
// values in the -0.5...7.4999 range.
3 0 0

2033 17 CopyOnWriteObject 0 141313 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 1554 0 3 1551 1552 1553 0 0 1 0 2023 0 0 0 0 169
/**
 * This base class provides basic reference counting, but also can be used
 * with a CopyOnWritePointer to provide get_read_pointer() and
 * get_write_pointer().
 */

2034 14 DatagramBuffer 0 141313 14 DatagramBuffer 14 DatagramBuffer 0 0 0 1 1559 1563 1 2402 1 1560 0 0 2 3 2005 1555 1556 3 1998 1557 1558 0 0 355
/**
 * This class can be used to write a series of datagrams into a memory buffer.
 * It acts as both a datagram sink and generator; you can fill it up with
 * datagrams and then read as many datagrams from it.
 *
 * This uses the same format as DatagramInputFile and DatagramOutputFile,
 * meaning that Datagram sizes are always stored little-endian.
 */

2035 18 vector_uchar const 0 8832 18 vector_uchar const 18 vector_uchar const 0 0 2036 0 0 0 0 0 0 0 0 0 0

2036 12 vector_uchar 0 2105344 12 vector_uchar 12 vector_uchar 0 0 2037 0 0 0 0 0 0 0 0 0 0

2037 24 pvector< unsigned char > 0 2048 24 pvector< unsigned char > 24 pvector< unsigned char > 0 0 0 0 0 0 0 0 0 0 0 0 0

2038 17 DatagramInputFile 0 75777 17 DatagramInputFile 17 DatagramInputFile 0 0 0 1 1564 0 0 4 1565 1566 1567 1568 0 0 1 0 1998 0 0 0 0 130
/**
 * This class can be used to read a binary file that consists of an arbitrary
 * header followed by a number of datagrams.
 */

2039 18 DatagramOutputFile 0 75777 18 DatagramOutputFile 18 DatagramOutputFile 0 0 0 1 1569 0 1 2403 3 1570 1571 1572 0 0 1 0 2005 0 0 0 0 131
/**
 * This class can be used to write a binary file that consists of an arbitrary
 * header followed by a number of datagrams.
 */

2040 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

2041 30 DoubleBitMask< BitMaskNative > 0 141313 30 DoubleBitMask< BitMaskNative > 30 DoubleBitMask< BitMaskNative > 0 0 0 1 1574 1629 0 54 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 0 0 0 0 0 0

2042 19 DoubleBitMaskNative 0 2105345 19 DoubleBitMaskNative 19 DoubleBitMaskNative 0 0 2041 0 0 0 0 0 0 0 0 0 0

2043 36 DoubleBitMask< DoubleBitMaskNative > 0 141313 36 DoubleBitMask< DoubleBitMaskNative > 36 DoubleBitMask< DoubleBitMaskNative > 0 0 0 1 1630 1685 0 54 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 0 0 0 0 0 0

2044 17 QuadBitMaskNative 0 2105345 17 QuadBitMaskNative 17 QuadBitMaskNative 0 0 2043 0 0 0 0 0 0 0 0 0 0

2045 8 DrawMask 0 2105345 8 DrawMask 8 DrawMask 0 0 2009 0 0 0 0 0 0 0 0 0 0

2046 13 GamepadButton 0 141313 13 GamepadButton 13 GamepadButton 0 0 0 1 1717 1718 0 31 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 0 0 0 0 0 155
/**
 * This class is just used as a convenient namespace for grouping all of these
 * handy functions that return buttons which map to gamepad buttons.
 */

2047 10 PTA_ushort 0 2105345 10 PTA_ushort 10 PTA_ushort 0 0 1968 0 0 0 0 0 0 0 0 0 0

2048 11 CPTA_ushort 0 2105345 11 CPTA_ushort 11 CPTA_ushort 0 0 1964 0 0 0 0 0 0 0 0 0 0

2049 14 KeyboardButton 0 141313 14 KeyboardButton 14 KeyboardButton 0 0 0 1 1771 1772 0 52 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 0 0 0 0 0 162
/**
 * This class is just used as a convenient namespace for grouping all of these
 * handy functions that return buttons which map to standard keyboard keys.
 */

2050 15 ModifierButtons 0 26625 15 ModifierButtons 15 ModifierButtons 0 0 0 1 1777 1778 1 2404 23 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1 2427 0 0 0 0 135
/**
 * This class monitors the state of a number of individual buttons and tracks
 * whether each button is known to be down or up.
 */

2051 11 MouseButton 0 141313 11 MouseButton 11 MouseButton 0 0 0 1 1813 1814 0 11 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 0 0 0 0 0 162
/**
 * This class is just used as a convenient namespace for grouping all of these
 * handy functions that return buttons which map to standard mouse buttons.
 */

2052 24 NodeCachedReferenceCount 0 43009 24 NodeCachedReferenceCount 24 NodeCachedReferenceCount 0 0 0 0 0 0 6 1815 1816 1817 1818 1819 1820 0 0 1 0 2023 0 0 0 1 2053 1495
/**
 * This class further specializes CachedTypedWritableReferenceCount to also
 * add a node_ref_count, for the purposes of counting the number of times the
 * object is referenced by a "node", presumably a PandaNode.
 *
 * This essentially combines the functionality of NodeReferenceCount and
 * CachedTypedWritableReferenceCount, so that a derivative of this object
 * actually has three counters: the standard reference count, the "cache"
 * reference count, and the "node" reference count.  Rather than multiply
 * inheriting from the two reference count classes, we inherit only from
 * CachedTypedWritableReferenceCount and simply duplicate the functionality of
 * NodeReferenceCount, to avoid all of the problems associated with multiple
 * inheritance.
 *
 * The intended design is to use this as a base class for RenderState and
 * TransformState, both of which are held by PandaNodes, and also have caches
 * which are independently maintained.  By keeping track of how many nodes
 * hold a pointer to a particular object, we can classify each object into
 * node-referenced, cache-referenced, or other, which is primarily useful for
 * PStats reporting.
 *
 * As with CachedTypedWritableReferenceCount's cache_ref() and cache_unref(),
 * the new methods node_ref() and node_unref() automatically increment and
 * decrement the primary reference count as well.  In this case, however,
 * there does exist a NodePointerTo<> class to maintain the node_ref counters
 * automatically.
 */

2053 10 Referenced 0 794624 36 NodeCachedReferenceCount::Referenced 36 NodeCachedReferenceCount::Referenced 2052 0 0 0 0 0 0 0 0 0 2 6 R_node 32 NodeCachedReferenceCount::R_node 0
1 7 R_cache 33 NodeCachedReferenceCount::R_cache 0
2 0 0

2054 11 SparseArray 0 141313 11 SparseArray 11 SparseArray 0 0 0 1 1821 1876 0 54 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 0 0 0 0 0 736
/**
 * This class records a set of integers, where each integer is either present
 * or not present in the set.
 *
 * It is similar in principle and in interface to a BitArray (which can be
 * thought of as a set of integers, one integer corresponding to each
 * different bit position), but the SparseArray is implemented as a list of
 * min/max subrange lists, rather than as a bitmask.
 *
 * This makes it particularly efficient for storing sets which consist of
 * large sections of consecutively included or consecutively excluded
 * elements, with arbitrarily large integers, but particularly inefficient for
 * doing boolean operations such as & or |.
 *
 * Also, unlike BitArray, the SparseArray can store negative integers.
 */

2055 14 ParamValueBase 0 75777 14 ParamValueBase 14 ParamValueBase 0 0 0 0 1085 0 3 1877 1878 1879 0 0 1 0 1980 0 0 0 0 141
/**
 * A non-template base class of ParamValue (below), which serves mainly to
 * define the placeholder for the virtual output function.
 */

2056 18 ParamTypedRefCount 0 75777 18 ParamTypedRefCount 18 ParamTypedRefCount 0 0 0 1 1880 1085 1 2405 2 1881 1882 0 0 1 0 2055 0 0 0 0 143
/**
 * A class object for storing specifically objects of type
 * TypedReferenceCount, which is different than TypedWritableReferenceCount.
 */

2057 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 2021 0 0 0 0 0 0 0 0 0 0

2058 20 ParamValue< string > 0 75777 25 ParamValue< std::string > 25 ParamValue< std::string > 0 0 0 1 1883 1085 1 2406 3 1884 1885 1886 0 0 1 0 2055 0 0 0 0 0

2059 10 Type const 0 8832 10 Type const 10 Type const 0 0 0 0 0 0 0 0 0 0 0 0 0

2060 11 ParamString 0 2105345 11 ParamString 11 ParamString 0 0 2058 0 0 0 0 0 0 0 0 0 0

2061 21 ParamValue< wstring > 0 75777 26 ParamValue< std::wstring > 26 ParamValue< std::wstring > 0 0 0 1 1887 1085 1 2407 3 1888 1889 1890 0 0 1 0 2055 0 0 0 0 0

2062 12 ParamWstring 0 2105345 12 ParamWstring 12 ParamWstring 0 0 2061 0 0 0 0 0 0 0 0 0 0

2063 24 ParamValue< LVecBase2d > 0 75777 24 ParamValue< LVecBase2d > 24 ParamValue< LVecBase2d > 0 0 0 1 1891 1085 1 2408 3 1892 1893 1894 0 0 1 0 2055 0 0 0 0 0

2064 14 ParamVecBase2d 0 2105345 14 ParamVecBase2d 14 ParamVecBase2d 0 0 2063 0 0 0 0 0 0 0 0 0 0

2065 24 ParamValue< LVecBase2f > 0 75777 24 ParamValue< LVecBase2f > 24 ParamValue< LVecBase2f > 0 0 0 1 1895 1085 1 2409 3 1896 1897 1898 0 0 1 0 2055 0 0 0 0 0

2066 14 ParamVecBase2f 0 2105345 14 ParamVecBase2f 14 ParamVecBase2f 0 0 2065 0 0 0 0 0 0 0 0 0 0

2067 24 ParamValue< LVecBase2i > 0 75777 24 ParamValue< LVecBase2i > 24 ParamValue< LVecBase2i > 0 0 0 1 1899 1085 1 2410 3 1900 1901 1902 0 0 1 0 2055 0 0 0 0 0

2068 14 ParamVecBase2i 0 2105345 14 ParamVecBase2i 14 ParamVecBase2i 0 0 2067 0 0 0 0 0 0 0 0 0 0

2069 24 ParamValue< LVecBase3d > 0 75777 24 ParamValue< LVecBase3d > 24 ParamValue< LVecBase3d > 0 0 0 1 1903 1085 1 2411 3 1904 1905 1906 0 0 1 0 2055 0 0 0 0 0

2070 14 ParamVecBase3d 0 2105345 14 ParamVecBase3d 14 ParamVecBase3d 0 0 2069 0 0 0 0 0 0 0 0 0 0

2071 24 ParamValue< LVecBase3f > 0 75777 24 ParamValue< LVecBase3f > 24 ParamValue< LVecBase3f > 0 0 0 1 1907 1085 1 2412 3 1908 1909 1910 0 0 1 0 2055 0 0 0 0 0

2072 14 ParamVecBase3f 0 2105345 14 ParamVecBase3f 14 ParamVecBase3f 0 0 2071 0 0 0 0 0 0 0 0 0 0

2073 24 ParamValue< LVecBase3i > 0 75777 24 ParamValue< LVecBase3i > 24 ParamValue< LVecBase3i > 0 0 0 1 1911 1085 1 2413 3 1912 1913 1914 0 0 1 0 2055 0 0 0 0 0

2074 14 ParamVecBase3i 0 2105345 14 ParamVecBase3i 14 ParamVecBase3i 0 0 2073 0 0 0 0 0 0 0 0 0 0

2075 24 ParamValue< LVecBase4d > 0 75777 24 ParamValue< LVecBase4d > 24 ParamValue< LVecBase4d > 0 0 0 1 1915 1085 1 2414 3 1916 1917 1918 0 0 1 0 2055 0 0 0 0 0

2076 14 ParamVecBase4d 0 2105345 14 ParamVecBase4d 14 ParamVecBase4d 0 0 2075 0 0 0 0 0 0 0 0 0 0

2077 24 ParamValue< LVecBase4f > 0 75777 24 ParamValue< LVecBase4f > 24 ParamValue< LVecBase4f > 0 0 0 1 1919 1085 1 2415 3 1920 1921 1922 0 0 1 0 2055 0 0 0 0 0

2078 14 ParamVecBase4f 0 2105345 14 ParamVecBase4f 14 ParamVecBase4f 0 0 2077 0 0 0 0 0 0 0 0 0 0

2079 24 ParamValue< LVecBase4i > 0 75777 24 ParamValue< LVecBase4i > 24 ParamValue< LVecBase4i > 0 0 0 1 1923 1085 1 2416 3 1924 1925 1926 0 0 1 0 2055 0 0 0 0 0

2080 14 ParamVecBase4i 0 2105345 14 ParamVecBase4i 14 ParamVecBase4i 0 0 2079 0 0 0 0 0 0 0 0 0 0

2081 23 ParamValue< LMatrix3d > 0 75777 23 ParamValue< LMatrix3d > 23 ParamValue< LMatrix3d > 0 0 0 1 1927 1085 1 2417 3 1928 1929 1930 0 0 1 0 2055 0 0 0 0 0

2082 13 ParamMatrix3d 0 2105345 13 ParamMatrix3d 13 ParamMatrix3d 0 0 2081 0 0 0 0 0 0 0 0 0 0

2083 23 ParamValue< LMatrix3f > 0 75777 23 ParamValue< LMatrix3f > 23 ParamValue< LMatrix3f > 0 0 0 1 1931 1085 1 2418 3 1932 1933 1934 0 0 1 0 2055 0 0 0 0 0

2084 13 ParamMatrix3f 0 2105345 13 ParamMatrix3f 13 ParamMatrix3f 0 0 2083 0 0 0 0 0 0 0 0 0 0

2085 23 ParamValue< LMatrix4d > 0 75777 23 ParamValue< LMatrix4d > 23 ParamValue< LMatrix4d > 0 0 0 1 1935 1085 1 2419 3 1936 1937 1938 0 0 1 0 2055 0 0 0 0 0

2086 13 ParamMatrix4d 0 2105345 13 ParamMatrix4d 13 ParamMatrix4d 0 0 2085 0 0 0 0 0 0 0 0 0 0

2087 23 ParamValue< LMatrix4f > 0 75777 23 ParamValue< LMatrix4f > 23 ParamValue< LMatrix4f > 0 0 0 1 1939 1085 1 2420 3 1940 1941 1942 0 0 1 0 2055 0 0 0 0 0

2088 13 ParamMatrix4f 0 2105345 13 ParamMatrix4f 13 ParamMatrix4f 0 0 2087 0 0 0 0 0 0 0 0 0 0

2089 13 ParamVecBase2 0 2105345 13 ParamVecBase2 13 ParamVecBase2 0 0 2066 0 0 0 0 0 0 0 0 0 0

2090 13 ParamVecBase3 0 2105345 13 ParamVecBase3 13 ParamVecBase3 0 0 2072 0 0 0 0 0 0 0 0 0 0

2091 13 ParamVecBase4 0 2105345 13 ParamVecBase4 13 ParamVecBase4 0 0 2078 0 0 0 0 0 0 0 0 0 0

2092 12 ParamMatrix3 0 2105345 12 ParamMatrix3 12 ParamMatrix3 0 0 2084 0 0 0 0 0 0 0 0 0 0

2093 12 ParamMatrix4 0 2105345 12 ParamMatrix4 12 ParamMatrix4 0 0 2088 0 0 0 0 0 0 0 0 0 0

2094 20 WritableConfigurable 0 141313 20 WritableConfigurable 20 WritableConfigurable 0 0 0 0 1944 0 1 1943 0 0 1 0 1978 0 0 0 0 379
/**
 * Defined as a fix to allow creating Configurable and Writable objects.
 * Otherwise the compiler gets confused since both TypedWritable and
 * Configurable inherit from TypedObject.
 *
 * An object that has data or parameters that are set less frequently (at
 * least occasionally) than every frame.  We can cache the configuration info
 * by by using the "dirty" flag.
 */

2095 11 PointerType 0 8921089 11 PointerType 11 PointerType 0 0 0 0 0 0 0 0 0 0 10 7 UNKNOWN 7 UNKNOWN 0
0 5 MOUSE 5 MOUSE 0
1 6 FINGER 6 FINGER 0
2 6 STYLUS 6 STYLUS 0
3 6 ERASER 6 ERASER 0
4 7 unknown 7 unknown 21
// deprecated aliases
0 5 mouse 5 mouse 0
1 6 finger 6 finger 0
2 6 stylus 6 stylus 0
3 6 eraser 6 eraser 0
4 0 48
/**
 * Contains the types of pointer device.
 */

2096 11 PointerData 0 141313 11 PointerData 11 PointerData 0 0 0 1 1951 1952 6 2421 2422 2423 2424 2425 2426 3 1945 1946 1947 0 0 0 0 0 124
/**
 * Holds the data that might be generated by a 2-d pointer input device, such
 * as the mouse in the GraphicsWindow.
 */

2097 17 UniqueIdAllocator 0 26625 17 UniqueIdAllocator 17 UniqueIdAllocator 0 0 0 1 1953 1954 0 7 1955 1956 1957 1958 1959 1960 1961 0 0 0 0 0 812
/**
 * Manage a set of ID values from min to max inclusive.  The ID numbers that
 * are freed will be allocated (reused) in the same order.  I.e.  the oldest
 * ID numbers will be allocated.
 *
 * This implementation will use 4 bytes per id number, plus a few bytes of
 * management data.  e.g.  10,000 ID numbers will use 40KB.
 *
 * Also be advised that ID -1 and -2 are used internally by the allocator.  If
 * allocate returns IndexEnd (-1) then the allocator is out of free ID
 * numbers.
 *
 * There are other implementations that can better leverage runs of used or
 * unused IDs or use bit arrays for the IDs.  But, it takes extra work to
 * track the age of freed IDs, which is required for what we wanted.  If you
 * would like to kick around other implementation ideas, please contact
 * Schuyler.
 */

2098 10 PortalMask 0 2105345 10 PortalMask 10 PortalMask 0 0 2009 0 0 0 0 0 0 0 0 0 0

2099 49 ConstPointerToArray< unsigned short int > const * 0 8576 49 ConstPointerToArray< unsigned short int > const * 49 ConstPointerToArray< unsigned short int > const * 0 0 2100 0 0 0 0 0 0 0 0 0 0

2100 47 ConstPointerToArray< unsigned short int > const 0 8832 47 ConstPointerToArray< unsigned short int > const 47 ConstPointerToArray< unsigned short int > const 0 0 1964 0 0 0 0 0 0 0 0 0 0

2101 43 ConstPointerToArray< unsigned short int > * 0 8576 43 ConstPointerToArray< unsigned short int > * 43 ConstPointerToArray< unsigned short int > * 0 0 1964 0 0 0 0 0 0 0 0 0 0

2102 44 PointerToArray< unsigned short int > const * 0 8576 44 PointerToArray< unsigned short int > const * 44 PointerToArray< unsigned short int > const * 0 0 2103 0 0 0 0 0 0 0 0 0 0

2103 42 PointerToArray< unsigned short int > const 0 8832 42 PointerToArray< unsigned short int > const 42 PointerToArray< unsigned short int > const 0 0 1968 0 0 0 0 0 0 0 0 0 0

2104 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

2105 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

2106 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0

2107 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 2108 0 0 0 0 0 0 0 0 0 0

2108 9 Py_buffer 0 2105344 9 Py_buffer 9 Py_buffer 0 0 2109 0 0 0 0 0 0 0 0 0 0

2109 10 bufferinfo 0 1024 10 bufferinfo 10 bufferinfo 0 0 0 0 0 0 0 0 0 0 0 0 0

2110 48 PointerToArrayBase< unsigned short int > const * 0 8576 48 PointerToArrayBase< unsigned short int > const * 48 PointerToArrayBase< unsigned short int > const * 0 0 2111 0 0 0 0 0 0 0 0 0 0

2111 46 PointerToArrayBase< unsigned short int > const 0 8832 46 PointerToArrayBase< unsigned short int > const 46 PointerToArrayBase< unsigned short int > const 0 0 1965 0 0 0 0 0 0 0 0 0 0

2112 63 PointerToBase< ReferenceCountedVector< unsigned short int > > * 0 8576 63 PointerToBase< ReferenceCountedVector< unsigned short int > > * 63 PointerToBase< ReferenceCountedVector< unsigned short int > > * 0 0 1966 0 0 0 0 0 0 0 0 0 0

2113 69 PointerToBase< ReferenceCountedVector< unsigned short int > > const * 0 8576 69 PointerToBase< ReferenceCountedVector< unsigned short int > > const * 69 PointerToBase< ReferenceCountedVector< unsigned short int > > const * 0 0 2114 0 0 0 0 0 0 0 0 0 0

2114 67 PointerToBase< ReferenceCountedVector< unsigned short int > > const 0 8832 67 PointerToBase< ReferenceCountedVector< unsigned short int > > const 67 PointerToBase< ReferenceCountedVector< unsigned short int > > const 0 0 1966 0 0 0 0 0 0 0 0 0 0

2115 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 2040 0 0 0 0 0 0 0 0 0 0

2116 38 PointerToArray< unsigned short int > * 0 8576 38 PointerToArray< unsigned short int > * 38 PointerToArray< unsigned short int > * 0 0 1968 0 0 0 0 0 0 0 0 0 0

2117 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 2118 0 0 0 0 0 0 0 0 0 0

2118 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

2119 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

2120 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 1969 0 0 0 0 0 0 0 0 0 0

2121 21 AnimInterface const * 0 8576 21 AnimInterface const * 21 AnimInterface const * 0 0 2122 0 0 0 0 0 0 0 0 0 0

2122 19 AnimInterface const 0 8832 19 AnimInterface const 19 AnimInterface const 0 0 1969 0 0 0 0 0 0 0 0 0 0

2123 11 UpdateSeq * 0 8576 11 UpdateSeq * 11 UpdateSeq * 0 0 1974 0 0 0 0 0 0 0 0 0 0

2124 17 UpdateSeq const * 0 8576 17 UpdateSeq const * 17 UpdateSeq const * 0 0 2125 0 0 0 0 0 0 0 0 0 0

2125 15 UpdateSeq const 0 8832 15 UpdateSeq const 15 UpdateSeq const 0 0 1974 0 0 0 0 0 0 0 0 0 0

2126 11 BamWriter * 0 8576 11 BamWriter * 11 BamWriter * 0 0 2003 0 0 0 0 0 0 0 0 0 0

2127 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 2128 0 0 0 0 0 0 0 0 0 0

2128 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 0

2129 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 2130 0 0 0 0 0 0 0 0 0 0

2130 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 0

2131 11 BamReader * 0 8576 11 BamReader * 11 BamReader * 0 0 1996 0 0 0 0 0 0 0 0 0 0

2132 21 TypedWritable const * 0 8576 21 TypedWritable const * 21 TypedWritable const * 0 0 2133 0 0 0 0 0 0 0 0 0 0

2133 19 TypedWritable const 0 8832 19 TypedWritable const 19 TypedWritable const 0 0 1978 0 0 0 0 0 0 0 0 0 0

2134 14 vector_uchar * 0 8576 14 vector_uchar * 14 vector_uchar * 0 0 2036 0 0 0 0 0 0 0 0 0 0

2135 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 1980 0 0 0 0 0 0 0 0 0 0

2136 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 1981 0 0 0 0 0 0 0 0 0 0

2137 22 BamCacheRecord const * 0 8576 22 BamCacheRecord const * 22 BamCacheRecord const * 0 0 2138 0 0 0 0 0 0 0 0 0 0

2138 20 BamCacheRecord const 0 8832 20 BamCacheRecord const 20 BamCacheRecord const 0 0 1982 0 0 0 0 0 0 0 0 0 0

2139 16 BamCacheRecord * 0 8576 16 BamCacheRecord * 16 BamCacheRecord * 0 0 1982 0 0 0 0 0 0 0 0 0 0

2140 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 1984 0 0 0 0 0 0 0 0 0 0

2141 19 VirtualFile const * 0 8576 19 VirtualFile const * 19 VirtualFile const * 0 0 2142 0 0 0 0 0 0 0 0 0 0

2142 17 VirtualFile const 0 8832 17 VirtualFile const 17 VirtualFile const 0 0 2143 0 0 0 0 0 0 0 0 0 0

2143 11 VirtualFile 0 2048 11 VirtualFile 11 VirtualFile 0 0 0 0 0 0 0 0 0 0 0 0 0

2144 10 BamCache * 0 8576 10 BamCache * 10 BamCache * 0 0 1988 0 0 0 0 0 0 0 0 0 0

2145 16 BamCache const * 0 8576 16 BamCache const * 16 BamCache const * 0 0 2146 0 0 0 0 0 0 0 0 0 0

2146 14 BamCache const 0 8832 14 BamCache const 14 BamCache const 0 0 1988 0 0 0 0 0 0 0 0 0 0

2147 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 1985 0 0 0 0 0 0 0 0 0 0

2148 10 BamEnums * 0 8576 10 BamEnums * 10 BamEnums * 0 0 1989 0 0 0 0 0 0 0 0 0 0

2149 16 BamEnums const * 0 8576 16 BamEnums const * 16 BamEnums const * 0 0 2150 0 0 0 0 0 0 0 0 0 0

2150 14 BamEnums const 0 8832 14 BamEnums const 14 BamEnums const 0 0 1989 0 0 0 0 0 0 0 0 0 0

2151 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 1999 0 0 0 0 0 0 0 0 0 0

2152 15 LoaderOptions * 0 8576 15 LoaderOptions * 15 LoaderOptions * 0 0 1993 0 0 0 0 0 0 0 0 0 0

2153 9 AuxData * 0 8576 20 BamReader::AuxData * 20 BamReader::AuxData * 0 0 2154 0 0 0 0 0 0 0 0 0 0

2154 7 AuxData 0 1312768 18 BamReader::AuxData 18 BamReader::AuxData 1996 0 0 0 0 0 0 0 0 0 0 0 187
// Inherit from this class to piggyback additional temporary data on the
// bamReader (via set_aux_data() and get_aux_data()) for any particular
// objects during the bam reading process.

2155 17 BamReader const * 0 8576 17 BamReader const * 17 BamReader const * 0 0 2156 0 0 0 0 0 0 0 0 0 0

2156 15 BamReader const 0 8832 15 BamReader const 15 BamReader const 0 0 1996 0 0 0 0 0 0 0 0 0 0

2157 17 BamWriter const * 0 8576 17 BamWriter const * 17 BamWriter const * 0 0 2158 0 0 0 0 0 0 0 0 0 0

2158 15 BamWriter const 0 8832 15 BamWriter const 15 BamWriter const 0 0 2003 0 0 0 0 0 0 0 0 0 0

2159 25 BitMask< uint16_t, 16 > * 0 8576 25 BitMask< uint16_t, 16 > * 25 BitMask< uint16_t, 16 > * 0 0 2006 0 0 0 0 0 0 0 0 0 0

2160 31 BitMask< uint16_t, 16 > const * 0 8576 31 BitMask< uint16_t, 16 > const * 31 BitMask< uint16_t, 16 > const * 0 0 2161 0 0 0 0 0 0 0 0 0 0

2161 29 BitMask< uint16_t, 16 > const 0 8832 29 BitMask< uint16_t, 16 > const 29 BitMask< uint16_t, 16 > const 0 0 2006 0 0 0 0 0 0 0 0 0 0

2162 8 uint16_t 0 2105344 8 uint16_t 8 uint16_t 0 0 2106 0 0 0 0 0 0 0 0 0 0

2163 25 BitMask< uint32_t, 32 > * 0 8576 25 BitMask< uint32_t, 32 > * 25 BitMask< uint32_t, 32 > * 0 0 2008 0 0 0 0 0 0 0 0 0 0

2164 31 BitMask< uint32_t, 32 > const * 0 8576 31 BitMask< uint32_t, 32 > const * 31 BitMask< uint32_t, 32 > const * 0 0 2165 0 0 0 0 0 0 0 0 0 0

2165 29 BitMask< uint32_t, 32 > const 0 8832 29 BitMask< uint32_t, 32 > const 29 BitMask< uint32_t, 32 > const 0 0 2008 0 0 0 0 0 0 0 0 0 0

2166 8 uint32_t 0 2105344 8 uint32_t 8 uint32_t 0 0 2167 0 0 0 0 0 0 0 0 0 0

2167 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

2168 25 BitMask< uint64_t, 64 > * 0 8576 25 BitMask< uint64_t, 64 > * 25 BitMask< uint64_t, 64 > * 0 0 2010 0 0 0 0 0 0 0 0 0 0

2169 31 BitMask< uint64_t, 64 > const * 0 8576 31 BitMask< uint64_t, 64 > const * 31 BitMask< uint64_t, 64 > const * 0 0 2170 0 0 0 0 0 0 0 0 0 0

2170 29 BitMask< uint64_t, 64 > const 0 8832 29 BitMask< uint64_t, 64 > const 29 BitMask< uint64_t, 64 > const 0 0 2010 0 0 0 0 0 0 0 0 0 0

2171 8 uint64_t 0 2105344 8 uint64_t 8 uint64_t 0 0 2105 0 0 0 0 0 0 0 0 0 0

2172 10 BitArray * 0 8576 10 BitArray * 10 BitArray * 0 0 2013 0 0 0 0 0 0 0 0 0 0

2173 16 BitArray const * 0 8576 16 BitArray const * 16 BitArray const * 0 0 2174 0 0 0 0 0 0 0 0 0 0

2174 14 BitArray const 0 8832 14 BitArray const 14 BitArray const 0 0 2013 0 0 0 0 0 0 0 0 0 0

2175 19 SparseArray const * 0 8576 19 SparseArray const * 19 SparseArray const * 0 0 2176 0 0 0 0 0 0 0 0 0 0

2176 17 SparseArray const 0 8832 17 SparseArray const 17 SparseArray const 0 0 2054 0 0 0 0 0 0 0 0 0 0

2177 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 2105 0 0 0 0 0 0 0 0 0 0

2178 8 WordType 0 2367488 18 BitArray::WordType 18 BitArray::WordType 2013 0 2171 0 0 0 0 0 0 0 0 0 0

2179 14 ButtonHandle * 0 8576 14 ButtonHandle * 14 ButtonHandle * 0 0 2015 0 0 0 0 0 0 0 0 0 0

2180 20 ButtonHandle const * 0 8576 20 ButtonHandle const * 20 ButtonHandle const * 0 0 2181 0 0 0 0 0 0 0 0 0 0

2181 18 ButtonHandle const 0 8832 18 ButtonHandle const 18 ButtonHandle const 0 0 2015 0 0 0 0 0 0 0 0 0 0

2182 22 ButtonRegistry const * 0 8576 22 ButtonRegistry const * 22 ButtonRegistry const * 0 0 2183 0 0 0 0 0 0 0 0 0 0

2183 20 ButtonRegistry const 0 8832 20 ButtonRegistry const 20 ButtonRegistry const 0 0 2019 0 0 0 0 0 0 0 0 0 0

2184 16 ButtonRegistry * 0 8576 16 ButtonRegistry * 16 ButtonRegistry * 0 0 2019 0 0 0 0 0 0 0 0 0 0

2185 11 ButtonMap * 0 8576 11 ButtonMap * 11 ButtonMap * 0 0 2020 0 0 0 0 0 0 0 0 0 0

2186 17 ButtonMap const * 0 8576 17 ButtonMap const * 17 ButtonMap const * 0 0 2187 0 0 0 0 0 0 0 0 0 0

2187 15 ButtonMap const 0 8832 15 ButtonMap const 15 ButtonMap const 0 0 2020 0 0 0 0 0 0 0 0 0 0

2188 22 CallbackObject const * 0 8576 22 CallbackObject const * 22 CallbackObject const * 0 0 2189 0 0 0 0 0 0 0 0 0 0

2189 20 CallbackObject const 0 8832 20 CallbackObject const 20 CallbackObject const 0 0 2022 0 0 0 0 0 0 0 0 0 0

2190 16 CallbackObject * 0 8576 16 CallbackObject * 16 CallbackObject * 0 0 2022 0 0 0 0 0 0 0 0 0 0

2191 41 CachedTypedWritableReferenceCount const * 0 8576 41 CachedTypedWritableReferenceCount const * 41 CachedTypedWritableReferenceCount const * 0 0 2192 0 0 0 0 0 0 0 0 0 0

2192 39 CachedTypedWritableReferenceCount const 0 8832 39 CachedTypedWritableReferenceCount const 39 CachedTypedWritableReferenceCount const 0 0 2023 0 0 0 0 0 0 0 0 0 0

2193 20 CallbackData const * 0 8576 20 CallbackData const * 20 CallbackData const * 0 0 2194 0 0 0 0 0 0 0 0 0 0

2194 18 CallbackData const 0 8832 18 CallbackData const 18 CallbackData const 0 0 2024 0 0 0 0 0 0 0 0 0 0

2195 14 CallbackData * 0 8576 14 CallbackData * 14 CallbackData * 0 0 2024 0 0 0 0 0 0 0 0 0 0

2196 22 PythonCallbackObject * 0 8576 22 PythonCallbackObject * 22 PythonCallbackObject * 0 0 2025 0 0 0 0 0 0 0 0 0 0

2197 28 PythonCallbackObject const * 0 8576 28 PythonCallbackObject const * 28 PythonCallbackObject const * 0 0 2198 0 0 0 0 0 0 0 0 0 0

2198 26 PythonCallbackObject const 0 8832 26 PythonCallbackObject const 26 PythonCallbackObject const 0 0 2025 0 0 0 0 0 0 0 0 0 0

2199 9 TimeVal * 0 8576 9 TimeVal * 9 TimeVal * 0 0 2026 0 0 0 0 0 0 0 0 0 0

2200 15 TimeVal const * 0 8576 15 TimeVal const * 15 TimeVal const * 0 0 2201 0 0 0 0 0 0 0 0 0 0

2201 13 TimeVal const 0 8832 13 TimeVal const 13 TimeVal const 0 0 2026 0 0 0 0 0 0 0 0 0 0

2202 19 ClockObject const * 0 8576 19 ClockObject const * 19 ClockObject const * 0 0 2203 0 0 0 0 0 0 0 0 0 0

2203 17 ClockObject const 0 8832 17 ClockObject const 17 ClockObject const 0 0 2029 0 0 0 0 0 0 0 0 0 0

2204 13 ClockObject * 0 8576 13 ClockObject * 13 ClockObject * 0 0 2029 0 0 0 0 0 0 0 0 0 0

2205 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 2206 0 0 0 0 0 0 0 0 0 0

2206 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 71
// Due to a GCC bug, we can't use alignas() together with an attribute.

2207 25 CopyOnWriteObject const * 0 8576 25 CopyOnWriteObject const * 25 CopyOnWriteObject const * 0 0 2208 0 0 0 0 0 0 0 0 0 0

2208 23 CopyOnWriteObject const 0 8832 23 CopyOnWriteObject const 23 CopyOnWriteObject const 0 0 2033 0 0 0 0 0 0 0 0 0 0

2209 16 DatagramBuffer * 0 8576 16 DatagramBuffer * 16 DatagramBuffer * 0 0 2034 0 0 0 0 0 0 0 0 0 0

2210 19 DatagramInputFile * 0 8576 19 DatagramInputFile * 19 DatagramInputFile * 0 0 2038 0 0 0 0 0 0 0 0 0 0

2211 21 FileReference const * 0 8576 21 FileReference const * 21 FileReference const * 0 0 2212 0 0 0 0 0 0 0 0 0 0

2212 19 FileReference const 0 8832 19 FileReference const 19 FileReference const 0 0 2213 0 0 0 0 0 0 0 0 0 0

2213 13 FileReference 0 2048 13 FileReference 13 FileReference 0 0 0 0 0 0 0 0 0 0 0 0 149
/**
 * Keeps a reference-counted pointer to a file on disk.  As long as the
 * FileReference is held, someone presumably has a use for this file.
 */

2214 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 2215 0 0 0 0 0 0 0 0 0 0

2215 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0

2216 20 DatagramOutputFile * 0 8576 20 DatagramOutputFile * 20 DatagramOutputFile * 0 0 2039 0 0 0 0 0 0 0 0 0 0

2217 32 DoubleBitMask< BitMaskNative > * 0 8576 32 DoubleBitMask< BitMaskNative > * 32 DoubleBitMask< BitMaskNative > * 0 0 2041 0 0 0 0 0 0 0 0 0 0

2218 38 DoubleBitMask< BitMaskNative > const * 0 8576 38 DoubleBitMask< BitMaskNative > const * 38 DoubleBitMask< BitMaskNative > const * 0 0 2219 0 0 0 0 0 0 0 0 0 0

2219 36 DoubleBitMask< BitMaskNative > const 0 8832 36 DoubleBitMask< BitMaskNative > const 36 DoubleBitMask< BitMaskNative > const 0 0 2041 0 0 0 0 0 0 0 0 0 0

2220 38 DoubleBitMask< DoubleBitMaskNative > * 0 8576 38 DoubleBitMask< DoubleBitMaskNative > * 38 DoubleBitMask< DoubleBitMaskNative > * 0 0 2043 0 0 0 0 0 0 0 0 0 0

2221 44 DoubleBitMask< DoubleBitMaskNative > const * 0 8576 44 DoubleBitMask< DoubleBitMaskNative > const * 44 DoubleBitMask< DoubleBitMaskNative > const * 0 0 2222 0 0 0 0 0 0 0 0 0 0

2222 42 DoubleBitMask< DoubleBitMaskNative > const 0 8832 42 DoubleBitMask< DoubleBitMaskNative > const 42 DoubleBitMask< DoubleBitMaskNative > const 0 0 2043 0 0 0 0 0 0 0 0 0 0

2223 15 GamepadButton * 0 8576 15 GamepadButton * 15 GamepadButton * 0 0 2046 0 0 0 0 0 0 0 0 0 0

2224 21 GamepadButton const * 0 8576 21 GamepadButton const * 21 GamepadButton const * 0 0 2225 0 0 0 0 0 0 0 0 0 0

2225 19 GamepadButton const 0 8832 19 GamepadButton const 19 GamepadButton const 0 0 2046 0 0 0 0 0 0 0 0 0 0

2226 16 KeyboardButton * 0 8576 16 KeyboardButton * 16 KeyboardButton * 0 0 2049 0 0 0 0 0 0 0 0 0 0

2227 22 KeyboardButton const * 0 8576 22 KeyboardButton const * 22 KeyboardButton const * 0 0 2228 0 0 0 0 0 0 0 0 0 0

2228 20 KeyboardButton const 0 8832 20 KeyboardButton const 20 KeyboardButton const 0 0 2049 0 0 0 0 0 0 0 0 0 0

2229 17 ModifierButtons * 0 8576 17 ModifierButtons * 17 ModifierButtons * 0 0 2050 0 0 0 0 0 0 0 0 0 0

2230 23 ModifierButtons const * 0 8576 23 ModifierButtons const * 23 ModifierButtons const * 0 0 2231 0 0 0 0 0 0 0 0 0 0

2231 21 ModifierButtons const 0 8832 21 ModifierButtons const 21 ModifierButtons const 0 0 2050 0 0 0 0 0 0 0 0 0 0

2232 13 MouseButton * 0 8576 13 MouseButton * 13 MouseButton * 0 0 2051 0 0 0 0 0 0 0 0 0 0

2233 19 MouseButton const * 0 8576 19 MouseButton const * 19 MouseButton const * 0 0 2234 0 0 0 0 0 0 0 0 0 0

2234 17 MouseButton const 0 8832 17 MouseButton const 17 MouseButton const 0 0 2051 0 0 0 0 0 0 0 0 0 0

2235 32 NodeCachedReferenceCount const * 0 8576 32 NodeCachedReferenceCount const * 32 NodeCachedReferenceCount const * 0 0 2236 0 0 0 0 0 0 0 0 0 0

2236 30 NodeCachedReferenceCount const 0 8832 30 NodeCachedReferenceCount const 30 NodeCachedReferenceCount const 0 0 2052 0 0 0 0 0 0 0 0 0 0

2237 13 SparseArray * 0 8576 13 SparseArray * 13 SparseArray * 0 0 2054 0 0 0 0 0 0 0 0 0 0

2238 22 ParamValueBase const * 0 8576 22 ParamValueBase const * 22 ParamValueBase const * 0 0 2239 0 0 0 0 0 0 0 0 0 0

2239 20 ParamValueBase const 0 8832 20 ParamValueBase const 20 ParamValueBase const 0 0 2055 0 0 0 0 0 0 0 0 0 0

2240 27 TypedReferenceCount const * 0 8576 27 TypedReferenceCount const * 27 TypedReferenceCount const * 0 0 2241 0 0 0 0 0 0 0 0 0 0

2241 25 TypedReferenceCount const 0 8832 25 TypedReferenceCount const 25 TypedReferenceCount const 0 0 2021 0 0 0 0 0 0 0 0 0 0

2242 20 ParamTypedRefCount * 0 8576 20 ParamTypedRefCount * 20 ParamTypedRefCount * 0 0 2056 0 0 0 0 0 0 0 0 0 0

2243 26 ParamTypedRefCount const * 0 8576 26 ParamTypedRefCount const * 26 ParamTypedRefCount const * 0 0 2244 0 0 0 0 0 0 0 0 0 0

2244 24 ParamTypedRefCount const 0 8832 24 ParamTypedRefCount const 24 ParamTypedRefCount const 0 0 2056 0 0 0 0 0 0 0 0 0 0

2245 22 ParamValue< string > * 0 8576 27 ParamValue< std::string > * 27 ParamValue< std::string > * 0 0 2058 0 0 0 0 0 0 0 0 0 0

2246 28 ParamValue< string > const * 0 8576 33 ParamValue< std::string > const * 33 ParamValue< std::string > const * 0 0 2247 0 0 0 0 0 0 0 0 0 0

2247 26 ParamValue< string > const 0 8832 31 ParamValue< std::string > const 31 ParamValue< std::string > const 0 0 2058 0 0 0 0 0 0 0 0 0 0

2248 23 ParamValue< wstring > * 0 8576 28 ParamValue< std::wstring > * 28 ParamValue< std::wstring > * 0 0 2061 0 0 0 0 0 0 0 0 0 0

2249 29 ParamValue< wstring > const * 0 8576 34 ParamValue< std::wstring > const * 34 ParamValue< std::wstring > const * 0 0 2250 0 0 0 0 0 0 0 0 0 0

2250 27 ParamValue< wstring > const 0 8832 32 ParamValue< std::wstring > const 32 ParamValue< std::wstring > const 0 0 2061 0 0 0 0 0 0 0 0 0 0

2251 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 2252 0 0 0 0 0 0 0 0 0 0

2252 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 2253 0 0 0 0 0 0 0 0 0 0

2253 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

2254 26 ParamValue< LVecBase2d > * 0 8576 26 ParamValue< LVecBase2d > * 26 ParamValue< LVecBase2d > * 0 0 2063 0 0 0 0 0 0 0 0 0 0

2255 32 ParamValue< LVecBase2d > const * 0 8576 32 ParamValue< LVecBase2d > const * 32 ParamValue< LVecBase2d > const * 0 0 2256 0 0 0 0 0 0 0 0 0 0

2256 30 ParamValue< LVecBase2d > const 0 8832 30 ParamValue< LVecBase2d > const 30 ParamValue< LVecBase2d > const 0 0 2063 0 0 0 0 0 0 0 0 0 0

2257 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 2258 0 0 0 0 0 0 0 0 0 0

2258 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 2259 0 0 0 0 0 0 0 0 0 0

2259 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

2260 26 ParamValue< LVecBase2f > * 0 8576 26 ParamValue< LVecBase2f > * 26 ParamValue< LVecBase2f > * 0 0 2065 0 0 0 0 0 0 0 0 0 0

2261 32 ParamValue< LVecBase2f > const * 0 8576 32 ParamValue< LVecBase2f > const * 32 ParamValue< LVecBase2f > const * 0 0 2262 0 0 0 0 0 0 0 0 0 0

2262 30 ParamValue< LVecBase2f > const 0 8832 30 ParamValue< LVecBase2f > const 30 ParamValue< LVecBase2f > const 0 0 2065 0 0 0 0 0 0 0 0 0 0

2263 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 2264 0 0 0 0 0 0 0 0 0 0

2264 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 2265 0 0 0 0 0 0 0 0 0 0

2265 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

2266 26 ParamValue< LVecBase2i > * 0 8576 26 ParamValue< LVecBase2i > * 26 ParamValue< LVecBase2i > * 0 0 2067 0 0 0 0 0 0 0 0 0 0

2267 32 ParamValue< LVecBase2i > const * 0 8576 32 ParamValue< LVecBase2i > const * 32 ParamValue< LVecBase2i > const * 0 0 2268 0 0 0 0 0 0 0 0 0 0

2268 30 ParamValue< LVecBase2i > const 0 8832 30 ParamValue< LVecBase2i > const 30 ParamValue< LVecBase2i > const 0 0 2067 0 0 0 0 0 0 0 0 0 0

2269 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 2270 0 0 0 0 0 0 0 0 0 0

2270 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 2271 0 0 0 0 0 0 0 0 0 0

2271 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2272 26 ParamValue< LVecBase3d > * 0 8576 26 ParamValue< LVecBase3d > * 26 ParamValue< LVecBase3d > * 0 0 2069 0 0 0 0 0 0 0 0 0 0

2273 32 ParamValue< LVecBase3d > const * 0 8576 32 ParamValue< LVecBase3d > const * 32 ParamValue< LVecBase3d > const * 0 0 2274 0 0 0 0 0 0 0 0 0 0

2274 30 ParamValue< LVecBase3d > const 0 8832 30 ParamValue< LVecBase3d > const 30 ParamValue< LVecBase3d > const 0 0 2069 0 0 0 0 0 0 0 0 0 0

2275 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 2276 0 0 0 0 0 0 0 0 0 0

2276 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 2277 0 0 0 0 0 0 0 0 0 0

2277 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2278 26 ParamValue< LVecBase3f > * 0 8576 26 ParamValue< LVecBase3f > * 26 ParamValue< LVecBase3f > * 0 0 2071 0 0 0 0 0 0 0 0 0 0

2279 32 ParamValue< LVecBase3f > const * 0 8576 32 ParamValue< LVecBase3f > const * 32 ParamValue< LVecBase3f > const * 0 0 2280 0 0 0 0 0 0 0 0 0 0

2280 30 ParamValue< LVecBase3f > const 0 8832 30 ParamValue< LVecBase3f > const 30 ParamValue< LVecBase3f > const 0 0 2071 0 0 0 0 0 0 0 0 0 0

2281 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 2282 0 0 0 0 0 0 0 0 0 0

2282 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 2283 0 0 0 0 0 0 0 0 0 0

2283 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2284 26 ParamValue< LVecBase3i > * 0 8576 26 ParamValue< LVecBase3i > * 26 ParamValue< LVecBase3i > * 0 0 2073 0 0 0 0 0 0 0 0 0 0

2285 32 ParamValue< LVecBase3i > const * 0 8576 32 ParamValue< LVecBase3i > const * 32 ParamValue< LVecBase3i > const * 0 0 2286 0 0 0 0 0 0 0 0 0 0

2286 30 ParamValue< LVecBase3i > const 0 8832 30 ParamValue< LVecBase3i > const 30 ParamValue< LVecBase3i > const 0 0 2073 0 0 0 0 0 0 0 0 0 0

2287 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 2288 0 0 0 0 0 0 0 0 0 0

2288 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 2289 0 0 0 0 0 0 0 0 0 0

2289 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2290 26 ParamValue< LVecBase4d > * 0 8576 26 ParamValue< LVecBase4d > * 26 ParamValue< LVecBase4d > * 0 0 2075 0 0 0 0 0 0 0 0 0 0

2291 32 ParamValue< LVecBase4d > const * 0 8576 32 ParamValue< LVecBase4d > const * 32 ParamValue< LVecBase4d > const * 0 0 2292 0 0 0 0 0 0 0 0 0 0

2292 30 ParamValue< LVecBase4d > const 0 8832 30 ParamValue< LVecBase4d > const 30 ParamValue< LVecBase4d > const 0 0 2075 0 0 0 0 0 0 0 0 0 0

2293 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 2294 0 0 0 0 0 0 0 0 0 0

2294 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 2295 0 0 0 0 0 0 0 0 0 0

2295 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2296 26 ParamValue< LVecBase4f > * 0 8576 26 ParamValue< LVecBase4f > * 26 ParamValue< LVecBase4f > * 0 0 2077 0 0 0 0 0 0 0 0 0 0

2297 32 ParamValue< LVecBase4f > const * 0 8576 32 ParamValue< LVecBase4f > const * 32 ParamValue< LVecBase4f > const * 0 0 2298 0 0 0 0 0 0 0 0 0 0

2298 30 ParamValue< LVecBase4f > const 0 8832 30 ParamValue< LVecBase4f > const 30 ParamValue< LVecBase4f > const 0 0 2077 0 0 0 0 0 0 0 0 0 0

2299 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 2300 0 0 0 0 0 0 0 0 0 0

2300 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 2301 0 0 0 0 0 0 0 0 0 0

2301 10 LVecBase4i 0 2048 10 LVecBase4i 10 LVecBase4i 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2302 26 ParamValue< LVecBase4i > * 0 8576 26 ParamValue< LVecBase4i > * 26 ParamValue< LVecBase4i > * 0 0 2079 0 0 0 0 0 0 0 0 0 0

2303 32 ParamValue< LVecBase4i > const * 0 8576 32 ParamValue< LVecBase4i > const * 32 ParamValue< LVecBase4i > const * 0 0 2304 0 0 0 0 0 0 0 0 0 0

2304 30 ParamValue< LVecBase4i > const 0 8832 30 ParamValue< LVecBase4i > const 30 ParamValue< LVecBase4i > const 0 0 2079 0 0 0 0 0 0 0 0 0 0

2305 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 2306 0 0 0 0 0 0 0 0 0 0

2306 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 2307 0 0 0 0 0 0 0 0 0 0

2307 9 LMatrix3d 0 2048 9 LMatrix3d 9 LMatrix3d 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

2308 25 ParamValue< LMatrix3d > * 0 8576 25 ParamValue< LMatrix3d > * 25 ParamValue< LMatrix3d > * 0 0 2081 0 0 0 0 0 0 0 0 0 0

2309 31 ParamValue< LMatrix3d > const * 0 8576 31 ParamValue< LMatrix3d > const * 31 ParamValue< LMatrix3d > const * 0 0 2310 0 0 0 0 0 0 0 0 0 0

2310 29 ParamValue< LMatrix3d > const 0 8832 29 ParamValue< LMatrix3d > const 29 ParamValue< LMatrix3d > const 0 0 2081 0 0 0 0 0 0 0 0 0 0

2311 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 2312 0 0 0 0 0 0 0 0 0 0

2312 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 2313 0 0 0 0 0 0 0 0 0 0

2313 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

2314 25 ParamValue< LMatrix3f > * 0 8576 25 ParamValue< LMatrix3f > * 25 ParamValue< LMatrix3f > * 0 0 2083 0 0 0 0 0 0 0 0 0 0

2315 31 ParamValue< LMatrix3f > const * 0 8576 31 ParamValue< LMatrix3f > const * 31 ParamValue< LMatrix3f > const * 0 0 2316 0 0 0 0 0 0 0 0 0 0

2316 29 ParamValue< LMatrix3f > const 0 8832 29 ParamValue< LMatrix3f > const 29 ParamValue< LMatrix3f > const 0 0 2083 0 0 0 0 0 0 0 0 0 0

2317 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 2318 0 0 0 0 0 0 0 0 0 0

2318 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 2319 0 0 0 0 0 0 0 0 0 0

2319 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

2320 25 ParamValue< LMatrix4d > * 0 8576 25 ParamValue< LMatrix4d > * 25 ParamValue< LMatrix4d > * 0 0 2085 0 0 0 0 0 0 0 0 0 0

2321 31 ParamValue< LMatrix4d > const * 0 8576 31 ParamValue< LMatrix4d > const * 31 ParamValue< LMatrix4d > const * 0 0 2322 0 0 0 0 0 0 0 0 0 0

2322 29 ParamValue< LMatrix4d > const 0 8832 29 ParamValue< LMatrix4d > const 29 ParamValue< LMatrix4d > const 0 0 2085 0 0 0 0 0 0 0 0 0 0

2323 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 2324 0 0 0 0 0 0 0 0 0 0

2324 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 2325 0 0 0 0 0 0 0 0 0 0

2325 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

2326 25 ParamValue< LMatrix4f > * 0 8576 25 ParamValue< LMatrix4f > * 25 ParamValue< LMatrix4f > * 0 0 2087 0 0 0 0 0 0 0 0 0 0

2327 31 ParamValue< LMatrix4f > const * 0 8576 31 ParamValue< LMatrix4f > const * 31 ParamValue< LMatrix4f > const * 0 0 2328 0 0 0 0 0 0 0 0 0 0

2328 29 ParamValue< LMatrix4f > const 0 8832 29 ParamValue< LMatrix4f > const 29 ParamValue< LMatrix4f > const 0 0 2087 0 0 0 0 0 0 0 0 0 0

2329 13 PointerData * 0 8576 13 PointerData * 13 PointerData * 0 0 2096 0 0 0 0 0 0 0 0 0 0

2330 19 PointerData const * 0 8576 19 PointerData const * 19 PointerData const * 0 0 2331 0 0 0 0 0 0 0 0 0 0

2331 17 PointerData const 0 8832 17 PointerData const 17 PointerData const 0 0 2096 0 0 0 0 0 0 0 0 0 0

2332 19 UniqueIdAllocator * 0 8576 19 UniqueIdAllocator * 19 UniqueIdAllocator * 0 0 2097 0 0 0 0 0 0 0 0 0 0

2333 25 UniqueIdAllocator const * 0 8576 25 UniqueIdAllocator const * 25 UniqueIdAllocator const * 0 0 2334 0 0 0 0 0 0 0 0 0 0

2334 23 UniqueIdAllocator const 0 8832 23 UniqueIdAllocator const 23 UniqueIdAllocator const 0 0 2097 0 0 0 0 0 0 0 0 0 0

2335 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 2336 0 0 0 0 0 0 0 0 0 0

2336 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

2337 26 ConfigVariableSearchPath * 0 8576 26 ConfigVariableSearchPath * 26 ConfigVariableSearchPath * 0 0 2338 0 0 0 0 0 0 0 0 0 0

2338 24 ConfigVariableSearchPath 0 2048 24 ConfigVariableSearchPath 24 ConfigVariableSearchPath 0 0 0 0 0 0 0 0 0 0 0 0 731
/**
 * This is similar to a ConfigVariableList, but it returns its list as a
 * DSearchPath, as a list of directories.
 *
 * You may locally append directories to the end of the search path with the
 * methods here, or prepend them to the beginning.  Use these methods to make
 * adjustments to the path; do not attempt to directly modify the const
 * DSearchPath object returned by get_value().
 *
 * Unlike other ConfigVariable types, local changes (made by calling
 * append_directory() and prepend_directory()) are specific to this particular
 * instance of the ConfigVariableSearchPath.  A separate instance of the same
 * variable, created by using the same name to the constructor, will not
 * reflect the local changes.
 */

2339 12 ConfigPage * 0 8576 12 ConfigPage * 12 ConfigPage * 0 0 2340 0 0 0 0 0 0 0 0 0 0

2340 10 ConfigPage 0 2048 10 ConfigPage 10 ConfigPage 0 0 0 0 0 0 0 0 0 0 0 0 262
/**
 * A page of ConfigDeclarations that may be loaded or unloaded.  Typically
 * this represents a single .prc file that is read from disk at runtime, but
 * it may also represent a list of declarations built up by application code
 * and explicitly loaded.
 */

2341 9 HashVal * 0 8576 9 HashVal * 9 HashVal * 0 0 2342 0 0 0 0 0 0 0 0 0 0

2342 7 HashVal 0 2048 7 HashVal 7 HashVal 0 0 0 0 0 0 0 0 0 0 0 0 0

0
84
2343 9 play_rate 0 6 1970 1037 1036 0 0 0 0 0 0 24 AnimInterface::play_rate 0

2344 10 frame_rate 0 2 1970 1038 0 0 0 0 0 0 0 25 AnimInterface::frame_rate 0

2345 10 num_frames 0 2 1971 1039 0 0 0 0 0 0 0 25 AnimInterface::num_frames 0

2346 5 frame 0 2 1971 1040 0 0 0 0 0 0 0 20 AnimInterface::frame 0

2347 10 next_frame 0 2 1971 1041 0 0 0 0 0 0 0 25 AnimInterface::next_frame 0

2348 4 frac 0 2 1970 1042 0 0 0 0 0 0 0 19 AnimInterface::frac 0

2349 10 full_frame 0 2 1971 1043 0 0 0 0 0 0 0 25 AnimInterface::full_frame 0

2350 11 full_fframe 0 2 1970 1044 0 0 0 0 0 0 0 26 AnimInterface::full_fframe 0

2351 7 playing 0 2 1972 1045 0 0 0 0 0 0 0 22 AnimInterface::playing 0

2352 3 seq 0 2 1975 1066 0 0 0 0 0 0 0 14 UpdateSeq::seq 0

2353 15 source_pathname 0 2 1984 1093 0 0 0 0 0 0 0 31 BamCacheRecord::source_pathname 0

2354 14 cache_filename 0 2 1984 1094 0 0 0 0 0 0 0 30 BamCacheRecord::cache_filename 0

2355 16 source_timestamp 0 2 1986 1095 0 0 0 0 0 0 0 32 BamCacheRecord::source_timestamp 0

2356 13 recorded_time 0 2 1986 1096 0 0 0 0 0 0 0 29 BamCacheRecord::recorded_time 0

2357 4 data 0 30 1987 1104 1106 1102 1103 0 0 0 0 20 BamCacheRecord::data 0

2358 6 active 0 6 1972 1113 1112 0 0 0 0 0 0 16 BamCache::active 0

2359 12 cache_models 0 6 1972 1115 1114 0 0 0 0 0 0 22 BamCache::cache_models 0

2360 14 cache_textures 0 6 1972 1117 1116 0 0 0 0 0 0 24 BamCache::cache_textures 0

2361 25 cache_compressed_textures 0 6 1972 1119 1118 0 0 0 0 0 0 35 BamCache::cache_compressed_textures 0

2362 22 cache_compiled_shaders 0 6 1972 1121 1120 0 0 0 0 0 0 32 BamCache::cache_compiled_shaders 0

2363 4 root 0 6 1985 1123 1122 0 0 0 0 0 0 14 BamCache::root 0

2364 10 flush_time 0 6 1971 1125 1124 0 0 0 0 0 0 20 BamCache::flush_time 0

2365 16 cache_max_kbytes 0 6 1971 1127 1126 0 0 0 0 0 0 26 BamCache::cache_max_kbytes 0

2366 9 read_only 0 6 1972 1129 1128 0 0 0 0 0 0 19 BamCache::read_only 0

2367 5 flags 0 6 1971 1142 1141 0 0 0 0 0 0 20 LoaderOptions::flags 0

2368 13 texture_flags 0 6 1971 1144 1143 0 0 0 0 0 0 28 LoaderOptions::texture_flags 0

2369 17 texture_num_views 0 6 1971 1152 1151 0 0 0 0 0 0 32 LoaderOptions::texture_num_views 0

2370 18 auto_texture_scale 0 6 1973 1154 1153 0 0 0 0 0 0 33 LoaderOptions::auto_texture_scale 0

2371 6 source 0 6 1997 1160 1159 0 0 0 0 0 0 17 BamReader::source 0

2372 8 filename 0 2 1984 1164 0 0 0 0 0 0 0 19 BamReader::filename 0

2373 14 loader_options 0 6 1999 1165 1166 0 0 0 0 0 0 25 BamReader::loader_options 0

2374 12 file_version 0 2 2000 1177 0 0 0 0 0 0 0 23 BamReader::file_version 0

2375 11 file_endian 0 2 1990 1173 0 0 0 0 0 0 0 22 BamReader::file_endian 0

2376 20 file_stdfloat_double 0 2 1972 1174 0 0 0 0 0 0 0 31 BamReader::file_stdfloat_double 0

2377 6 target 0 6 2004 1182 1181 0 0 0 0 0 0 17 BamWriter::target 0

2378 8 filename 0 2 1984 1184 0 0 0 0 0 0 0 19 BamWriter::filename 0

2379 12 file_version 0 2 2000 1197 0 0 0 0 0 0 0 23 BamWriter::file_version 0

2380 11 file_endian 0 2 1990 1191 0 0 0 0 0 0 0 22 BamWriter::file_endian 0

2381 20 file_stdfloat_double 0 2 1972 1192 0 0 0 0 0 0 0 31 BamWriter::file_stdfloat_double 0

2382 17 file_texture_mode 0 2 1992 1193 0 0 0 0 0 0 0 28 BamWriter::file_texture_mode 0

2383 9 root_node 0 6 1987 1195 1196 0 0 0 0 0 0 20 BamWriter::root_node 0

2384 5 index 0 2 1971 1468 0 0 0 0 0 0 0 19 ButtonHandle::index 0

2385 4 name 0 2 2016 1463 0 0 0 0 0 0 0 18 ButtonHandle::name 0

2386 16 ascii_equivalent 0 10 2018 1465 0 1464 0 0 0 0 0 30 ButtonHandle::ascii_equivalent 0

2387 5 alias 0 2 2015 1466 0 0 0 0 0 0 0 19 ButtonHandle::alias 0

2388 15 cache_ref_count 0 2 1971 1495 0 0 0 0 0 0 0 50 CachedTypedWritableReferenceCount::cache_ref_count 0

2389 8 function 0 6 2000 1509 1508 0 0 0 0 0 0 30 PythonCallbackObject::function 0

2390 2 tv 0 6 2027 1515 1516 0 0 0 0 0 0 11 TimeVal::tv 0

2391 4 mode 0 6 2030 1520 1519 0 0 0 0 0 0 17 ClockObject::mode 0

2392 10 frame_time 0 6 1970 1521 1526 0 0 0 0 0 0 23 ClockObject::frame_time 0

2393 9 real_time 0 6 1970 1522 1525 0 0 0 0 0 0 22 ClockObject::real_time 0

2394 9 long_time 0 2 1970 1523 0 0 0 0 0 0 0 22 ClockObject::long_time 0

2395 11 frame_count 0 6 1971 1528 1527 0 0 0 0 0 0 24 ClockObject::frame_count 0

2396 2 dt 0 6 1970 1530 1531 0 0 0 0 0 0 15 ClockObject::dt 0

2397 6 max_dt 0 6 1970 1533 1534 0 0 0 0 0 0 19 ClockObject::max_dt 0

2398 14 degrade_factor 0 6 1970 1535 1536 0 0 0 0 0 0 27 ClockObject::degrade_factor 0

2399 27 average_frame_rate_interval 0 6 1970 1538 1537 0 0 0 0 0 0 40 ClockObject::average_frame_rate_interval 0

2400 18 average_frame_rate 0 2 1970 1539 0 0 0 0 0 0 0 31 ClockObject::average_frame_rate 0

2401 18 max_frame_duration 0 2 1970 1540 0 0 0 0 0 0 0 31 ClockObject::max_frame_duration 0

2402 4 data 0 6 2035 1561 1562 0 0 0 0 0 0 20 DatagramBuffer::data 0

2403 6 stream 0 2 2040 1573 0 0 0 0 0 0 0 26 DatagramOutputFile::stream 0

2404 7 buttons 0 66 2015 1793 0 0 0 0 1792 0 0 24 ModifierButtons::buttons 0

2405 5 value 0 2 2057 1881 0 0 0 0 0 0 0 25 ParamTypedRefCount::value 0

2406 5 value 0 6 2059 1885 1884 0 0 0 0 0 0 27 ParamValue< string >::value 0

2407 5 value 0 6 2059 1889 1888 0 0 0 0 0 0 28 ParamValue< wstring >::value 0

2408 5 value 0 6 2059 1893 1892 0 0 0 0 0 0 31 ParamValue< LVecBase2d >::value 0

2409 5 value 0 6 2059 1897 1896 0 0 0 0 0 0 31 ParamValue< LVecBase2f >::value 0

2410 5 value 0 6 2059 1901 1900 0 0 0 0 0 0 31 ParamValue< LVecBase2i >::value 0

2411 5 value 0 6 2059 1905 1904 0 0 0 0 0 0 31 ParamValue< LVecBase3d >::value 0

2412 5 value 0 6 2059 1909 1908 0 0 0 0 0 0 31 ParamValue< LVecBase3f >::value 0

2413 5 value 0 6 2059 1913 1912 0 0 0 0 0 0 31 ParamValue< LVecBase3i >::value 0

2414 5 value 0 6 2059 1917 1916 0 0 0 0 0 0 31 ParamValue< LVecBase4d >::value 0

2415 5 value 0 6 2059 1921 1920 0 0 0 0 0 0 31 ParamValue< LVecBase4f >::value 0

2416 5 value 0 6 2059 1925 1924 0 0 0 0 0 0 31 ParamValue< LVecBase4i >::value 0

2417 5 value 0 6 2059 1929 1928 0 0 0 0 0 0 30 ParamValue< LMatrix3d >::value 0

2418 5 value 0 6 2059 1933 1932 0 0 0 0 0 0 30 ParamValue< LMatrix3f >::value 0

2419 5 value 0 6 2059 1937 1936 0 0 0 0 0 0 30 ParamValue< LMatrix4d >::value 0

2420 5 value 0 6 2059 1941 1940 0 0 0 0 0 0 30 ParamValue< LMatrix4f >::value 0

2421 1 x 0 2 1970 1945 0 0 0 0 0 0 0 14 PointerData::x 0

2422 1 y 0 2 1970 1946 0 0 0 0 0 0 0 14 PointerData::y 0

2423 4 type 0 2 2095 1948 0 0 0 0 0 0 0 17 PointerData::type 0

2424 2 id 0 2 1971 1949 0 0 0 0 0 0 0 15 PointerData::id 0

2425 9 in_window 0 2 1972 1947 0 0 0 0 0 0 0 22 PointerData::in_window 0

2426 8 pressure 0 2 1970 1950 0 0 0 0 0 0 0 21 PointerData::pressure 0

1
2427 11 get_buttons 0 1792 1793 28 ModifierButtons::get_buttons 0

